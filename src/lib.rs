//! # Protrust
//! A Protocol Buffers library that supports proto2, proto3, reflection,
//! JSON mapping, dynamic messages, and all proto file optimizations
//!
//! This documentation is sorted into two parts:
//!
//! 1. [Generated code](#generated-code)
//! 2. [Library API](#library)
//!
//! ## Generated code
//!
//! This section describes the layout of the Rust code generated by the
//! protoc-gen-rust plugin included in this crate, as well as the usage of the plugin itself.
//! It does not describe the protobuf language itself. Docs for [proto2](https://developers.google.com/protocol-buffers/docs/proto) or [proto3](https://developers.google.com/protocol-buffers/docs/proto3)
//! should be read before using this library.
//!
//! ### Using the compiler
//!
//! The compiler plugin can be installed by running `cargo install protrust`.
//! The plugin is added to the path and can be used with the `--rust_out=`
//! option in protoc.
//!
//! The plugin creates a file for each input proto along with a mod file that
//! contains a reference to each generated file. The mod file also includes a
//! descriptor pool containing all the files in a generated code output as well
//! as an extension registry containing all the extensions in the generated code output.
//!
//! The plugin also has various options that can be set by passing a string via the
//! `--rust_opt=` cmdline option. Available options are:
//!
//!  * `crate_name`: Specifies the name of the protrust crate in cases where the crate has been
//!  reused under another name
//!
//!  * `no_reflection`: Removes generated reflection code from generated output.
//!  Used in cases where all generated files are LITE_RUNTIME optimized and consumers don't
//!  use the reflection feature.
//!
//!  * `size_checks`: Changes the generated output to use checked addition when calculating the
//!  size of messages. This is used with the `checked_size` crate feature.
//!
//!  * `external_modules`: Specifies external generated output modules to import into this output.
//!  External modules can be generated in seperate crates and used in generated code by passing
//!  their full module paths as a '+' seperated string. If generated code uses well known types
//!  or descriptor and plugin protos and doesn't generate the code for them, the compiler will
//!  automatically import the module for the consumer.
//!
//! Example:
//! ```text
//! protoc input.proto --rust_out=.
//! --rust_opt=crate_name=foo,no_reflection,size_checks,external_modules=external_lib::gen+another_lib::generated
//! ```
//!
//! ### Messages
//!
//! The compiler generates messages as structs. They derive the `Clone`, `PartialEq`, `Default`, and `Debug` traits.
//! All messages implement the [`CodedMessage`] and [`LiteMessage`] traits. A [`Message`] implementation is generated for it as well
//! unless the `no_reflection` option is enabled. If the message defines extension ranges, an implementation for 
//! `ExtendableMessage` is also provided.
//! 
//! [`CodedMessage`]: trait.CodedMessage.html
//! [`LiteMessage`]: trait.LiteMessage.html
//! [`ExtendableMessage`]: trait.ExtendableMessage.html
//! [`Message`]: trait.Message.html
//!
//! Nested messages, nested enums, oneof field enums, and extension fields defined in the scope of a message are generated
//! in a module named after the name of the message converted to snake case.
//! For example, a message named FooBar would have a paired module named foo_bar. A module is not generated
//! if a message doesn't contain any of the items mentioned.
//!
//! ### Enums
//! 
//! The compiler generates enums as standard enums, however to support value aliasing these are not C-style enums. To convert these enums to
//! their underlying i32 value, use the `Into<i32>` implementation provided by std.

#![feature(const_fn)]
#![feature(specialization)]

mod extend;

#[cfg_attr(checked_size, path = "generated/checked/mod.rs")]
#[cfg_attr(not(checked_size), path = "generated/unchecked/mod.rs")]
#[rustfmt::skip]
#[doc(hidden)]
pub mod generated;

/// The protrust prelude
///
/// Alleviates imports of many common protobuf traits and io structs
/// by adding a glob import to the top of protobuf heavy modules
pub mod prelude {
    pub use crate::CodedMessage;
    pub use crate::Enum;
    pub use crate::EnumValue::{self, Defined};
    pub use crate::ExtendableMessage;
    pub use crate::LiteMessage;
    #[cfg(feature = "reflection")]
    pub use crate::Message;
}
pub mod collections;
pub mod io;
#[cfg(all(feature = "reflection"))]
pub mod wkt;
#[cfg(feature = "reflection")]
pub use crate::generated::google_protobuf_descriptor_proto as descriptor;
#[cfg(feature = "plugin")]
pub mod plugin;
#[cfg(feature = "reflection")]
pub mod reflect;

pub use extend::{
    Extension, ExtensionField, ExtensionIdentifier, ExtendableMessage, ExtensionRegistry,
    ExtensionSet, RepeatedExtension, RepeatedExtensionField,
};

use crate::io::{Tag, WireType};
use std::collections::HashMap;
use std::convert::TryFrom;
use std::fmt::Debug;
use std::hash::{Hash, Hasher};

/// A Protocol Buffers message capable of writing itself to a coded output or reading itself from a coded input.
/// 
/// This only describes the mechanisms for reading, writing, calculating the size of, and checking the intialization of messages.
/// 
/// # Example
/// 
/// ```
/// use protrust::{CodedMessage, LiteMessage};
/// use protrust::wkt::timestamp::Timestamp;
/// 
/// fn main() -> Result<(), Box<dyn std::error::Error>> {
///     let input = [8, 3, 16, 5];
///     let mut timestamp = Timestamp::new();
///     timestamp.merge_from_reader(&mut input.as_ref())?;
/// 
///     assert_eq!(*timestamp.seconds(), 3);
///     assert_eq!(*timestamp.nanos(), 5);
/// 
///     let output = timestamp.write_to_vec()?;
/// 
///     assert_eq!(input.as_ref(), output.as_slice());
/// 
///     Ok(())
/// }
/// ```
pub trait CodedMessage {
    /// Merges fields from the coded input into this message. This requires setting up a [`CodedInput`] to read from. 
    /// If you just want to read from an input, use [`merge_from_reader`]
    /// 
    /// [`merge_from_reader`]: #method.merge_from_reader
    /// [`CodedInput`]: io/struct.CodedInput.html
    /// 
    /// # Example
    /// 
    /// ```
    /// use protrust::{CodedMessage, LiteMessage};
    /// use protrust::io::CodedInput;
    /// use protrust::wkt::timestamp::Timestamp;
    /// 
    /// fn main() -> protrust::io::InputResult<()> {
    ///     let mut data: &[u8] = &[8, 3, 16, 5];
    ///     let mut input = CodedInput::new(&mut data);
    ///     let mut timestamp = Timestamp::new();
    ///     timestamp.merge_from(&mut input)?;
    /// 
    ///     assert_eq!(*timestamp.seconds(), 3);
    ///     assert_eq!(*timestamp.nanos(), 5);
    /// 
    ///     Ok(())
    /// }
    /// ```
    fn merge_from(&mut self, input: &mut io::CodedInput) -> io::InputResult<()>;

    /// Merges an instance of self from a [`Read`] instance. This is the recommended method to use for simple merging.
    /// 
    /// [`Read`]: https://doc.rust-lang.org/std/io/trait.Read.html
    /// 
    /// # Example
    /// 
    /// ```
    /// use protrust::{CodedMessage, LiteMessage};
    /// use protrust::wkt::timestamp::Timestamp;
    /// 
    /// fn main() -> protrust::io::InputResult<()> {
    ///     let data = [8, 3, 16, 5];
    ///     let mut timestamp = Timestamp::new();
    ///     timestamp.merge_from_reader(&mut data.as_ref())?;
    /// 
    ///     assert_eq!(*timestamp.seconds(), 3);
    ///     assert_eq!(*timestamp.nanos(), 5);
    /// 
    ///     Ok(())
    /// }
    /// ```
    #[inline]
    fn merge_from_reader(&mut self, read: &mut dyn std::io::Read) -> io::InputResult<()> {
        let mut reader = io::CodedInput::new(read);
        self.merge_from(&mut reader)
    }

    /// Calculates the size of the message and returns it as an 32-bit integer or None if the message is larger than `i32::MAX`
    /// 
    /// # Example
    /// 
    /// ```
    /// use protrust::{CodedMessage, LiteMessage};
    /// use protrust::io::CodedOutput;
    /// use protrust::wkt::timestamp::Timestamp;
    /// 
    /// let mut timestamp = Timestamp::new();
    /// *timestamp.seconds_mut() = 3;
    /// *timestamp.nanos_mut() = 5;
    /// 
    /// assert_eq!(timestamp.calculate_size(), Some(4));
    /// ```
    #[cfg(checked_size)]
    fn calculate_size(&self) -> Option<i32>;

    /// Calculates the size of the message and returns it as an 32-bit integer.
    /// 
    /// # Example
    /// 
    /// ```
    /// use protrust::{CodedMessage, LiteMessage};
    /// use protrust::io::CodedOutput;
    /// use protrust::wkt::timestamp::Timestamp;
    /// 
    /// let mut timestamp = Timestamp::new();
    /// *timestamp.seconds_mut() = 3;
    /// *timestamp.nanos_mut() = 5;
    /// 
    /// assert_eq!(timestamp.calculate_size(), 4);
    /// ```
    #[cfg(not(checked_size))]
    fn calculate_size(&self) -> i32;

    /// Writes the fields of this message to the coded output. This requires setting up a [`CodedOutput`] to write to.
    /// If you want to just write to an output, use [`write`].
    /// 
    /// [`CodedOutput`]: io/struct.CodedOutput.html
    /// [`write`]: #method.write
    /// 
    /// # Example
    /// 
    /// ```
    /// use protrust::{CodedMessage, LiteMessage};
    /// use protrust::io::CodedOutput;
    /// use protrust::wkt::timestamp::Timestamp;
    /// 
    /// fn main() -> protrust::io::OutputResult {
    ///     let mut timestamp = Timestamp::new();
    ///     *timestamp.seconds_mut() = 3;
    ///     *timestamp.nanos_mut() = 5;
    /// 
    ///     let mut output = Vec::new();
    ///     let mut coded_output = CodedOutput::new(&mut output);
    ///     timestamp.write_to(&mut coded_output)?;
    /// 
    ///     assert_eq!(&output, &[8, 3, 16, 5]);
    /// 
    ///     Ok(())
    /// }
    /// ```
    fn write_to(&self, output: &mut io::CodedOutput) -> io::OutputResult;

    /// Writes the message to a [`Write`] instance. This is the recommended method for simple writing.
    /// 
    /// [`Write`]: https://doc.rust-lang.org/std/io/trait.Write.html
    /// 
    /// # Example
    /// 
    /// ```
    /// use protrust::{CodedMessage, LiteMessage};
    /// use protrust::wkt::timestamp::Timestamp;
    /// 
    /// fn main() -> protrust::io::OutputResult {
    ///     let mut timestamp = Timestamp::new();
    ///     *timestamp.seconds_mut() = 3;
    ///     *timestamp.nanos_mut() = 5;
    /// 
    ///     let mut output = Vec::new();
    ///     timestamp.write(&mut output)?;
    /// 
    ///     assert_eq!(&output, &[8, 3, 16, 5]);
    /// 
    ///     Ok(())
    /// }
    /// ```
    #[inline]
    fn write(&self, write: &mut dyn std::io::Write) -> io::OutputResult {
        let mut writer = io::CodedOutput::new(write);
        self.write_to(&mut writer)
    }

    /// Writes the message to a new Vec<u8> or Err(io::OutputError::ValueTooLarge) if the message is too large.
    /// 
    /// # Example
    /// 
    /// ```
    /// use protrust::{CodedMessage, LiteMessage};
    /// use protrust::wkt::timestamp::Timestamp;
    /// 
    /// fn main() -> protrust::io::OutputResult {
    ///     let mut timestamp = Timestamp::new();
    ///     *timestamp.seconds_mut() = 3;
    ///     *timestamp.nanos_mut() = 5;
    /// 
    ///     let output = timestamp.write_to_vec()?;
    /// 
    ///     assert_eq!(&output, &[8, 3, 16, 5]);
    /// 
    ///     Ok(())
    /// }
    /// ```
    #[cfg(checked_size)]
    #[inline]
    fn write_to_vec(&self) -> Result<Vec<u8>, io::OutputError> {
        if let Some(size) = self.calculate_size() {
            let mut out = Vec::with_capacity(size as usize);
            self.write(&mut out)?;
            Ok(out)
        } else {
            Err(io::OutputError::ValueTooLarge)
        }
    }

    /// Writes the message to a new `Vec<u8>`
    /// 
    /// # Example
    /// 
    /// ```
    /// use protrust::{CodedMessage, LiteMessage};
    /// use protrust::wkt::timestamp::Timestamp;
    /// 
    /// fn main() -> protrust::io::OutputResult {
    ///     let mut timestamp = Timestamp::new();
    ///     *timestamp.seconds_mut() = 3;
    ///     *timestamp.nanos_mut() = 5;
    /// 
    ///     let output = timestamp.write_to_vec()?;
    /// 
    ///     assert_eq!(&output, &[8, 3, 16, 5]);
    /// 
    ///     Ok(())
    /// }
    /// ```
    #[cfg(not(checked_size))]
    #[inline]
    fn write_to_vec(&self) -> Result<Vec<u8>, io::OutputError> {
        let mut out = Vec::with_capacity(self.calculate_size() as usize);
        self.write(&mut out)?;
        Ok(out)
    }

    /// Gets whether all the required fields and messages are initialized. Proto3 messages return `true`
    /// 
    /// # Example
    /// 
    /// ```
    /// use protrust::{CodedMessage, LiteMessage};
    /// use protrust::wkt::timestamp::Timestamp;
    /// 
    /// let timestamp = Timestamp::new();
    /// assert!(timestamp.is_initialized());
    /// 
    /// use protrust::descriptor::uninterpreted_option::NamePart;
    /// 
    /// let mut name_part = NamePart::new();
    /// assert!(!name_part.is_initialized());
    /// 
    /// name_part.set_name_part(String::from("foo"));
    /// 
    /// assert!(!name_part.is_initialized());
    /// 
    /// name_part.set_is_extension(true);
    /// 
    /// assert!(name_part.is_initialized());
    /// ```
    #[inline]
    fn is_initialized(&self) -> bool {
        true
    }
}

/// A LITE Protocol Buffers message.
/// 
/// # Example
/// 
/// ```
/// use protrust::{CodedMessage, LiteMessage};
/// use protrust::wkt::timestamp::Timestamp;
/// 
/// fn main() -> protrust::io::InputResult<()> {
///     let input = [8, 3];
///     let mut timestamp = Timestamp::read_new(&mut input.as_ref())?;
/// 
///     assert_eq!(*timestamp.seconds(), 3);
///     
///     let other_input = [16, 5];
///     let other_timestamp = Timestamp::read_new(&mut other_input.as_ref())?;
/// 
///     timestamp.merge(&other_timestamp);
/// 
///     assert_eq!(*timestamp.nanos(), 5);
/// 
///     Ok(())
/// }
/// ```
pub trait LiteMessage:
    CodedMessage + Default + Clone + PartialEq + Debug + Send + Sync + 'static
{
    /// Creates a new instance of the message. This message has every field value set to its default.
    /// 
    /// # Example
    /// 
    /// ```
    /// use protrust::LiteMessage;
    /// use protrust::wkt::timestamp::Timestamp;
    /// 
    /// let mut timestamp = Timestamp::new();
    /// 
    /// assert_eq!(*timestamp.seconds(), 0);
    /// assert_eq!(*timestamp.nanos(), 0);
    /// ```
    fn new() -> Self {
        Default::default()
    }

    /// Merges the fields from another message into this one via copy assignment
    fn merge(&mut self, other: &Self);

    /// Reads a new instance of Self from the specified [`Read`] using a [`CodedInput`]
    /// 
    /// [`Read`]: https://doc.rust-lang.org/std/io/trait.Read.html
    /// [`CodedInput`]: io/struct.CodedInput.html
    fn read_new(read: &mut dyn std::io::Read) -> io::InputResult<Self> {
        let mut reader = io::CodedInput::new(read);
        Self::read_new_from_input(&mut reader)
    }

    /// Reads a new instance of Self from the specified CodedInput
    fn read_new_from_input(input: &mut io::CodedInput) -> io::InputResult<Self> {
        let mut instance = Self::new();
        instance.merge_from(input)?;
        Ok(instance)
    }
}

/// A Protocol Buffers message. This exposes the static descriptor that describes the generated message.
#[cfg(feature = "reflection")]
pub trait Message: LiteMessage {
    /// Gets a static reference to the descriptor describing this message type
    fn descriptor() -> &'static reflect::MessageDescriptor<'static>;
}

/// The error result for when an enum value is undefined
pub struct VariantUndefinedError;

/// The common trait for enum types
pub trait Enum:
    'static
    + TryFrom<i32, Error = VariantUndefinedError>
    + Into<i32>
    + Clone
    + Copy
    + Debug
    + Send
    + Sync
{
    /// Gets a static reference to the descriptor for this enum
    #[cfg(feature = "reflection")]
    fn descriptor() -> &'static reflect::EnumDescriptor<'static>;
}

/// Represents a Protocol Buffer enum value that can be a defined enum value or an undefined integer
///
/// In Rust, an enum value without an associated discriminant is undefined behavior.
/// In Protocol Buffers, there is no guarantee that an enum value will be valid.
/// Thus, this union is introduced to allow for both undefined enum values and defined enum values.
#[derive(Copy, Debug, Clone)]
pub enum EnumValue<E> {
    /// A defined enum value
    Defined(E),
    /// An undefined enum value
    Undefined(i32),
}

impl<E: Enum> Default for EnumValue<E> {
    fn default() -> EnumValue<E> {
        EnumValue::from(0)
    }
}

impl<E: Enum> PartialEq for EnumValue<E> {
    fn eq(&self, other: &Self) -> bool {
        i32::from(*self) == i32::from(*other)
    }
}

impl<E: Enum> Eq for EnumValue<E> { }

impl<E: Enum> Hash for EnumValue<E> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        i32::from(*self).hash(state)
    }
}

impl<E> EnumValue<E> {
    /// Converts from an EnumValue<E> to Option<E>, discarding the undefined value if it exists
    pub fn defined(self) -> Option<E> {
        match self {
            EnumValue::Defined(e) => Some(e),
            EnumValue::Undefined(_) => None,
        }
    }

    /// Returns a Defined value, panics if Undefined
    pub fn unwrap(self) -> E {
        match self {
            EnumValue::Defined(e) => e,
            EnumValue::Undefined(u) => panic!("Undefined enum value {}", u),
        }
    }

    /// Returns a Defined value, panics with the specified message if Undefined
    pub fn expect(self, msg: &str) -> E {
        match self {
            EnumValue::Defined(e) => e,
            EnumValue::Undefined(_) => expect_failed(msg),
        }
    }
}

#[inline(never)]
#[cold]
fn expect_failed(msg: &str) -> ! {
    panic!("{}", msg)
}

impl<E: TryFrom<i32, Error = VariantUndefinedError>> From<i32> for EnumValue<E> {
    fn from(value: i32) -> EnumValue<E> {
        if let Ok(e) = E::try_from(value) {
            EnumValue::Defined(e)
        } else {
            EnumValue::Undefined(value)
        }
    }
}

impl<E: Clone + Into<i32>> From<EnumValue<E>> for i32 {
    fn from(value: EnumValue<E>) -> i32 {
        match value {
            EnumValue::Defined(e) => e.into(),
            EnumValue::Undefined(v) => v,
        }
    }
}

#[doc(hidden)]
pub struct Codec<T> {
    start: Tag,
    end: Option<Tag>,
    size: ValueSize<T>,
    merge: fn(&mut io::CodedInput, &mut Option<T>) -> io::InputResult<()>,
    value_merge: fn(&mut T, &T),
    write: fn(&mut io::CodedOutput, &T) -> io::OutputResult,
    packed: bool,
    packable: bool,
}

enum ValueSize<T> {
    Fixed(i32),
    #[cfg(checked_size)]
    Func(fn(&T) -> Option<i32>),
    #[cfg(not(checked_size))]
    Func(fn(&T) -> i32),
}

const fn is_packed(tag: u32) -> bool {
    (tag & 0b111) == 2
}

impl<T> Codec<T> {
    #[inline]
    fn packable(&self) -> bool {
        self.packable
    }

    #[inline]
    fn is_packed(&self) -> bool {
        self.packed
    }

    #[inline]
    fn tag(&self) -> Tag {
        self.start
    }

    #[inline]
    fn end_tag(&self) -> Option<Tag> {
        self.end
    }

    #[cfg(checked_size)]
    #[inline]
    fn calculate_size(&self, value: &T) -> Option<i32> {
        match self.size {
            ValueSize::Fixed(s) => Some(s),
            ValueSize::Func(f) => (f)(value),
        }
    }

    #[cfg(not(checked_size))]
    #[inline]
    fn calculate_size(&self, value: &T) -> i32 {
        match self.size {
            ValueSize::Fixed(s) => s,
            ValueSize::Func(f) => (f)(value),
        }
    }

    #[inline]
    fn write_to(&self, output: &mut io::CodedOutput, value: &T) -> io::OutputResult {
        (self.write)(output, value)
    }

    fn read_from(&self, input: &mut io::CodedInput) -> io::InputResult<T> {
        let mut value = None;
        self.merge_from(input, &mut value)?;
        if let Some(value) = value {
            Ok(value)
        } else {
            panic!("codec did not read and assign value from coded input")
        }
    }

    #[inline]
    fn merge_from(&self, input: &mut io::CodedInput, value: &mut Option<T>) -> io::InputResult<()> {
        (self.merge)(input, value)
    }

    #[inline]
    fn merge_values(&self, first: &mut T, second: &T) {
        (self.value_merge)(first, second)
    }
}

#[doc(hidden)]
impl Codec<f32> {
    pub const fn float(tag: u32) -> Codec<f32> {
        unsafe {
            Codec {
                start: Tag::new_unchecked(tag),
                end: None,
                #[cfg(checked_size)]
                size: ValueSize::Func(|i| Some(io::sizes::float(*i))),
                #[cfg(not(checked_size))]
                size: ValueSize::Func(|i| io::sizes::float(*i)),
                merge: |i, v| {
                    *v = Some(i.read_float()?);
                    Ok(())
                },
                value_merge: |s, o| *s = o.clone(),
                write: |o, v| o.write_float(*v),
                packed: is_packed(tag),
                packable: true,
            }
        }
    }
}

#[doc(hidden)]
impl Codec<f64> {
    pub const fn double(tag: u32) -> Codec<f64> {
        unsafe {
            Codec {
                start: Tag::new_unchecked(tag),
                end: None,
                #[cfg(checked_size)]
                size: ValueSize::Func(|i| Some(io::sizes::double(*i))),
                #[cfg(not(checked_size))]
                size: ValueSize::Func(|i| io::sizes::double(*i)),
                merge: |i, v| {
                    *v = Some(i.read_double()?);
                    Ok(())
                },
                value_merge: |s, o| *s = o.clone(),
                write: |o, v| o.write_double(*v),
                packed: is_packed(tag),
                packable: true,
            }
        }
    }
}

#[doc(hidden)]
impl Codec<i32> {
    pub const fn int32(tag: u32) -> Codec<i32> {
        unsafe {
            Codec {
                start: Tag::new_unchecked(tag),
                end: None,
                #[cfg(checked_size)]
                size: ValueSize::Func(|i| Some(io::sizes::int32(*i))),
                #[cfg(not(checked_size))]
                size: ValueSize::Func(|i| io::sizes::int32(*i)),
                merge: |i, v| {
                    *v = Some(i.read_int32()?);
                    Ok(())
                },
                value_merge: |s, o| *s = o.clone(),
                write: |o, v| o.write_int32(*v),
                packed: is_packed(tag),
                packable: true,
            }
        }
    }

    pub const fn sint32(tag: u32) -> Codec<i32> {
        unsafe {
            Codec {
                start: Tag::new_unchecked(tag),
                end: None,
                #[cfg(checked_size)]
                size: ValueSize::Func(|i| Some(io::sizes::sint32(*i))),
                #[cfg(not(checked_size))]
                size: ValueSize::Func(|i| io::sizes::sint32(*i)),
                merge: |i, v| {
                    *v = Some(i.read_sint32()?);
                    Ok(())
                },
                value_merge: |s, o| *s = o.clone(),
                write: |o, v| o.write_sint32(*v),
                packed: is_packed(tag),
                packable: true,
            }
        }
    }

    pub const fn sfixed32(tag: u32) -> Codec<i32> {
        unsafe {
            Codec {
                start: Tag::new_unchecked(tag),
                end: None,
                size: ValueSize::Fixed(4),
                merge: |i, v| {
                    *v = Some(i.read_sfixed32()?);
                    Ok(())
                },
                value_merge: |s, o| *s = o.clone(),
                write: |o, v| o.write_sfixed32(*v),
                packed: is_packed(tag),
                packable: true,
            }
        }
    }
}

#[doc(hidden)]
impl Codec<u32> {
    pub const fn uint32(tag: u32) -> Codec<u32> {
        unsafe {
            Codec {
                start: Tag::new_unchecked(tag),
                end: None,
                #[cfg(checked_size)]
                size: ValueSize::Func(|i| Some(io::sizes::uint32(*i))),
                #[cfg(not(checked_size))]
                size: ValueSize::Func(|i| io::sizes::uint32(*i)),
                merge: |i, v| {
                    *v = Some(i.read_uint32()?);
                    Ok(())
                },
                value_merge: |s, o| *s = o.clone(),
                write: |o, v| o.write_uint32(*v),
                packed: is_packed(tag),
                packable: true,
            }
        }
    }

    pub const fn fixed32(tag: u32) -> Codec<u32> {
        unsafe {
            Codec {
                start: Tag::new_unchecked(tag),
                end: None,
                size: ValueSize::Fixed(4),
                merge: |i, v| {
                    *v = Some(i.read_fixed32()?);
                    Ok(())
                },
                value_merge: |s, o| *s = o.clone(),
                write: |o, v| o.write_fixed32(*v),
                packed: is_packed(tag),
                packable: true,
            }
        }
    }
}

#[doc(hidden)]
impl Codec<i64> {
    pub const fn int64(tag: u32) -> Codec<i64> {
        unsafe {
            Codec {
                start: Tag::new_unchecked(tag),
                end: None,
                #[cfg(checked_size)]
                size: ValueSize::Func(|i| Some(io::sizes::int64(*i))),
                #[cfg(not(checked_size))]
                size: ValueSize::Func(|i| io::sizes::int64(*i)),
                merge: |i, v| {
                    *v = Some(i.read_int64()?);
                    Ok(())
                },
                value_merge: |s, o| *s = o.clone(),
                write: |o, v| o.write_int64(*v),
                packed: is_packed(tag),
                packable: true,
            }
        }
    }

    pub const fn sint64(tag: u32) -> Codec<i64> {
        unsafe {
            Codec {
                start: Tag::new_unchecked(tag),
                end: None,
                #[cfg(checked_size)]
                size: ValueSize::Func(|i| Some(io::sizes::sint64(*i))),
                #[cfg(not(checked_size))]
                size: ValueSize::Func(|i| io::sizes::sint64(*i)),
                merge: |i, v| {
                    *v = Some(i.read_sint64()?);
                    Ok(())
                },
                value_merge: |s, o| *s = o.clone(),
                write: |o, v| o.write_sint64(*v),
                packed: is_packed(tag),
                packable: true,
            }
        }
    }

    pub const fn sfixed64(tag: u32) -> Codec<i64> {
        unsafe {
            Codec {
                start: Tag::new_unchecked(tag),
                end: None,
                size: ValueSize::Fixed(8),
                merge: |i, v| {
                    *v = Some(i.read_sfixed64()?);
                    Ok(())
                },
                value_merge: |s, o| *s = o.clone(),
                write: |o, v| o.write_sfixed64(*v),
                packed: is_packed(tag),
                packable: true,
            }
        }
    }
}

#[doc(hidden)]
impl Codec<u64> {
    pub const fn uint64(tag: u32) -> Codec<u64> {
        unsafe {
            Codec {
                start: Tag::new_unchecked(tag),
                end: None,
                #[cfg(checked_size)]
                size: ValueSize::Func(|i| Some(io::sizes::uint64(*i))),
                #[cfg(not(checked_size))]
                size: ValueSize::Func(|i| io::sizes::uint64(*i)),
                merge: |i, v| {
                    *v = Some(i.read_uint64()?);
                    Ok(())
                },
                value_merge: |s, o| *s = o.clone(),
                write: |o, v| o.write_uint64(*v),
                packed: is_packed(tag),
                packable: true,
            }
        }
    }

    pub const fn fixed64(tag: u32) -> Codec<u64> {
        unsafe {
            Codec {
                start: Tag::new_unchecked(tag),
                end: None,
                size: ValueSize::Fixed(8),
                merge: |i, v| {
                    *v = Some(i.read_fixed64()?);
                    Ok(())
                },
                value_merge: |s, o| *s = o.clone(),
                write: |o, v| o.write_fixed64(*v),
                packed: is_packed(tag),
                packable: true,
            }
        }
    }
}

#[doc(hidden)]
impl Codec<bool> {
    pub const fn bool(tag: u32) -> Codec<bool> {
        unsafe {
            Codec {
                start: Tag::new_unchecked(tag),
                end: None,
                size: ValueSize::Fixed(1),
                merge: |i, v| {
                    *v = Some(i.read_bool()?);
                    Ok(())
                },
                value_merge: |s, o| *s = o.clone(),
                write: |o, v| o.write_bool(*v),
                packed: is_packed(tag),
                packable: true,
            }
        }
    }
}

#[doc(hidden)]
impl Codec<String> {
    pub const fn string(tag: u32) -> Codec<String> {
        unsafe {
            Codec {
                start: Tag::new_unchecked(tag),
                end: None,
                size: ValueSize::Func(|s| io::sizes::string(s)),
                merge: |i, v| {
                    *v = Some(i.read_string()?);
                    Ok(())
                },
                value_merge: |s, o| *s = o.clone(),
                write: |o, v| o.write_string(v),
                packed: false,
                packable: false,
            }
        }
    }
}

#[doc(hidden)]
impl Codec<Vec<u8>> {
    pub const fn bytes(tag: u32) -> Codec<Vec<u8>> {
        unsafe {
            Codec {
                start: Tag::new_unchecked(tag),
                end: None,
                size: ValueSize::Func(|b| io::sizes::bytes(b)),
                merge: |i, v| {
                    *v = Some(i.read_bytes()?);
                    Ok(())
                },
                value_merge: |s, o| *s = o.clone(),
                write: |o, v| o.write_bytes(v),
                packed: false,
                packable: false,
            }
        }
    }
}

#[doc(hidden)]
impl<M: LiteMessage> Codec<M> {
    pub const fn message(tag: u32) -> Codec<M> {
        unsafe {
            Codec {
                start: Tag::new_unchecked(tag),
                end: None,
                size: ValueSize::Func(|m| io::sizes::message(m)),
                merge: |i, v| {
                    if let Some(v) = v {
                        i.read_message(v)?;
                    } else {
                        let mut new = M::new();
                        i.read_message(&mut new)?;
                        *v = Some(new);
                    }
                    Ok(())
                },
                value_merge: |s, o| s.merge(o),
                write: |o, v| o.write_message(v),
                packed: false,
                packable: false,
            }
        }
    }

    pub const fn group(start: u32, end: u32) -> Codec<M> {
        unsafe {
            Codec {
                start: Tag::new_unchecked(start),
                end: Some(Tag::new_unchecked(end)),
                size: ValueSize::Func(|m| io::sizes::group(m)),
                merge: |i, v| {
                    if let Some(v) = v {
                        i.read_group(v)?;
                    } else {
                        let mut new = M::new();
                        i.read_group(&mut new)?;
                        *v = Some(new);
                    }
                    Ok(())
                },
                value_merge: |s, o| s.merge(o),
                write: |o, v| o.write_group(v),
                packed: false,
                packable: false,
            }
        }
    }
}

#[doc(hidden)]
impl<M: ExtendableMessage> Codec<M> {
    pub const fn extension_message(tag: u32) -> Codec<M> {
        unsafe {
            Codec {
                start: Tag::new_unchecked(tag),
                end: None,
                size: ValueSize::Func(|m| io::sizes::message(m)),
                merge: |i, v| {
                    if let Some(v) = v {
                        i.read_message(v)?;
                    } else {
                        let mut new = M::with_registry(i.registry());
                        i.read_message(&mut new)?;
                        *v = Some(new);
                    }
                    Ok(())
                },
                value_merge: |s, o| s.merge(o),
                write: |o, v| o.write_message(v),
                packed: false,
                packable: false,
            }
        }
    }
}

#[doc(hidden)]
impl<E: Enum> Codec<EnumValue<E>> {
    pub const fn enum_value(tag: u32) -> Codec<EnumValue<E>> {
        unsafe {
            Codec {
                start: Tag::new_unchecked(tag),
                end: None,
                #[cfg(checked_size)]
                size: ValueSize::Func(|e| Some(io::sizes::enum_value(e.clone()))),
                #[cfg(not(checked_size))]
                size: ValueSize::Func(|e| io::sizes::enum_value(e.clone())),
                merge: |i, v| {
                    *v = Some(EnumValue::from(i.read_int32()?));
                    Ok(())
                },
                value_merge: |s, o| *s = o.clone(),
                write: |o, v| o.write_int32(Into::<i32>::into(v.clone())),
                packed: is_packed(tag),
                packable: true,
            }
        }
    }
}

#[derive(Clone, Debug, PartialEq, Default)]
#[doc(hidden)]
pub struct UnknownFieldSet(HashMap<Tag, UnknownField>);

#[derive(Clone, Debug, PartialEq)]
enum UnknownField {
    Varint(u64),
    Bit64(u64),
    LengthDelimited(Vec<u8>),
    Group(UnknownFieldSet),
    Bit32(u32),
}

impl UnknownFieldSet {
    pub fn new() -> UnknownFieldSet {
        UnknownFieldSet(HashMap::new())
    }

    pub fn write_to(&self, output: &mut io::CodedOutput) -> io::OutputResult {
        for field in &self.0 {
            output.write_tag(*field.0)?;
            match field.1 {
                UnknownField::Varint(v) => {
                    output.write_uint64(*v)?;
                }
                UnknownField::Bit64(v) => {
                    output.write_fixed64(*v)?;
                }
                UnknownField::LengthDelimited(v) => {
                    output.write_bytes(v)?;
                }
                UnknownField::Group(v) => {
                    v.write_to(output)?;
                    output.write_tag(Tag::new(field.0.number(), WireType::EndGroup))?;
                }
                UnknownField::Bit32(v) => {
                    output.write_fixed32(*v)?;
                }
            }
        }
        Ok(())
    }

    #[cfg(checked_size)]
    pub fn calculate_size(&self) -> Option<i32> {
        let mut size = 0i32;
        for field in &self.0 {
            size = size.checked_add(io::sizes::uint32(field.0.get()))?;
            match field.1 {
                UnknownField::Varint(v) => {
                    size = size.checked_add(io::sizes::uint64(*v))?;
                }
                UnknownField::Bit64(v) => {
                    size = size.checked_add(io::sizes::fixed64(*v))?;
                }
                UnknownField::LengthDelimited(v) => {
                    size = size.checked_add(io::sizes::bytes(v)?)?;
                }
                UnknownField::Group(v) => {
                    size = size.checked_add(v.calculate_size()?)?;
                    size = size.checked_add(io::sizes::uint32(Tag::new(
                        field.0.number(),
                        WireType::EndGroup,
                    )))?;
                }
                UnknownField::Bit32(v) => {
                    size = size.checked_add(io::sizes::fixed32(*v))?;
                }
            }
        }
        Some(size)
    }

    #[cfg(not(checked_size))]
    pub fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        for field in &self.0 {
            size += io::sizes::uint32(field.0.get());
            match field.1 {
                UnknownField::Varint(v) => {
                    size += io::sizes::uint64(*v);
                }
                UnknownField::Bit64(v) => {
                    size += io::sizes::fixed64(*v);
                }
                UnknownField::LengthDelimited(v) => {
                    size += io::sizes::bytes(v);
                }
                UnknownField::Group(v) => {
                    size += v.calculate_size();
                    size += io::sizes::uint32(Tag::new(field.0.number(), WireType::EndGroup).get());
                }
                UnknownField::Bit32(v) => {
                    size += io::sizes::fixed32(*v);
                }
            }
        }
        size
    }

    pub fn merge_from(&mut self, tag: Tag, input: &mut io::CodedInput) -> io::InputResult<()> {
        let wt = tag.wire_type();
        match wt {
            WireType::Varint => {
                self.0
                    .insert(tag, UnknownField::Varint(input.read_uint64()?));
            }
            WireType::Bit64 => {
                self.0
                    .insert(tag, UnknownField::Bit64(input.read_fixed64()?));
            }
            WireType::LengthDelimited => {
                self.0
                    .insert(tag, UnknownField::LengthDelimited(input.read_bytes()?));
            }
            WireType::StartGroup => {
                let end = Tag::new(tag.number(), WireType::EndGroup);
                let mut set = UnknownFieldSet::new();
                while let Some(tag) = input.read_tag()? {
                    match tag.get() {
                        _ if end == tag => break,
                        _ => set.merge_from(tag, input)?,
                    }
                }
                self.0.insert(tag, UnknownField::Group(set));
            }
            WireType::EndGroup => return Err(io::InputError::InvalidTag(tag.get())),
            WireType::Bit32 => {
                self.0
                    .insert(tag, UnknownField::Bit32(input.read_fixed32()?));
            }
        }

        Ok(())
    }

    pub fn merge(&mut self, other: &Self) {
        for field in &other.0 {
            self.0.insert(*field.0, field.1.clone());
        }
    }
}