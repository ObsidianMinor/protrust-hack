// DO NOT EDIT!
// Generated by protoc-gen-rust, part of the protrust crate.
//
// Source: google/protobuf/descriptor.proto

static FILE_ONCE: ::std::sync::Once = ::std::sync::Once::new();
static mut FILE_POOL: ::std::option::Option<crate::reflect::DescriptorPool<'static>> = ::std::option::Option::None;
static mut FILE_PROTO: ::std::option::Option<[crate::descriptor::FileDescriptorProto; 1]> = ::std::option::Option::None;
static mut FILE_DESCRIPTOR: ::std::option::Option<&'static crate::reflect::FileDescriptor> = ::std::option::Option::None;
static mut FILE_DEPS: ::std::option::Option<[&'static crate::reflect::DescriptorPool<'static>; 0]> = ::std::option::Option::None;

fn file_once_init() {
    unsafe {
        FILE_PROTO = ::std::option::Option::Some([crate::LiteMessage::read_new(&mut [
            10, 32, 103, 111, 111, 103, 108, 101, 47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 100, 101, 
            115, 99, 114, 105, 112, 116, 111, 114, 46, 112, 114, 111, 116, 111, 18, 15, 103, 111, 111, 103, 
            108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 34, 77, 10, 17, 70, 105, 108, 101, 68, 
            101, 115, 99, 114, 105, 112, 116, 111, 114, 83, 101, 116, 18, 56, 10, 4, 102, 105, 108, 101, 
            24, 1, 32, 3, 40, 11, 50, 36, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 
            111, 98, 117, 102, 46, 70, 105, 108, 101, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 
            114, 111, 116, 111, 82, 4, 102, 105, 108, 101, 34, 228, 4, 10, 19, 70, 105, 108, 101, 68, 
            101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 18, 18, 10, 4, 110, 97, 
            109, 101, 24, 1, 32, 1, 40, 9, 82, 4, 110, 97, 109, 101, 18, 24, 10, 7, 112, 97, 
            99, 107, 97, 103, 101, 24, 2, 32, 1, 40, 9, 82, 7, 112, 97, 99, 107, 97, 103, 101, 
            18, 30, 10, 10, 100, 101, 112, 101, 110, 100, 101, 110, 99, 121, 24, 3, 32, 3, 40, 9, 
            82, 10, 100, 101, 112, 101, 110, 100, 101, 110, 99, 121, 18, 43, 10, 17, 112, 117, 98, 108, 
            105, 99, 95, 100, 101, 112, 101, 110, 100, 101, 110, 99, 121, 24, 10, 32, 3, 40, 5, 82, 
            16, 112, 117, 98, 108, 105, 99, 68, 101, 112, 101, 110, 100, 101, 110, 99, 121, 18, 39, 10, 
            15, 119, 101, 97, 107, 95, 100, 101, 112, 101, 110, 100, 101, 110, 99, 121, 24, 11, 32, 3, 
            40, 5, 82, 14, 119, 101, 97, 107, 68, 101, 112, 101, 110, 100, 101, 110, 99, 121, 18, 67, 
            10, 12, 109, 101, 115, 115, 97, 103, 101, 95, 116, 121, 112, 101, 24, 4, 32, 3, 40, 11, 
            50, 32, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 68, 
            101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 82, 11, 109, 101, 115, 115, 
            97, 103, 101, 84, 121, 112, 101, 18, 65, 10, 9, 101, 110, 117, 109, 95, 116, 121, 112, 101, 
            24, 5, 32, 3, 40, 11, 50, 36, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 
            111, 98, 117, 102, 46, 69, 110, 117, 109, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 
            114, 111, 116, 111, 82, 8, 101, 110, 117, 109, 84, 121, 112, 101, 18, 65, 10, 7, 115, 101, 
            114, 118, 105, 99, 101, 24, 6, 32, 3, 40, 11, 50, 39, 46, 103, 111, 111, 103, 108, 101, 
            46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 83, 101, 114, 118, 105, 99, 101, 68, 101, 115, 
            99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 82, 7, 115, 101, 114, 118, 105, 99, 
            101, 18, 67, 10, 9, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 7, 32, 3, 40, 11, 
            50, 37, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 70, 
            105, 101, 108, 100, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 82, 
            9, 101, 120, 116, 101, 110, 115, 105, 111, 110, 18, 54, 10, 7, 111, 112, 116, 105, 111, 110, 
            115, 24, 8, 32, 1, 40, 11, 50, 28, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 
            116, 111, 98, 117, 102, 46, 70, 105, 108, 101, 79, 112, 116, 105, 111, 110, 115, 82, 7, 111, 
            112, 116, 105, 111, 110, 115, 18, 73, 10, 16, 115, 111, 117, 114, 99, 101, 95, 99, 111, 100, 
            101, 95, 105, 110, 102, 111, 24, 9, 32, 1, 40, 11, 50, 31, 46, 103, 111, 111, 103, 108, 
            101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 83, 111, 117, 114, 99, 101, 67, 111, 100, 
            101, 73, 110, 102, 111, 82, 14, 115, 111, 117, 114, 99, 101, 67, 111, 100, 101, 73, 110, 102, 
            111, 18, 22, 10, 6, 115, 121, 110, 116, 97, 120, 24, 12, 32, 1, 40, 9, 82, 6, 115, 
            121, 110, 116, 97, 120, 34, 185, 6, 10, 15, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 
            80, 114, 111, 116, 111, 18, 18, 10, 4, 110, 97, 109, 101, 24, 1, 32, 1, 40, 9, 82, 
            4, 110, 97, 109, 101, 18, 59, 10, 5, 102, 105, 101, 108, 100, 24, 2, 32, 3, 40, 11, 
            50, 37, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 70, 
            105, 101, 108, 100, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 82, 
            5, 102, 105, 101, 108, 100, 18, 67, 10, 9, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 
            6, 32, 3, 40, 11, 50, 37, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 
            98, 117, 102, 46, 70, 105, 101, 108, 100, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 
            114, 111, 116, 111, 82, 9, 101, 120, 116, 101, 110, 115, 105, 111, 110, 18, 65, 10, 11, 110, 
            101, 115, 116, 101, 100, 95, 116, 121, 112, 101, 24, 3, 32, 3, 40, 11, 50, 32, 46, 103, 
            111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 68, 101, 115, 99, 114, 
            105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 82, 10, 110, 101, 115, 116, 101, 100, 84, 121, 
            112, 101, 18, 65, 10, 9, 101, 110, 117, 109, 95, 116, 121, 112, 101, 24, 4, 32, 3, 40, 
            11, 50, 36, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 
            69, 110, 117, 109, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 82, 
            8, 101, 110, 117, 109, 84, 121, 112, 101, 18, 88, 10, 15, 101, 120, 116, 101, 110, 115, 105, 
            111, 110, 95, 114, 97, 110, 103, 101, 24, 5, 32, 3, 40, 11, 50, 47, 46, 103, 111, 111, 
            103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 68, 101, 115, 99, 114, 105, 112, 
            116, 111, 114, 80, 114, 111, 116, 111, 46, 69, 120, 116, 101, 110, 115, 105, 111, 110, 82, 97, 
            110, 103, 101, 82, 14, 101, 120, 116, 101, 110, 115, 105, 111, 110, 82, 97, 110, 103, 101, 18, 
            68, 10, 10, 111, 110, 101, 111, 102, 95, 100, 101, 99, 108, 24, 8, 32, 3, 40, 11, 50, 
            37, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 79, 110, 
            101, 111, 102, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 82, 9, 
            111, 110, 101, 111, 102, 68, 101, 99, 108, 18, 57, 10, 7, 111, 112, 116, 105, 111, 110, 115, 
            24, 7, 32, 1, 40, 11, 50, 31, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 
            111, 98, 117, 102, 46, 77, 101, 115, 115, 97, 103, 101, 79, 112, 116, 105, 111, 110, 115, 82, 
            7, 111, 112, 116, 105, 111, 110, 115, 18, 85, 10, 14, 114, 101, 115, 101, 114, 118, 101, 100, 
            95, 114, 97, 110, 103, 101, 24, 9, 32, 3, 40, 11, 50, 46, 46, 103, 111, 111, 103, 108, 
            101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 68, 101, 115, 99, 114, 105, 112, 116, 111, 
            114, 80, 114, 111, 116, 111, 46, 82, 101, 115, 101, 114, 118, 101, 100, 82, 97, 110, 103, 101, 
            82, 13, 114, 101, 115, 101, 114, 118, 101, 100, 82, 97, 110, 103, 101, 18, 35, 10, 13, 114, 
            101, 115, 101, 114, 118, 101, 100, 95, 110, 97, 109, 101, 24, 10, 32, 3, 40, 9, 82, 12, 
            114, 101, 115, 101, 114, 118, 101, 100, 78, 97, 109, 101, 26, 122, 10, 14, 69, 120, 116, 101, 
            110, 115, 105, 111, 110, 82, 97, 110, 103, 101, 18, 20, 10, 5, 115, 116, 97, 114, 116, 24, 
            1, 32, 1, 40, 5, 82, 5, 115, 116, 97, 114, 116, 18, 16, 10, 3, 101, 110, 100, 24, 
            2, 32, 1, 40, 5, 82, 3, 101, 110, 100, 18, 64, 10, 7, 111, 112, 116, 105, 111, 110, 
            115, 24, 3, 32, 1, 40, 11, 50, 38, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 
            116, 111, 98, 117, 102, 46, 69, 120, 116, 101, 110, 115, 105, 111, 110, 82, 97, 110, 103, 101, 
            79, 112, 116, 105, 111, 110, 115, 82, 7, 111, 112, 116, 105, 111, 110, 115, 26, 55, 10, 13, 
            82, 101, 115, 101, 114, 118, 101, 100, 82, 97, 110, 103, 101, 18, 20, 10, 5, 115, 116, 97, 
            114, 116, 24, 1, 32, 1, 40, 5, 82, 5, 115, 116, 97, 114, 116, 18, 16, 10, 3, 101, 
            110, 100, 24, 2, 32, 1, 40, 5, 82, 3, 101, 110, 100, 34, 124, 10, 21, 69, 120, 116, 
            101, 110, 115, 105, 111, 110, 82, 97, 110, 103, 101, 79, 112, 116, 105, 111, 110, 115, 18, 88, 
            10, 20, 117, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 95, 111, 112, 116, 105, 
            111, 110, 24, 231, 7, 32, 3, 40, 11, 50, 36, 46, 103, 111, 111, 103, 108, 101, 46, 112, 
            114, 111, 116, 111, 98, 117, 102, 46, 85, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 
            100, 79, 112, 116, 105, 111, 110, 82, 19, 117, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 
            101, 100, 79, 112, 116, 105, 111, 110, 42, 9, 8, 232, 7, 16, 128, 128, 128, 128, 2, 34, 
            152, 6, 10, 20, 70, 105, 101, 108, 100, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 
            114, 111, 116, 111, 18, 18, 10, 4, 110, 97, 109, 101, 24, 1, 32, 1, 40, 9, 82, 4, 
            110, 97, 109, 101, 18, 22, 10, 6, 110, 117, 109, 98, 101, 114, 24, 3, 32, 1, 40, 5, 
            82, 6, 110, 117, 109, 98, 101, 114, 18, 65, 10, 5, 108, 97, 98, 101, 108, 24, 4, 32, 
            1, 40, 14, 50, 43, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 
            102, 46, 70, 105, 101, 108, 100, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 
            116, 111, 46, 76, 97, 98, 101, 108, 82, 5, 108, 97, 98, 101, 108, 18, 62, 10, 4, 116, 
            121, 112, 101, 24, 5, 32, 1, 40, 14, 50, 42, 46, 103, 111, 111, 103, 108, 101, 46, 112, 
            114, 111, 116, 111, 98, 117, 102, 46, 70, 105, 101, 108, 100, 68, 101, 115, 99, 114, 105, 112, 
            116, 111, 114, 80, 114, 111, 116, 111, 46, 84, 121, 112, 101, 82, 4, 116, 121, 112, 101, 18, 
            27, 10, 9, 116, 121, 112, 101, 95, 110, 97, 109, 101, 24, 6, 32, 1, 40, 9, 82, 8, 
            116, 121, 112, 101, 78, 97, 109, 101, 18, 26, 10, 8, 101, 120, 116, 101, 110, 100, 101, 101, 
            24, 2, 32, 1, 40, 9, 82, 8, 101, 120, 116, 101, 110, 100, 101, 101, 18, 35, 10, 13, 
            100, 101, 102, 97, 117, 108, 116, 95, 118, 97, 108, 117, 101, 24, 7, 32, 1, 40, 9, 82, 
            12, 100, 101, 102, 97, 117, 108, 116, 86, 97, 108, 117, 101, 18, 31, 10, 11, 111, 110, 101, 
            111, 102, 95, 105, 110, 100, 101, 120, 24, 9, 32, 1, 40, 5, 82, 10, 111, 110, 101, 111, 
            102, 73, 110, 100, 101, 120, 18, 27, 10, 9, 106, 115, 111, 110, 95, 110, 97, 109, 101, 24, 
            10, 32, 1, 40, 9, 82, 8, 106, 115, 111, 110, 78, 97, 109, 101, 18, 55, 10, 7, 111, 
            112, 116, 105, 111, 110, 115, 24, 8, 32, 1, 40, 11, 50, 29, 46, 103, 111, 111, 103, 108, 
            101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 70, 105, 101, 108, 100, 79, 112, 116, 105, 
            111, 110, 115, 82, 7, 111, 112, 116, 105, 111, 110, 115, 34, 182, 2, 10, 4, 84, 121, 112, 
            101, 18, 15, 10, 11, 84, 89, 80, 69, 95, 68, 79, 85, 66, 76, 69, 16, 1, 18, 14, 
            10, 10, 84, 89, 80, 69, 95, 70, 76, 79, 65, 84, 16, 2, 18, 14, 10, 10, 84, 89, 
            80, 69, 95, 73, 78, 84, 54, 52, 16, 3, 18, 15, 10, 11, 84, 89, 80, 69, 95, 85, 
            73, 78, 84, 54, 52, 16, 4, 18, 14, 10, 10, 84, 89, 80, 69, 95, 73, 78, 84, 51, 
            50, 16, 5, 18, 16, 10, 12, 84, 89, 80, 69, 95, 70, 73, 88, 69, 68, 54, 52, 16, 
            6, 18, 16, 10, 12, 84, 89, 80, 69, 95, 70, 73, 88, 69, 68, 51, 50, 16, 7, 18, 
            13, 10, 9, 84, 89, 80, 69, 95, 66, 79, 79, 76, 16, 8, 18, 15, 10, 11, 84, 89, 
            80, 69, 95, 83, 84, 82, 73, 78, 71, 16, 9, 18, 14, 10, 10, 84, 89, 80, 69, 95, 
            71, 82, 79, 85, 80, 16, 10, 18, 16, 10, 12, 84, 89, 80, 69, 95, 77, 69, 83, 83, 
            65, 71, 69, 16, 11, 18, 14, 10, 10, 84, 89, 80, 69, 95, 66, 89, 84, 69, 83, 16, 
            12, 18, 15, 10, 11, 84, 89, 80, 69, 95, 85, 73, 78, 84, 51, 50, 16, 13, 18, 13, 
            10, 9, 84, 89, 80, 69, 95, 69, 78, 85, 77, 16, 14, 18, 17, 10, 13, 84, 89, 80, 
            69, 95, 83, 70, 73, 88, 69, 68, 51, 50, 16, 15, 18, 17, 10, 13, 84, 89, 80, 69, 
            95, 83, 70, 73, 88, 69, 68, 54, 52, 16, 16, 18, 15, 10, 11, 84, 89, 80, 69, 95, 
            83, 73, 78, 84, 51, 50, 16, 17, 18, 15, 10, 11, 84, 89, 80, 69, 95, 83, 73, 78, 
            84, 54, 52, 16, 18, 34, 67, 10, 5, 76, 97, 98, 101, 108, 18, 18, 10, 14, 76, 65, 
            66, 69, 76, 95, 79, 80, 84, 73, 79, 78, 65, 76, 16, 1, 18, 18, 10, 14, 76, 65, 
            66, 69, 76, 95, 82, 69, 81, 85, 73, 82, 69, 68, 16, 2, 18, 18, 10, 14, 76, 65, 
            66, 69, 76, 95, 82, 69, 80, 69, 65, 84, 69, 68, 16, 3, 34, 99, 10, 20, 79, 110, 
            101, 111, 102, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 18, 18, 
            10, 4, 110, 97, 109, 101, 24, 1, 32, 1, 40, 9, 82, 4, 110, 97, 109, 101, 18, 55, 
            10, 7, 111, 112, 116, 105, 111, 110, 115, 24, 2, 32, 1, 40, 11, 50, 29, 46, 103, 111, 
            111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 79, 110, 101, 111, 102, 79, 
            112, 116, 105, 111, 110, 115, 82, 7, 111, 112, 116, 105, 111, 110, 115, 34, 227, 2, 10, 19, 
            69, 110, 117, 109, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 18, 
            18, 10, 4, 110, 97, 109, 101, 24, 1, 32, 1, 40, 9, 82, 4, 110, 97, 109, 101, 18, 
            63, 10, 5, 118, 97, 108, 117, 101, 24, 2, 32, 3, 40, 11, 50, 41, 46, 103, 111, 111, 
            103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 69, 110, 117, 109, 86, 97, 108, 
            117, 101, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 82, 5, 118, 
            97, 108, 117, 101, 18, 54, 10, 7, 111, 112, 116, 105, 111, 110, 115, 24, 3, 32, 1, 40, 
            11, 50, 28, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 
            69, 110, 117, 109, 79, 112, 116, 105, 111, 110, 115, 82, 7, 111, 112, 116, 105, 111, 110, 115, 
            18, 93, 10, 14, 114, 101, 115, 101, 114, 118, 101, 100, 95, 114, 97, 110, 103, 101, 24, 4, 
            32, 3, 40, 11, 50, 54, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 
            117, 102, 46, 69, 110, 117, 109, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 
            116, 111, 46, 69, 110, 117, 109, 82, 101, 115, 101, 114, 118, 101, 100, 82, 97, 110, 103, 101, 
            82, 13, 114, 101, 115, 101, 114, 118, 101, 100, 82, 97, 110, 103, 101, 18, 35, 10, 13, 114, 
            101, 115, 101, 114, 118, 101, 100, 95, 110, 97, 109, 101, 24, 5, 32, 3, 40, 9, 82, 12, 
            114, 101, 115, 101, 114, 118, 101, 100, 78, 97, 109, 101, 26, 59, 10, 17, 69, 110, 117, 109, 
            82, 101, 115, 101, 114, 118, 101, 100, 82, 97, 110, 103, 101, 18, 20, 10, 5, 115, 116, 97, 
            114, 116, 24, 1, 32, 1, 40, 5, 82, 5, 115, 116, 97, 114, 116, 18, 16, 10, 3, 101, 
            110, 100, 24, 2, 32, 1, 40, 5, 82, 3, 101, 110, 100, 34, 131, 1, 10, 24, 69, 110, 
            117, 109, 86, 97, 108, 117, 101, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 
            116, 111, 18, 18, 10, 4, 110, 97, 109, 101, 24, 1, 32, 1, 40, 9, 82, 4, 110, 97, 
            109, 101, 18, 22, 10, 6, 110, 117, 109, 98, 101, 114, 24, 2, 32, 1, 40, 5, 82, 6, 
            110, 117, 109, 98, 101, 114, 18, 59, 10, 7, 111, 112, 116, 105, 111, 110, 115, 24, 3, 32, 
            1, 40, 11, 50, 33, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 
            102, 46, 69, 110, 117, 109, 86, 97, 108, 117, 101, 79, 112, 116, 105, 111, 110, 115, 82, 7, 
            111, 112, 116, 105, 111, 110, 115, 34, 167, 1, 10, 22, 83, 101, 114, 118, 105, 99, 101, 68, 
            101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 18, 18, 10, 4, 110, 97, 
            109, 101, 24, 1, 32, 1, 40, 9, 82, 4, 110, 97, 109, 101, 18, 62, 10, 6, 109, 101, 
            116, 104, 111, 100, 24, 2, 32, 3, 40, 11, 50, 38, 46, 103, 111, 111, 103, 108, 101, 46, 
            112, 114, 111, 116, 111, 98, 117, 102, 46, 77, 101, 116, 104, 111, 100, 68, 101, 115, 99, 114, 
            105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 82, 6, 109, 101, 116, 104, 111, 100, 18, 57, 
            10, 7, 111, 112, 116, 105, 111, 110, 115, 24, 3, 32, 1, 40, 11, 50, 31, 46, 103, 111, 
            111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 83, 101, 114, 118, 105, 99, 
            101, 79, 112, 116, 105, 111, 110, 115, 82, 7, 111, 112, 116, 105, 111, 110, 115, 34, 137, 2, 
            10, 21, 77, 101, 116, 104, 111, 100, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 
            111, 116, 111, 18, 18, 10, 4, 110, 97, 109, 101, 24, 1, 32, 1, 40, 9, 82, 4, 110, 
            97, 109, 101, 18, 29, 10, 10, 105, 110, 112, 117, 116, 95, 116, 121, 112, 101, 24, 2, 32, 
            1, 40, 9, 82, 9, 105, 110, 112, 117, 116, 84, 121, 112, 101, 18, 31, 10, 11, 111, 117, 
            116, 112, 117, 116, 95, 116, 121, 112, 101, 24, 3, 32, 1, 40, 9, 82, 10, 111, 117, 116, 
            112, 117, 116, 84, 121, 112, 101, 18, 56, 10, 7, 111, 112, 116, 105, 111, 110, 115, 24, 4, 
            32, 1, 40, 11, 50, 30, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 
            117, 102, 46, 77, 101, 116, 104, 111, 100, 79, 112, 116, 105, 111, 110, 115, 82, 7, 111, 112, 
            116, 105, 111, 110, 115, 18, 48, 10, 16, 99, 108, 105, 101, 110, 116, 95, 115, 116, 114, 101, 
            97, 109, 105, 110, 103, 24, 5, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 82, 15, 
            99, 108, 105, 101, 110, 116, 83, 116, 114, 101, 97, 109, 105, 110, 103, 18, 48, 10, 16, 115, 
            101, 114, 118, 101, 114, 95, 115, 116, 114, 101, 97, 109, 105, 110, 103, 24, 6, 32, 1, 40, 
            8, 58, 5, 102, 97, 108, 115, 101, 82, 15, 115, 101, 114, 118, 101, 114, 83, 116, 114, 101, 
            97, 109, 105, 110, 103, 34, 146, 9, 10, 11, 70, 105, 108, 101, 79, 112, 116, 105, 111, 110, 
            115, 18, 33, 10, 12, 106, 97, 118, 97, 95, 112, 97, 99, 107, 97, 103, 101, 24, 1, 32, 
            1, 40, 9, 82, 11, 106, 97, 118, 97, 80, 97, 99, 107, 97, 103, 101, 18, 48, 10, 20, 
            106, 97, 118, 97, 95, 111, 117, 116, 101, 114, 95, 99, 108, 97, 115, 115, 110, 97, 109, 101, 
            24, 8, 32, 1, 40, 9, 82, 18, 106, 97, 118, 97, 79, 117, 116, 101, 114, 67, 108, 97, 
            115, 115, 110, 97, 109, 101, 18, 53, 10, 19, 106, 97, 118, 97, 95, 109, 117, 108, 116, 105, 
            112, 108, 101, 95, 102, 105, 108, 101, 115, 24, 10, 32, 1, 40, 8, 58, 5, 102, 97, 108, 
            115, 101, 82, 17, 106, 97, 118, 97, 77, 117, 108, 116, 105, 112, 108, 101, 70, 105, 108, 101, 
            115, 18, 68, 10, 29, 106, 97, 118, 97, 95, 103, 101, 110, 101, 114, 97, 116, 101, 95, 101, 
            113, 117, 97, 108, 115, 95, 97, 110, 100, 95, 104, 97, 115, 104, 24, 20, 32, 1, 40, 8, 
            82, 25, 106, 97, 118, 97, 71, 101, 110, 101, 114, 97, 116, 101, 69, 113, 117, 97, 108, 115, 
            65, 110, 100, 72, 97, 115, 104, 66, 2, 24, 1, 18, 58, 10, 22, 106, 97, 118, 97, 95, 
            115, 116, 114, 105, 110, 103, 95, 99, 104, 101, 99, 107, 95, 117, 116, 102, 56, 24, 27, 32, 
            1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 82, 19, 106, 97, 118, 97, 83, 116, 114, 105, 
            110, 103, 67, 104, 101, 99, 107, 85, 116, 102, 56, 18, 83, 10, 12, 111, 112, 116, 105, 109, 
            105, 122, 101, 95, 102, 111, 114, 24, 9, 32, 1, 40, 14, 50, 41, 46, 103, 111, 111, 103, 
            108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 70, 105, 108, 101, 79, 112, 116, 105, 
            111, 110, 115, 46, 79, 112, 116, 105, 109, 105, 122, 101, 77, 111, 100, 101, 58, 5, 83, 80, 
            69, 69, 68, 82, 11, 111, 112, 116, 105, 109, 105, 122, 101, 70, 111, 114, 18, 29, 10, 10, 
            103, 111, 95, 112, 97, 99, 107, 97, 103, 101, 24, 11, 32, 1, 40, 9, 82, 9, 103, 111, 
            80, 97, 99, 107, 97, 103, 101, 18, 53, 10, 19, 99, 99, 95, 103, 101, 110, 101, 114, 105, 
            99, 95, 115, 101, 114, 118, 105, 99, 101, 115, 24, 16, 32, 1, 40, 8, 58, 5, 102, 97, 
            108, 115, 101, 82, 17, 99, 99, 71, 101, 110, 101, 114, 105, 99, 83, 101, 114, 118, 105, 99, 
            101, 115, 18, 57, 10, 21, 106, 97, 118, 97, 95, 103, 101, 110, 101, 114, 105, 99, 95, 115, 
            101, 114, 118, 105, 99, 101, 115, 24, 17, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 
            82, 19, 106, 97, 118, 97, 71, 101, 110, 101, 114, 105, 99, 83, 101, 114, 118, 105, 99, 101, 
            115, 18, 53, 10, 19, 112, 121, 95, 103, 101, 110, 101, 114, 105, 99, 95, 115, 101, 114, 118, 
            105, 99, 101, 115, 24, 18, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 82, 17, 112, 
            121, 71, 101, 110, 101, 114, 105, 99, 83, 101, 114, 118, 105, 99, 101, 115, 18, 55, 10, 20, 
            112, 104, 112, 95, 103, 101, 110, 101, 114, 105, 99, 95, 115, 101, 114, 118, 105, 99, 101, 115, 
            24, 42, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 82, 18, 112, 104, 112, 71, 101, 
            110, 101, 114, 105, 99, 83, 101, 114, 118, 105, 99, 101, 115, 18, 37, 10, 10, 100, 101, 112, 
            114, 101, 99, 97, 116, 101, 100, 24, 23, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 
            82, 10, 100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 18, 47, 10, 16, 99, 99, 95, 101, 
            110, 97, 98, 108, 101, 95, 97, 114, 101, 110, 97, 115, 24, 31, 32, 1, 40, 8, 58, 5, 
            102, 97, 108, 115, 101, 82, 14, 99, 99, 69, 110, 97, 98, 108, 101, 65, 114, 101, 110, 97, 
            115, 18, 42, 10, 17, 111, 98, 106, 99, 95, 99, 108, 97, 115, 115, 95, 112, 114, 101, 102, 
            105, 120, 24, 36, 32, 1, 40, 9, 82, 15, 111, 98, 106, 99, 67, 108, 97, 115, 115, 80, 
            114, 101, 102, 105, 120, 18, 41, 10, 16, 99, 115, 104, 97, 114, 112, 95, 110, 97, 109, 101, 
            115, 112, 97, 99, 101, 24, 37, 32, 1, 40, 9, 82, 15, 99, 115, 104, 97, 114, 112, 78, 
            97, 109, 101, 115, 112, 97, 99, 101, 18, 33, 10, 12, 115, 119, 105, 102, 116, 95, 112, 114, 
            101, 102, 105, 120, 24, 39, 32, 1, 40, 9, 82, 11, 115, 119, 105, 102, 116, 80, 114, 101, 
            102, 105, 120, 18, 40, 10, 16, 112, 104, 112, 95, 99, 108, 97, 115, 115, 95, 112, 114, 101, 
            102, 105, 120, 24, 40, 32, 1, 40, 9, 82, 14, 112, 104, 112, 67, 108, 97, 115, 115, 80, 
            114, 101, 102, 105, 120, 18, 35, 10, 13, 112, 104, 112, 95, 110, 97, 109, 101, 115, 112, 97, 
            99, 101, 24, 41, 32, 1, 40, 9, 82, 12, 112, 104, 112, 78, 97, 109, 101, 115, 112, 97, 
            99, 101, 18, 52, 10, 22, 112, 104, 112, 95, 109, 101, 116, 97, 100, 97, 116, 97, 95, 110, 
            97, 109, 101, 115, 112, 97, 99, 101, 24, 44, 32, 1, 40, 9, 82, 20, 112, 104, 112, 77, 
            101, 116, 97, 100, 97, 116, 97, 78, 97, 109, 101, 115, 112, 97, 99, 101, 18, 33, 10, 12, 
            114, 117, 98, 121, 95, 112, 97, 99, 107, 97, 103, 101, 24, 45, 32, 1, 40, 9, 82, 11, 
            114, 117, 98, 121, 80, 97, 99, 107, 97, 103, 101, 18, 88, 10, 20, 117, 110, 105, 110, 116, 
            101, 114, 112, 114, 101, 116, 101, 100, 95, 111, 112, 116, 105, 111, 110, 24, 231, 7, 32, 3, 
            40, 11, 50, 36, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 
            46, 85, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 
            82, 19, 117, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 
            110, 34, 58, 10, 12, 79, 112, 116, 105, 109, 105, 122, 101, 77, 111, 100, 101, 18, 9, 10, 
            5, 83, 80, 69, 69, 68, 16, 1, 18, 13, 10, 9, 67, 79, 68, 69, 95, 83, 73, 90, 
            69, 16, 2, 18, 16, 10, 12, 76, 73, 84, 69, 95, 82, 85, 78, 84, 73, 77, 69, 16, 
            3, 42, 9, 8, 232, 7, 16, 128, 128, 128, 128, 2, 74, 4, 8, 38, 16, 39, 34, 209, 
            2, 10, 14, 77, 101, 115, 115, 97, 103, 101, 79, 112, 116, 105, 111, 110, 115, 18, 60, 10, 
            23, 109, 101, 115, 115, 97, 103, 101, 95, 115, 101, 116, 95, 119, 105, 114, 101, 95, 102, 111, 
            114, 109, 97, 116, 24, 1, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 82, 20, 109, 
            101, 115, 115, 97, 103, 101, 83, 101, 116, 87, 105, 114, 101, 70, 111, 114, 109, 97, 116, 18, 
            76, 10, 31, 110, 111, 95, 115, 116, 97, 110, 100, 97, 114, 100, 95, 100, 101, 115, 99, 114, 
            105, 112, 116, 111, 114, 95, 97, 99, 99, 101, 115, 115, 111, 114, 24, 2, 32, 1, 40, 8, 
            58, 5, 102, 97, 108, 115, 101, 82, 28, 110, 111, 83, 116, 97, 110, 100, 97, 114, 100, 68, 
            101, 115, 99, 114, 105, 112, 116, 111, 114, 65, 99, 99, 101, 115, 115, 111, 114, 18, 37, 10, 
            10, 100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 24, 3, 32, 1, 40, 8, 58, 5, 102, 
            97, 108, 115, 101, 82, 10, 100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 18, 27, 10, 9, 
            109, 97, 112, 95, 101, 110, 116, 114, 121, 24, 7, 32, 1, 40, 8, 82, 8, 109, 97, 112, 
            69, 110, 116, 114, 121, 18, 88, 10, 20, 117, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 
            101, 100, 95, 111, 112, 116, 105, 111, 110, 24, 231, 7, 32, 3, 40, 11, 50, 36, 46, 103, 
            111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 85, 110, 105, 110, 116, 
            101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 82, 19, 117, 110, 105, 110, 
            116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 42, 9, 8, 232, 7, 
            16, 128, 128, 128, 128, 2, 74, 4, 8, 8, 16, 9, 74, 4, 8, 9, 16, 10, 34, 222, 
            3, 10, 12, 70, 105, 101, 108, 100, 79, 112, 116, 105, 111, 110, 115, 18, 65, 10, 5, 99, 
            116, 121, 112, 101, 24, 1, 32, 1, 40, 14, 50, 35, 46, 103, 111, 111, 103, 108, 101, 46, 
            112, 114, 111, 116, 111, 98, 117, 102, 46, 70, 105, 101, 108, 100, 79, 112, 116, 105, 111, 110, 
            115, 46, 67, 84, 121, 112, 101, 58, 6, 83, 84, 82, 73, 78, 71, 82, 5, 99, 116, 121, 
            112, 101, 18, 22, 10, 6, 112, 97, 99, 107, 101, 100, 24, 2, 32, 1, 40, 8, 82, 6, 
            112, 97, 99, 107, 101, 100, 18, 71, 10, 6, 106, 115, 116, 121, 112, 101, 24, 6, 32, 1, 
            40, 14, 50, 36, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 
            46, 70, 105, 101, 108, 100, 79, 112, 116, 105, 111, 110, 115, 46, 74, 83, 84, 121, 112, 101, 
            58, 9, 74, 83, 95, 78, 79, 82, 77, 65, 76, 82, 6, 106, 115, 116, 121, 112, 101, 18, 
            25, 10, 4, 108, 97, 122, 121, 24, 5, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 
            82, 4, 108, 97, 122, 121, 18, 37, 10, 10, 100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 
            24, 3, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 82, 10, 100, 101, 112, 114, 101, 
            99, 97, 116, 101, 100, 18, 25, 10, 4, 119, 101, 97, 107, 24, 10, 32, 1, 40, 8, 58, 
            5, 102, 97, 108, 115, 101, 82, 4, 119, 101, 97, 107, 18, 88, 10, 20, 117, 110, 105, 110, 
            116, 101, 114, 112, 114, 101, 116, 101, 100, 95, 111, 112, 116, 105, 111, 110, 24, 231, 7, 32, 
            3, 40, 11, 50, 36, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 
            102, 46, 85, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 
            110, 82, 19, 117, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 
            111, 110, 34, 45, 10, 5, 67, 84, 121, 112, 101, 18, 8, 10, 6, 83, 84, 82, 73, 78, 
            71, 18, 8, 10, 4, 67, 79, 82, 68, 16, 1, 18, 16, 10, 12, 83, 84, 82, 73, 78, 
            71, 95, 80, 73, 69, 67, 69, 16, 2, 34, 51, 10, 6, 74, 83, 84, 121, 112, 101, 18, 
            11, 10, 9, 74, 83, 95, 78, 79, 82, 77, 65, 76, 18, 13, 10, 9, 74, 83, 95, 83, 
            84, 82, 73, 78, 71, 16, 1, 18, 13, 10, 9, 74, 83, 95, 78, 85, 77, 66, 69, 82, 
            16, 2, 42, 9, 8, 232, 7, 16, 128, 128, 128, 128, 2, 74, 4, 8, 4, 16, 5, 34, 
            115, 10, 12, 79, 110, 101, 111, 102, 79, 112, 116, 105, 111, 110, 115, 18, 88, 10, 20, 117, 
            110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 95, 111, 112, 116, 105, 111, 110, 24, 
            231, 7, 32, 3, 40, 11, 50, 36, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 
            111, 98, 117, 102, 46, 85, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 
            116, 105, 111, 110, 82, 19, 117, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 
            112, 116, 105, 111, 110, 42, 9, 8, 232, 7, 16, 128, 128, 128, 128, 2, 34, 192, 1, 10, 
            11, 69, 110, 117, 109, 79, 112, 116, 105, 111, 110, 115, 18, 31, 10, 11, 97, 108, 108, 111, 
            119, 95, 97, 108, 105, 97, 115, 24, 2, 32, 1, 40, 8, 82, 10, 97, 108, 108, 111, 119, 
            65, 108, 105, 97, 115, 18, 37, 10, 10, 100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 24, 
            3, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 82, 10, 100, 101, 112, 114, 101, 99, 
            97, 116, 101, 100, 18, 88, 10, 20, 117, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 
            100, 95, 111, 112, 116, 105, 111, 110, 24, 231, 7, 32, 3, 40, 11, 50, 36, 46, 103, 111, 
            111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 85, 110, 105, 110, 116, 101, 
            114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 82, 19, 117, 110, 105, 110, 116, 
            101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 42, 9, 8, 232, 7, 16, 
            128, 128, 128, 128, 2, 74, 4, 8, 5, 16, 6, 34, 158, 1, 10, 16, 69, 110, 117, 109, 
            86, 97, 108, 117, 101, 79, 112, 116, 105, 111, 110, 115, 18, 37, 10, 10, 100, 101, 112, 114, 
            101, 99, 97, 116, 101, 100, 24, 1, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 82, 
            10, 100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 18, 88, 10, 20, 117, 110, 105, 110, 116, 
            101, 114, 112, 114, 101, 116, 101, 100, 95, 111, 112, 116, 105, 111, 110, 24, 231, 7, 32, 3, 
            40, 11, 50, 36, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 
            46, 85, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 
            82, 19, 117, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 
            110, 42, 9, 8, 232, 7, 16, 128, 128, 128, 128, 2, 34, 156, 1, 10, 14, 83, 101, 114, 
            118, 105, 99, 101, 79, 112, 116, 105, 111, 110, 115, 18, 37, 10, 10, 100, 101, 112, 114, 101, 
            99, 97, 116, 101, 100, 24, 33, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 82, 10, 
            100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 18, 88, 10, 20, 117, 110, 105, 110, 116, 101, 
            114, 112, 114, 101, 116, 101, 100, 95, 111, 112, 116, 105, 111, 110, 24, 231, 7, 32, 3, 40, 
            11, 50, 36, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 
            85, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 82, 
            19, 117, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 
            42, 9, 8, 232, 7, 16, 128, 128, 128, 128, 2, 34, 222, 2, 10, 13, 77, 101, 116, 104, 
            111, 100, 79, 112, 116, 105, 111, 110, 115, 18, 37, 10, 10, 100, 101, 112, 114, 101, 99, 97, 
            116, 101, 100, 24, 33, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 82, 10, 100, 101, 
            112, 114, 101, 99, 97, 116, 101, 100, 18, 113, 10, 17, 105, 100, 101, 109, 112, 111, 116, 101, 
            110, 99, 121, 95, 108, 101, 118, 101, 108, 24, 34, 32, 1, 40, 14, 50, 47, 46, 103, 111, 
            111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 77, 101, 116, 104, 111, 100, 
            79, 112, 116, 105, 111, 110, 115, 46, 73, 100, 101, 109, 112, 111, 116, 101, 110, 99, 121, 76, 
            101, 118, 101, 108, 58, 19, 73, 68, 69, 77, 80, 79, 84, 69, 78, 67, 89, 95, 85, 78, 
            75, 78, 79, 87, 78, 82, 16, 105, 100, 101, 109, 112, 111, 116, 101, 110, 99, 121, 76, 101, 
            118, 101, 108, 18, 88, 10, 20, 117, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 
            95, 111, 112, 116, 105, 111, 110, 24, 231, 7, 32, 3, 40, 11, 50, 36, 46, 103, 111, 111, 
            103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 85, 110, 105, 110, 116, 101, 114, 
            112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 82, 19, 117, 110, 105, 110, 116, 101, 
            114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 34, 78, 10, 16, 73, 100, 101, 
            109, 112, 111, 116, 101, 110, 99, 121, 76, 101, 118, 101, 108, 18, 21, 10, 19, 73, 68, 69, 
            77, 80, 79, 84, 69, 78, 67, 89, 95, 85, 78, 75, 78, 79, 87, 78, 18, 19, 10, 15, 
            78, 79, 95, 83, 73, 68, 69, 95, 69, 70, 70, 69, 67, 84, 83, 16, 1, 18, 14, 10, 
            10, 73, 68, 69, 77, 80, 79, 84, 69, 78, 84, 16, 2, 42, 9, 8, 232, 7, 16, 128, 
            128, 128, 128, 2, 34, 154, 3, 10, 19, 85, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 
            101, 100, 79, 112, 116, 105, 111, 110, 18, 65, 10, 4, 110, 97, 109, 101, 24, 2, 32, 3, 
            40, 11, 50, 45, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 
            46, 85, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 
            46, 78, 97, 109, 101, 80, 97, 114, 116, 82, 4, 110, 97, 109, 101, 18, 41, 10, 16, 105, 
            100, 101, 110, 116, 105, 102, 105, 101, 114, 95, 118, 97, 108, 117, 101, 24, 3, 32, 1, 40, 
            9, 82, 15, 105, 100, 101, 110, 116, 105, 102, 105, 101, 114, 86, 97, 108, 117, 101, 18, 44, 
            10, 18, 112, 111, 115, 105, 116, 105, 118, 101, 95, 105, 110, 116, 95, 118, 97, 108, 117, 101, 
            24, 4, 32, 1, 40, 4, 82, 16, 112, 111, 115, 105, 116, 105, 118, 101, 73, 110, 116, 86, 
            97, 108, 117, 101, 18, 44, 10, 18, 110, 101, 103, 97, 116, 105, 118, 101, 95, 105, 110, 116, 
            95, 118, 97, 108, 117, 101, 24, 5, 32, 1, 40, 3, 82, 16, 110, 101, 103, 97, 116, 105, 
            118, 101, 73, 110, 116, 86, 97, 108, 117, 101, 18, 33, 10, 12, 100, 111, 117, 98, 108, 101, 
            95, 118, 97, 108, 117, 101, 24, 6, 32, 1, 40, 1, 82, 11, 100, 111, 117, 98, 108, 101, 
            86, 97, 108, 117, 101, 18, 33, 10, 12, 115, 116, 114, 105, 110, 103, 95, 118, 97, 108, 117, 
            101, 24, 7, 32, 1, 40, 12, 82, 11, 115, 116, 114, 105, 110, 103, 86, 97, 108, 117, 101, 
            18, 39, 10, 15, 97, 103, 103, 114, 101, 103, 97, 116, 101, 95, 118, 97, 108, 117, 101, 24, 
            8, 32, 1, 40, 9, 82, 14, 97, 103, 103, 114, 101, 103, 97, 116, 101, 86, 97, 108, 117, 
            101, 26, 74, 10, 8, 78, 97, 109, 101, 80, 97, 114, 116, 18, 27, 10, 9, 110, 97, 109, 
            101, 95, 112, 97, 114, 116, 24, 1, 32, 2, 40, 9, 82, 8, 110, 97, 109, 101, 80, 97, 
            114, 116, 18, 33, 10, 12, 105, 115, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 2, 
            32, 2, 40, 8, 82, 11, 105, 115, 69, 120, 116, 101, 110, 115, 105, 111, 110, 34, 167, 2, 
            10, 14, 83, 111, 117, 114, 99, 101, 67, 111, 100, 101, 73, 110, 102, 111, 18, 68, 10, 8, 
            108, 111, 99, 97, 116, 105, 111, 110, 24, 1, 32, 3, 40, 11, 50, 40, 46, 103, 111, 111, 
            103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 83, 111, 117, 114, 99, 101, 67, 
            111, 100, 101, 73, 110, 102, 111, 46, 76, 111, 99, 97, 116, 105, 111, 110, 82, 8, 108, 111, 
            99, 97, 116, 105, 111, 110, 26, 206, 1, 10, 8, 76, 111, 99, 97, 116, 105, 111, 110, 18, 
            22, 10, 4, 112, 97, 116, 104, 24, 1, 32, 3, 40, 5, 82, 4, 112, 97, 116, 104, 66, 
            2, 16, 1, 18, 22, 10, 4, 115, 112, 97, 110, 24, 2, 32, 3, 40, 5, 82, 4, 115, 
            112, 97, 110, 66, 2, 16, 1, 18, 41, 10, 16, 108, 101, 97, 100, 105, 110, 103, 95, 99, 
            111, 109, 109, 101, 110, 116, 115, 24, 3, 32, 1, 40, 9, 82, 15, 108, 101, 97, 100, 105, 
            110, 103, 67, 111, 109, 109, 101, 110, 116, 115, 18, 43, 10, 17, 116, 114, 97, 105, 108, 105, 
            110, 103, 95, 99, 111, 109, 109, 101, 110, 116, 115, 24, 4, 32, 1, 40, 9, 82, 16, 116, 
            114, 97, 105, 108, 105, 110, 103, 67, 111, 109, 109, 101, 110, 116, 115, 18, 58, 10, 25, 108, 
            101, 97, 100, 105, 110, 103, 95, 100, 101, 116, 97, 99, 104, 101, 100, 95, 99, 111, 109, 109, 
            101, 110, 116, 115, 24, 6, 32, 3, 40, 9, 82, 23, 108, 101, 97, 100, 105, 110, 103, 68, 
            101, 116, 97, 99, 104, 101, 100, 67, 111, 109, 109, 101, 110, 116, 115, 34, 209, 1, 10, 17, 
            71, 101, 110, 101, 114, 97, 116, 101, 100, 67, 111, 100, 101, 73, 110, 102, 111, 18, 77, 10, 
            10, 97, 110, 110, 111, 116, 97, 116, 105, 111, 110, 24, 1, 32, 3, 40, 11, 50, 45, 46, 
            103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 71, 101, 110, 101, 
            114, 97, 116, 101, 100, 67, 111, 100, 101, 73, 110, 102, 111, 46, 65, 110, 110, 111, 116, 97, 
            116, 105, 111, 110, 82, 10, 97, 110, 110, 111, 116, 97, 116, 105, 111, 110, 26, 109, 10, 10, 
            65, 110, 110, 111, 116, 97, 116, 105, 111, 110, 18, 22, 10, 4, 112, 97, 116, 104, 24, 1, 
            32, 3, 40, 5, 82, 4, 112, 97, 116, 104, 66, 2, 16, 1, 18, 31, 10, 11, 115, 111, 
            117, 114, 99, 101, 95, 102, 105, 108, 101, 24, 2, 32, 1, 40, 9, 82, 10, 115, 111, 117, 
            114, 99, 101, 70, 105, 108, 101, 18, 20, 10, 5, 98, 101, 103, 105, 110, 24, 3, 32, 1, 
            40, 5, 82, 5, 98, 101, 103, 105, 110, 18, 16, 10, 3, 101, 110, 100, 24, 4, 32, 1, 
            40, 5, 82, 3, 101, 110, 100, 66, 141, 1, 10, 19, 99, 111, 109, 46, 103, 111, 111, 103, 
            108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 66, 16, 68, 101, 115, 99, 114, 105, 112, 
            116, 111, 114, 80, 114, 111, 116, 111, 115, 90, 62, 103, 105, 116, 104, 117, 98, 46, 99, 111, 
            109, 47, 103, 111, 108, 97, 110, 103, 47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 112, 114, 
            111, 116, 111, 99, 45, 103, 101, 110, 45, 103, 111, 47, 100, 101, 115, 99, 114, 105, 112, 116, 
            111, 114, 59, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 248, 1, 1, 162, 2, 3, 71, 
            80, 66, 170, 2, 26, 71, 111, 111, 103, 108, 101, 46, 80, 114, 111, 116, 111, 98, 117, 102, 
            46, 82, 101, 102, 108, 101, 99, 116, 105, 111, 110, 
        ].as_ref()).expect("Could not read file descriptor")]);
        FILE_DEPS = ::std::option::Option::Some([]);
        FILE_POOL = ::std::option::Option::Some(crate::reflect::DescriptorPool::build_generated_pool(
            FILE_PROTO.as_ref().unwrap(),
            FILE_DEPS.as_ref().unwrap()
        ));
        FILE_DESCRIPTOR = ::std::option::Option::Some(FILE_POOL.as_ref().unwrap().find_file_by_name("google/protobuf/descriptor.proto").unwrap());
    }
}

/// Gets the pool containing all the symbols in this proto file and its dependencies
pub fn pool() -> &'static crate::reflect::DescriptorPool<'static> {
    unsafe {
        FILE_ONCE.call_once(file_once_init);
        FILE_POOL.as_ref().unwrap()
    }
}
/// Gets the file descriptor representing the proto that created this generated file
pub fn file() -> &'static crate::reflect::FileDescriptor {
    unsafe {
        FILE_ONCE.call_once(file_once_init);
        FILE_DESCRIPTOR.as_ref().unwrap()
    }
}
/// The protocol compiler can output a FileDescriptorSet containing the .proto
/// files it parses.
#[derive(Clone, Debug, PartialEq)]
pub struct FileDescriptorSet {
    file: crate::collections::RepeatedField<self::FileDescriptorProto>,
    unknown_fields: crate::UnknownFieldSet
}
static FILE_DESCRIPTOR_SET_FILE_CODEC: crate::Codec<self::FileDescriptorProto> = crate::Codec::message(10);
impl crate::CodedMessage for self::FileDescriptorSet {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.file.add_entries(tag.get(), input, &FILE_DESCRIPTOR_SET_FILE_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.file.calculate_size(&FILE_DESCRIPTOR_SET_FILE_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        self.file.write_to(output, &FILE_DESCRIPTOR_SET_FILE_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::FileDescriptorSet {
    fn new() -> Self {
        Self {
            file: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
    fn merge(&mut self, other: &Self) {
        self.file.merge(&other.file);
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl crate::Message for self::FileDescriptorSet {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[0]
    }
}
impl self::FileDescriptorSet {
    /// Gets the field number of the [`file`] field
    ///
    /// [`file`]: #method.file
    pub const FILE_FIELD_NUMBER: i32 = 1;
    pub fn file(&self) -> &crate::collections::RepeatedField<self::FileDescriptorProto> {
        &self.file
    }
    /// Returns a unique reference to the [`file`] field
    ///
    /// [`file`]: #method.file
    pub fn file_mut(&mut self) -> &mut crate::collections::RepeatedField<self::FileDescriptorProto> {
        &mut self.file
    }
}
/// Describes a complete .proto file.
#[derive(Clone, Debug, PartialEq)]
pub struct FileDescriptorProto {
    name: ::std::option::Option<::std::string::String>,
    package: ::std::option::Option<::std::string::String>,
    dependency: crate::collections::RepeatedField<::std::string::String>,
    public_dependency: crate::collections::RepeatedField<i32>,
    weak_dependency: crate::collections::RepeatedField<i32>,
    message_type: crate::collections::RepeatedField<self::DescriptorProto>,
    enum_type: crate::collections::RepeatedField<self::EnumDescriptorProto>,
    service: crate::collections::RepeatedField<self::ServiceDescriptorProto>,
    extension: crate::collections::RepeatedField<self::FieldDescriptorProto>,
    options: ::std::option::Option<::std::boxed::Box<self::FileOptions>>,
    source_code_info: ::std::option::Option<::std::boxed::Box<self::SourceCodeInfo>>,
    syntax: ::std::option::Option<::std::string::String>,
    unknown_fields: crate::UnknownFieldSet
}
static FILE_DESCRIPTOR_PROTO_DEPENDENCY_CODEC: crate::Codec<::std::string::String> = crate::Codec::string(26);
static FILE_DESCRIPTOR_PROTO_PUBLIC_DEPENDENCY_CODEC: crate::Codec<i32> = crate::Codec::int32(80);
static FILE_DESCRIPTOR_PROTO_WEAK_DEPENDENCY_CODEC: crate::Codec<i32> = crate::Codec::int32(88);
static FILE_DESCRIPTOR_PROTO_MESSAGE_TYPE_CODEC: crate::Codec<self::DescriptorProto> = crate::Codec::message(34);
static FILE_DESCRIPTOR_PROTO_ENUM_TYPE_CODEC: crate::Codec<self::EnumDescriptorProto> = crate::Codec::message(42);
static FILE_DESCRIPTOR_PROTO_SERVICE_CODEC: crate::Codec<self::ServiceDescriptorProto> = crate::Codec::message(50);
static FILE_DESCRIPTOR_PROTO_EXTENSION_CODEC: crate::Codec<self::FieldDescriptorProto> = crate::Codec::message(58);
impl crate::CodedMessage for self::FileDescriptorProto {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.name = ::std::option::Option::Some(input.read_string()?),
                18 => self.package = ::std::option::Option::Some(input.read_string()?),
                26 => self.dependency.add_entries(tag.get(), input, &FILE_DESCRIPTOR_PROTO_DEPENDENCY_CODEC)?,
                80 => self.public_dependency.add_entries(tag.get(), input, &FILE_DESCRIPTOR_PROTO_PUBLIC_DEPENDENCY_CODEC)?,
                88 => self.weak_dependency.add_entries(tag.get(), input, &FILE_DESCRIPTOR_PROTO_WEAK_DEPENDENCY_CODEC)?,
                34 => self.message_type.add_entries(tag.get(), input, &FILE_DESCRIPTOR_PROTO_MESSAGE_TYPE_CODEC)?,
                42 => self.enum_type.add_entries(tag.get(), input, &FILE_DESCRIPTOR_PROTO_ENUM_TYPE_CODEC)?,
                50 => self.service.add_entries(tag.get(), input, &FILE_DESCRIPTOR_PROTO_SERVICE_CODEC)?,
                58 => self.extension.add_entries(tag.get(), input, &FILE_DESCRIPTOR_PROTO_EXTENSION_CODEC)?,
                66 => input.read_message(self.options.get_or_insert_with(crate::LiteMessage::new))?,
                74 => input.read_message(self.source_code_info.get_or_insert_with(crate::LiteMessage::new))?,
                98 => self.syntax = ::std::option::Option::Some(input.read_string()?),
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(name);
            }
        }
        let package = &self.package;
        if let ::std::option::Option::Some(package) = package {
            if package != Self::PACKAGE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(package);
            }
        }
        size += self.dependency.calculate_size(&FILE_DESCRIPTOR_PROTO_DEPENDENCY_CODEC);
        size += self.public_dependency.calculate_size(&FILE_DESCRIPTOR_PROTO_PUBLIC_DEPENDENCY_CODEC);
        size += self.weak_dependency.calculate_size(&FILE_DESCRIPTOR_PROTO_WEAK_DEPENDENCY_CODEC);
        size += self.message_type.calculate_size(&FILE_DESCRIPTOR_PROTO_MESSAGE_TYPE_CODEC);
        size += self.enum_type.calculate_size(&FILE_DESCRIPTOR_PROTO_ENUM_TYPE_CODEC);
        size += self.service.calculate_size(&FILE_DESCRIPTOR_PROTO_SERVICE_CODEC);
        size += self.extension.calculate_size(&FILE_DESCRIPTOR_PROTO_EXTENSION_CODEC);
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            size += 1;
            size += crate::io::sizes::message(options);
        }
        let source_code_info = &self.source_code_info;
        if let ::std::option::Option::Some(source_code_info) = source_code_info {
            size += 1;
            size += crate::io::sizes::message(source_code_info);
        }
        let syntax = &self.syntax;
        if let ::std::option::Option::Some(syntax) = syntax {
            if syntax != Self::SYNTAX_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(syntax);
            }
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
        }
        let package = &self.package;
        if let ::std::option::Option::Some(package) = package {
            if package != Self::PACKAGE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[18])?;
                output.write_string(package)?;
            }
        }
        self.dependency.write_to(output, &FILE_DESCRIPTOR_PROTO_DEPENDENCY_CODEC)?;
        self.public_dependency.write_to(output, &FILE_DESCRIPTOR_PROTO_PUBLIC_DEPENDENCY_CODEC)?;
        self.weak_dependency.write_to(output, &FILE_DESCRIPTOR_PROTO_WEAK_DEPENDENCY_CODEC)?;
        self.message_type.write_to(output, &FILE_DESCRIPTOR_PROTO_MESSAGE_TYPE_CODEC)?;
        self.enum_type.write_to(output, &FILE_DESCRIPTOR_PROTO_ENUM_TYPE_CODEC)?;
        self.service.write_to(output, &FILE_DESCRIPTOR_PROTO_SERVICE_CODEC)?;
        self.extension.write_to(output, &FILE_DESCRIPTOR_PROTO_EXTENSION_CODEC)?;
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            output.write_raw_tag_bytes(&[66])?;
            output.write_message(options)?;
        }
        let source_code_info = &self.source_code_info;
        if let ::std::option::Option::Some(source_code_info) = source_code_info {
            output.write_raw_tag_bytes(&[74])?;
            output.write_message(source_code_info)?;
        }
        let syntax = &self.syntax;
        if let ::std::option::Option::Some(syntax) = syntax {
            if syntax != Self::SYNTAX_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[98])?;
                output.write_string(syntax)?;
            }
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::FileDescriptorProto {
    fn new() -> Self {
        Self {
            name: ::std::option::Option::None,
            package: ::std::option::Option::None,
            dependency: crate::collections::RepeatedField::new(),
            public_dependency: crate::collections::RepeatedField::new(),
            weak_dependency: crate::collections::RepeatedField::new(),
            message_type: crate::collections::RepeatedField::new(),
            enum_type: crate::collections::RepeatedField::new(),
            service: crate::collections::RepeatedField::new(),
            extension: crate::collections::RepeatedField::new(),
            options: ::std::option::Option::None,
            source_code_info: ::std::option::Option::None,
            syntax: ::std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
    fn merge(&mut self, other: &Self) {
        self.name = other.name.clone();
        self.package = other.package.clone();
        self.dependency.merge(&other.dependency);
        self.public_dependency.merge(&other.public_dependency);
        self.weak_dependency.merge(&other.weak_dependency);
        self.message_type.merge(&other.message_type);
        self.enum_type.merge(&other.enum_type);
        self.service.merge(&other.service);
        self.extension.merge(&other.extension);
        if let ::std::option::Option::Some(options) = &other.options {
            self.options.get_or_insert_with(crate::LiteMessage::new).merge(options);
        }
        if let ::std::option::Option::Some(source_code_info) = &other.source_code_info {
            self.source_code_info.get_or_insert_with(crate::LiteMessage::new).merge(source_code_info);
        }
        self.syntax = other.syntax.clone();
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl crate::Message for self::FileDescriptorProto {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[1]
    }
}
impl self::FileDescriptorProto {
    /// Gets the field number of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub const NAME_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub const NAME_DEFAULT_VALUE: &'static str = "";
    /// file name, relative to root of source tree
    pub fn name(&self) -> &str {
        &self.name.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::NAME_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn name_mut(&mut self) -> &mut ::std::string::String {
        self.name.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }
    /// Sets the value of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn set_name(&mut self, value: ::std::string::String) {
        self.name = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`name`] field, leaving it empty
    ///
    /// [`name`]: #method.name
    pub fn take_name(&mut self) -> ::std::option::Option<::std::string::String> {
        self.name.take()
    }
    /// Clears the value of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None
    }
    /// Gets the field number of the [`package`] field
    ///
    /// [`package`]: #method.package
    pub const PACKAGE_FIELD_NUMBER: i32 = 2;
    /// A constant value representing the default value of the [`package`] field
    ///
    /// [`package`]: #method.package
    pub const PACKAGE_DEFAULT_VALUE: &'static str = "";
    /// e.g. "foo", "foo.bar", etc.
    pub fn package(&self) -> &str {
        &self.package.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::PACKAGE_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`package`] field
    ///
    /// [`package`]: #method.package
    pub fn package_mut(&mut self) -> &mut ::std::string::String {
        self.package.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`package`] field
    ///
    /// [`package`]: #method.package
    pub fn has_package(&self) -> bool {
        self.package.is_some()
    }
    /// Sets the value of the [`package`] field
    ///
    /// [`package`]: #method.package
    pub fn set_package(&mut self, value: ::std::string::String) {
        self.package = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`package`] field, leaving it empty
    ///
    /// [`package`]: #method.package
    pub fn take_package(&mut self) -> ::std::option::Option<::std::string::String> {
        self.package.take()
    }
    /// Clears the value of the [`package`] field
    ///
    /// [`package`]: #method.package
    pub fn clear_package(&mut self) {
        self.package = ::std::option::Option::None
    }
    /// Gets the field number of the [`dependency`] field
    ///
    /// [`dependency`]: #method.dependency
    pub const DEPENDENCY_FIELD_NUMBER: i32 = 3;
    /// Names of files imported by this file.
    pub fn dependency(&self) -> &crate::collections::RepeatedField<::std::string::String> {
        &self.dependency
    }
    /// Returns a unique reference to the [`dependency`] field
    ///
    /// [`dependency`]: #method.dependency
    pub fn dependency_mut(&mut self) -> &mut crate::collections::RepeatedField<::std::string::String> {
        &mut self.dependency
    }
    /// Gets the field number of the [`public_dependency`] field
    ///
    /// [`public_dependency`]: #method.public_dependency
    pub const PUBLIC_DEPENDENCY_FIELD_NUMBER: i32 = 10;
    /// Indexes of the public imported files in the dependency list above.
    pub fn public_dependency(&self) -> &crate::collections::RepeatedField<i32> {
        &self.public_dependency
    }
    /// Returns a unique reference to the [`public_dependency`] field
    ///
    /// [`public_dependency`]: #method.public_dependency
    pub fn public_dependency_mut(&mut self) -> &mut crate::collections::RepeatedField<i32> {
        &mut self.public_dependency
    }
    /// Gets the field number of the [`weak_dependency`] field
    ///
    /// [`weak_dependency`]: #method.weak_dependency
    pub const WEAK_DEPENDENCY_FIELD_NUMBER: i32 = 11;
    /// Indexes of the weak imported files in the dependency list.
    /// For Google-internal migration only. Do not use.
    pub fn weak_dependency(&self) -> &crate::collections::RepeatedField<i32> {
        &self.weak_dependency
    }
    /// Returns a unique reference to the [`weak_dependency`] field
    ///
    /// [`weak_dependency`]: #method.weak_dependency
    pub fn weak_dependency_mut(&mut self) -> &mut crate::collections::RepeatedField<i32> {
        &mut self.weak_dependency
    }
    /// Gets the field number of the [`message_type`] field
    ///
    /// [`message_type`]: #method.message_type
    pub const MESSAGE_TYPE_FIELD_NUMBER: i32 = 4;
    /// All top-level definitions in this file.
    pub fn message_type(&self) -> &crate::collections::RepeatedField<self::DescriptorProto> {
        &self.message_type
    }
    /// Returns a unique reference to the [`message_type`] field
    ///
    /// [`message_type`]: #method.message_type
    pub fn message_type_mut(&mut self) -> &mut crate::collections::RepeatedField<self::DescriptorProto> {
        &mut self.message_type
    }
    /// Gets the field number of the [`enum_type`] field
    ///
    /// [`enum_type`]: #method.enum_type
    pub const ENUM_TYPE_FIELD_NUMBER: i32 = 5;
    pub fn enum_type(&self) -> &crate::collections::RepeatedField<self::EnumDescriptorProto> {
        &self.enum_type
    }
    /// Returns a unique reference to the [`enum_type`] field
    ///
    /// [`enum_type`]: #method.enum_type
    pub fn enum_type_mut(&mut self) -> &mut crate::collections::RepeatedField<self::EnumDescriptorProto> {
        &mut self.enum_type
    }
    /// Gets the field number of the [`service`] field
    ///
    /// [`service`]: #method.service
    pub const SERVICE_FIELD_NUMBER: i32 = 6;
    pub fn service(&self) -> &crate::collections::RepeatedField<self::ServiceDescriptorProto> {
        &self.service
    }
    /// Returns a unique reference to the [`service`] field
    ///
    /// [`service`]: #method.service
    pub fn service_mut(&mut self) -> &mut crate::collections::RepeatedField<self::ServiceDescriptorProto> {
        &mut self.service
    }
    /// Gets the field number of the [`extension`] field
    ///
    /// [`extension`]: #method.extension
    pub const EXTENSION_FIELD_NUMBER: i32 = 7;
    pub fn extension(&self) -> &crate::collections::RepeatedField<self::FieldDescriptorProto> {
        &self.extension
    }
    /// Returns a unique reference to the [`extension`] field
    ///
    /// [`extension`]: #method.extension
    pub fn extension_mut(&mut self) -> &mut crate::collections::RepeatedField<self::FieldDescriptorProto> {
        &mut self.extension
    }
    /// Gets the field number of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub const OPTIONS_FIELD_NUMBER: i32 = 8;
    pub fn options(&self) -> ::std::option::Option<&self::FileOptions> {
        self.options.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn options_mut(&mut self) -> &mut self::FileOptions {
        self.options.get_or_insert_with(crate::LiteMessage::new)
    }
    /// Returns a bool indicating the presence of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }
    /// Sets the value of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn set_options(&mut self, value: self::FileOptions) {
        self.options = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`options`] field, leaving it empty
    ///
    /// [`options`]: #method.options
    pub fn take_options(&mut self) -> ::std::option::Option<self::FileOptions> {
        self.options.take().map(|b| *b)
    }
    /// Clears the value of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn clear_options(&mut self) {
        self.options = ::std::option::Option::None
    }
    /// Gets the field number of the [`source_code_info`] field
    ///
    /// [`source_code_info`]: #method.source_code_info
    pub const SOURCE_CODE_INFO_FIELD_NUMBER: i32 = 9;
    /// This field contains optional information about the original source code.
    /// You may safely remove this entire field without harming runtime
    /// functionality of the descriptors -- the information is needed only by
    /// development tools.
    pub fn source_code_info(&self) -> ::std::option::Option<&self::SourceCodeInfo> {
        self.source_code_info.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`source_code_info`] field
    ///
    /// [`source_code_info`]: #method.source_code_info
    pub fn source_code_info_mut(&mut self) -> &mut self::SourceCodeInfo {
        self.source_code_info.get_or_insert_with(crate::LiteMessage::new)
    }
    /// Returns a bool indicating the presence of the [`source_code_info`] field
    ///
    /// [`source_code_info`]: #method.source_code_info
    pub fn has_source_code_info(&self) -> bool {
        self.source_code_info.is_some()
    }
    /// Sets the value of the [`source_code_info`] field
    ///
    /// [`source_code_info`]: #method.source_code_info
    pub fn set_source_code_info(&mut self, value: self::SourceCodeInfo) {
        self.source_code_info = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`source_code_info`] field, leaving it empty
    ///
    /// [`source_code_info`]: #method.source_code_info
    pub fn take_source_code_info(&mut self) -> ::std::option::Option<self::SourceCodeInfo> {
        self.source_code_info.take().map(|b| *b)
    }
    /// Clears the value of the [`source_code_info`] field
    ///
    /// [`source_code_info`]: #method.source_code_info
    pub fn clear_source_code_info(&mut self) {
        self.source_code_info = ::std::option::Option::None
    }
    /// Gets the field number of the [`syntax`] field
    ///
    /// [`syntax`]: #method.syntax
    pub const SYNTAX_FIELD_NUMBER: i32 = 12;
    /// A constant value representing the default value of the [`syntax`] field
    ///
    /// [`syntax`]: #method.syntax
    pub const SYNTAX_DEFAULT_VALUE: &'static str = "";
    /// The syntax of the proto file.
    /// The supported values are "proto2" and "proto3".
    pub fn syntax(&self) -> &str {
        &self.syntax.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::SYNTAX_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`syntax`] field
    ///
    /// [`syntax`]: #method.syntax
    pub fn syntax_mut(&mut self) -> &mut ::std::string::String {
        self.syntax.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`syntax`] field
    ///
    /// [`syntax`]: #method.syntax
    pub fn has_syntax(&self) -> bool {
        self.syntax.is_some()
    }
    /// Sets the value of the [`syntax`] field
    ///
    /// [`syntax`]: #method.syntax
    pub fn set_syntax(&mut self, value: ::std::string::String) {
        self.syntax = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`syntax`] field, leaving it empty
    ///
    /// [`syntax`]: #method.syntax
    pub fn take_syntax(&mut self) -> ::std::option::Option<::std::string::String> {
        self.syntax.take()
    }
    /// Clears the value of the [`syntax`] field
    ///
    /// [`syntax`]: #method.syntax
    pub fn clear_syntax(&mut self) {
        self.syntax = ::std::option::Option::None
    }
}
/// Describes a message type.
#[derive(Clone, Debug, PartialEq)]
pub struct DescriptorProto {
    name: ::std::option::Option<::std::string::String>,
    field: crate::collections::RepeatedField<self::FieldDescriptorProto>,
    extension: crate::collections::RepeatedField<self::FieldDescriptorProto>,
    nested_type: crate::collections::RepeatedField<self::DescriptorProto>,
    enum_type: crate::collections::RepeatedField<self::EnumDescriptorProto>,
    extension_range: crate::collections::RepeatedField<self::DescriptorProto_ExtensionRange>,
    oneof_decl: crate::collections::RepeatedField<self::OneofDescriptorProto>,
    options: ::std::option::Option<::std::boxed::Box<self::MessageOptions>>,
    reserved_range: crate::collections::RepeatedField<self::DescriptorProto_ReservedRange>,
    reserved_name: crate::collections::RepeatedField<::std::string::String>,
    unknown_fields: crate::UnknownFieldSet
}
static DESCRIPTOR_PROTO_FIELD_CODEC: crate::Codec<self::FieldDescriptorProto> = crate::Codec::message(18);
static DESCRIPTOR_PROTO_EXTENSION_CODEC: crate::Codec<self::FieldDescriptorProto> = crate::Codec::message(50);
static DESCRIPTOR_PROTO_NESTED_TYPE_CODEC: crate::Codec<self::DescriptorProto> = crate::Codec::message(26);
static DESCRIPTOR_PROTO_ENUM_TYPE_CODEC: crate::Codec<self::EnumDescriptorProto> = crate::Codec::message(34);
static DESCRIPTOR_PROTO_EXTENSION_RANGE_CODEC: crate::Codec<self::DescriptorProto_ExtensionRange> = crate::Codec::message(42);
static DESCRIPTOR_PROTO_ONEOF_DECL_CODEC: crate::Codec<self::OneofDescriptorProto> = crate::Codec::message(66);
static DESCRIPTOR_PROTO_RESERVED_RANGE_CODEC: crate::Codec<self::DescriptorProto_ReservedRange> = crate::Codec::message(74);
static DESCRIPTOR_PROTO_RESERVED_NAME_CODEC: crate::Codec<::std::string::String> = crate::Codec::string(82);
impl crate::CodedMessage for self::DescriptorProto {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.name = ::std::option::Option::Some(input.read_string()?),
                18 => self.field.add_entries(tag.get(), input, &DESCRIPTOR_PROTO_FIELD_CODEC)?,
                50 => self.extension.add_entries(tag.get(), input, &DESCRIPTOR_PROTO_EXTENSION_CODEC)?,
                26 => self.nested_type.add_entries(tag.get(), input, &DESCRIPTOR_PROTO_NESTED_TYPE_CODEC)?,
                34 => self.enum_type.add_entries(tag.get(), input, &DESCRIPTOR_PROTO_ENUM_TYPE_CODEC)?,
                42 => self.extension_range.add_entries(tag.get(), input, &DESCRIPTOR_PROTO_EXTENSION_RANGE_CODEC)?,
                66 => self.oneof_decl.add_entries(tag.get(), input, &DESCRIPTOR_PROTO_ONEOF_DECL_CODEC)?,
                58 => input.read_message(self.options.get_or_insert_with(crate::LiteMessage::new))?,
                74 => self.reserved_range.add_entries(tag.get(), input, &DESCRIPTOR_PROTO_RESERVED_RANGE_CODEC)?,
                82 => self.reserved_name.add_entries(tag.get(), input, &DESCRIPTOR_PROTO_RESERVED_NAME_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(name);
            }
        }
        size += self.field.calculate_size(&DESCRIPTOR_PROTO_FIELD_CODEC);
        size += self.extension.calculate_size(&DESCRIPTOR_PROTO_EXTENSION_CODEC);
        size += self.nested_type.calculate_size(&DESCRIPTOR_PROTO_NESTED_TYPE_CODEC);
        size += self.enum_type.calculate_size(&DESCRIPTOR_PROTO_ENUM_TYPE_CODEC);
        size += self.extension_range.calculate_size(&DESCRIPTOR_PROTO_EXTENSION_RANGE_CODEC);
        size += self.oneof_decl.calculate_size(&DESCRIPTOR_PROTO_ONEOF_DECL_CODEC);
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            size += 1;
            size += crate::io::sizes::message(options);
        }
        size += self.reserved_range.calculate_size(&DESCRIPTOR_PROTO_RESERVED_RANGE_CODEC);
        size += self.reserved_name.calculate_size(&DESCRIPTOR_PROTO_RESERVED_NAME_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
        }
        self.field.write_to(output, &DESCRIPTOR_PROTO_FIELD_CODEC)?;
        self.extension.write_to(output, &DESCRIPTOR_PROTO_EXTENSION_CODEC)?;
        self.nested_type.write_to(output, &DESCRIPTOR_PROTO_NESTED_TYPE_CODEC)?;
        self.enum_type.write_to(output, &DESCRIPTOR_PROTO_ENUM_TYPE_CODEC)?;
        self.extension_range.write_to(output, &DESCRIPTOR_PROTO_EXTENSION_RANGE_CODEC)?;
        self.oneof_decl.write_to(output, &DESCRIPTOR_PROTO_ONEOF_DECL_CODEC)?;
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            output.write_raw_tag_bytes(&[58])?;
            output.write_message(options)?;
        }
        self.reserved_range.write_to(output, &DESCRIPTOR_PROTO_RESERVED_RANGE_CODEC)?;
        self.reserved_name.write_to(output, &DESCRIPTOR_PROTO_RESERVED_NAME_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::DescriptorProto {
    fn new() -> Self {
        Self {
            name: ::std::option::Option::None,
            field: crate::collections::RepeatedField::new(),
            extension: crate::collections::RepeatedField::new(),
            nested_type: crate::collections::RepeatedField::new(),
            enum_type: crate::collections::RepeatedField::new(),
            extension_range: crate::collections::RepeatedField::new(),
            oneof_decl: crate::collections::RepeatedField::new(),
            options: ::std::option::Option::None,
            reserved_range: crate::collections::RepeatedField::new(),
            reserved_name: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
    fn merge(&mut self, other: &Self) {
        self.name = other.name.clone();
        self.field.merge(&other.field);
        self.extension.merge(&other.extension);
        self.nested_type.merge(&other.nested_type);
        self.enum_type.merge(&other.enum_type);
        self.extension_range.merge(&other.extension_range);
        self.oneof_decl.merge(&other.oneof_decl);
        if let ::std::option::Option::Some(options) = &other.options {
            self.options.get_or_insert_with(crate::LiteMessage::new).merge(options);
        }
        self.reserved_range.merge(&other.reserved_range);
        self.reserved_name.merge(&other.reserved_name);
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl crate::Message for self::DescriptorProto {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[2]
    }
}
impl self::DescriptorProto {
    /// Gets the field number of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub const NAME_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub const NAME_DEFAULT_VALUE: &'static str = "";
    pub fn name(&self) -> &str {
        &self.name.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::NAME_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn name_mut(&mut self) -> &mut ::std::string::String {
        self.name.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }
    /// Sets the value of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn set_name(&mut self, value: ::std::string::String) {
        self.name = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`name`] field, leaving it empty
    ///
    /// [`name`]: #method.name
    pub fn take_name(&mut self) -> ::std::option::Option<::std::string::String> {
        self.name.take()
    }
    /// Clears the value of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None
    }
    /// Gets the field number of the [`field`] field
    ///
    /// [`field`]: #method.field
    pub const FIELD_FIELD_NUMBER: i32 = 2;
    pub fn field(&self) -> &crate::collections::RepeatedField<self::FieldDescriptorProto> {
        &self.field
    }
    /// Returns a unique reference to the [`field`] field
    ///
    /// [`field`]: #method.field
    pub fn field_mut(&mut self) -> &mut crate::collections::RepeatedField<self::FieldDescriptorProto> {
        &mut self.field
    }
    /// Gets the field number of the [`extension`] field
    ///
    /// [`extension`]: #method.extension
    pub const EXTENSION_FIELD_NUMBER: i32 = 6;
    pub fn extension(&self) -> &crate::collections::RepeatedField<self::FieldDescriptorProto> {
        &self.extension
    }
    /// Returns a unique reference to the [`extension`] field
    ///
    /// [`extension`]: #method.extension
    pub fn extension_mut(&mut self) -> &mut crate::collections::RepeatedField<self::FieldDescriptorProto> {
        &mut self.extension
    }
    /// Gets the field number of the [`nested_type`] field
    ///
    /// [`nested_type`]: #method.nested_type
    pub const NESTED_TYPE_FIELD_NUMBER: i32 = 3;
    pub fn nested_type(&self) -> &crate::collections::RepeatedField<self::DescriptorProto> {
        &self.nested_type
    }
    /// Returns a unique reference to the [`nested_type`] field
    ///
    /// [`nested_type`]: #method.nested_type
    pub fn nested_type_mut(&mut self) -> &mut crate::collections::RepeatedField<self::DescriptorProto> {
        &mut self.nested_type
    }
    /// Gets the field number of the [`enum_type`] field
    ///
    /// [`enum_type`]: #method.enum_type
    pub const ENUM_TYPE_FIELD_NUMBER: i32 = 4;
    pub fn enum_type(&self) -> &crate::collections::RepeatedField<self::EnumDescriptorProto> {
        &self.enum_type
    }
    /// Returns a unique reference to the [`enum_type`] field
    ///
    /// [`enum_type`]: #method.enum_type
    pub fn enum_type_mut(&mut self) -> &mut crate::collections::RepeatedField<self::EnumDescriptorProto> {
        &mut self.enum_type
    }
    /// Gets the field number of the [`extension_range`] field
    ///
    /// [`extension_range`]: #method.extension_range
    pub const EXTENSION_RANGE_FIELD_NUMBER: i32 = 5;
    pub fn extension_range(&self) -> &crate::collections::RepeatedField<self::DescriptorProto_ExtensionRange> {
        &self.extension_range
    }
    /// Returns a unique reference to the [`extension_range`] field
    ///
    /// [`extension_range`]: #method.extension_range
    pub fn extension_range_mut(&mut self) -> &mut crate::collections::RepeatedField<self::DescriptorProto_ExtensionRange> {
        &mut self.extension_range
    }
    /// Gets the field number of the [`oneof_decl`] field
    ///
    /// [`oneof_decl`]: #method.oneof_decl
    pub const ONEOF_DECL_FIELD_NUMBER: i32 = 8;
    pub fn oneof_decl(&self) -> &crate::collections::RepeatedField<self::OneofDescriptorProto> {
        &self.oneof_decl
    }
    /// Returns a unique reference to the [`oneof_decl`] field
    ///
    /// [`oneof_decl`]: #method.oneof_decl
    pub fn oneof_decl_mut(&mut self) -> &mut crate::collections::RepeatedField<self::OneofDescriptorProto> {
        &mut self.oneof_decl
    }
    /// Gets the field number of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub const OPTIONS_FIELD_NUMBER: i32 = 7;
    pub fn options(&self) -> ::std::option::Option<&self::MessageOptions> {
        self.options.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn options_mut(&mut self) -> &mut self::MessageOptions {
        self.options.get_or_insert_with(crate::LiteMessage::new)
    }
    /// Returns a bool indicating the presence of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }
    /// Sets the value of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn set_options(&mut self, value: self::MessageOptions) {
        self.options = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`options`] field, leaving it empty
    ///
    /// [`options`]: #method.options
    pub fn take_options(&mut self) -> ::std::option::Option<self::MessageOptions> {
        self.options.take().map(|b| *b)
    }
    /// Clears the value of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn clear_options(&mut self) {
        self.options = ::std::option::Option::None
    }
    /// Gets the field number of the [`reserved_range`] field
    ///
    /// [`reserved_range`]: #method.reserved_range
    pub const RESERVED_RANGE_FIELD_NUMBER: i32 = 9;
    pub fn reserved_range(&self) -> &crate::collections::RepeatedField<self::DescriptorProto_ReservedRange> {
        &self.reserved_range
    }
    /// Returns a unique reference to the [`reserved_range`] field
    ///
    /// [`reserved_range`]: #method.reserved_range
    pub fn reserved_range_mut(&mut self) -> &mut crate::collections::RepeatedField<self::DescriptorProto_ReservedRange> {
        &mut self.reserved_range
    }
    /// Gets the field number of the [`reserved_name`] field
    ///
    /// [`reserved_name`]: #method.reserved_name
    pub const RESERVED_NAME_FIELD_NUMBER: i32 = 10;
    /// Reserved field names, which may not be used by fields in the same message.
    /// A given name may only be reserved once.
    pub fn reserved_name(&self) -> &crate::collections::RepeatedField<::std::string::String> {
        &self.reserved_name
    }
    /// Returns a unique reference to the [`reserved_name`] field
    ///
    /// [`reserved_name`]: #method.reserved_name
    pub fn reserved_name_mut(&mut self) -> &mut crate::collections::RepeatedField<::std::string::String> {
        &mut self.reserved_name
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct DescriptorProto_ExtensionRange {
    start: ::std::option::Option<i32>,
    end: ::std::option::Option<i32>,
    options: ::std::option::Option<::std::boxed::Box<self::ExtensionRangeOptions>>,
    unknown_fields: crate::UnknownFieldSet
}
impl crate::CodedMessage for self::DescriptorProto_ExtensionRange {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 => self.start = ::std::option::Option::Some(input.read_int32()?),
                16 => self.end = ::std::option::Option::Some(input.read_int32()?),
                26 => input.read_message(self.options.get_or_insert_with(crate::LiteMessage::new))?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let start = self.start;
        if let ::std::option::Option::Some(start) = start {
            if start != Self::START_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::int32(start);
            }
        }
        let end = self.end;
        if let ::std::option::Option::Some(end) = end {
            if end != Self::END_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::int32(end);
            }
        }
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            size += 1;
            size += crate::io::sizes::message(options);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let start = self.start;
        if let ::std::option::Option::Some(start) = start {
            if start != Self::START_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(start)?;
            }
        }
        let end = self.end;
        if let ::std::option::Option::Some(end) = end {
            if end != Self::END_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_int32(end)?;
            }
        }
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            output.write_raw_tag_bytes(&[26])?;
            output.write_message(options)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::DescriptorProto_ExtensionRange {
    fn new() -> Self {
        Self {
            start: ::std::option::Option::None,
            end: ::std::option::Option::None,
            options: ::std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
    fn merge(&mut self, other: &Self) {
        self.start = other.start;
        self.end = other.end;
        if let ::std::option::Option::Some(options) = &other.options {
            self.options.get_or_insert_with(crate::LiteMessage::new).merge(options);
        }
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl crate::Message for self::DescriptorProto_ExtensionRange {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[2].messages()[0]
    }
}
impl self::DescriptorProto_ExtensionRange {
    /// Gets the field number of the [`start`] field
    ///
    /// [`start`]: #method.start
    pub const START_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`start`] field
    ///
    /// [`start`]: #method.start
    pub const START_DEFAULT_VALUE: i32 = 0;
    pub fn start(&self) -> i32 {
        self.start.unwrap_or(Self::START_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`start`] field
    ///
    /// [`start`]: #method.start
    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }
    /// Sets the value of the [`start`] field
    ///
    /// [`start`]: #method.start
    pub fn set_start(&mut self, value: i32) {
        self.start = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`start`] field
    ///
    /// [`start`]: #method.start
    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None
    }
    /// Gets the field number of the [`end`] field
    ///
    /// [`end`]: #method.end
    pub const END_FIELD_NUMBER: i32 = 2;
    /// A constant value representing the default value of the [`end`] field
    ///
    /// [`end`]: #method.end
    pub const END_DEFAULT_VALUE: i32 = 0;
    pub fn end(&self) -> i32 {
        self.end.unwrap_or(Self::END_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`end`] field
    ///
    /// [`end`]: #method.end
    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }
    /// Sets the value of the [`end`] field
    ///
    /// [`end`]: #method.end
    pub fn set_end(&mut self, value: i32) {
        self.end = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`end`] field
    ///
    /// [`end`]: #method.end
    pub fn clear_end(&mut self) {
        self.end = ::std::option::Option::None
    }
    /// Gets the field number of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub const OPTIONS_FIELD_NUMBER: i32 = 3;
    pub fn options(&self) -> ::std::option::Option<&self::ExtensionRangeOptions> {
        self.options.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn options_mut(&mut self) -> &mut self::ExtensionRangeOptions {
        self.options.get_or_insert_with(crate::LiteMessage::new)
    }
    /// Returns a bool indicating the presence of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }
    /// Sets the value of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn set_options(&mut self, value: self::ExtensionRangeOptions) {
        self.options = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`options`] field, leaving it empty
    ///
    /// [`options`]: #method.options
    pub fn take_options(&mut self) -> ::std::option::Option<self::ExtensionRangeOptions> {
        self.options.take().map(|b| *b)
    }
    /// Clears the value of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn clear_options(&mut self) {
        self.options = ::std::option::Option::None
    }
}
/// Range of reserved tag numbers. Reserved tag numbers may not be used by
/// fields or extension ranges in the same message. Reserved ranges may
/// not overlap.
#[derive(Clone, Debug, PartialEq)]
pub struct DescriptorProto_ReservedRange {
    start: ::std::option::Option<i32>,
    end: ::std::option::Option<i32>,
    unknown_fields: crate::UnknownFieldSet
}
impl crate::CodedMessage for self::DescriptorProto_ReservedRange {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 => self.start = ::std::option::Option::Some(input.read_int32()?),
                16 => self.end = ::std::option::Option::Some(input.read_int32()?),
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let start = self.start;
        if let ::std::option::Option::Some(start) = start {
            if start != Self::START_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::int32(start);
            }
        }
        let end = self.end;
        if let ::std::option::Option::Some(end) = end {
            if end != Self::END_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::int32(end);
            }
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let start = self.start;
        if let ::std::option::Option::Some(start) = start {
            if start != Self::START_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(start)?;
            }
        }
        let end = self.end;
        if let ::std::option::Option::Some(end) = end {
            if end != Self::END_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_int32(end)?;
            }
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::DescriptorProto_ReservedRange {
    fn new() -> Self {
        Self {
            start: ::std::option::Option::None,
            end: ::std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
    fn merge(&mut self, other: &Self) {
        self.start = other.start;
        self.end = other.end;
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl crate::Message for self::DescriptorProto_ReservedRange {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[2].messages()[1]
    }
}
impl self::DescriptorProto_ReservedRange {
    /// Gets the field number of the [`start`] field
    ///
    /// [`start`]: #method.start
    pub const START_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`start`] field
    ///
    /// [`start`]: #method.start
    pub const START_DEFAULT_VALUE: i32 = 0;
    /// Inclusive.
    pub fn start(&self) -> i32 {
        self.start.unwrap_or(Self::START_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`start`] field
    ///
    /// [`start`]: #method.start
    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }
    /// Sets the value of the [`start`] field
    ///
    /// [`start`]: #method.start
    pub fn set_start(&mut self, value: i32) {
        self.start = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`start`] field
    ///
    /// [`start`]: #method.start
    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None
    }
    /// Gets the field number of the [`end`] field
    ///
    /// [`end`]: #method.end
    pub const END_FIELD_NUMBER: i32 = 2;
    /// A constant value representing the default value of the [`end`] field
    ///
    /// [`end`]: #method.end
    pub const END_DEFAULT_VALUE: i32 = 0;
    /// Exclusive.
    pub fn end(&self) -> i32 {
        self.end.unwrap_or(Self::END_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`end`] field
    ///
    /// [`end`]: #method.end
    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }
    /// Sets the value of the [`end`] field
    ///
    /// [`end`]: #method.end
    pub fn set_end(&mut self, value: i32) {
        self.end = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`end`] field
    ///
    /// [`end`]: #method.end
    pub fn clear_end(&mut self) {
        self.end = ::std::option::Option::None
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct ExtensionRangeOptions {
    uninterpreted_option: crate::collections::RepeatedField<self::UninterpretedOption>,
    unknown_fields: crate::UnknownFieldSet
}
static EXTENSION_RANGE_OPTIONS_UNINTERPRETED_OPTION_CODEC: crate::Codec<self::UninterpretedOption> = crate::Codec::message(7994);
impl crate::CodedMessage for self::ExtensionRangeOptions {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                7994 => self.uninterpreted_option.add_entries(tag.get(), input, &EXTENSION_RANGE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.uninterpreted_option.calculate_size(&EXTENSION_RANGE_OPTIONS_UNINTERPRETED_OPTION_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        self.uninterpreted_option.write_to(output, &EXTENSION_RANGE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::ExtensionRangeOptions {
    fn new() -> Self {
        Self {
            uninterpreted_option: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
    fn merge(&mut self, other: &Self) {
        self.uninterpreted_option.merge(&other.uninterpreted_option);
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl crate::Message for self::ExtensionRangeOptions {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[3]
    }
}
impl self::ExtensionRangeOptions {
    /// Gets the field number of the [`uninterpreted_option`] field
    ///
    /// [`uninterpreted_option`]: #method.uninterpreted_option
    pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
    /// The parser stores options it doesn't recognize here. See above.
    pub fn uninterpreted_option(&self) -> &crate::collections::RepeatedField<self::UninterpretedOption> {
        &self.uninterpreted_option
    }
    /// Returns a unique reference to the [`uninterpreted_option`] field
    ///
    /// [`uninterpreted_option`]: #method.uninterpreted_option
    pub fn uninterpreted_option_mut(&mut self) -> &mut crate::collections::RepeatedField<self::UninterpretedOption> {
        &mut self.uninterpreted_option
    }
}
/// Describes a field within a message.
#[derive(Clone, Debug, PartialEq)]
pub struct FieldDescriptorProto {
    name: ::std::option::Option<::std::string::String>,
    number: ::std::option::Option<i32>,
    label: ::std::option::Option<crate::EnumValue<self::FieldDescriptorProto_Label>>,
    r#type: ::std::option::Option<crate::EnumValue<self::FieldDescriptorProto_Type>>,
    type_name: ::std::option::Option<::std::string::String>,
    extendee: ::std::option::Option<::std::string::String>,
    default_value: ::std::option::Option<::std::string::String>,
    oneof_index: ::std::option::Option<i32>,
    json_name: ::std::option::Option<::std::string::String>,
    options: ::std::option::Option<::std::boxed::Box<self::FieldOptions>>,
    unknown_fields: crate::UnknownFieldSet
}
impl crate::CodedMessage for self::FieldDescriptorProto {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.name = ::std::option::Option::Some(input.read_string()?),
                24 => self.number = ::std::option::Option::Some(input.read_int32()?),
                32 => self.label = ::std::option::Option::Some(input.read_enum_value()?),
                40 => self.r#type = ::std::option::Option::Some(input.read_enum_value()?),
                50 => self.type_name = ::std::option::Option::Some(input.read_string()?),
                18 => self.extendee = ::std::option::Option::Some(input.read_string()?),
                58 => self.default_value = ::std::option::Option::Some(input.read_string()?),
                72 => self.oneof_index = ::std::option::Option::Some(input.read_int32()?),
                82 => self.json_name = ::std::option::Option::Some(input.read_string()?),
                66 => input.read_message(self.options.get_or_insert_with(crate::LiteMessage::new))?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(name);
            }
        }
        let number = self.number;
        if let ::std::option::Option::Some(number) = number {
            if number != Self::NUMBER_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::int32(number);
            }
        }
        let label = self.label;
        if let ::std::option::Option::Some(label) = label {
            if label != Self::LABEL_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::enum_value(label);
            }
        }
        let r#type = self.r#type;
        if let ::std::option::Option::Some(r#type) = r#type {
            if r#type != Self::TYPE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::enum_value(r#type);
            }
        }
        let type_name = &self.type_name;
        if let ::std::option::Option::Some(type_name) = type_name {
            if type_name != Self::TYPE_NAME_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(type_name);
            }
        }
        let extendee = &self.extendee;
        if let ::std::option::Option::Some(extendee) = extendee {
            if extendee != Self::EXTENDEE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(extendee);
            }
        }
        let default_value = &self.default_value;
        if let ::std::option::Option::Some(default_value) = default_value {
            if default_value != Self::DEFAULT_VALUE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(default_value);
            }
        }
        let oneof_index = self.oneof_index;
        if let ::std::option::Option::Some(oneof_index) = oneof_index {
            if oneof_index != Self::ONEOF_INDEX_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::int32(oneof_index);
            }
        }
        let json_name = &self.json_name;
        if let ::std::option::Option::Some(json_name) = json_name {
            if json_name != Self::JSON_NAME_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(json_name);
            }
        }
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            size += 1;
            size += crate::io::sizes::message(options);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
        }
        let number = self.number;
        if let ::std::option::Option::Some(number) = number {
            if number != Self::NUMBER_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[24])?;
                output.write_int32(number)?;
            }
        }
        let label = self.label;
        if let ::std::option::Option::Some(label) = label {
            if label != Self::LABEL_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[32])?;
                output.write_enum_value(label)?;
            }
        }
        let r#type = self.r#type;
        if let ::std::option::Option::Some(r#type) = r#type {
            if r#type != Self::TYPE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[40])?;
                output.write_enum_value(r#type)?;
            }
        }
        let type_name = &self.type_name;
        if let ::std::option::Option::Some(type_name) = type_name {
            if type_name != Self::TYPE_NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[50])?;
                output.write_string(type_name)?;
            }
        }
        let extendee = &self.extendee;
        if let ::std::option::Option::Some(extendee) = extendee {
            if extendee != Self::EXTENDEE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[18])?;
                output.write_string(extendee)?;
            }
        }
        let default_value = &self.default_value;
        if let ::std::option::Option::Some(default_value) = default_value {
            if default_value != Self::DEFAULT_VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[58])?;
                output.write_string(default_value)?;
            }
        }
        let oneof_index = self.oneof_index;
        if let ::std::option::Option::Some(oneof_index) = oneof_index {
            if oneof_index != Self::ONEOF_INDEX_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[72])?;
                output.write_int32(oneof_index)?;
            }
        }
        let json_name = &self.json_name;
        if let ::std::option::Option::Some(json_name) = json_name {
            if json_name != Self::JSON_NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[82])?;
                output.write_string(json_name)?;
            }
        }
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            output.write_raw_tag_bytes(&[66])?;
            output.write_message(options)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::FieldDescriptorProto {
    fn new() -> Self {
        Self {
            name: ::std::option::Option::None,
            number: ::std::option::Option::None,
            label: ::std::option::Option::None,
            r#type: ::std::option::Option::None,
            type_name: ::std::option::Option::None,
            extendee: ::std::option::Option::None,
            default_value: ::std::option::Option::None,
            oneof_index: ::std::option::Option::None,
            json_name: ::std::option::Option::None,
            options: ::std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
    fn merge(&mut self, other: &Self) {
        self.name = other.name.clone();
        self.number = other.number;
        self.label = other.label;
        self.r#type = other.r#type;
        self.type_name = other.type_name.clone();
        self.extendee = other.extendee.clone();
        self.default_value = other.default_value.clone();
        self.oneof_index = other.oneof_index;
        self.json_name = other.json_name.clone();
        if let ::std::option::Option::Some(options) = &other.options {
            self.options.get_or_insert_with(crate::LiteMessage::new).merge(options);
        }
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl crate::Message for self::FieldDescriptorProto {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[4]
    }
}
impl self::FieldDescriptorProto {
    /// Gets the field number of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub const NAME_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub const NAME_DEFAULT_VALUE: &'static str = "";
    pub fn name(&self) -> &str {
        &self.name.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::NAME_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn name_mut(&mut self) -> &mut ::std::string::String {
        self.name.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }
    /// Sets the value of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn set_name(&mut self, value: ::std::string::String) {
        self.name = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`name`] field, leaving it empty
    ///
    /// [`name`]: #method.name
    pub fn take_name(&mut self) -> ::std::option::Option<::std::string::String> {
        self.name.take()
    }
    /// Clears the value of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None
    }
    /// Gets the field number of the [`number`] field
    ///
    /// [`number`]: #method.number
    pub const NUMBER_FIELD_NUMBER: i32 = 3;
    /// A constant value representing the default value of the [`number`] field
    ///
    /// [`number`]: #method.number
    pub const NUMBER_DEFAULT_VALUE: i32 = 0;
    pub fn number(&self) -> i32 {
        self.number.unwrap_or(Self::NUMBER_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`number`] field
    ///
    /// [`number`]: #method.number
    pub fn has_number(&self) -> bool {
        self.number.is_some()
    }
    /// Sets the value of the [`number`] field
    ///
    /// [`number`]: #method.number
    pub fn set_number(&mut self, value: i32) {
        self.number = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`number`] field
    ///
    /// [`number`]: #method.number
    pub fn clear_number(&mut self) {
        self.number = ::std::option::Option::None
    }
    /// Gets the field number of the [`label`] field
    ///
    /// [`label`]: #method.label
    pub const LABEL_FIELD_NUMBER: i32 = 4;
    /// A constant value representing the default value of the [`label`] field
    ///
    /// [`label`]: #method.label
    pub const LABEL_DEFAULT_VALUE: crate::EnumValue<self::FieldDescriptorProto_Label> = crate::EnumValue::Undefined(0);
    pub fn label(&self) -> crate::EnumValue<self::FieldDescriptorProto_Label> {
        self.label.unwrap_or(Self::LABEL_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`label`] field
    ///
    /// [`label`]: #method.label
    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }
    /// Sets the value of the [`label`] field
    ///
    /// [`label`]: #method.label
    pub fn set_label(&mut self, value: crate::EnumValue<self::FieldDescriptorProto_Label>) {
        self.label = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`label`] field
    ///
    /// [`label`]: #method.label
    pub fn clear_label(&mut self) {
        self.label = ::std::option::Option::None
    }
    /// Gets the field number of the [`type`] field
    ///
    /// [`type`]: #method.type
    pub const TYPE_FIELD_NUMBER: i32 = 5;
    /// A constant value representing the default value of the [`type`] field
    ///
    /// [`type`]: #method.type
    pub const TYPE_DEFAULT_VALUE: crate::EnumValue<self::FieldDescriptorProto_Type> = crate::EnumValue::Undefined(0);
    /// If type_name is set, this need not be set.  If both this and type_name
    /// are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
    pub fn r#type(&self) -> crate::EnumValue<self::FieldDescriptorProto_Type> {
        self.r#type.unwrap_or(Self::TYPE_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`type`] field
    ///
    /// [`type`]: #method.type
    pub fn has_type(&self) -> bool {
        self.r#type.is_some()
    }
    /// Sets the value of the [`type`] field
    ///
    /// [`type`]: #method.type
    pub fn set_type(&mut self, value: crate::EnumValue<self::FieldDescriptorProto_Type>) {
        self.r#type = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`type`] field
    ///
    /// [`type`]: #method.type
    pub fn clear_type(&mut self) {
        self.r#type = ::std::option::Option::None
    }
    /// Gets the field number of the [`type_name`] field
    ///
    /// [`type_name`]: #method.type_name
    pub const TYPE_NAME_FIELD_NUMBER: i32 = 6;
    /// A constant value representing the default value of the [`type_name`] field
    ///
    /// [`type_name`]: #method.type_name
    pub const TYPE_NAME_DEFAULT_VALUE: &'static str = "";
    /// For message and enum types, this is the name of the type.  If the name
    /// starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
    /// rules are used to find the type (i.e. first the nested types within this
    /// message are searched, then within the parent, on up to the root
    /// namespace).
    pub fn type_name(&self) -> &str {
        &self.type_name.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::TYPE_NAME_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`type_name`] field
    ///
    /// [`type_name`]: #method.type_name
    pub fn type_name_mut(&mut self) -> &mut ::std::string::String {
        self.type_name.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`type_name`] field
    ///
    /// [`type_name`]: #method.type_name
    pub fn has_type_name(&self) -> bool {
        self.type_name.is_some()
    }
    /// Sets the value of the [`type_name`] field
    ///
    /// [`type_name`]: #method.type_name
    pub fn set_type_name(&mut self, value: ::std::string::String) {
        self.type_name = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`type_name`] field, leaving it empty
    ///
    /// [`type_name`]: #method.type_name
    pub fn take_type_name(&mut self) -> ::std::option::Option<::std::string::String> {
        self.type_name.take()
    }
    /// Clears the value of the [`type_name`] field
    ///
    /// [`type_name`]: #method.type_name
    pub fn clear_type_name(&mut self) {
        self.type_name = ::std::option::Option::None
    }
    /// Gets the field number of the [`extendee`] field
    ///
    /// [`extendee`]: #method.extendee
    pub const EXTENDEE_FIELD_NUMBER: i32 = 2;
    /// A constant value representing the default value of the [`extendee`] field
    ///
    /// [`extendee`]: #method.extendee
    pub const EXTENDEE_DEFAULT_VALUE: &'static str = "";
    /// For extensions, this is the name of the type being extended.  It is
    /// resolved in the same manner as type_name.
    pub fn extendee(&self) -> &str {
        &self.extendee.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::EXTENDEE_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`extendee`] field
    ///
    /// [`extendee`]: #method.extendee
    pub fn extendee_mut(&mut self) -> &mut ::std::string::String {
        self.extendee.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`extendee`] field
    ///
    /// [`extendee`]: #method.extendee
    pub fn has_extendee(&self) -> bool {
        self.extendee.is_some()
    }
    /// Sets the value of the [`extendee`] field
    ///
    /// [`extendee`]: #method.extendee
    pub fn set_extendee(&mut self, value: ::std::string::String) {
        self.extendee = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`extendee`] field, leaving it empty
    ///
    /// [`extendee`]: #method.extendee
    pub fn take_extendee(&mut self) -> ::std::option::Option<::std::string::String> {
        self.extendee.take()
    }
    /// Clears the value of the [`extendee`] field
    ///
    /// [`extendee`]: #method.extendee
    pub fn clear_extendee(&mut self) {
        self.extendee = ::std::option::Option::None
    }
    /// Gets the field number of the [`default_value`] field
    ///
    /// [`default_value`]: #method.default_value
    pub const DEFAULT_VALUE_FIELD_NUMBER: i32 = 7;
    /// A constant value representing the default value of the [`default_value`] field
    ///
    /// [`default_value`]: #method.default_value
    pub const DEFAULT_VALUE_DEFAULT_VALUE: &'static str = "";
    /// For numeric types, contains the original text representation of the value.
    /// For booleans, "true" or "false".
    /// For strings, contains the default text contents (not escaped in any way).
    /// For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
    /// TODO(kenton):  Base-64 encode?
    pub fn default_value(&self) -> &str {
        &self.default_value.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::DEFAULT_VALUE_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`default_value`] field
    ///
    /// [`default_value`]: #method.default_value
    pub fn default_value_mut(&mut self) -> &mut ::std::string::String {
        self.default_value.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`default_value`] field
    ///
    /// [`default_value`]: #method.default_value
    pub fn has_default_value(&self) -> bool {
        self.default_value.is_some()
    }
    /// Sets the value of the [`default_value`] field
    ///
    /// [`default_value`]: #method.default_value
    pub fn set_default_value(&mut self, value: ::std::string::String) {
        self.default_value = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`default_value`] field, leaving it empty
    ///
    /// [`default_value`]: #method.default_value
    pub fn take_default_value(&mut self) -> ::std::option::Option<::std::string::String> {
        self.default_value.take()
    }
    /// Clears the value of the [`default_value`] field
    ///
    /// [`default_value`]: #method.default_value
    pub fn clear_default_value(&mut self) {
        self.default_value = ::std::option::Option::None
    }
    /// Gets the field number of the [`oneof_index`] field
    ///
    /// [`oneof_index`]: #method.oneof_index
    pub const ONEOF_INDEX_FIELD_NUMBER: i32 = 9;
    /// A constant value representing the default value of the [`oneof_index`] field
    ///
    /// [`oneof_index`]: #method.oneof_index
    pub const ONEOF_INDEX_DEFAULT_VALUE: i32 = 0;
    /// If set, gives the index of a oneof in the containing type's oneof_decl
    /// list.  This field is a member of that oneof.
    pub fn oneof_index(&self) -> i32 {
        self.oneof_index.unwrap_or(Self::ONEOF_INDEX_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`oneof_index`] field
    ///
    /// [`oneof_index`]: #method.oneof_index
    pub fn has_oneof_index(&self) -> bool {
        self.oneof_index.is_some()
    }
    /// Sets the value of the [`oneof_index`] field
    ///
    /// [`oneof_index`]: #method.oneof_index
    pub fn set_oneof_index(&mut self, value: i32) {
        self.oneof_index = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`oneof_index`] field
    ///
    /// [`oneof_index`]: #method.oneof_index
    pub fn clear_oneof_index(&mut self) {
        self.oneof_index = ::std::option::Option::None
    }
    /// Gets the field number of the [`json_name`] field
    ///
    /// [`json_name`]: #method.json_name
    pub const JSON_NAME_FIELD_NUMBER: i32 = 10;
    /// A constant value representing the default value of the [`json_name`] field
    ///
    /// [`json_name`]: #method.json_name
    pub const JSON_NAME_DEFAULT_VALUE: &'static str = "";
    /// JSON name of this field. The value is set by protocol compiler. If the
    /// user has set a "json_name" option on this field, that option's value
    /// will be used. Otherwise, it's deduced from the field's name by converting
    /// it to camelCase.
    pub fn json_name(&self) -> &str {
        &self.json_name.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::JSON_NAME_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`json_name`] field
    ///
    /// [`json_name`]: #method.json_name
    pub fn json_name_mut(&mut self) -> &mut ::std::string::String {
        self.json_name.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`json_name`] field
    ///
    /// [`json_name`]: #method.json_name
    pub fn has_json_name(&self) -> bool {
        self.json_name.is_some()
    }
    /// Sets the value of the [`json_name`] field
    ///
    /// [`json_name`]: #method.json_name
    pub fn set_json_name(&mut self, value: ::std::string::String) {
        self.json_name = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`json_name`] field, leaving it empty
    ///
    /// [`json_name`]: #method.json_name
    pub fn take_json_name(&mut self) -> ::std::option::Option<::std::string::String> {
        self.json_name.take()
    }
    /// Clears the value of the [`json_name`] field
    ///
    /// [`json_name`]: #method.json_name
    pub fn clear_json_name(&mut self) {
        self.json_name = ::std::option::Option::None
    }
    /// Gets the field number of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub const OPTIONS_FIELD_NUMBER: i32 = 8;
    pub fn options(&self) -> ::std::option::Option<&self::FieldOptions> {
        self.options.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn options_mut(&mut self) -> &mut self::FieldOptions {
        self.options.get_or_insert_with(crate::LiteMessage::new)
    }
    /// Returns a bool indicating the presence of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }
    /// Sets the value of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn set_options(&mut self, value: self::FieldOptions) {
        self.options = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`options`] field, leaving it empty
    ///
    /// [`options`]: #method.options
    pub fn take_options(&mut self) -> ::std::option::Option<self::FieldOptions> {
        self.options.take().map(|b| *b)
    }
    /// Clears the value of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn clear_options(&mut self) {
        self.options = ::std::option::Option::None
    }
}
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum FieldDescriptorProto_Type {
    /// 0 is reserved for errors.
    /// Order is weird for historical reasons.
    Double = 1,
    Float = 2,
    /// Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
    /// negative values are likely.
    Int64 = 3,
    Uint64 = 4,
    /// Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
    /// negative values are likely.
    Int32 = 5,
    Fixed64 = 6,
    Fixed32 = 7,
    Bool = 8,
    String = 9,
    /// Tag-delimited aggregate.
    /// Group type is deprecated and not supported in proto3. However, Proto3
    /// implementations should still be able to parse the group wire format and
    /// treat group fields as unknown fields.
    Group = 10,
    /// Length-delimited aggregate.
    Message = 11,
    /// New in version 2.
    Bytes = 12,
    Uint32 = 13,
    Enum = 14,
    Sfixed32 = 15,
    Sfixed64 = 16,
    /// Uses ZigZag encoding.
    Sint32 = 17,
    /// Uses ZigZag encoding.
    Sint64 = 18,
}
impl ::std::convert::TryFrom<i32> for self::FieldDescriptorProto_Type {
    type Error = crate::VariantUndefinedError;
    fn try_from(value: i32) -> ::std::result::Result<Self, crate::VariantUndefinedError> {
        match value {
            1 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Double),
            2 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Float),
            3 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Int64),
            4 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Uint64),
            5 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Int32),
            6 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Fixed64),
            7 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Fixed32),
            8 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Bool),
            9 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::String),
            10 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Group),
            11 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Message),
            12 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Bytes),
            13 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Uint32),
            14 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Enum),
            15 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Sfixed32),
            16 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Sfixed64),
            17 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Sint32),
            18 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Sint64),
            _ => ::std::result::Result::Err(crate::VariantUndefinedError)
        }
    }
}
impl ::std::convert::From<self::FieldDescriptorProto_Type> for i32 {
    fn from(value: self::FieldDescriptorProto_Type) -> i32 {
        value as i32
    }
}
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum FieldDescriptorProto_Label {
    /// 0 is reserved for errors
    Optional = 1,
    Required = 2,
    Repeated = 3,
}
impl ::std::convert::TryFrom<i32> for self::FieldDescriptorProto_Label {
    type Error = crate::VariantUndefinedError;
    fn try_from(value: i32) -> ::std::result::Result<Self, crate::VariantUndefinedError> {
        match value {
            1 => ::std::result::Result::Ok(self::FieldDescriptorProto_Label::Optional),
            2 => ::std::result::Result::Ok(self::FieldDescriptorProto_Label::Required),
            3 => ::std::result::Result::Ok(self::FieldDescriptorProto_Label::Repeated),
            _ => ::std::result::Result::Err(crate::VariantUndefinedError)
        }
    }
}
impl ::std::convert::From<self::FieldDescriptorProto_Label> for i32 {
    fn from(value: self::FieldDescriptorProto_Label) -> i32 {
        value as i32
    }
}
/// Describes a oneof.
#[derive(Clone, Debug, PartialEq)]
pub struct OneofDescriptorProto {
    name: ::std::option::Option<::std::string::String>,
    options: ::std::option::Option<::std::boxed::Box<self::OneofOptions>>,
    unknown_fields: crate::UnknownFieldSet
}
impl crate::CodedMessage for self::OneofDescriptorProto {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.name = ::std::option::Option::Some(input.read_string()?),
                18 => input.read_message(self.options.get_or_insert_with(crate::LiteMessage::new))?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(name);
            }
        }
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            size += 1;
            size += crate::io::sizes::message(options);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
        }
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            output.write_raw_tag_bytes(&[18])?;
            output.write_message(options)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::OneofDescriptorProto {
    fn new() -> Self {
        Self {
            name: ::std::option::Option::None,
            options: ::std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
    fn merge(&mut self, other: &Self) {
        self.name = other.name.clone();
        if let ::std::option::Option::Some(options) = &other.options {
            self.options.get_or_insert_with(crate::LiteMessage::new).merge(options);
        }
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl crate::Message for self::OneofDescriptorProto {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[5]
    }
}
impl self::OneofDescriptorProto {
    /// Gets the field number of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub const NAME_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub const NAME_DEFAULT_VALUE: &'static str = "";
    pub fn name(&self) -> &str {
        &self.name.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::NAME_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn name_mut(&mut self) -> &mut ::std::string::String {
        self.name.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }
    /// Sets the value of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn set_name(&mut self, value: ::std::string::String) {
        self.name = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`name`] field, leaving it empty
    ///
    /// [`name`]: #method.name
    pub fn take_name(&mut self) -> ::std::option::Option<::std::string::String> {
        self.name.take()
    }
    /// Clears the value of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None
    }
    /// Gets the field number of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub const OPTIONS_FIELD_NUMBER: i32 = 2;
    pub fn options(&self) -> ::std::option::Option<&self::OneofOptions> {
        self.options.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn options_mut(&mut self) -> &mut self::OneofOptions {
        self.options.get_or_insert_with(crate::LiteMessage::new)
    }
    /// Returns a bool indicating the presence of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }
    /// Sets the value of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn set_options(&mut self, value: self::OneofOptions) {
        self.options = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`options`] field, leaving it empty
    ///
    /// [`options`]: #method.options
    pub fn take_options(&mut self) -> ::std::option::Option<self::OneofOptions> {
        self.options.take().map(|b| *b)
    }
    /// Clears the value of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn clear_options(&mut self) {
        self.options = ::std::option::Option::None
    }
}
/// Describes an enum type.
#[derive(Clone, Debug, PartialEq)]
pub struct EnumDescriptorProto {
    name: ::std::option::Option<::std::string::String>,
    value: crate::collections::RepeatedField<self::EnumValueDescriptorProto>,
    options: ::std::option::Option<::std::boxed::Box<self::EnumOptions>>,
    reserved_range: crate::collections::RepeatedField<self::EnumDescriptorProto_EnumReservedRange>,
    reserved_name: crate::collections::RepeatedField<::std::string::String>,
    unknown_fields: crate::UnknownFieldSet
}
static ENUM_DESCRIPTOR_PROTO_VALUE_CODEC: crate::Codec<self::EnumValueDescriptorProto> = crate::Codec::message(18);
static ENUM_DESCRIPTOR_PROTO_RESERVED_RANGE_CODEC: crate::Codec<self::EnumDescriptorProto_EnumReservedRange> = crate::Codec::message(34);
static ENUM_DESCRIPTOR_PROTO_RESERVED_NAME_CODEC: crate::Codec<::std::string::String> = crate::Codec::string(42);
impl crate::CodedMessage for self::EnumDescriptorProto {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.name = ::std::option::Option::Some(input.read_string()?),
                18 => self.value.add_entries(tag.get(), input, &ENUM_DESCRIPTOR_PROTO_VALUE_CODEC)?,
                26 => input.read_message(self.options.get_or_insert_with(crate::LiteMessage::new))?,
                34 => self.reserved_range.add_entries(tag.get(), input, &ENUM_DESCRIPTOR_PROTO_RESERVED_RANGE_CODEC)?,
                42 => self.reserved_name.add_entries(tag.get(), input, &ENUM_DESCRIPTOR_PROTO_RESERVED_NAME_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(name);
            }
        }
        size += self.value.calculate_size(&ENUM_DESCRIPTOR_PROTO_VALUE_CODEC);
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            size += 1;
            size += crate::io::sizes::message(options);
        }
        size += self.reserved_range.calculate_size(&ENUM_DESCRIPTOR_PROTO_RESERVED_RANGE_CODEC);
        size += self.reserved_name.calculate_size(&ENUM_DESCRIPTOR_PROTO_RESERVED_NAME_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
        }
        self.value.write_to(output, &ENUM_DESCRIPTOR_PROTO_VALUE_CODEC)?;
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            output.write_raw_tag_bytes(&[26])?;
            output.write_message(options)?;
        }
        self.reserved_range.write_to(output, &ENUM_DESCRIPTOR_PROTO_RESERVED_RANGE_CODEC)?;
        self.reserved_name.write_to(output, &ENUM_DESCRIPTOR_PROTO_RESERVED_NAME_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::EnumDescriptorProto {
    fn new() -> Self {
        Self {
            name: ::std::option::Option::None,
            value: crate::collections::RepeatedField::new(),
            options: ::std::option::Option::None,
            reserved_range: crate::collections::RepeatedField::new(),
            reserved_name: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
    fn merge(&mut self, other: &Self) {
        self.name = other.name.clone();
        self.value.merge(&other.value);
        if let ::std::option::Option::Some(options) = &other.options {
            self.options.get_or_insert_with(crate::LiteMessage::new).merge(options);
        }
        self.reserved_range.merge(&other.reserved_range);
        self.reserved_name.merge(&other.reserved_name);
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl crate::Message for self::EnumDescriptorProto {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[6]
    }
}
impl self::EnumDescriptorProto {
    /// Gets the field number of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub const NAME_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub const NAME_DEFAULT_VALUE: &'static str = "";
    pub fn name(&self) -> &str {
        &self.name.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::NAME_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn name_mut(&mut self) -> &mut ::std::string::String {
        self.name.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }
    /// Sets the value of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn set_name(&mut self, value: ::std::string::String) {
        self.name = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`name`] field, leaving it empty
    ///
    /// [`name`]: #method.name
    pub fn take_name(&mut self) -> ::std::option::Option<::std::string::String> {
        self.name.take()
    }
    /// Clears the value of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None
    }
    /// Gets the field number of the [`value`] field
    ///
    /// [`value`]: #method.value
    pub const VALUE_FIELD_NUMBER: i32 = 2;
    pub fn value(&self) -> &crate::collections::RepeatedField<self::EnumValueDescriptorProto> {
        &self.value
    }
    /// Returns a unique reference to the [`value`] field
    ///
    /// [`value`]: #method.value
    pub fn value_mut(&mut self) -> &mut crate::collections::RepeatedField<self::EnumValueDescriptorProto> {
        &mut self.value
    }
    /// Gets the field number of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub const OPTIONS_FIELD_NUMBER: i32 = 3;
    pub fn options(&self) -> ::std::option::Option<&self::EnumOptions> {
        self.options.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn options_mut(&mut self) -> &mut self::EnumOptions {
        self.options.get_or_insert_with(crate::LiteMessage::new)
    }
    /// Returns a bool indicating the presence of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }
    /// Sets the value of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn set_options(&mut self, value: self::EnumOptions) {
        self.options = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`options`] field, leaving it empty
    ///
    /// [`options`]: #method.options
    pub fn take_options(&mut self) -> ::std::option::Option<self::EnumOptions> {
        self.options.take().map(|b| *b)
    }
    /// Clears the value of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn clear_options(&mut self) {
        self.options = ::std::option::Option::None
    }
    /// Gets the field number of the [`reserved_range`] field
    ///
    /// [`reserved_range`]: #method.reserved_range
    pub const RESERVED_RANGE_FIELD_NUMBER: i32 = 4;
    /// Range of reserved numeric values. Reserved numeric values may not be used
    /// by enum values in the same enum declaration. Reserved ranges may not
    /// overlap.
    pub fn reserved_range(&self) -> &crate::collections::RepeatedField<self::EnumDescriptorProto_EnumReservedRange> {
        &self.reserved_range
    }
    /// Returns a unique reference to the [`reserved_range`] field
    ///
    /// [`reserved_range`]: #method.reserved_range
    pub fn reserved_range_mut(&mut self) -> &mut crate::collections::RepeatedField<self::EnumDescriptorProto_EnumReservedRange> {
        &mut self.reserved_range
    }
    /// Gets the field number of the [`reserved_name`] field
    ///
    /// [`reserved_name`]: #method.reserved_name
    pub const RESERVED_NAME_FIELD_NUMBER: i32 = 5;
    /// Reserved enum value names, which may not be reused. A given name may only
    /// be reserved once.
    pub fn reserved_name(&self) -> &crate::collections::RepeatedField<::std::string::String> {
        &self.reserved_name
    }
    /// Returns a unique reference to the [`reserved_name`] field
    ///
    /// [`reserved_name`]: #method.reserved_name
    pub fn reserved_name_mut(&mut self) -> &mut crate::collections::RepeatedField<::std::string::String> {
        &mut self.reserved_name
    }
}
/// Range of reserved numeric values. Reserved values may not be used by
/// entries in the same enum. Reserved ranges may not overlap.
///
/// Note that this is distinct from DescriptorProto.ReservedRange in that it
/// is inclusive such that it can appropriately represent the entire int32
/// domain.
#[derive(Clone, Debug, PartialEq)]
pub struct EnumDescriptorProto_EnumReservedRange {
    start: ::std::option::Option<i32>,
    end: ::std::option::Option<i32>,
    unknown_fields: crate::UnknownFieldSet
}
impl crate::CodedMessage for self::EnumDescriptorProto_EnumReservedRange {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 => self.start = ::std::option::Option::Some(input.read_int32()?),
                16 => self.end = ::std::option::Option::Some(input.read_int32()?),
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let start = self.start;
        if let ::std::option::Option::Some(start) = start {
            if start != Self::START_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::int32(start);
            }
        }
        let end = self.end;
        if let ::std::option::Option::Some(end) = end {
            if end != Self::END_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::int32(end);
            }
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let start = self.start;
        if let ::std::option::Option::Some(start) = start {
            if start != Self::START_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(start)?;
            }
        }
        let end = self.end;
        if let ::std::option::Option::Some(end) = end {
            if end != Self::END_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_int32(end)?;
            }
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::EnumDescriptorProto_EnumReservedRange {
    fn new() -> Self {
        Self {
            start: ::std::option::Option::None,
            end: ::std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
    fn merge(&mut self, other: &Self) {
        self.start = other.start;
        self.end = other.end;
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl crate::Message for self::EnumDescriptorProto_EnumReservedRange {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[6].messages()[0]
    }
}
impl self::EnumDescriptorProto_EnumReservedRange {
    /// Gets the field number of the [`start`] field
    ///
    /// [`start`]: #method.start
    pub const START_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`start`] field
    ///
    /// [`start`]: #method.start
    pub const START_DEFAULT_VALUE: i32 = 0;
    /// Inclusive.
    pub fn start(&self) -> i32 {
        self.start.unwrap_or(Self::START_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`start`] field
    ///
    /// [`start`]: #method.start
    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }
    /// Sets the value of the [`start`] field
    ///
    /// [`start`]: #method.start
    pub fn set_start(&mut self, value: i32) {
        self.start = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`start`] field
    ///
    /// [`start`]: #method.start
    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None
    }
    /// Gets the field number of the [`end`] field
    ///
    /// [`end`]: #method.end
    pub const END_FIELD_NUMBER: i32 = 2;
    /// A constant value representing the default value of the [`end`] field
    ///
    /// [`end`]: #method.end
    pub const END_DEFAULT_VALUE: i32 = 0;
    /// Inclusive.
    pub fn end(&self) -> i32 {
        self.end.unwrap_or(Self::END_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`end`] field
    ///
    /// [`end`]: #method.end
    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }
    /// Sets the value of the [`end`] field
    ///
    /// [`end`]: #method.end
    pub fn set_end(&mut self, value: i32) {
        self.end = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`end`] field
    ///
    /// [`end`]: #method.end
    pub fn clear_end(&mut self) {
        self.end = ::std::option::Option::None
    }
}
/// Describes a value within an enum.
#[derive(Clone, Debug, PartialEq)]
pub struct EnumValueDescriptorProto {
    name: ::std::option::Option<::std::string::String>,
    number: ::std::option::Option<i32>,
    options: ::std::option::Option<::std::boxed::Box<self::EnumValueOptions>>,
    unknown_fields: crate::UnknownFieldSet
}
impl crate::CodedMessage for self::EnumValueDescriptorProto {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.name = ::std::option::Option::Some(input.read_string()?),
                16 => self.number = ::std::option::Option::Some(input.read_int32()?),
                26 => input.read_message(self.options.get_or_insert_with(crate::LiteMessage::new))?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(name);
            }
        }
        let number = self.number;
        if let ::std::option::Option::Some(number) = number {
            if number != Self::NUMBER_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::int32(number);
            }
        }
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            size += 1;
            size += crate::io::sizes::message(options);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
        }
        let number = self.number;
        if let ::std::option::Option::Some(number) = number {
            if number != Self::NUMBER_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_int32(number)?;
            }
        }
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            output.write_raw_tag_bytes(&[26])?;
            output.write_message(options)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::EnumValueDescriptorProto {
    fn new() -> Self {
        Self {
            name: ::std::option::Option::None,
            number: ::std::option::Option::None,
            options: ::std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
    fn merge(&mut self, other: &Self) {
        self.name = other.name.clone();
        self.number = other.number;
        if let ::std::option::Option::Some(options) = &other.options {
            self.options.get_or_insert_with(crate::LiteMessage::new).merge(options);
        }
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl crate::Message for self::EnumValueDescriptorProto {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[7]
    }
}
impl self::EnumValueDescriptorProto {
    /// Gets the field number of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub const NAME_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub const NAME_DEFAULT_VALUE: &'static str = "";
    pub fn name(&self) -> &str {
        &self.name.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::NAME_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn name_mut(&mut self) -> &mut ::std::string::String {
        self.name.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }
    /// Sets the value of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn set_name(&mut self, value: ::std::string::String) {
        self.name = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`name`] field, leaving it empty
    ///
    /// [`name`]: #method.name
    pub fn take_name(&mut self) -> ::std::option::Option<::std::string::String> {
        self.name.take()
    }
    /// Clears the value of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None
    }
    /// Gets the field number of the [`number`] field
    ///
    /// [`number`]: #method.number
    pub const NUMBER_FIELD_NUMBER: i32 = 2;
    /// A constant value representing the default value of the [`number`] field
    ///
    /// [`number`]: #method.number
    pub const NUMBER_DEFAULT_VALUE: i32 = 0;
    pub fn number(&self) -> i32 {
        self.number.unwrap_or(Self::NUMBER_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`number`] field
    ///
    /// [`number`]: #method.number
    pub fn has_number(&self) -> bool {
        self.number.is_some()
    }
    /// Sets the value of the [`number`] field
    ///
    /// [`number`]: #method.number
    pub fn set_number(&mut self, value: i32) {
        self.number = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`number`] field
    ///
    /// [`number`]: #method.number
    pub fn clear_number(&mut self) {
        self.number = ::std::option::Option::None
    }
    /// Gets the field number of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub const OPTIONS_FIELD_NUMBER: i32 = 3;
    pub fn options(&self) -> ::std::option::Option<&self::EnumValueOptions> {
        self.options.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn options_mut(&mut self) -> &mut self::EnumValueOptions {
        self.options.get_or_insert_with(crate::LiteMessage::new)
    }
    /// Returns a bool indicating the presence of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }
    /// Sets the value of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn set_options(&mut self, value: self::EnumValueOptions) {
        self.options = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`options`] field, leaving it empty
    ///
    /// [`options`]: #method.options
    pub fn take_options(&mut self) -> ::std::option::Option<self::EnumValueOptions> {
        self.options.take().map(|b| *b)
    }
    /// Clears the value of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn clear_options(&mut self) {
        self.options = ::std::option::Option::None
    }
}
/// Describes a service.
#[derive(Clone, Debug, PartialEq)]
pub struct ServiceDescriptorProto {
    name: ::std::option::Option<::std::string::String>,
    method: crate::collections::RepeatedField<self::MethodDescriptorProto>,
    options: ::std::option::Option<::std::boxed::Box<self::ServiceOptions>>,
    unknown_fields: crate::UnknownFieldSet
}
static SERVICE_DESCRIPTOR_PROTO_METHOD_CODEC: crate::Codec<self::MethodDescriptorProto> = crate::Codec::message(18);
impl crate::CodedMessage for self::ServiceDescriptorProto {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.name = ::std::option::Option::Some(input.read_string()?),
                18 => self.method.add_entries(tag.get(), input, &SERVICE_DESCRIPTOR_PROTO_METHOD_CODEC)?,
                26 => input.read_message(self.options.get_or_insert_with(crate::LiteMessage::new))?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(name);
            }
        }
        size += self.method.calculate_size(&SERVICE_DESCRIPTOR_PROTO_METHOD_CODEC);
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            size += 1;
            size += crate::io::sizes::message(options);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
        }
        self.method.write_to(output, &SERVICE_DESCRIPTOR_PROTO_METHOD_CODEC)?;
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            output.write_raw_tag_bytes(&[26])?;
            output.write_message(options)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::ServiceDescriptorProto {
    fn new() -> Self {
        Self {
            name: ::std::option::Option::None,
            method: crate::collections::RepeatedField::new(),
            options: ::std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
    fn merge(&mut self, other: &Self) {
        self.name = other.name.clone();
        self.method.merge(&other.method);
        if let ::std::option::Option::Some(options) = &other.options {
            self.options.get_or_insert_with(crate::LiteMessage::new).merge(options);
        }
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl crate::Message for self::ServiceDescriptorProto {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[8]
    }
}
impl self::ServiceDescriptorProto {
    /// Gets the field number of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub const NAME_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub const NAME_DEFAULT_VALUE: &'static str = "";
    pub fn name(&self) -> &str {
        &self.name.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::NAME_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn name_mut(&mut self) -> &mut ::std::string::String {
        self.name.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }
    /// Sets the value of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn set_name(&mut self, value: ::std::string::String) {
        self.name = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`name`] field, leaving it empty
    ///
    /// [`name`]: #method.name
    pub fn take_name(&mut self) -> ::std::option::Option<::std::string::String> {
        self.name.take()
    }
    /// Clears the value of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None
    }
    /// Gets the field number of the [`method`] field
    ///
    /// [`method`]: #method.method
    pub const METHOD_FIELD_NUMBER: i32 = 2;
    pub fn method(&self) -> &crate::collections::RepeatedField<self::MethodDescriptorProto> {
        &self.method
    }
    /// Returns a unique reference to the [`method`] field
    ///
    /// [`method`]: #method.method
    pub fn method_mut(&mut self) -> &mut crate::collections::RepeatedField<self::MethodDescriptorProto> {
        &mut self.method
    }
    /// Gets the field number of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub const OPTIONS_FIELD_NUMBER: i32 = 3;
    pub fn options(&self) -> ::std::option::Option<&self::ServiceOptions> {
        self.options.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn options_mut(&mut self) -> &mut self::ServiceOptions {
        self.options.get_or_insert_with(crate::LiteMessage::new)
    }
    /// Returns a bool indicating the presence of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }
    /// Sets the value of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn set_options(&mut self, value: self::ServiceOptions) {
        self.options = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`options`] field, leaving it empty
    ///
    /// [`options`]: #method.options
    pub fn take_options(&mut self) -> ::std::option::Option<self::ServiceOptions> {
        self.options.take().map(|b| *b)
    }
    /// Clears the value of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn clear_options(&mut self) {
        self.options = ::std::option::Option::None
    }
}
/// Describes a method of a service.
#[derive(Clone, Debug, PartialEq)]
pub struct MethodDescriptorProto {
    name: ::std::option::Option<::std::string::String>,
    input_type: ::std::option::Option<::std::string::String>,
    output_type: ::std::option::Option<::std::string::String>,
    options: ::std::option::Option<::std::boxed::Box<self::MethodOptions>>,
    client_streaming: ::std::option::Option<bool>,
    server_streaming: ::std::option::Option<bool>,
    unknown_fields: crate::UnknownFieldSet
}
impl crate::CodedMessage for self::MethodDescriptorProto {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.name = ::std::option::Option::Some(input.read_string()?),
                18 => self.input_type = ::std::option::Option::Some(input.read_string()?),
                26 => self.output_type = ::std::option::Option::Some(input.read_string()?),
                34 => input.read_message(self.options.get_or_insert_with(crate::LiteMessage::new))?,
                40 => self.client_streaming = ::std::option::Option::Some(input.read_bool()?),
                48 => self.server_streaming = ::std::option::Option::Some(input.read_bool()?),
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(name);
            }
        }
        let input_type = &self.input_type;
        if let ::std::option::Option::Some(input_type) = input_type {
            if input_type != Self::INPUT_TYPE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(input_type);
            }
        }
        let output_type = &self.output_type;
        if let ::std::option::Option::Some(output_type) = output_type {
            if output_type != Self::OUTPUT_TYPE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(output_type);
            }
        }
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            size += 1;
            size += crate::io::sizes::message(options);
        }
        let client_streaming = self.client_streaming;
        if let ::std::option::Option::Some(client_streaming) = client_streaming {
            if client_streaming != Self::CLIENT_STREAMING_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(client_streaming);
            }
        }
        let server_streaming = self.server_streaming;
        if let ::std::option::Option::Some(server_streaming) = server_streaming {
            if server_streaming != Self::SERVER_STREAMING_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(server_streaming);
            }
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
        }
        let input_type = &self.input_type;
        if let ::std::option::Option::Some(input_type) = input_type {
            if input_type != Self::INPUT_TYPE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[18])?;
                output.write_string(input_type)?;
            }
        }
        let output_type = &self.output_type;
        if let ::std::option::Option::Some(output_type) = output_type {
            if output_type != Self::OUTPUT_TYPE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[26])?;
                output.write_string(output_type)?;
            }
        }
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            output.write_raw_tag_bytes(&[34])?;
            output.write_message(options)?;
        }
        let client_streaming = self.client_streaming;
        if let ::std::option::Option::Some(client_streaming) = client_streaming {
            if client_streaming != Self::CLIENT_STREAMING_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[40])?;
                output.write_bool(client_streaming)?;
            }
        }
        let server_streaming = self.server_streaming;
        if let ::std::option::Option::Some(server_streaming) = server_streaming {
            if server_streaming != Self::SERVER_STREAMING_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[48])?;
                output.write_bool(server_streaming)?;
            }
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::MethodDescriptorProto {
    fn new() -> Self {
        Self {
            name: ::std::option::Option::None,
            input_type: ::std::option::Option::None,
            output_type: ::std::option::Option::None,
            options: ::std::option::Option::None,
            client_streaming: ::std::option::Option::None,
            server_streaming: ::std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
    fn merge(&mut self, other: &Self) {
        self.name = other.name.clone();
        self.input_type = other.input_type.clone();
        self.output_type = other.output_type.clone();
        if let ::std::option::Option::Some(options) = &other.options {
            self.options.get_or_insert_with(crate::LiteMessage::new).merge(options);
        }
        self.client_streaming = other.client_streaming;
        self.server_streaming = other.server_streaming;
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl crate::Message for self::MethodDescriptorProto {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[9]
    }
}
impl self::MethodDescriptorProto {
    /// Gets the field number of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub const NAME_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub const NAME_DEFAULT_VALUE: &'static str = "";
    pub fn name(&self) -> &str {
        &self.name.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::NAME_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn name_mut(&mut self) -> &mut ::std::string::String {
        self.name.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }
    /// Sets the value of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn set_name(&mut self, value: ::std::string::String) {
        self.name = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`name`] field, leaving it empty
    ///
    /// [`name`]: #method.name
    pub fn take_name(&mut self) -> ::std::option::Option<::std::string::String> {
        self.name.take()
    }
    /// Clears the value of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None
    }
    /// Gets the field number of the [`input_type`] field
    ///
    /// [`input_type`]: #method.input_type
    pub const INPUT_TYPE_FIELD_NUMBER: i32 = 2;
    /// A constant value representing the default value of the [`input_type`] field
    ///
    /// [`input_type`]: #method.input_type
    pub const INPUT_TYPE_DEFAULT_VALUE: &'static str = "";
    /// Input and output type names.  These are resolved in the same way as
    /// FieldDescriptorProto.type_name, but must refer to a message type.
    pub fn input_type(&self) -> &str {
        &self.input_type.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::INPUT_TYPE_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`input_type`] field
    ///
    /// [`input_type`]: #method.input_type
    pub fn input_type_mut(&mut self) -> &mut ::std::string::String {
        self.input_type.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`input_type`] field
    ///
    /// [`input_type`]: #method.input_type
    pub fn has_input_type(&self) -> bool {
        self.input_type.is_some()
    }
    /// Sets the value of the [`input_type`] field
    ///
    /// [`input_type`]: #method.input_type
    pub fn set_input_type(&mut self, value: ::std::string::String) {
        self.input_type = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`input_type`] field, leaving it empty
    ///
    /// [`input_type`]: #method.input_type
    pub fn take_input_type(&mut self) -> ::std::option::Option<::std::string::String> {
        self.input_type.take()
    }
    /// Clears the value of the [`input_type`] field
    ///
    /// [`input_type`]: #method.input_type
    pub fn clear_input_type(&mut self) {
        self.input_type = ::std::option::Option::None
    }
    /// Gets the field number of the [`output_type`] field
    ///
    /// [`output_type`]: #method.output_type
    pub const OUTPUT_TYPE_FIELD_NUMBER: i32 = 3;
    /// A constant value representing the default value of the [`output_type`] field
    ///
    /// [`output_type`]: #method.output_type
    pub const OUTPUT_TYPE_DEFAULT_VALUE: &'static str = "";
    pub fn output_type(&self) -> &str {
        &self.output_type.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::OUTPUT_TYPE_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`output_type`] field
    ///
    /// [`output_type`]: #method.output_type
    pub fn output_type_mut(&mut self) -> &mut ::std::string::String {
        self.output_type.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`output_type`] field
    ///
    /// [`output_type`]: #method.output_type
    pub fn has_output_type(&self) -> bool {
        self.output_type.is_some()
    }
    /// Sets the value of the [`output_type`] field
    ///
    /// [`output_type`]: #method.output_type
    pub fn set_output_type(&mut self, value: ::std::string::String) {
        self.output_type = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`output_type`] field, leaving it empty
    ///
    /// [`output_type`]: #method.output_type
    pub fn take_output_type(&mut self) -> ::std::option::Option<::std::string::String> {
        self.output_type.take()
    }
    /// Clears the value of the [`output_type`] field
    ///
    /// [`output_type`]: #method.output_type
    pub fn clear_output_type(&mut self) {
        self.output_type = ::std::option::Option::None
    }
    /// Gets the field number of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub const OPTIONS_FIELD_NUMBER: i32 = 4;
    pub fn options(&self) -> ::std::option::Option<&self::MethodOptions> {
        self.options.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn options_mut(&mut self) -> &mut self::MethodOptions {
        self.options.get_or_insert_with(crate::LiteMessage::new)
    }
    /// Returns a bool indicating the presence of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }
    /// Sets the value of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn set_options(&mut self, value: self::MethodOptions) {
        self.options = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`options`] field, leaving it empty
    ///
    /// [`options`]: #method.options
    pub fn take_options(&mut self) -> ::std::option::Option<self::MethodOptions> {
        self.options.take().map(|b| *b)
    }
    /// Clears the value of the [`options`] field
    ///
    /// [`options`]: #method.options
    pub fn clear_options(&mut self) {
        self.options = ::std::option::Option::None
    }
    /// Gets the field number of the [`client_streaming`] field
    ///
    /// [`client_streaming`]: #method.client_streaming
    pub const CLIENT_STREAMING_FIELD_NUMBER: i32 = 5;
    /// A constant value representing the default value of the [`client_streaming`] field
    ///
    /// [`client_streaming`]: #method.client_streaming
    pub const CLIENT_STREAMING_DEFAULT_VALUE: bool = false;
    /// Identifies if client streams multiple client messages
    pub fn client_streaming(&self) -> bool {
        self.client_streaming.unwrap_or(Self::CLIENT_STREAMING_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`client_streaming`] field
    ///
    /// [`client_streaming`]: #method.client_streaming
    pub fn has_client_streaming(&self) -> bool {
        self.client_streaming.is_some()
    }
    /// Sets the value of the [`client_streaming`] field
    ///
    /// [`client_streaming`]: #method.client_streaming
    pub fn set_client_streaming(&mut self, value: bool) {
        self.client_streaming = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`client_streaming`] field
    ///
    /// [`client_streaming`]: #method.client_streaming
    pub fn clear_client_streaming(&mut self) {
        self.client_streaming = ::std::option::Option::None
    }
    /// Gets the field number of the [`server_streaming`] field
    ///
    /// [`server_streaming`]: #method.server_streaming
    pub const SERVER_STREAMING_FIELD_NUMBER: i32 = 6;
    /// A constant value representing the default value of the [`server_streaming`] field
    ///
    /// [`server_streaming`]: #method.server_streaming
    pub const SERVER_STREAMING_DEFAULT_VALUE: bool = false;
    /// Identifies if server streams multiple server messages
    pub fn server_streaming(&self) -> bool {
        self.server_streaming.unwrap_or(Self::SERVER_STREAMING_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`server_streaming`] field
    ///
    /// [`server_streaming`]: #method.server_streaming
    pub fn has_server_streaming(&self) -> bool {
        self.server_streaming.is_some()
    }
    /// Sets the value of the [`server_streaming`] field
    ///
    /// [`server_streaming`]: #method.server_streaming
    pub fn set_server_streaming(&mut self, value: bool) {
        self.server_streaming = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`server_streaming`] field
    ///
    /// [`server_streaming`]: #method.server_streaming
    pub fn clear_server_streaming(&mut self) {
        self.server_streaming = ::std::option::Option::None
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct FileOptions {
    java_package: ::std::option::Option<::std::string::String>,
    java_outer_classname: ::std::option::Option<::std::string::String>,
    java_multiple_files: ::std::option::Option<bool>,
    java_generate_equals_and_hash: ::std::option::Option<bool>,
    java_string_check_utf8: ::std::option::Option<bool>,
    optimize_for: ::std::option::Option<crate::EnumValue<self::FileOptions_OptimizeMode>>,
    go_package: ::std::option::Option<::std::string::String>,
    cc_generic_services: ::std::option::Option<bool>,
    java_generic_services: ::std::option::Option<bool>,
    py_generic_services: ::std::option::Option<bool>,
    php_generic_services: ::std::option::Option<bool>,
    deprecated: ::std::option::Option<bool>,
    cc_enable_arenas: ::std::option::Option<bool>,
    objc_class_prefix: ::std::option::Option<::std::string::String>,
    csharp_namespace: ::std::option::Option<::std::string::String>,
    swift_prefix: ::std::option::Option<::std::string::String>,
    php_class_prefix: ::std::option::Option<::std::string::String>,
    php_namespace: ::std::option::Option<::std::string::String>,
    php_metadata_namespace: ::std::option::Option<::std::string::String>,
    ruby_package: ::std::option::Option<::std::string::String>,
    uninterpreted_option: crate::collections::RepeatedField<self::UninterpretedOption>,
    unknown_fields: crate::UnknownFieldSet
}
static FILE_OPTIONS_UNINTERPRETED_OPTION_CODEC: crate::Codec<self::UninterpretedOption> = crate::Codec::message(7994);
impl crate::CodedMessage for self::FileOptions {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.java_package = ::std::option::Option::Some(input.read_string()?),
                66 => self.java_outer_classname = ::std::option::Option::Some(input.read_string()?),
                80 => self.java_multiple_files = ::std::option::Option::Some(input.read_bool()?),
                160 => self.java_generate_equals_and_hash = ::std::option::Option::Some(input.read_bool()?),
                216 => self.java_string_check_utf8 = ::std::option::Option::Some(input.read_bool()?),
                72 => self.optimize_for = ::std::option::Option::Some(input.read_enum_value()?),
                90 => self.go_package = ::std::option::Option::Some(input.read_string()?),
                128 => self.cc_generic_services = ::std::option::Option::Some(input.read_bool()?),
                136 => self.java_generic_services = ::std::option::Option::Some(input.read_bool()?),
                144 => self.py_generic_services = ::std::option::Option::Some(input.read_bool()?),
                336 => self.php_generic_services = ::std::option::Option::Some(input.read_bool()?),
                184 => self.deprecated = ::std::option::Option::Some(input.read_bool()?),
                248 => self.cc_enable_arenas = ::std::option::Option::Some(input.read_bool()?),
                290 => self.objc_class_prefix = ::std::option::Option::Some(input.read_string()?),
                298 => self.csharp_namespace = ::std::option::Option::Some(input.read_string()?),
                314 => self.swift_prefix = ::std::option::Option::Some(input.read_string()?),
                322 => self.php_class_prefix = ::std::option::Option::Some(input.read_string()?),
                330 => self.php_namespace = ::std::option::Option::Some(input.read_string()?),
                354 => self.php_metadata_namespace = ::std::option::Option::Some(input.read_string()?),
                362 => self.ruby_package = ::std::option::Option::Some(input.read_string()?),
                7994 => self.uninterpreted_option.add_entries(tag.get(), input, &FILE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let java_package = &self.java_package;
        if let ::std::option::Option::Some(java_package) = java_package {
            if java_package != Self::JAVA_PACKAGE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(java_package);
            }
        }
        let java_outer_classname = &self.java_outer_classname;
        if let ::std::option::Option::Some(java_outer_classname) = java_outer_classname {
            if java_outer_classname != Self::JAVA_OUTER_CLASSNAME_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(java_outer_classname);
            }
        }
        let java_multiple_files = self.java_multiple_files;
        if let ::std::option::Option::Some(java_multiple_files) = java_multiple_files {
            if java_multiple_files != Self::JAVA_MULTIPLE_FILES_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(java_multiple_files);
            }
        }
        let java_generate_equals_and_hash = self.java_generate_equals_and_hash;
        if let ::std::option::Option::Some(java_generate_equals_and_hash) = java_generate_equals_and_hash {
            if java_generate_equals_and_hash != Self::JAVA_GENERATE_EQUALS_AND_HASH_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::bool(java_generate_equals_and_hash);
            }
        }
        let java_string_check_utf8 = self.java_string_check_utf8;
        if let ::std::option::Option::Some(java_string_check_utf8) = java_string_check_utf8 {
            if java_string_check_utf8 != Self::JAVA_STRING_CHECK_UTF8_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::bool(java_string_check_utf8);
            }
        }
        let optimize_for = self.optimize_for;
        if let ::std::option::Option::Some(optimize_for) = optimize_for {
            if optimize_for != Self::OPTIMIZE_FOR_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::enum_value(optimize_for);
            }
        }
        let go_package = &self.go_package;
        if let ::std::option::Option::Some(go_package) = go_package {
            if go_package != Self::GO_PACKAGE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(go_package);
            }
        }
        let cc_generic_services = self.cc_generic_services;
        if let ::std::option::Option::Some(cc_generic_services) = cc_generic_services {
            if cc_generic_services != Self::CC_GENERIC_SERVICES_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::bool(cc_generic_services);
            }
        }
        let java_generic_services = self.java_generic_services;
        if let ::std::option::Option::Some(java_generic_services) = java_generic_services {
            if java_generic_services != Self::JAVA_GENERIC_SERVICES_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::bool(java_generic_services);
            }
        }
        let py_generic_services = self.py_generic_services;
        if let ::std::option::Option::Some(py_generic_services) = py_generic_services {
            if py_generic_services != Self::PY_GENERIC_SERVICES_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::bool(py_generic_services);
            }
        }
        let php_generic_services = self.php_generic_services;
        if let ::std::option::Option::Some(php_generic_services) = php_generic_services {
            if php_generic_services != Self::PHP_GENERIC_SERVICES_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::bool(php_generic_services);
            }
        }
        let deprecated = self.deprecated;
        if let ::std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::bool(deprecated);
            }
        }
        let cc_enable_arenas = self.cc_enable_arenas;
        if let ::std::option::Option::Some(cc_enable_arenas) = cc_enable_arenas {
            if cc_enable_arenas != Self::CC_ENABLE_ARENAS_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::bool(cc_enable_arenas);
            }
        }
        let objc_class_prefix = &self.objc_class_prefix;
        if let ::std::option::Option::Some(objc_class_prefix) = objc_class_prefix {
            if objc_class_prefix != Self::OBJC_CLASS_PREFIX_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::string(objc_class_prefix);
            }
        }
        let csharp_namespace = &self.csharp_namespace;
        if let ::std::option::Option::Some(csharp_namespace) = csharp_namespace {
            if csharp_namespace != Self::CSHARP_NAMESPACE_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::string(csharp_namespace);
            }
        }
        let swift_prefix = &self.swift_prefix;
        if let ::std::option::Option::Some(swift_prefix) = swift_prefix {
            if swift_prefix != Self::SWIFT_PREFIX_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::string(swift_prefix);
            }
        }
        let php_class_prefix = &self.php_class_prefix;
        if let ::std::option::Option::Some(php_class_prefix) = php_class_prefix {
            if php_class_prefix != Self::PHP_CLASS_PREFIX_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::string(php_class_prefix);
            }
        }
        let php_namespace = &self.php_namespace;
        if let ::std::option::Option::Some(php_namespace) = php_namespace {
            if php_namespace != Self::PHP_NAMESPACE_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::string(php_namespace);
            }
        }
        let php_metadata_namespace = &self.php_metadata_namespace;
        if let ::std::option::Option::Some(php_metadata_namespace) = php_metadata_namespace {
            if php_metadata_namespace != Self::PHP_METADATA_NAMESPACE_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::string(php_metadata_namespace);
            }
        }
        let ruby_package = &self.ruby_package;
        if let ::std::option::Option::Some(ruby_package) = ruby_package {
            if ruby_package != Self::RUBY_PACKAGE_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::string(ruby_package);
            }
        }
        size += self.uninterpreted_option.calculate_size(&FILE_OPTIONS_UNINTERPRETED_OPTION_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let java_package = &self.java_package;
        if let ::std::option::Option::Some(java_package) = java_package {
            if java_package != Self::JAVA_PACKAGE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(java_package)?;
            }
        }
        let java_outer_classname = &self.java_outer_classname;
        if let ::std::option::Option::Some(java_outer_classname) = java_outer_classname {
            if java_outer_classname != Self::JAVA_OUTER_CLASSNAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[66])?;
                output.write_string(java_outer_classname)?;
            }
        }
        let java_multiple_files = self.java_multiple_files;
        if let ::std::option::Option::Some(java_multiple_files) = java_multiple_files {
            if java_multiple_files != Self::JAVA_MULTIPLE_FILES_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[80])?;
                output.write_bool(java_multiple_files)?;
            }
        }
        let java_generate_equals_and_hash = self.java_generate_equals_and_hash;
        if let ::std::option::Option::Some(java_generate_equals_and_hash) = java_generate_equals_and_hash {
            if java_generate_equals_and_hash != Self::JAVA_GENERATE_EQUALS_AND_HASH_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[160, 1])?;
                output.write_bool(java_generate_equals_and_hash)?;
            }
        }
        let java_string_check_utf8 = self.java_string_check_utf8;
        if let ::std::option::Option::Some(java_string_check_utf8) = java_string_check_utf8 {
            if java_string_check_utf8 != Self::JAVA_STRING_CHECK_UTF8_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[216, 1])?;
                output.write_bool(java_string_check_utf8)?;
            }
        }
        let optimize_for = self.optimize_for;
        if let ::std::option::Option::Some(optimize_for) = optimize_for {
            if optimize_for != Self::OPTIMIZE_FOR_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[72])?;
                output.write_enum_value(optimize_for)?;
            }
        }
        let go_package = &self.go_package;
        if let ::std::option::Option::Some(go_package) = go_package {
            if go_package != Self::GO_PACKAGE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[90])?;
                output.write_string(go_package)?;
            }
        }
        let cc_generic_services = self.cc_generic_services;
        if let ::std::option::Option::Some(cc_generic_services) = cc_generic_services {
            if cc_generic_services != Self::CC_GENERIC_SERVICES_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[128, 1])?;
                output.write_bool(cc_generic_services)?;
            }
        }
        let java_generic_services = self.java_generic_services;
        if let ::std::option::Option::Some(java_generic_services) = java_generic_services {
            if java_generic_services != Self::JAVA_GENERIC_SERVICES_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[136, 1])?;
                output.write_bool(java_generic_services)?;
            }
        }
        let py_generic_services = self.py_generic_services;
        if let ::std::option::Option::Some(py_generic_services) = py_generic_services {
            if py_generic_services != Self::PY_GENERIC_SERVICES_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[144, 1])?;
                output.write_bool(py_generic_services)?;
            }
        }
        let php_generic_services = self.php_generic_services;
        if let ::std::option::Option::Some(php_generic_services) = php_generic_services {
            if php_generic_services != Self::PHP_GENERIC_SERVICES_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[208, 2])?;
                output.write_bool(php_generic_services)?;
            }
        }
        let deprecated = self.deprecated;
        if let ::std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[184, 1])?;
                output.write_bool(deprecated)?;
            }
        }
        let cc_enable_arenas = self.cc_enable_arenas;
        if let ::std::option::Option::Some(cc_enable_arenas) = cc_enable_arenas {
            if cc_enable_arenas != Self::CC_ENABLE_ARENAS_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[248, 1])?;
                output.write_bool(cc_enable_arenas)?;
            }
        }
        let objc_class_prefix = &self.objc_class_prefix;
        if let ::std::option::Option::Some(objc_class_prefix) = objc_class_prefix {
            if objc_class_prefix != Self::OBJC_CLASS_PREFIX_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[162, 2])?;
                output.write_string(objc_class_prefix)?;
            }
        }
        let csharp_namespace = &self.csharp_namespace;
        if let ::std::option::Option::Some(csharp_namespace) = csharp_namespace {
            if csharp_namespace != Self::CSHARP_NAMESPACE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[170, 2])?;
                output.write_string(csharp_namespace)?;
            }
        }
        let swift_prefix = &self.swift_prefix;
        if let ::std::option::Option::Some(swift_prefix) = swift_prefix {
            if swift_prefix != Self::SWIFT_PREFIX_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[186, 2])?;
                output.write_string(swift_prefix)?;
            }
        }
        let php_class_prefix = &self.php_class_prefix;
        if let ::std::option::Option::Some(php_class_prefix) = php_class_prefix {
            if php_class_prefix != Self::PHP_CLASS_PREFIX_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[194, 2])?;
                output.write_string(php_class_prefix)?;
            }
        }
        let php_namespace = &self.php_namespace;
        if let ::std::option::Option::Some(php_namespace) = php_namespace {
            if php_namespace != Self::PHP_NAMESPACE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[202, 2])?;
                output.write_string(php_namespace)?;
            }
        }
        let php_metadata_namespace = &self.php_metadata_namespace;
        if let ::std::option::Option::Some(php_metadata_namespace) = php_metadata_namespace {
            if php_metadata_namespace != Self::PHP_METADATA_NAMESPACE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[226, 2])?;
                output.write_string(php_metadata_namespace)?;
            }
        }
        let ruby_package = &self.ruby_package;
        if let ::std::option::Option::Some(ruby_package) = ruby_package {
            if ruby_package != Self::RUBY_PACKAGE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[234, 2])?;
                output.write_string(ruby_package)?;
            }
        }
        self.uninterpreted_option.write_to(output, &FILE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::FileOptions {
    fn new() -> Self {
        Self {
            java_package: ::std::option::Option::None,
            java_outer_classname: ::std::option::Option::None,
            java_multiple_files: ::std::option::Option::None,
            java_generate_equals_and_hash: ::std::option::Option::None,
            java_string_check_utf8: ::std::option::Option::None,
            optimize_for: ::std::option::Option::None,
            go_package: ::std::option::Option::None,
            cc_generic_services: ::std::option::Option::None,
            java_generic_services: ::std::option::Option::None,
            py_generic_services: ::std::option::Option::None,
            php_generic_services: ::std::option::Option::None,
            deprecated: ::std::option::Option::None,
            cc_enable_arenas: ::std::option::Option::None,
            objc_class_prefix: ::std::option::Option::None,
            csharp_namespace: ::std::option::Option::None,
            swift_prefix: ::std::option::Option::None,
            php_class_prefix: ::std::option::Option::None,
            php_namespace: ::std::option::Option::None,
            php_metadata_namespace: ::std::option::Option::None,
            ruby_package: ::std::option::Option::None,
            uninterpreted_option: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
    fn merge(&mut self, other: &Self) {
        self.java_package = other.java_package.clone();
        self.java_outer_classname = other.java_outer_classname.clone();
        self.java_multiple_files = other.java_multiple_files;
        self.java_generate_equals_and_hash = other.java_generate_equals_and_hash;
        self.java_string_check_utf8 = other.java_string_check_utf8;
        self.optimize_for = other.optimize_for;
        self.go_package = other.go_package.clone();
        self.cc_generic_services = other.cc_generic_services;
        self.java_generic_services = other.java_generic_services;
        self.py_generic_services = other.py_generic_services;
        self.php_generic_services = other.php_generic_services;
        self.deprecated = other.deprecated;
        self.cc_enable_arenas = other.cc_enable_arenas;
        self.objc_class_prefix = other.objc_class_prefix.clone();
        self.csharp_namespace = other.csharp_namespace.clone();
        self.swift_prefix = other.swift_prefix.clone();
        self.php_class_prefix = other.php_class_prefix.clone();
        self.php_namespace = other.php_namespace.clone();
        self.php_metadata_namespace = other.php_metadata_namespace.clone();
        self.ruby_package = other.ruby_package.clone();
        self.uninterpreted_option.merge(&other.uninterpreted_option);
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl crate::Message for self::FileOptions {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[10]
    }
}
impl self::FileOptions {
    /// Gets the field number of the [`java_package`] field
    ///
    /// [`java_package`]: #method.java_package
    pub const JAVA_PACKAGE_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`java_package`] field
    ///
    /// [`java_package`]: #method.java_package
    pub const JAVA_PACKAGE_DEFAULT_VALUE: &'static str = "";
    /// Sets the Java package where classes generated from this .proto will be
    /// placed.  By default, the proto package is used, but this is often
    /// inappropriate because proto packages do not normally start with backwards
    /// domain names.
    pub fn java_package(&self) -> &str {
        &self.java_package.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::JAVA_PACKAGE_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`java_package`] field
    ///
    /// [`java_package`]: #method.java_package
    pub fn java_package_mut(&mut self) -> &mut ::std::string::String {
        self.java_package.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`java_package`] field
    ///
    /// [`java_package`]: #method.java_package
    pub fn has_java_package(&self) -> bool {
        self.java_package.is_some()
    }
    /// Sets the value of the [`java_package`] field
    ///
    /// [`java_package`]: #method.java_package
    pub fn set_java_package(&mut self, value: ::std::string::String) {
        self.java_package = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`java_package`] field, leaving it empty
    ///
    /// [`java_package`]: #method.java_package
    pub fn take_java_package(&mut self) -> ::std::option::Option<::std::string::String> {
        self.java_package.take()
    }
    /// Clears the value of the [`java_package`] field
    ///
    /// [`java_package`]: #method.java_package
    pub fn clear_java_package(&mut self) {
        self.java_package = ::std::option::Option::None
    }
    /// Gets the field number of the [`java_outer_classname`] field
    ///
    /// [`java_outer_classname`]: #method.java_outer_classname
    pub const JAVA_OUTER_CLASSNAME_FIELD_NUMBER: i32 = 8;
    /// A constant value representing the default value of the [`java_outer_classname`] field
    ///
    /// [`java_outer_classname`]: #method.java_outer_classname
    pub const JAVA_OUTER_CLASSNAME_DEFAULT_VALUE: &'static str = "";
    /// If set, all the classes from the .proto file are wrapped in a single
    /// outer class with the given name.  This applies to both Proto1
    /// (equivalent to the old "--one_java_file" option) and Proto2 (where
    /// a .proto always translates to a single class, but you may want to
    /// explicitly choose the class name).
    pub fn java_outer_classname(&self) -> &str {
        &self.java_outer_classname.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::JAVA_OUTER_CLASSNAME_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`java_outer_classname`] field
    ///
    /// [`java_outer_classname`]: #method.java_outer_classname
    pub fn java_outer_classname_mut(&mut self) -> &mut ::std::string::String {
        self.java_outer_classname.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`java_outer_classname`] field
    ///
    /// [`java_outer_classname`]: #method.java_outer_classname
    pub fn has_java_outer_classname(&self) -> bool {
        self.java_outer_classname.is_some()
    }
    /// Sets the value of the [`java_outer_classname`] field
    ///
    /// [`java_outer_classname`]: #method.java_outer_classname
    pub fn set_java_outer_classname(&mut self, value: ::std::string::String) {
        self.java_outer_classname = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`java_outer_classname`] field, leaving it empty
    ///
    /// [`java_outer_classname`]: #method.java_outer_classname
    pub fn take_java_outer_classname(&mut self) -> ::std::option::Option<::std::string::String> {
        self.java_outer_classname.take()
    }
    /// Clears the value of the [`java_outer_classname`] field
    ///
    /// [`java_outer_classname`]: #method.java_outer_classname
    pub fn clear_java_outer_classname(&mut self) {
        self.java_outer_classname = ::std::option::Option::None
    }
    /// Gets the field number of the [`java_multiple_files`] field
    ///
    /// [`java_multiple_files`]: #method.java_multiple_files
    pub const JAVA_MULTIPLE_FILES_FIELD_NUMBER: i32 = 10;
    /// A constant value representing the default value of the [`java_multiple_files`] field
    ///
    /// [`java_multiple_files`]: #method.java_multiple_files
    pub const JAVA_MULTIPLE_FILES_DEFAULT_VALUE: bool = false;
    /// If set true, then the Java code generator will generate a separate .java
    /// file for each top-level message, enum, and service defined in the .proto
    /// file.  Thus, these types will *not* be nested inside the outer class
    /// named by java_outer_classname.  However, the outer class will still be
    /// generated to contain the file's getDescriptor() method as well as any
    /// top-level extensions defined in the file.
    pub fn java_multiple_files(&self) -> bool {
        self.java_multiple_files.unwrap_or(Self::JAVA_MULTIPLE_FILES_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`java_multiple_files`] field
    ///
    /// [`java_multiple_files`]: #method.java_multiple_files
    pub fn has_java_multiple_files(&self) -> bool {
        self.java_multiple_files.is_some()
    }
    /// Sets the value of the [`java_multiple_files`] field
    ///
    /// [`java_multiple_files`]: #method.java_multiple_files
    pub fn set_java_multiple_files(&mut self, value: bool) {
        self.java_multiple_files = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`java_multiple_files`] field
    ///
    /// [`java_multiple_files`]: #method.java_multiple_files
    pub fn clear_java_multiple_files(&mut self) {
        self.java_multiple_files = ::std::option::Option::None
    }
    /// Gets the field number of the [`java_generate_equals_and_hash`] field
    ///
    /// [`java_generate_equals_and_hash`]: #method.java_generate_equals_and_hash
    pub const JAVA_GENERATE_EQUALS_AND_HASH_FIELD_NUMBER: i32 = 20;
    /// A constant value representing the default value of the [`java_generate_equals_and_hash`] field
    ///
    /// [`java_generate_equals_and_hash`]: #method.java_generate_equals_and_hash
    pub const JAVA_GENERATE_EQUALS_AND_HASH_DEFAULT_VALUE: bool = false;
    /// This option does nothing.
    pub fn java_generate_equals_and_hash(&self) -> bool {
        self.java_generate_equals_and_hash.unwrap_or(Self::JAVA_GENERATE_EQUALS_AND_HASH_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`java_generate_equals_and_hash`] field
    ///
    /// [`java_generate_equals_and_hash`]: #method.java_generate_equals_and_hash
    pub fn has_java_generate_equals_and_hash(&self) -> bool {
        self.java_generate_equals_and_hash.is_some()
    }
    /// Sets the value of the [`java_generate_equals_and_hash`] field
    ///
    /// [`java_generate_equals_and_hash`]: #method.java_generate_equals_and_hash
    pub fn set_java_generate_equals_and_hash(&mut self, value: bool) {
        self.java_generate_equals_and_hash = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`java_generate_equals_and_hash`] field
    ///
    /// [`java_generate_equals_and_hash`]: #method.java_generate_equals_and_hash
    pub fn clear_java_generate_equals_and_hash(&mut self) {
        self.java_generate_equals_and_hash = ::std::option::Option::None
    }
    /// Gets the field number of the [`java_string_check_utf8`] field
    ///
    /// [`java_string_check_utf8`]: #method.java_string_check_utf8
    pub const JAVA_STRING_CHECK_UTF8_FIELD_NUMBER: i32 = 27;
    /// A constant value representing the default value of the [`java_string_check_utf8`] field
    ///
    /// [`java_string_check_utf8`]: #method.java_string_check_utf8
    pub const JAVA_STRING_CHECK_UTF8_DEFAULT_VALUE: bool = false;
    /// If set true, then the Java2 code generator will generate code that
    /// throws an exception whenever an attempt is made to assign a non-UTF-8
    /// byte sequence to a string field.
    /// Message reflection will do the same.
    /// However, an extension field still accepts non-UTF-8 byte sequences.
    /// This option has no effect on when used with the lite runtime.
    pub fn java_string_check_utf8(&self) -> bool {
        self.java_string_check_utf8.unwrap_or(Self::JAVA_STRING_CHECK_UTF8_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`java_string_check_utf8`] field
    ///
    /// [`java_string_check_utf8`]: #method.java_string_check_utf8
    pub fn has_java_string_check_utf8(&self) -> bool {
        self.java_string_check_utf8.is_some()
    }
    /// Sets the value of the [`java_string_check_utf8`] field
    ///
    /// [`java_string_check_utf8`]: #method.java_string_check_utf8
    pub fn set_java_string_check_utf8(&mut self, value: bool) {
        self.java_string_check_utf8 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`java_string_check_utf8`] field
    ///
    /// [`java_string_check_utf8`]: #method.java_string_check_utf8
    pub fn clear_java_string_check_utf8(&mut self) {
        self.java_string_check_utf8 = ::std::option::Option::None
    }
    /// Gets the field number of the [`optimize_for`] field
    ///
    /// [`optimize_for`]: #method.optimize_for
    pub const OPTIMIZE_FOR_FIELD_NUMBER: i32 = 9;
    /// A constant value representing the default value of the [`optimize_for`] field
    ///
    /// [`optimize_for`]: #method.optimize_for
    pub const OPTIMIZE_FOR_DEFAULT_VALUE: crate::EnumValue<self::FileOptions_OptimizeMode> = crate::EnumValue::Defined(self::FileOptions_OptimizeMode::Speed);
    pub fn optimize_for(&self) -> crate::EnumValue<self::FileOptions_OptimizeMode> {
        self.optimize_for.unwrap_or(Self::OPTIMIZE_FOR_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`optimize_for`] field
    ///
    /// [`optimize_for`]: #method.optimize_for
    pub fn has_optimize_for(&self) -> bool {
        self.optimize_for.is_some()
    }
    /// Sets the value of the [`optimize_for`] field
    ///
    /// [`optimize_for`]: #method.optimize_for
    pub fn set_optimize_for(&mut self, value: crate::EnumValue<self::FileOptions_OptimizeMode>) {
        self.optimize_for = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`optimize_for`] field
    ///
    /// [`optimize_for`]: #method.optimize_for
    pub fn clear_optimize_for(&mut self) {
        self.optimize_for = ::std::option::Option::None
    }
    /// Gets the field number of the [`go_package`] field
    ///
    /// [`go_package`]: #method.go_package
    pub const GO_PACKAGE_FIELD_NUMBER: i32 = 11;
    /// A constant value representing the default value of the [`go_package`] field
    ///
    /// [`go_package`]: #method.go_package
    pub const GO_PACKAGE_DEFAULT_VALUE: &'static str = "";
    /// Sets the Go package where structs generated from this .proto will be
    /// placed. If omitted, the Go package will be derived from the following:
    ///   - The basename of the package import path, if provided.
    ///   - Otherwise, the package statement in the .proto file, if present.
    ///   - Otherwise, the basename of the .proto file, without extension.
    pub fn go_package(&self) -> &str {
        &self.go_package.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::GO_PACKAGE_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`go_package`] field
    ///
    /// [`go_package`]: #method.go_package
    pub fn go_package_mut(&mut self) -> &mut ::std::string::String {
        self.go_package.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`go_package`] field
    ///
    /// [`go_package`]: #method.go_package
    pub fn has_go_package(&self) -> bool {
        self.go_package.is_some()
    }
    /// Sets the value of the [`go_package`] field
    ///
    /// [`go_package`]: #method.go_package
    pub fn set_go_package(&mut self, value: ::std::string::String) {
        self.go_package = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`go_package`] field, leaving it empty
    ///
    /// [`go_package`]: #method.go_package
    pub fn take_go_package(&mut self) -> ::std::option::Option<::std::string::String> {
        self.go_package.take()
    }
    /// Clears the value of the [`go_package`] field
    ///
    /// [`go_package`]: #method.go_package
    pub fn clear_go_package(&mut self) {
        self.go_package = ::std::option::Option::None
    }
    /// Gets the field number of the [`cc_generic_services`] field
    ///
    /// [`cc_generic_services`]: #method.cc_generic_services
    pub const CC_GENERIC_SERVICES_FIELD_NUMBER: i32 = 16;
    /// A constant value representing the default value of the [`cc_generic_services`] field
    ///
    /// [`cc_generic_services`]: #method.cc_generic_services
    pub const CC_GENERIC_SERVICES_DEFAULT_VALUE: bool = false;
    /// Should generic services be generated in each language?  "Generic" services
    /// are not specific to any particular RPC system.  They are generated by the
    /// main code generators in each language (without additional plugins).
    /// Generic services were the only kind of service generation supported by
    /// early versions of google.protobuf.
    ///
    /// Generic services are now considered deprecated in favor of using plugins
    /// that generate code specific to your particular RPC system.  Therefore,
    /// these default to false.  Old code which depends on generic services should
    /// explicitly set them to true.
    pub fn cc_generic_services(&self) -> bool {
        self.cc_generic_services.unwrap_or(Self::CC_GENERIC_SERVICES_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`cc_generic_services`] field
    ///
    /// [`cc_generic_services`]: #method.cc_generic_services
    pub fn has_cc_generic_services(&self) -> bool {
        self.cc_generic_services.is_some()
    }
    /// Sets the value of the [`cc_generic_services`] field
    ///
    /// [`cc_generic_services`]: #method.cc_generic_services
    pub fn set_cc_generic_services(&mut self, value: bool) {
        self.cc_generic_services = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`cc_generic_services`] field
    ///
    /// [`cc_generic_services`]: #method.cc_generic_services
    pub fn clear_cc_generic_services(&mut self) {
        self.cc_generic_services = ::std::option::Option::None
    }
    /// Gets the field number of the [`java_generic_services`] field
    ///
    /// [`java_generic_services`]: #method.java_generic_services
    pub const JAVA_GENERIC_SERVICES_FIELD_NUMBER: i32 = 17;
    /// A constant value representing the default value of the [`java_generic_services`] field
    ///
    /// [`java_generic_services`]: #method.java_generic_services
    pub const JAVA_GENERIC_SERVICES_DEFAULT_VALUE: bool = false;
    pub fn java_generic_services(&self) -> bool {
        self.java_generic_services.unwrap_or(Self::JAVA_GENERIC_SERVICES_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`java_generic_services`] field
    ///
    /// [`java_generic_services`]: #method.java_generic_services
    pub fn has_java_generic_services(&self) -> bool {
        self.java_generic_services.is_some()
    }
    /// Sets the value of the [`java_generic_services`] field
    ///
    /// [`java_generic_services`]: #method.java_generic_services
    pub fn set_java_generic_services(&mut self, value: bool) {
        self.java_generic_services = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`java_generic_services`] field
    ///
    /// [`java_generic_services`]: #method.java_generic_services
    pub fn clear_java_generic_services(&mut self) {
        self.java_generic_services = ::std::option::Option::None
    }
    /// Gets the field number of the [`py_generic_services`] field
    ///
    /// [`py_generic_services`]: #method.py_generic_services
    pub const PY_GENERIC_SERVICES_FIELD_NUMBER: i32 = 18;
    /// A constant value representing the default value of the [`py_generic_services`] field
    ///
    /// [`py_generic_services`]: #method.py_generic_services
    pub const PY_GENERIC_SERVICES_DEFAULT_VALUE: bool = false;
    pub fn py_generic_services(&self) -> bool {
        self.py_generic_services.unwrap_or(Self::PY_GENERIC_SERVICES_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`py_generic_services`] field
    ///
    /// [`py_generic_services`]: #method.py_generic_services
    pub fn has_py_generic_services(&self) -> bool {
        self.py_generic_services.is_some()
    }
    /// Sets the value of the [`py_generic_services`] field
    ///
    /// [`py_generic_services`]: #method.py_generic_services
    pub fn set_py_generic_services(&mut self, value: bool) {
        self.py_generic_services = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`py_generic_services`] field
    ///
    /// [`py_generic_services`]: #method.py_generic_services
    pub fn clear_py_generic_services(&mut self) {
        self.py_generic_services = ::std::option::Option::None
    }
    /// Gets the field number of the [`php_generic_services`] field
    ///
    /// [`php_generic_services`]: #method.php_generic_services
    pub const PHP_GENERIC_SERVICES_FIELD_NUMBER: i32 = 42;
    /// A constant value representing the default value of the [`php_generic_services`] field
    ///
    /// [`php_generic_services`]: #method.php_generic_services
    pub const PHP_GENERIC_SERVICES_DEFAULT_VALUE: bool = false;
    pub fn php_generic_services(&self) -> bool {
        self.php_generic_services.unwrap_or(Self::PHP_GENERIC_SERVICES_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`php_generic_services`] field
    ///
    /// [`php_generic_services`]: #method.php_generic_services
    pub fn has_php_generic_services(&self) -> bool {
        self.php_generic_services.is_some()
    }
    /// Sets the value of the [`php_generic_services`] field
    ///
    /// [`php_generic_services`]: #method.php_generic_services
    pub fn set_php_generic_services(&mut self, value: bool) {
        self.php_generic_services = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`php_generic_services`] field
    ///
    /// [`php_generic_services`]: #method.php_generic_services
    pub fn clear_php_generic_services(&mut self) {
        self.php_generic_services = ::std::option::Option::None
    }
    /// Gets the field number of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub const DEPRECATED_FIELD_NUMBER: i32 = 23;
    /// A constant value representing the default value of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub const DEPRECATED_DEFAULT_VALUE: bool = false;
    /// Is this file deprecated?
    /// Depending on the target platform, this can emit Deprecated annotations
    /// for everything in the file, or it will be completely ignored; in the very
    /// least, this is a formalization for deprecating files.
    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(Self::DEPRECATED_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }
    /// Sets the value of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub fn set_deprecated(&mut self, value: bool) {
        self.deprecated = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None
    }
    /// Gets the field number of the [`cc_enable_arenas`] field
    ///
    /// [`cc_enable_arenas`]: #method.cc_enable_arenas
    pub const CC_ENABLE_ARENAS_FIELD_NUMBER: i32 = 31;
    /// A constant value representing the default value of the [`cc_enable_arenas`] field
    ///
    /// [`cc_enable_arenas`]: #method.cc_enable_arenas
    pub const CC_ENABLE_ARENAS_DEFAULT_VALUE: bool = false;
    /// Enables the use of arenas for the proto messages in this file. This applies
    /// only to generated classes for C++.
    pub fn cc_enable_arenas(&self) -> bool {
        self.cc_enable_arenas.unwrap_or(Self::CC_ENABLE_ARENAS_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`cc_enable_arenas`] field
    ///
    /// [`cc_enable_arenas`]: #method.cc_enable_arenas
    pub fn has_cc_enable_arenas(&self) -> bool {
        self.cc_enable_arenas.is_some()
    }
    /// Sets the value of the [`cc_enable_arenas`] field
    ///
    /// [`cc_enable_arenas`]: #method.cc_enable_arenas
    pub fn set_cc_enable_arenas(&mut self, value: bool) {
        self.cc_enable_arenas = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`cc_enable_arenas`] field
    ///
    /// [`cc_enable_arenas`]: #method.cc_enable_arenas
    pub fn clear_cc_enable_arenas(&mut self) {
        self.cc_enable_arenas = ::std::option::Option::None
    }
    /// Gets the field number of the [`objc_class_prefix`] field
    ///
    /// [`objc_class_prefix`]: #method.objc_class_prefix
    pub const OBJC_CLASS_PREFIX_FIELD_NUMBER: i32 = 36;
    /// A constant value representing the default value of the [`objc_class_prefix`] field
    ///
    /// [`objc_class_prefix`]: #method.objc_class_prefix
    pub const OBJC_CLASS_PREFIX_DEFAULT_VALUE: &'static str = "";
    /// Sets the objective c class prefix which is prepended to all objective c
    /// generated classes from this .proto. There is no default.
    pub fn objc_class_prefix(&self) -> &str {
        &self.objc_class_prefix.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::OBJC_CLASS_PREFIX_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`objc_class_prefix`] field
    ///
    /// [`objc_class_prefix`]: #method.objc_class_prefix
    pub fn objc_class_prefix_mut(&mut self) -> &mut ::std::string::String {
        self.objc_class_prefix.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`objc_class_prefix`] field
    ///
    /// [`objc_class_prefix`]: #method.objc_class_prefix
    pub fn has_objc_class_prefix(&self) -> bool {
        self.objc_class_prefix.is_some()
    }
    /// Sets the value of the [`objc_class_prefix`] field
    ///
    /// [`objc_class_prefix`]: #method.objc_class_prefix
    pub fn set_objc_class_prefix(&mut self, value: ::std::string::String) {
        self.objc_class_prefix = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`objc_class_prefix`] field, leaving it empty
    ///
    /// [`objc_class_prefix`]: #method.objc_class_prefix
    pub fn take_objc_class_prefix(&mut self) -> ::std::option::Option<::std::string::String> {
        self.objc_class_prefix.take()
    }
    /// Clears the value of the [`objc_class_prefix`] field
    ///
    /// [`objc_class_prefix`]: #method.objc_class_prefix
    pub fn clear_objc_class_prefix(&mut self) {
        self.objc_class_prefix = ::std::option::Option::None
    }
    /// Gets the field number of the [`csharp_namespace`] field
    ///
    /// [`csharp_namespace`]: #method.csharp_namespace
    pub const CSHARP_NAMESPACE_FIELD_NUMBER: i32 = 37;
    /// A constant value representing the default value of the [`csharp_namespace`] field
    ///
    /// [`csharp_namespace`]: #method.csharp_namespace
    pub const CSHARP_NAMESPACE_DEFAULT_VALUE: &'static str = "";
    /// Namespace for generated classes; defaults to the package.
    pub fn csharp_namespace(&self) -> &str {
        &self.csharp_namespace.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::CSHARP_NAMESPACE_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`csharp_namespace`] field
    ///
    /// [`csharp_namespace`]: #method.csharp_namespace
    pub fn csharp_namespace_mut(&mut self) -> &mut ::std::string::String {
        self.csharp_namespace.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`csharp_namespace`] field
    ///
    /// [`csharp_namespace`]: #method.csharp_namespace
    pub fn has_csharp_namespace(&self) -> bool {
        self.csharp_namespace.is_some()
    }
    /// Sets the value of the [`csharp_namespace`] field
    ///
    /// [`csharp_namespace`]: #method.csharp_namespace
    pub fn set_csharp_namespace(&mut self, value: ::std::string::String) {
        self.csharp_namespace = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`csharp_namespace`] field, leaving it empty
    ///
    /// [`csharp_namespace`]: #method.csharp_namespace
    pub fn take_csharp_namespace(&mut self) -> ::std::option::Option<::std::string::String> {
        self.csharp_namespace.take()
    }
    /// Clears the value of the [`csharp_namespace`] field
    ///
    /// [`csharp_namespace`]: #method.csharp_namespace
    pub fn clear_csharp_namespace(&mut self) {
        self.csharp_namespace = ::std::option::Option::None
    }
    /// Gets the field number of the [`swift_prefix`] field
    ///
    /// [`swift_prefix`]: #method.swift_prefix
    pub const SWIFT_PREFIX_FIELD_NUMBER: i32 = 39;
    /// A constant value representing the default value of the [`swift_prefix`] field
    ///
    /// [`swift_prefix`]: #method.swift_prefix
    pub const SWIFT_PREFIX_DEFAULT_VALUE: &'static str = "";
    /// By default Swift generators will take the proto package and CamelCase it
    /// replacing '.' with underscore and use that to prefix the types/symbols
    /// defined. When this options is provided, they will use this value instead
    /// to prefix the types/symbols defined.
    pub fn swift_prefix(&self) -> &str {
        &self.swift_prefix.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::SWIFT_PREFIX_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`swift_prefix`] field
    ///
    /// [`swift_prefix`]: #method.swift_prefix
    pub fn swift_prefix_mut(&mut self) -> &mut ::std::string::String {
        self.swift_prefix.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`swift_prefix`] field
    ///
    /// [`swift_prefix`]: #method.swift_prefix
    pub fn has_swift_prefix(&self) -> bool {
        self.swift_prefix.is_some()
    }
    /// Sets the value of the [`swift_prefix`] field
    ///
    /// [`swift_prefix`]: #method.swift_prefix
    pub fn set_swift_prefix(&mut self, value: ::std::string::String) {
        self.swift_prefix = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`swift_prefix`] field, leaving it empty
    ///
    /// [`swift_prefix`]: #method.swift_prefix
    pub fn take_swift_prefix(&mut self) -> ::std::option::Option<::std::string::String> {
        self.swift_prefix.take()
    }
    /// Clears the value of the [`swift_prefix`] field
    ///
    /// [`swift_prefix`]: #method.swift_prefix
    pub fn clear_swift_prefix(&mut self) {
        self.swift_prefix = ::std::option::Option::None
    }
    /// Gets the field number of the [`php_class_prefix`] field
    ///
    /// [`php_class_prefix`]: #method.php_class_prefix
    pub const PHP_CLASS_PREFIX_FIELD_NUMBER: i32 = 40;
    /// A constant value representing the default value of the [`php_class_prefix`] field
    ///
    /// [`php_class_prefix`]: #method.php_class_prefix
    pub const PHP_CLASS_PREFIX_DEFAULT_VALUE: &'static str = "";
    /// Sets the php class prefix which is prepended to all php generated classes
    /// from this .proto. Default is empty.
    pub fn php_class_prefix(&self) -> &str {
        &self.php_class_prefix.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::PHP_CLASS_PREFIX_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`php_class_prefix`] field
    ///
    /// [`php_class_prefix`]: #method.php_class_prefix
    pub fn php_class_prefix_mut(&mut self) -> &mut ::std::string::String {
        self.php_class_prefix.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`php_class_prefix`] field
    ///
    /// [`php_class_prefix`]: #method.php_class_prefix
    pub fn has_php_class_prefix(&self) -> bool {
        self.php_class_prefix.is_some()
    }
    /// Sets the value of the [`php_class_prefix`] field
    ///
    /// [`php_class_prefix`]: #method.php_class_prefix
    pub fn set_php_class_prefix(&mut self, value: ::std::string::String) {
        self.php_class_prefix = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`php_class_prefix`] field, leaving it empty
    ///
    /// [`php_class_prefix`]: #method.php_class_prefix
    pub fn take_php_class_prefix(&mut self) -> ::std::option::Option<::std::string::String> {
        self.php_class_prefix.take()
    }
    /// Clears the value of the [`php_class_prefix`] field
    ///
    /// [`php_class_prefix`]: #method.php_class_prefix
    pub fn clear_php_class_prefix(&mut self) {
        self.php_class_prefix = ::std::option::Option::None
    }
    /// Gets the field number of the [`php_namespace`] field
    ///
    /// [`php_namespace`]: #method.php_namespace
    pub const PHP_NAMESPACE_FIELD_NUMBER: i32 = 41;
    /// A constant value representing the default value of the [`php_namespace`] field
    ///
    /// [`php_namespace`]: #method.php_namespace
    pub const PHP_NAMESPACE_DEFAULT_VALUE: &'static str = "";
    /// Use this option to change the namespace of php generated classes. Default
    /// is empty. When this option is empty, the package name will be used for
    /// determining the namespace.
    pub fn php_namespace(&self) -> &str {
        &self.php_namespace.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::PHP_NAMESPACE_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`php_namespace`] field
    ///
    /// [`php_namespace`]: #method.php_namespace
    pub fn php_namespace_mut(&mut self) -> &mut ::std::string::String {
        self.php_namespace.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`php_namespace`] field
    ///
    /// [`php_namespace`]: #method.php_namespace
    pub fn has_php_namespace(&self) -> bool {
        self.php_namespace.is_some()
    }
    /// Sets the value of the [`php_namespace`] field
    ///
    /// [`php_namespace`]: #method.php_namespace
    pub fn set_php_namespace(&mut self, value: ::std::string::String) {
        self.php_namespace = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`php_namespace`] field, leaving it empty
    ///
    /// [`php_namespace`]: #method.php_namespace
    pub fn take_php_namespace(&mut self) -> ::std::option::Option<::std::string::String> {
        self.php_namespace.take()
    }
    /// Clears the value of the [`php_namespace`] field
    ///
    /// [`php_namespace`]: #method.php_namespace
    pub fn clear_php_namespace(&mut self) {
        self.php_namespace = ::std::option::Option::None
    }
    /// Gets the field number of the [`php_metadata_namespace`] field
    ///
    /// [`php_metadata_namespace`]: #method.php_metadata_namespace
    pub const PHP_METADATA_NAMESPACE_FIELD_NUMBER: i32 = 44;
    /// A constant value representing the default value of the [`php_metadata_namespace`] field
    ///
    /// [`php_metadata_namespace`]: #method.php_metadata_namespace
    pub const PHP_METADATA_NAMESPACE_DEFAULT_VALUE: &'static str = "";
    /// Use this option to change the namespace of php generated metadata classes.
    /// Default is empty. When this option is empty, the proto file name will be used
    /// for determining the namespace.
    pub fn php_metadata_namespace(&self) -> &str {
        &self.php_metadata_namespace.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::PHP_METADATA_NAMESPACE_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`php_metadata_namespace`] field
    ///
    /// [`php_metadata_namespace`]: #method.php_metadata_namespace
    pub fn php_metadata_namespace_mut(&mut self) -> &mut ::std::string::String {
        self.php_metadata_namespace.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`php_metadata_namespace`] field
    ///
    /// [`php_metadata_namespace`]: #method.php_metadata_namespace
    pub fn has_php_metadata_namespace(&self) -> bool {
        self.php_metadata_namespace.is_some()
    }
    /// Sets the value of the [`php_metadata_namespace`] field
    ///
    /// [`php_metadata_namespace`]: #method.php_metadata_namespace
    pub fn set_php_metadata_namespace(&mut self, value: ::std::string::String) {
        self.php_metadata_namespace = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`php_metadata_namespace`] field, leaving it empty
    ///
    /// [`php_metadata_namespace`]: #method.php_metadata_namespace
    pub fn take_php_metadata_namespace(&mut self) -> ::std::option::Option<::std::string::String> {
        self.php_metadata_namespace.take()
    }
    /// Clears the value of the [`php_metadata_namespace`] field
    ///
    /// [`php_metadata_namespace`]: #method.php_metadata_namespace
    pub fn clear_php_metadata_namespace(&mut self) {
        self.php_metadata_namespace = ::std::option::Option::None
    }
    /// Gets the field number of the [`ruby_package`] field
    ///
    /// [`ruby_package`]: #method.ruby_package
    pub const RUBY_PACKAGE_FIELD_NUMBER: i32 = 45;
    /// A constant value representing the default value of the [`ruby_package`] field
    ///
    /// [`ruby_package`]: #method.ruby_package
    pub const RUBY_PACKAGE_DEFAULT_VALUE: &'static str = "";
    /// Use this option to change the package of ruby generated classes. Default
    /// is empty. When this option is not set, the package name will be used for
    /// determining the ruby package.
    pub fn ruby_package(&self) -> &str {
        &self.ruby_package.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::RUBY_PACKAGE_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`ruby_package`] field
    ///
    /// [`ruby_package`]: #method.ruby_package
    pub fn ruby_package_mut(&mut self) -> &mut ::std::string::String {
        self.ruby_package.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`ruby_package`] field
    ///
    /// [`ruby_package`]: #method.ruby_package
    pub fn has_ruby_package(&self) -> bool {
        self.ruby_package.is_some()
    }
    /// Sets the value of the [`ruby_package`] field
    ///
    /// [`ruby_package`]: #method.ruby_package
    pub fn set_ruby_package(&mut self, value: ::std::string::String) {
        self.ruby_package = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`ruby_package`] field, leaving it empty
    ///
    /// [`ruby_package`]: #method.ruby_package
    pub fn take_ruby_package(&mut self) -> ::std::option::Option<::std::string::String> {
        self.ruby_package.take()
    }
    /// Clears the value of the [`ruby_package`] field
    ///
    /// [`ruby_package`]: #method.ruby_package
    pub fn clear_ruby_package(&mut self) {
        self.ruby_package = ::std::option::Option::None
    }
    /// Gets the field number of the [`uninterpreted_option`] field
    ///
    /// [`uninterpreted_option`]: #method.uninterpreted_option
    pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
    /// The parser stores options it doesn't recognize here.
    /// See the documentation for the "Options" section above.
    pub fn uninterpreted_option(&self) -> &crate::collections::RepeatedField<self::UninterpretedOption> {
        &self.uninterpreted_option
    }
    /// Returns a unique reference to the [`uninterpreted_option`] field
    ///
    /// [`uninterpreted_option`]: #method.uninterpreted_option
    pub fn uninterpreted_option_mut(&mut self) -> &mut crate::collections::RepeatedField<self::UninterpretedOption> {
        &mut self.uninterpreted_option
    }
}
/// Generated classes can be optimized for speed or code size.
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum FileOptions_OptimizeMode {
    /// Generate complete code for parsing, serialization,
    Speed = 1,
    /// etc.
    CodeSize = 2,
    /// Generate code using MessageLite and the lite runtime.
    LiteRuntime = 3,
}
impl ::std::convert::TryFrom<i32> for self::FileOptions_OptimizeMode {
    type Error = crate::VariantUndefinedError;
    fn try_from(value: i32) -> ::std::result::Result<Self, crate::VariantUndefinedError> {
        match value {
            1 => ::std::result::Result::Ok(self::FileOptions_OptimizeMode::Speed),
            2 => ::std::result::Result::Ok(self::FileOptions_OptimizeMode::CodeSize),
            3 => ::std::result::Result::Ok(self::FileOptions_OptimizeMode::LiteRuntime),
            _ => ::std::result::Result::Err(crate::VariantUndefinedError)
        }
    }
}
impl ::std::convert::From<self::FileOptions_OptimizeMode> for i32 {
    fn from(value: self::FileOptions_OptimizeMode) -> i32 {
        value as i32
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct MessageOptions {
    message_set_wire_format: ::std::option::Option<bool>,
    no_standard_descriptor_accessor: ::std::option::Option<bool>,
    deprecated: ::std::option::Option<bool>,
    map_entry: ::std::option::Option<bool>,
    uninterpreted_option: crate::collections::RepeatedField<self::UninterpretedOption>,
    unknown_fields: crate::UnknownFieldSet
}
static MESSAGE_OPTIONS_UNINTERPRETED_OPTION_CODEC: crate::Codec<self::UninterpretedOption> = crate::Codec::message(7994);
impl crate::CodedMessage for self::MessageOptions {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 => self.message_set_wire_format = ::std::option::Option::Some(input.read_bool()?),
                16 => self.no_standard_descriptor_accessor = ::std::option::Option::Some(input.read_bool()?),
                24 => self.deprecated = ::std::option::Option::Some(input.read_bool()?),
                56 => self.map_entry = ::std::option::Option::Some(input.read_bool()?),
                7994 => self.uninterpreted_option.add_entries(tag.get(), input, &MESSAGE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let message_set_wire_format = self.message_set_wire_format;
        if let ::std::option::Option::Some(message_set_wire_format) = message_set_wire_format {
            if message_set_wire_format != Self::MESSAGE_SET_WIRE_FORMAT_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(message_set_wire_format);
            }
        }
        let no_standard_descriptor_accessor = self.no_standard_descriptor_accessor;
        if let ::std::option::Option::Some(no_standard_descriptor_accessor) = no_standard_descriptor_accessor {
            if no_standard_descriptor_accessor != Self::NO_STANDARD_DESCRIPTOR_ACCESSOR_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(no_standard_descriptor_accessor);
            }
        }
        let deprecated = self.deprecated;
        if let ::std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(deprecated);
            }
        }
        let map_entry = self.map_entry;
        if let ::std::option::Option::Some(map_entry) = map_entry {
            if map_entry != Self::MAP_ENTRY_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(map_entry);
            }
        }
        size += self.uninterpreted_option.calculate_size(&MESSAGE_OPTIONS_UNINTERPRETED_OPTION_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let message_set_wire_format = self.message_set_wire_format;
        if let ::std::option::Option::Some(message_set_wire_format) = message_set_wire_format {
            if message_set_wire_format != Self::MESSAGE_SET_WIRE_FORMAT_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_bool(message_set_wire_format)?;
            }
        }
        let no_standard_descriptor_accessor = self.no_standard_descriptor_accessor;
        if let ::std::option::Option::Some(no_standard_descriptor_accessor) = no_standard_descriptor_accessor {
            if no_standard_descriptor_accessor != Self::NO_STANDARD_DESCRIPTOR_ACCESSOR_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_bool(no_standard_descriptor_accessor)?;
            }
        }
        let deprecated = self.deprecated;
        if let ::std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[24])?;
                output.write_bool(deprecated)?;
            }
        }
        let map_entry = self.map_entry;
        if let ::std::option::Option::Some(map_entry) = map_entry {
            if map_entry != Self::MAP_ENTRY_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[56])?;
                output.write_bool(map_entry)?;
            }
        }
        self.uninterpreted_option.write_to(output, &MESSAGE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::MessageOptions {
    fn new() -> Self {
        Self {
            message_set_wire_format: ::std::option::Option::None,
            no_standard_descriptor_accessor: ::std::option::Option::None,
            deprecated: ::std::option::Option::None,
            map_entry: ::std::option::Option::None,
            uninterpreted_option: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
    fn merge(&mut self, other: &Self) {
        self.message_set_wire_format = other.message_set_wire_format;
        self.no_standard_descriptor_accessor = other.no_standard_descriptor_accessor;
        self.deprecated = other.deprecated;
        self.map_entry = other.map_entry;
        self.uninterpreted_option.merge(&other.uninterpreted_option);
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl crate::Message for self::MessageOptions {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[11]
    }
}
impl self::MessageOptions {
    /// Gets the field number of the [`message_set_wire_format`] field
    ///
    /// [`message_set_wire_format`]: #method.message_set_wire_format
    pub const MESSAGE_SET_WIRE_FORMAT_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`message_set_wire_format`] field
    ///
    /// [`message_set_wire_format`]: #method.message_set_wire_format
    pub const MESSAGE_SET_WIRE_FORMAT_DEFAULT_VALUE: bool = false;
    /// Set true to use the old proto1 MessageSet wire format for extensions.
    /// This is provided for backwards-compatibility with the MessageSet wire
    /// format.  You should not use this for any other reason:  It's less
    /// efficient, has fewer features, and is more complicated.
    ///
    /// The message must be defined exactly as follows:
    ///   message Foo {
    ///     option message_set_wire_format = true;
    ///     extensions 4 to max;
    ///   }
    /// Note that the message cannot have any defined fields; MessageSets only
    /// have extensions.
    ///
    /// All extensions of your type must be singular messages; e.g. they cannot
    /// be int32s, enums, or repeated messages.
    ///
    /// Because this is an option, the above two restrictions are not enforced by
    /// the protocol compiler.
    pub fn message_set_wire_format(&self) -> bool {
        self.message_set_wire_format.unwrap_or(Self::MESSAGE_SET_WIRE_FORMAT_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`message_set_wire_format`] field
    ///
    /// [`message_set_wire_format`]: #method.message_set_wire_format
    pub fn has_message_set_wire_format(&self) -> bool {
        self.message_set_wire_format.is_some()
    }
    /// Sets the value of the [`message_set_wire_format`] field
    ///
    /// [`message_set_wire_format`]: #method.message_set_wire_format
    pub fn set_message_set_wire_format(&mut self, value: bool) {
        self.message_set_wire_format = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`message_set_wire_format`] field
    ///
    /// [`message_set_wire_format`]: #method.message_set_wire_format
    pub fn clear_message_set_wire_format(&mut self) {
        self.message_set_wire_format = ::std::option::Option::None
    }
    /// Gets the field number of the [`no_standard_descriptor_accessor`] field
    ///
    /// [`no_standard_descriptor_accessor`]: #method.no_standard_descriptor_accessor
    pub const NO_STANDARD_DESCRIPTOR_ACCESSOR_FIELD_NUMBER: i32 = 2;
    /// A constant value representing the default value of the [`no_standard_descriptor_accessor`] field
    ///
    /// [`no_standard_descriptor_accessor`]: #method.no_standard_descriptor_accessor
    pub const NO_STANDARD_DESCRIPTOR_ACCESSOR_DEFAULT_VALUE: bool = false;
    /// Disables the generation of the standard "descriptor()" accessor, which can
    /// conflict with a field of the same name.  This is meant to make migration
    /// from proto1 easier; new code should avoid fields named "descriptor".
    pub fn no_standard_descriptor_accessor(&self) -> bool {
        self.no_standard_descriptor_accessor.unwrap_or(Self::NO_STANDARD_DESCRIPTOR_ACCESSOR_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`no_standard_descriptor_accessor`] field
    ///
    /// [`no_standard_descriptor_accessor`]: #method.no_standard_descriptor_accessor
    pub fn has_no_standard_descriptor_accessor(&self) -> bool {
        self.no_standard_descriptor_accessor.is_some()
    }
    /// Sets the value of the [`no_standard_descriptor_accessor`] field
    ///
    /// [`no_standard_descriptor_accessor`]: #method.no_standard_descriptor_accessor
    pub fn set_no_standard_descriptor_accessor(&mut self, value: bool) {
        self.no_standard_descriptor_accessor = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`no_standard_descriptor_accessor`] field
    ///
    /// [`no_standard_descriptor_accessor`]: #method.no_standard_descriptor_accessor
    pub fn clear_no_standard_descriptor_accessor(&mut self) {
        self.no_standard_descriptor_accessor = ::std::option::Option::None
    }
    /// Gets the field number of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub const DEPRECATED_FIELD_NUMBER: i32 = 3;
    /// A constant value representing the default value of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub const DEPRECATED_DEFAULT_VALUE: bool = false;
    /// Is this message deprecated?
    /// Depending on the target platform, this can emit Deprecated annotations
    /// for the message, or it will be completely ignored; in the very least,
    /// this is a formalization for deprecating messages.
    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(Self::DEPRECATED_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }
    /// Sets the value of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub fn set_deprecated(&mut self, value: bool) {
        self.deprecated = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None
    }
    /// Gets the field number of the [`map_entry`] field
    ///
    /// [`map_entry`]: #method.map_entry
    pub const MAP_ENTRY_FIELD_NUMBER: i32 = 7;
    /// A constant value representing the default value of the [`map_entry`] field
    ///
    /// [`map_entry`]: #method.map_entry
    pub const MAP_ENTRY_DEFAULT_VALUE: bool = false;
    /// Whether the message is an automatically generated map entry type for the
    /// maps field.
    ///
    /// For maps fields:
    ///     map<KeyType, ValueType> map_field = 1;
    /// The parsed descriptor looks like:
    ///     message MapFieldEntry {
    ///         option map_entry = true;
    ///         optional KeyType key = 1;
    ///         optional ValueType value = 2;
    ///     }
    ///     repeated MapFieldEntry map_field = 1;
    ///
    /// Implementations may choose not to generate the map_entry=true message, but
    /// use a native map in the target language to hold the keys and values.
    /// The reflection APIs in such implementions still need to work as
    /// if the field is a repeated message field.
    ///
    /// NOTE: Do not set the option in .proto files. Always use the maps syntax
    /// instead. The option should only be implicitly set by the proto compiler
    /// parser.
    pub fn map_entry(&self) -> bool {
        self.map_entry.unwrap_or(Self::MAP_ENTRY_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`map_entry`] field
    ///
    /// [`map_entry`]: #method.map_entry
    pub fn has_map_entry(&self) -> bool {
        self.map_entry.is_some()
    }
    /// Sets the value of the [`map_entry`] field
    ///
    /// [`map_entry`]: #method.map_entry
    pub fn set_map_entry(&mut self, value: bool) {
        self.map_entry = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`map_entry`] field
    ///
    /// [`map_entry`]: #method.map_entry
    pub fn clear_map_entry(&mut self) {
        self.map_entry = ::std::option::Option::None
    }
    /// Gets the field number of the [`uninterpreted_option`] field
    ///
    /// [`uninterpreted_option`]: #method.uninterpreted_option
    pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
    /// The parser stores options it doesn't recognize here. See above.
    pub fn uninterpreted_option(&self) -> &crate::collections::RepeatedField<self::UninterpretedOption> {
        &self.uninterpreted_option
    }
    /// Returns a unique reference to the [`uninterpreted_option`] field
    ///
    /// [`uninterpreted_option`]: #method.uninterpreted_option
    pub fn uninterpreted_option_mut(&mut self) -> &mut crate::collections::RepeatedField<self::UninterpretedOption> {
        &mut self.uninterpreted_option
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct FieldOptions {
    ctype: ::std::option::Option<crate::EnumValue<self::FieldOptions_CType>>,
    packed: ::std::option::Option<bool>,
    jstype: ::std::option::Option<crate::EnumValue<self::FieldOptions_JSType>>,
    lazy: ::std::option::Option<bool>,
    deprecated: ::std::option::Option<bool>,
    weak: ::std::option::Option<bool>,
    uninterpreted_option: crate::collections::RepeatedField<self::UninterpretedOption>,
    unknown_fields: crate::UnknownFieldSet
}
static FIELD_OPTIONS_UNINTERPRETED_OPTION_CODEC: crate::Codec<self::UninterpretedOption> = crate::Codec::message(7994);
impl crate::CodedMessage for self::FieldOptions {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 => self.ctype = ::std::option::Option::Some(input.read_enum_value()?),
                16 => self.packed = ::std::option::Option::Some(input.read_bool()?),
                48 => self.jstype = ::std::option::Option::Some(input.read_enum_value()?),
                40 => self.lazy = ::std::option::Option::Some(input.read_bool()?),
                24 => self.deprecated = ::std::option::Option::Some(input.read_bool()?),
                80 => self.weak = ::std::option::Option::Some(input.read_bool()?),
                7994 => self.uninterpreted_option.add_entries(tag.get(), input, &FIELD_OPTIONS_UNINTERPRETED_OPTION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let ctype = self.ctype;
        if let ::std::option::Option::Some(ctype) = ctype {
            if ctype != Self::CTYPE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::enum_value(ctype);
            }
        }
        let packed = self.packed;
        if let ::std::option::Option::Some(packed) = packed {
            if packed != Self::PACKED_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(packed);
            }
        }
        let jstype = self.jstype;
        if let ::std::option::Option::Some(jstype) = jstype {
            if jstype != Self::JSTYPE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::enum_value(jstype);
            }
        }
        let lazy = self.lazy;
        if let ::std::option::Option::Some(lazy) = lazy {
            if lazy != Self::LAZY_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(lazy);
            }
        }
        let deprecated = self.deprecated;
        if let ::std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(deprecated);
            }
        }
        let weak = self.weak;
        if let ::std::option::Option::Some(weak) = weak {
            if weak != Self::WEAK_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(weak);
            }
        }
        size += self.uninterpreted_option.calculate_size(&FIELD_OPTIONS_UNINTERPRETED_OPTION_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let ctype = self.ctype;
        if let ::std::option::Option::Some(ctype) = ctype {
            if ctype != Self::CTYPE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_enum_value(ctype)?;
            }
        }
        let packed = self.packed;
        if let ::std::option::Option::Some(packed) = packed {
            if packed != Self::PACKED_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_bool(packed)?;
            }
        }
        let jstype = self.jstype;
        if let ::std::option::Option::Some(jstype) = jstype {
            if jstype != Self::JSTYPE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[48])?;
                output.write_enum_value(jstype)?;
            }
        }
        let lazy = self.lazy;
        if let ::std::option::Option::Some(lazy) = lazy {
            if lazy != Self::LAZY_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[40])?;
                output.write_bool(lazy)?;
            }
        }
        let deprecated = self.deprecated;
        if let ::std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[24])?;
                output.write_bool(deprecated)?;
            }
        }
        let weak = self.weak;
        if let ::std::option::Option::Some(weak) = weak {
            if weak != Self::WEAK_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[80])?;
                output.write_bool(weak)?;
            }
        }
        self.uninterpreted_option.write_to(output, &FIELD_OPTIONS_UNINTERPRETED_OPTION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::FieldOptions {
    fn new() -> Self {
        Self {
            ctype: ::std::option::Option::None,
            packed: ::std::option::Option::None,
            jstype: ::std::option::Option::None,
            lazy: ::std::option::Option::None,
            deprecated: ::std::option::Option::None,
            weak: ::std::option::Option::None,
            uninterpreted_option: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
    fn merge(&mut self, other: &Self) {
        self.ctype = other.ctype;
        self.packed = other.packed;
        self.jstype = other.jstype;
        self.lazy = other.lazy;
        self.deprecated = other.deprecated;
        self.weak = other.weak;
        self.uninterpreted_option.merge(&other.uninterpreted_option);
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl crate::Message for self::FieldOptions {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[12]
    }
}
impl self::FieldOptions {
    /// Gets the field number of the [`ctype`] field
    ///
    /// [`ctype`]: #method.ctype
    pub const CTYPE_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`ctype`] field
    ///
    /// [`ctype`]: #method.ctype
    pub const CTYPE_DEFAULT_VALUE: crate::EnumValue<self::FieldOptions_CType> = crate::EnumValue::Defined(self::FieldOptions_CType::String);
    /// The ctype option instructs the C++ code generator to use a different
    /// representation of the field than it normally would.  See the specific
    /// options below.  This option is not yet implemented in the open source
    /// release -- sorry, we'll try to include it in a future version!
    pub fn ctype(&self) -> crate::EnumValue<self::FieldOptions_CType> {
        self.ctype.unwrap_or(Self::CTYPE_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`ctype`] field
    ///
    /// [`ctype`]: #method.ctype
    pub fn has_ctype(&self) -> bool {
        self.ctype.is_some()
    }
    /// Sets the value of the [`ctype`] field
    ///
    /// [`ctype`]: #method.ctype
    pub fn set_ctype(&mut self, value: crate::EnumValue<self::FieldOptions_CType>) {
        self.ctype = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`ctype`] field
    ///
    /// [`ctype`]: #method.ctype
    pub fn clear_ctype(&mut self) {
        self.ctype = ::std::option::Option::None
    }
    /// Gets the field number of the [`packed`] field
    ///
    /// [`packed`]: #method.packed
    pub const PACKED_FIELD_NUMBER: i32 = 2;
    /// A constant value representing the default value of the [`packed`] field
    ///
    /// [`packed`]: #method.packed
    pub const PACKED_DEFAULT_VALUE: bool = false;
    /// The packed option can be enabled for repeated primitive fields to enable
    /// a more efficient representation on the wire. Rather than repeatedly
    /// writing the tag and type for each element, the entire array is encoded as
    /// a single length-delimited blob. In proto3, only explicit setting it to
    /// false will avoid using packed encoding.
    pub fn packed(&self) -> bool {
        self.packed.unwrap_or(Self::PACKED_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`packed`] field
    ///
    /// [`packed`]: #method.packed
    pub fn has_packed(&self) -> bool {
        self.packed.is_some()
    }
    /// Sets the value of the [`packed`] field
    ///
    /// [`packed`]: #method.packed
    pub fn set_packed(&mut self, value: bool) {
        self.packed = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`packed`] field
    ///
    /// [`packed`]: #method.packed
    pub fn clear_packed(&mut self) {
        self.packed = ::std::option::Option::None
    }
    /// Gets the field number of the [`jstype`] field
    ///
    /// [`jstype`]: #method.jstype
    pub const JSTYPE_FIELD_NUMBER: i32 = 6;
    /// A constant value representing the default value of the [`jstype`] field
    ///
    /// [`jstype`]: #method.jstype
    pub const JSTYPE_DEFAULT_VALUE: crate::EnumValue<self::FieldOptions_JSType> = crate::EnumValue::Defined(self::FieldOptions_JSType::JsNormal);
    /// The jstype option determines the JavaScript type used for values of the
    /// field.  The option is permitted only for 64 bit integral and fixed types
    /// (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
    /// is represented as JavaScript string, which avoids loss of precision that
    /// can happen when a large value is converted to a floating point JavaScript.
    /// Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
    /// use the JavaScript "number" type.  The behavior of the default option
    /// JS_NORMAL is implementation dependent.
    ///
    /// This option is an enum to permit additional types to be added, e.g.
    /// goog.math.Integer.
    pub fn jstype(&self) -> crate::EnumValue<self::FieldOptions_JSType> {
        self.jstype.unwrap_or(Self::JSTYPE_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`jstype`] field
    ///
    /// [`jstype`]: #method.jstype
    pub fn has_jstype(&self) -> bool {
        self.jstype.is_some()
    }
    /// Sets the value of the [`jstype`] field
    ///
    /// [`jstype`]: #method.jstype
    pub fn set_jstype(&mut self, value: crate::EnumValue<self::FieldOptions_JSType>) {
        self.jstype = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`jstype`] field
    ///
    /// [`jstype`]: #method.jstype
    pub fn clear_jstype(&mut self) {
        self.jstype = ::std::option::Option::None
    }
    /// Gets the field number of the [`lazy`] field
    ///
    /// [`lazy`]: #method.lazy
    pub const LAZY_FIELD_NUMBER: i32 = 5;
    /// A constant value representing the default value of the [`lazy`] field
    ///
    /// [`lazy`]: #method.lazy
    pub const LAZY_DEFAULT_VALUE: bool = false;
    /// Should this field be parsed lazily?  Lazy applies only to message-type
    /// fields.  It means that when the outer message is initially parsed, the
    /// inner message's contents will not be parsed but instead stored in encoded
    /// form.  The inner message will actually be parsed when it is first accessed.
    ///
    /// This is only a hint.  Implementations are free to choose whether to use
    /// eager or lazy parsing regardless of the value of this option.  However,
    /// setting this option true suggests that the protocol author believes that
    /// using lazy parsing on this field is worth the additional bookkeeping
    /// overhead typically needed to implement it.
    ///
    /// This option does not affect the public interface of any generated code;
    /// all method signatures remain the same.  Furthermore, thread-safety of the
    /// interface is not affected by this option; const methods remain safe to
    /// call from multiple threads concurrently, while non-const methods continue
    /// to require exclusive access.
    ///
    ///
    /// Note that implementations may choose not to check required fields within
    /// a lazy sub-message.  That is, calling IsInitialized() on the outer message
    /// may return true even if the inner message has missing required fields.
    /// This is necessary because otherwise the inner message would have to be
    /// parsed in order to perform the check, defeating the purpose of lazy
    /// parsing.  An implementation which chooses not to check required fields
    /// must be consistent about it.  That is, for any particular sub-message, the
    /// implementation must either *always* check its required fields, or *never*
    /// check its required fields, regardless of whether or not the message has
    /// been parsed.
    pub fn lazy(&self) -> bool {
        self.lazy.unwrap_or(Self::LAZY_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`lazy`] field
    ///
    /// [`lazy`]: #method.lazy
    pub fn has_lazy(&self) -> bool {
        self.lazy.is_some()
    }
    /// Sets the value of the [`lazy`] field
    ///
    /// [`lazy`]: #method.lazy
    pub fn set_lazy(&mut self, value: bool) {
        self.lazy = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`lazy`] field
    ///
    /// [`lazy`]: #method.lazy
    pub fn clear_lazy(&mut self) {
        self.lazy = ::std::option::Option::None
    }
    /// Gets the field number of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub const DEPRECATED_FIELD_NUMBER: i32 = 3;
    /// A constant value representing the default value of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub const DEPRECATED_DEFAULT_VALUE: bool = false;
    /// Is this field deprecated?
    /// Depending on the target platform, this can emit Deprecated annotations
    /// for accessors, or it will be completely ignored; in the very least, this
    /// is a formalization for deprecating fields.
    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(Self::DEPRECATED_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }
    /// Sets the value of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub fn set_deprecated(&mut self, value: bool) {
        self.deprecated = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None
    }
    /// Gets the field number of the [`weak`] field
    ///
    /// [`weak`]: #method.weak
    pub const WEAK_FIELD_NUMBER: i32 = 10;
    /// A constant value representing the default value of the [`weak`] field
    ///
    /// [`weak`]: #method.weak
    pub const WEAK_DEFAULT_VALUE: bool = false;
    /// For Google-internal migration only. Do not use.
    pub fn weak(&self) -> bool {
        self.weak.unwrap_or(Self::WEAK_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`weak`] field
    ///
    /// [`weak`]: #method.weak
    pub fn has_weak(&self) -> bool {
        self.weak.is_some()
    }
    /// Sets the value of the [`weak`] field
    ///
    /// [`weak`]: #method.weak
    pub fn set_weak(&mut self, value: bool) {
        self.weak = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`weak`] field
    ///
    /// [`weak`]: #method.weak
    pub fn clear_weak(&mut self) {
        self.weak = ::std::option::Option::None
    }
    /// Gets the field number of the [`uninterpreted_option`] field
    ///
    /// [`uninterpreted_option`]: #method.uninterpreted_option
    pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
    /// The parser stores options it doesn't recognize here. See above.
    pub fn uninterpreted_option(&self) -> &crate::collections::RepeatedField<self::UninterpretedOption> {
        &self.uninterpreted_option
    }
    /// Returns a unique reference to the [`uninterpreted_option`] field
    ///
    /// [`uninterpreted_option`]: #method.uninterpreted_option
    pub fn uninterpreted_option_mut(&mut self) -> &mut crate::collections::RepeatedField<self::UninterpretedOption> {
        &mut self.uninterpreted_option
    }
}
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum FieldOptions_CType {
    /// Default mode.
    String = 0,
    Cord = 1,
    StringPiece = 2,
}
impl ::std::convert::TryFrom<i32> for self::FieldOptions_CType {
    type Error = crate::VariantUndefinedError;
    fn try_from(value: i32) -> ::std::result::Result<Self, crate::VariantUndefinedError> {
        match value {
            0 => ::std::result::Result::Ok(self::FieldOptions_CType::String),
            1 => ::std::result::Result::Ok(self::FieldOptions_CType::Cord),
            2 => ::std::result::Result::Ok(self::FieldOptions_CType::StringPiece),
            _ => ::std::result::Result::Err(crate::VariantUndefinedError)
        }
    }
}
impl ::std::convert::From<self::FieldOptions_CType> for i32 {
    fn from(value: self::FieldOptions_CType) -> i32 {
        value as i32
    }
}
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum FieldOptions_JSType {
    /// Use the default type.
    JsNormal = 0,
    /// Use JavaScript strings.
    JsString = 1,
    /// Use JavaScript numbers.
    JsNumber = 2,
}
impl ::std::convert::TryFrom<i32> for self::FieldOptions_JSType {
    type Error = crate::VariantUndefinedError;
    fn try_from(value: i32) -> ::std::result::Result<Self, crate::VariantUndefinedError> {
        match value {
            0 => ::std::result::Result::Ok(self::FieldOptions_JSType::JsNormal),
            1 => ::std::result::Result::Ok(self::FieldOptions_JSType::JsString),
            2 => ::std::result::Result::Ok(self::FieldOptions_JSType::JsNumber),
            _ => ::std::result::Result::Err(crate::VariantUndefinedError)
        }
    }
}
impl ::std::convert::From<self::FieldOptions_JSType> for i32 {
    fn from(value: self::FieldOptions_JSType) -> i32 {
        value as i32
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct OneofOptions {
    uninterpreted_option: crate::collections::RepeatedField<self::UninterpretedOption>,
    unknown_fields: crate::UnknownFieldSet
}
static ONEOF_OPTIONS_UNINTERPRETED_OPTION_CODEC: crate::Codec<self::UninterpretedOption> = crate::Codec::message(7994);
impl crate::CodedMessage for self::OneofOptions {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                7994 => self.uninterpreted_option.add_entries(tag.get(), input, &ONEOF_OPTIONS_UNINTERPRETED_OPTION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.uninterpreted_option.calculate_size(&ONEOF_OPTIONS_UNINTERPRETED_OPTION_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        self.uninterpreted_option.write_to(output, &ONEOF_OPTIONS_UNINTERPRETED_OPTION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::OneofOptions {
    fn new() -> Self {
        Self {
            uninterpreted_option: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
    fn merge(&mut self, other: &Self) {
        self.uninterpreted_option.merge(&other.uninterpreted_option);
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl crate::Message for self::OneofOptions {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[13]
    }
}
impl self::OneofOptions {
    /// Gets the field number of the [`uninterpreted_option`] field
    ///
    /// [`uninterpreted_option`]: #method.uninterpreted_option
    pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
    /// The parser stores options it doesn't recognize here. See above.
    pub fn uninterpreted_option(&self) -> &crate::collections::RepeatedField<self::UninterpretedOption> {
        &self.uninterpreted_option
    }
    /// Returns a unique reference to the [`uninterpreted_option`] field
    ///
    /// [`uninterpreted_option`]: #method.uninterpreted_option
    pub fn uninterpreted_option_mut(&mut self) -> &mut crate::collections::RepeatedField<self::UninterpretedOption> {
        &mut self.uninterpreted_option
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct EnumOptions {
    allow_alias: ::std::option::Option<bool>,
    deprecated: ::std::option::Option<bool>,
    uninterpreted_option: crate::collections::RepeatedField<self::UninterpretedOption>,
    unknown_fields: crate::UnknownFieldSet
}
static ENUM_OPTIONS_UNINTERPRETED_OPTION_CODEC: crate::Codec<self::UninterpretedOption> = crate::Codec::message(7994);
impl crate::CodedMessage for self::EnumOptions {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                16 => self.allow_alias = ::std::option::Option::Some(input.read_bool()?),
                24 => self.deprecated = ::std::option::Option::Some(input.read_bool()?),
                7994 => self.uninterpreted_option.add_entries(tag.get(), input, &ENUM_OPTIONS_UNINTERPRETED_OPTION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let allow_alias = self.allow_alias;
        if let ::std::option::Option::Some(allow_alias) = allow_alias {
            if allow_alias != Self::ALLOW_ALIAS_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(allow_alias);
            }
        }
        let deprecated = self.deprecated;
        if let ::std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(deprecated);
            }
        }
        size += self.uninterpreted_option.calculate_size(&ENUM_OPTIONS_UNINTERPRETED_OPTION_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let allow_alias = self.allow_alias;
        if let ::std::option::Option::Some(allow_alias) = allow_alias {
            if allow_alias != Self::ALLOW_ALIAS_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_bool(allow_alias)?;
            }
        }
        let deprecated = self.deprecated;
        if let ::std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[24])?;
                output.write_bool(deprecated)?;
            }
        }
        self.uninterpreted_option.write_to(output, &ENUM_OPTIONS_UNINTERPRETED_OPTION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::EnumOptions {
    fn new() -> Self {
        Self {
            allow_alias: ::std::option::Option::None,
            deprecated: ::std::option::Option::None,
            uninterpreted_option: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
    fn merge(&mut self, other: &Self) {
        self.allow_alias = other.allow_alias;
        self.deprecated = other.deprecated;
        self.uninterpreted_option.merge(&other.uninterpreted_option);
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl crate::Message for self::EnumOptions {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[14]
    }
}
impl self::EnumOptions {
    /// Gets the field number of the [`allow_alias`] field
    ///
    /// [`allow_alias`]: #method.allow_alias
    pub const ALLOW_ALIAS_FIELD_NUMBER: i32 = 2;
    /// A constant value representing the default value of the [`allow_alias`] field
    ///
    /// [`allow_alias`]: #method.allow_alias
    pub const ALLOW_ALIAS_DEFAULT_VALUE: bool = false;
    /// Set this option to true to allow mapping different tag names to the same
    /// value.
    pub fn allow_alias(&self) -> bool {
        self.allow_alias.unwrap_or(Self::ALLOW_ALIAS_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`allow_alias`] field
    ///
    /// [`allow_alias`]: #method.allow_alias
    pub fn has_allow_alias(&self) -> bool {
        self.allow_alias.is_some()
    }
    /// Sets the value of the [`allow_alias`] field
    ///
    /// [`allow_alias`]: #method.allow_alias
    pub fn set_allow_alias(&mut self, value: bool) {
        self.allow_alias = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`allow_alias`] field
    ///
    /// [`allow_alias`]: #method.allow_alias
    pub fn clear_allow_alias(&mut self) {
        self.allow_alias = ::std::option::Option::None
    }
    /// Gets the field number of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub const DEPRECATED_FIELD_NUMBER: i32 = 3;
    /// A constant value representing the default value of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub const DEPRECATED_DEFAULT_VALUE: bool = false;
    /// Is this enum deprecated?
    /// Depending on the target platform, this can emit Deprecated annotations
    /// for the enum, or it will be completely ignored; in the very least, this
    /// is a formalization for deprecating enums.
    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(Self::DEPRECATED_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }
    /// Sets the value of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub fn set_deprecated(&mut self, value: bool) {
        self.deprecated = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None
    }
    /// Gets the field number of the [`uninterpreted_option`] field
    ///
    /// [`uninterpreted_option`]: #method.uninterpreted_option
    pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
    /// The parser stores options it doesn't recognize here. See above.
    pub fn uninterpreted_option(&self) -> &crate::collections::RepeatedField<self::UninterpretedOption> {
        &self.uninterpreted_option
    }
    /// Returns a unique reference to the [`uninterpreted_option`] field
    ///
    /// [`uninterpreted_option`]: #method.uninterpreted_option
    pub fn uninterpreted_option_mut(&mut self) -> &mut crate::collections::RepeatedField<self::UninterpretedOption> {
        &mut self.uninterpreted_option
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct EnumValueOptions {
    deprecated: ::std::option::Option<bool>,
    uninterpreted_option: crate::collections::RepeatedField<self::UninterpretedOption>,
    unknown_fields: crate::UnknownFieldSet
}
static ENUM_VALUE_OPTIONS_UNINTERPRETED_OPTION_CODEC: crate::Codec<self::UninterpretedOption> = crate::Codec::message(7994);
impl crate::CodedMessage for self::EnumValueOptions {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 => self.deprecated = ::std::option::Option::Some(input.read_bool()?),
                7994 => self.uninterpreted_option.add_entries(tag.get(), input, &ENUM_VALUE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let deprecated = self.deprecated;
        if let ::std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(deprecated);
            }
        }
        size += self.uninterpreted_option.calculate_size(&ENUM_VALUE_OPTIONS_UNINTERPRETED_OPTION_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let deprecated = self.deprecated;
        if let ::std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_bool(deprecated)?;
            }
        }
        self.uninterpreted_option.write_to(output, &ENUM_VALUE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::EnumValueOptions {
    fn new() -> Self {
        Self {
            deprecated: ::std::option::Option::None,
            uninterpreted_option: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
    fn merge(&mut self, other: &Self) {
        self.deprecated = other.deprecated;
        self.uninterpreted_option.merge(&other.uninterpreted_option);
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl crate::Message for self::EnumValueOptions {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[15]
    }
}
impl self::EnumValueOptions {
    /// Gets the field number of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub const DEPRECATED_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub const DEPRECATED_DEFAULT_VALUE: bool = false;
    /// Is this enum value deprecated?
    /// Depending on the target platform, this can emit Deprecated annotations
    /// for the enum value, or it will be completely ignored; in the very least,
    /// this is a formalization for deprecating enum values.
    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(Self::DEPRECATED_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }
    /// Sets the value of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub fn set_deprecated(&mut self, value: bool) {
        self.deprecated = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None
    }
    /// Gets the field number of the [`uninterpreted_option`] field
    ///
    /// [`uninterpreted_option`]: #method.uninterpreted_option
    pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
    /// The parser stores options it doesn't recognize here. See above.
    pub fn uninterpreted_option(&self) -> &crate::collections::RepeatedField<self::UninterpretedOption> {
        &self.uninterpreted_option
    }
    /// Returns a unique reference to the [`uninterpreted_option`] field
    ///
    /// [`uninterpreted_option`]: #method.uninterpreted_option
    pub fn uninterpreted_option_mut(&mut self) -> &mut crate::collections::RepeatedField<self::UninterpretedOption> {
        &mut self.uninterpreted_option
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct ServiceOptions {
    deprecated: ::std::option::Option<bool>,
    uninterpreted_option: crate::collections::RepeatedField<self::UninterpretedOption>,
    unknown_fields: crate::UnknownFieldSet
}
static SERVICE_OPTIONS_UNINTERPRETED_OPTION_CODEC: crate::Codec<self::UninterpretedOption> = crate::Codec::message(7994);
impl crate::CodedMessage for self::ServiceOptions {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                264 => self.deprecated = ::std::option::Option::Some(input.read_bool()?),
                7994 => self.uninterpreted_option.add_entries(tag.get(), input, &SERVICE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let deprecated = self.deprecated;
        if let ::std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::bool(deprecated);
            }
        }
        size += self.uninterpreted_option.calculate_size(&SERVICE_OPTIONS_UNINTERPRETED_OPTION_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let deprecated = self.deprecated;
        if let ::std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[136, 2])?;
                output.write_bool(deprecated)?;
            }
        }
        self.uninterpreted_option.write_to(output, &SERVICE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::ServiceOptions {
    fn new() -> Self {
        Self {
            deprecated: ::std::option::Option::None,
            uninterpreted_option: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
    fn merge(&mut self, other: &Self) {
        self.deprecated = other.deprecated;
        self.uninterpreted_option.merge(&other.uninterpreted_option);
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl crate::Message for self::ServiceOptions {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[16]
    }
}
impl self::ServiceOptions {
    /// Gets the field number of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub const DEPRECATED_FIELD_NUMBER: i32 = 33;
    /// A constant value representing the default value of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub const DEPRECATED_DEFAULT_VALUE: bool = false;
    /// Is this service deprecated?
    /// Depending on the target platform, this can emit Deprecated annotations
    /// for the service, or it will be completely ignored; in the very least,
    /// this is a formalization for deprecating services.
    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(Self::DEPRECATED_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }
    /// Sets the value of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub fn set_deprecated(&mut self, value: bool) {
        self.deprecated = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None
    }
    /// Gets the field number of the [`uninterpreted_option`] field
    ///
    /// [`uninterpreted_option`]: #method.uninterpreted_option
    pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
    /// The parser stores options it doesn't recognize here. See above.
    pub fn uninterpreted_option(&self) -> &crate::collections::RepeatedField<self::UninterpretedOption> {
        &self.uninterpreted_option
    }
    /// Returns a unique reference to the [`uninterpreted_option`] field
    ///
    /// [`uninterpreted_option`]: #method.uninterpreted_option
    pub fn uninterpreted_option_mut(&mut self) -> &mut crate::collections::RepeatedField<self::UninterpretedOption> {
        &mut self.uninterpreted_option
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct MethodOptions {
    deprecated: ::std::option::Option<bool>,
    idempotency_level: ::std::option::Option<crate::EnumValue<self::MethodOptions_IdempotencyLevel>>,
    uninterpreted_option: crate::collections::RepeatedField<self::UninterpretedOption>,
    unknown_fields: crate::UnknownFieldSet
}
static METHOD_OPTIONS_UNINTERPRETED_OPTION_CODEC: crate::Codec<self::UninterpretedOption> = crate::Codec::message(7994);
impl crate::CodedMessage for self::MethodOptions {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                264 => self.deprecated = ::std::option::Option::Some(input.read_bool()?),
                272 => self.idempotency_level = ::std::option::Option::Some(input.read_enum_value()?),
                7994 => self.uninterpreted_option.add_entries(tag.get(), input, &METHOD_OPTIONS_UNINTERPRETED_OPTION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let deprecated = self.deprecated;
        if let ::std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::bool(deprecated);
            }
        }
        let idempotency_level = self.idempotency_level;
        if let ::std::option::Option::Some(idempotency_level) = idempotency_level {
            if idempotency_level != Self::IDEMPOTENCY_LEVEL_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::enum_value(idempotency_level);
            }
        }
        size += self.uninterpreted_option.calculate_size(&METHOD_OPTIONS_UNINTERPRETED_OPTION_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let deprecated = self.deprecated;
        if let ::std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[136, 2])?;
                output.write_bool(deprecated)?;
            }
        }
        let idempotency_level = self.idempotency_level;
        if let ::std::option::Option::Some(idempotency_level) = idempotency_level {
            if idempotency_level != Self::IDEMPOTENCY_LEVEL_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[144, 2])?;
                output.write_enum_value(idempotency_level)?;
            }
        }
        self.uninterpreted_option.write_to(output, &METHOD_OPTIONS_UNINTERPRETED_OPTION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::MethodOptions {
    fn new() -> Self {
        Self {
            deprecated: ::std::option::Option::None,
            idempotency_level: ::std::option::Option::None,
            uninterpreted_option: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
    fn merge(&mut self, other: &Self) {
        self.deprecated = other.deprecated;
        self.idempotency_level = other.idempotency_level;
        self.uninterpreted_option.merge(&other.uninterpreted_option);
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl crate::Message for self::MethodOptions {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[17]
    }
}
impl self::MethodOptions {
    /// Gets the field number of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub const DEPRECATED_FIELD_NUMBER: i32 = 33;
    /// A constant value representing the default value of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub const DEPRECATED_DEFAULT_VALUE: bool = false;
    /// Is this method deprecated?
    /// Depending on the target platform, this can emit Deprecated annotations
    /// for the method, or it will be completely ignored; in the very least,
    /// this is a formalization for deprecating methods.
    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(Self::DEPRECATED_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }
    /// Sets the value of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub fn set_deprecated(&mut self, value: bool) {
        self.deprecated = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`deprecated`] field
    ///
    /// [`deprecated`]: #method.deprecated
    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None
    }
    /// Gets the field number of the [`idempotency_level`] field
    ///
    /// [`idempotency_level`]: #method.idempotency_level
    pub const IDEMPOTENCY_LEVEL_FIELD_NUMBER: i32 = 34;
    /// A constant value representing the default value of the [`idempotency_level`] field
    ///
    /// [`idempotency_level`]: #method.idempotency_level
    pub const IDEMPOTENCY_LEVEL_DEFAULT_VALUE: crate::EnumValue<self::MethodOptions_IdempotencyLevel> = crate::EnumValue::Defined(self::MethodOptions_IdempotencyLevel::IdempotencyUnknown);
    pub fn idempotency_level(&self) -> crate::EnumValue<self::MethodOptions_IdempotencyLevel> {
        self.idempotency_level.unwrap_or(Self::IDEMPOTENCY_LEVEL_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`idempotency_level`] field
    ///
    /// [`idempotency_level`]: #method.idempotency_level
    pub fn has_idempotency_level(&self) -> bool {
        self.idempotency_level.is_some()
    }
    /// Sets the value of the [`idempotency_level`] field
    ///
    /// [`idempotency_level`]: #method.idempotency_level
    pub fn set_idempotency_level(&mut self, value: crate::EnumValue<self::MethodOptions_IdempotencyLevel>) {
        self.idempotency_level = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`idempotency_level`] field
    ///
    /// [`idempotency_level`]: #method.idempotency_level
    pub fn clear_idempotency_level(&mut self) {
        self.idempotency_level = ::std::option::Option::None
    }
    /// Gets the field number of the [`uninterpreted_option`] field
    ///
    /// [`uninterpreted_option`]: #method.uninterpreted_option
    pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
    /// The parser stores options it doesn't recognize here. See above.
    pub fn uninterpreted_option(&self) -> &crate::collections::RepeatedField<self::UninterpretedOption> {
        &self.uninterpreted_option
    }
    /// Returns a unique reference to the [`uninterpreted_option`] field
    ///
    /// [`uninterpreted_option`]: #method.uninterpreted_option
    pub fn uninterpreted_option_mut(&mut self) -> &mut crate::collections::RepeatedField<self::UninterpretedOption> {
        &mut self.uninterpreted_option
    }
}
/// Is this method side-effect-free (or safe in HTTP parlance), or idempotent,
/// or neither? HTTP based RPC implementation may choose GET verb for safe
/// methods, and PUT verb for idempotent methods instead of the default POST.
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum MethodOptions_IdempotencyLevel {
    IdempotencyUnknown = 0,
    /// implies idempotent
    NoSideEffects = 1,
    /// idempotent, but may have side effects
    Idempotent = 2,
}
impl ::std::convert::TryFrom<i32> for self::MethodOptions_IdempotencyLevel {
    type Error = crate::VariantUndefinedError;
    fn try_from(value: i32) -> ::std::result::Result<Self, crate::VariantUndefinedError> {
        match value {
            0 => ::std::result::Result::Ok(self::MethodOptions_IdempotencyLevel::IdempotencyUnknown),
            1 => ::std::result::Result::Ok(self::MethodOptions_IdempotencyLevel::NoSideEffects),
            2 => ::std::result::Result::Ok(self::MethodOptions_IdempotencyLevel::Idempotent),
            _ => ::std::result::Result::Err(crate::VariantUndefinedError)
        }
    }
}
impl ::std::convert::From<self::MethodOptions_IdempotencyLevel> for i32 {
    fn from(value: self::MethodOptions_IdempotencyLevel) -> i32 {
        value as i32
    }
}
/// A message representing a option the parser does not recognize. This only
/// appears in options protos created by the compiler::Parser class.
/// DescriptorPool resolves these when building Descriptor objects. Therefore,
/// options protos in descriptor objects (e.g. returned by Descriptor::options(),
/// or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
/// in them.
#[derive(Clone, Debug, PartialEq)]
pub struct UninterpretedOption {
    name: crate::collections::RepeatedField<self::UninterpretedOption_NamePart>,
    identifier_value: ::std::option::Option<::std::string::String>,
    positive_int_value: ::std::option::Option<u64>,
    negative_int_value: ::std::option::Option<i64>,
    double_value: ::std::option::Option<f64>,
    string_value: ::std::option::Option<::std::vec::Vec<u8>>,
    aggregate_value: ::std::option::Option<::std::string::String>,
    unknown_fields: crate::UnknownFieldSet
}
static UNINTERPRETED_OPTION_NAME_CODEC: crate::Codec<self::UninterpretedOption_NamePart> = crate::Codec::message(18);
impl crate::CodedMessage for self::UninterpretedOption {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                18 => self.name.add_entries(tag.get(), input, &UNINTERPRETED_OPTION_NAME_CODEC)?,
                26 => self.identifier_value = ::std::option::Option::Some(input.read_string()?),
                32 => self.positive_int_value = ::std::option::Option::Some(input.read_uint64()?),
                40 => self.negative_int_value = ::std::option::Option::Some(input.read_int64()?),
                49 => self.double_value = ::std::option::Option::Some(input.read_double()?),
                58 => self.string_value = ::std::option::Option::Some(input.read_bytes()?),
                66 => self.aggregate_value = ::std::option::Option::Some(input.read_string()?),
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.name.calculate_size(&UNINTERPRETED_OPTION_NAME_CODEC);
        let identifier_value = &self.identifier_value;
        if let ::std::option::Option::Some(identifier_value) = identifier_value {
            if identifier_value != Self::IDENTIFIER_VALUE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(identifier_value);
            }
        }
        let positive_int_value = self.positive_int_value;
        if let ::std::option::Option::Some(positive_int_value) = positive_int_value {
            if positive_int_value != Self::POSITIVE_INT_VALUE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::uint64(positive_int_value);
            }
        }
        let negative_int_value = self.negative_int_value;
        if let ::std::option::Option::Some(negative_int_value) = negative_int_value {
            if negative_int_value != Self::NEGATIVE_INT_VALUE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::int64(negative_int_value);
            }
        }
        let double_value = self.double_value;
        if let ::std::option::Option::Some(double_value) = double_value {
            if double_value != Self::DOUBLE_VALUE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::double(double_value);
            }
        }
        let string_value = &self.string_value;
        if let ::std::option::Option::Some(string_value) = string_value {
            if string_value.as_slice() != Self::STRING_VALUE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bytes(string_value);
            }
        }
        let aggregate_value = &self.aggregate_value;
        if let ::std::option::Option::Some(aggregate_value) = aggregate_value {
            if aggregate_value != Self::AGGREGATE_VALUE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(aggregate_value);
            }
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        self.name.write_to(output, &UNINTERPRETED_OPTION_NAME_CODEC)?;
        let identifier_value = &self.identifier_value;
        if let ::std::option::Option::Some(identifier_value) = identifier_value {
            if identifier_value != Self::IDENTIFIER_VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[26])?;
                output.write_string(identifier_value)?;
            }
        }
        let positive_int_value = self.positive_int_value;
        if let ::std::option::Option::Some(positive_int_value) = positive_int_value {
            if positive_int_value != Self::POSITIVE_INT_VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[32])?;
                output.write_uint64(positive_int_value)?;
            }
        }
        let negative_int_value = self.negative_int_value;
        if let ::std::option::Option::Some(negative_int_value) = negative_int_value {
            if negative_int_value != Self::NEGATIVE_INT_VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[40])?;
                output.write_int64(negative_int_value)?;
            }
        }
        let double_value = self.double_value;
        if let ::std::option::Option::Some(double_value) = double_value {
            if double_value != Self::DOUBLE_VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[49])?;
                output.write_double(double_value)?;
            }
        }
        let string_value = &self.string_value;
        if let ::std::option::Option::Some(string_value) = string_value {
            if string_value.as_slice() != Self::STRING_VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[58])?;
                output.write_bytes(string_value)?;
            }
        }
        let aggregate_value = &self.aggregate_value;
        if let ::std::option::Option::Some(aggregate_value) = aggregate_value {
            if aggregate_value != Self::AGGREGATE_VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[66])?;
                output.write_string(aggregate_value)?;
            }
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::UninterpretedOption {
    fn new() -> Self {
        Self {
            name: crate::collections::RepeatedField::new(),
            identifier_value: ::std::option::Option::None,
            positive_int_value: ::std::option::Option::None,
            negative_int_value: ::std::option::Option::None,
            double_value: ::std::option::Option::None,
            string_value: ::std::option::Option::None,
            aggregate_value: ::std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
    fn merge(&mut self, other: &Self) {
        self.name.merge(&other.name);
        self.identifier_value = other.identifier_value.clone();
        self.positive_int_value = other.positive_int_value;
        self.negative_int_value = other.negative_int_value;
        self.double_value = other.double_value;
        self.string_value = other.string_value.clone();
        self.aggregate_value = other.aggregate_value.clone();
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl crate::Message for self::UninterpretedOption {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[18]
    }
}
impl self::UninterpretedOption {
    /// Gets the field number of the [`name`] field
    ///
    /// [`name`]: #method.name
    pub const NAME_FIELD_NUMBER: i32 = 2;
    pub fn name(&self) -> &crate::collections::RepeatedField<self::UninterpretedOption_NamePart> {
        &self.name
    }
    /// Returns a unique reference to the [`name`] field
    ///
    /// [`name`]: #method.name
    pub fn name_mut(&mut self) -> &mut crate::collections::RepeatedField<self::UninterpretedOption_NamePart> {
        &mut self.name
    }
    /// Gets the field number of the [`identifier_value`] field
    ///
    /// [`identifier_value`]: #method.identifier_value
    pub const IDENTIFIER_VALUE_FIELD_NUMBER: i32 = 3;
    /// A constant value representing the default value of the [`identifier_value`] field
    ///
    /// [`identifier_value`]: #method.identifier_value
    pub const IDENTIFIER_VALUE_DEFAULT_VALUE: &'static str = "";
    /// The value of the uninterpreted option, in whatever type the tokenizer
    /// identified it as during parsing. Exactly one of these should be set.
    pub fn identifier_value(&self) -> &str {
        &self.identifier_value.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::IDENTIFIER_VALUE_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`identifier_value`] field
    ///
    /// [`identifier_value`]: #method.identifier_value
    pub fn identifier_value_mut(&mut self) -> &mut ::std::string::String {
        self.identifier_value.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`identifier_value`] field
    ///
    /// [`identifier_value`]: #method.identifier_value
    pub fn has_identifier_value(&self) -> bool {
        self.identifier_value.is_some()
    }
    /// Sets the value of the [`identifier_value`] field
    ///
    /// [`identifier_value`]: #method.identifier_value
    pub fn set_identifier_value(&mut self, value: ::std::string::String) {
        self.identifier_value = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`identifier_value`] field, leaving it empty
    ///
    /// [`identifier_value`]: #method.identifier_value
    pub fn take_identifier_value(&mut self) -> ::std::option::Option<::std::string::String> {
        self.identifier_value.take()
    }
    /// Clears the value of the [`identifier_value`] field
    ///
    /// [`identifier_value`]: #method.identifier_value
    pub fn clear_identifier_value(&mut self) {
        self.identifier_value = ::std::option::Option::None
    }
    /// Gets the field number of the [`positive_int_value`] field
    ///
    /// [`positive_int_value`]: #method.positive_int_value
    pub const POSITIVE_INT_VALUE_FIELD_NUMBER: i32 = 4;
    /// A constant value representing the default value of the [`positive_int_value`] field
    ///
    /// [`positive_int_value`]: #method.positive_int_value
    pub const POSITIVE_INT_VALUE_DEFAULT_VALUE: u64 = 0;
    pub fn positive_int_value(&self) -> u64 {
        self.positive_int_value.unwrap_or(Self::POSITIVE_INT_VALUE_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`positive_int_value`] field
    ///
    /// [`positive_int_value`]: #method.positive_int_value
    pub fn has_positive_int_value(&self) -> bool {
        self.positive_int_value.is_some()
    }
    /// Sets the value of the [`positive_int_value`] field
    ///
    /// [`positive_int_value`]: #method.positive_int_value
    pub fn set_positive_int_value(&mut self, value: u64) {
        self.positive_int_value = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`positive_int_value`] field
    ///
    /// [`positive_int_value`]: #method.positive_int_value
    pub fn clear_positive_int_value(&mut self) {
        self.positive_int_value = ::std::option::Option::None
    }
    /// Gets the field number of the [`negative_int_value`] field
    ///
    /// [`negative_int_value`]: #method.negative_int_value
    pub const NEGATIVE_INT_VALUE_FIELD_NUMBER: i32 = 5;
    /// A constant value representing the default value of the [`negative_int_value`] field
    ///
    /// [`negative_int_value`]: #method.negative_int_value
    pub const NEGATIVE_INT_VALUE_DEFAULT_VALUE: i64 = 0;
    pub fn negative_int_value(&self) -> i64 {
        self.negative_int_value.unwrap_or(Self::NEGATIVE_INT_VALUE_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`negative_int_value`] field
    ///
    /// [`negative_int_value`]: #method.negative_int_value
    pub fn has_negative_int_value(&self) -> bool {
        self.negative_int_value.is_some()
    }
    /// Sets the value of the [`negative_int_value`] field
    ///
    /// [`negative_int_value`]: #method.negative_int_value
    pub fn set_negative_int_value(&mut self, value: i64) {
        self.negative_int_value = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`negative_int_value`] field
    ///
    /// [`negative_int_value`]: #method.negative_int_value
    pub fn clear_negative_int_value(&mut self) {
        self.negative_int_value = ::std::option::Option::None
    }
    /// Gets the field number of the [`double_value`] field
    ///
    /// [`double_value`]: #method.double_value
    pub const DOUBLE_VALUE_FIELD_NUMBER: i32 = 6;
    /// A constant value representing the default value of the [`double_value`] field
    ///
    /// [`double_value`]: #method.double_value
    pub const DOUBLE_VALUE_DEFAULT_VALUE: f64 = 0.0;
    pub fn double_value(&self) -> f64 {
        self.double_value.unwrap_or(Self::DOUBLE_VALUE_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`double_value`] field
    ///
    /// [`double_value`]: #method.double_value
    pub fn has_double_value(&self) -> bool {
        self.double_value.is_some()
    }
    /// Sets the value of the [`double_value`] field
    ///
    /// [`double_value`]: #method.double_value
    pub fn set_double_value(&mut self, value: f64) {
        self.double_value = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`double_value`] field
    ///
    /// [`double_value`]: #method.double_value
    pub fn clear_double_value(&mut self) {
        self.double_value = ::std::option::Option::None
    }
    /// Gets the field number of the [`string_value`] field
    ///
    /// [`string_value`]: #method.string_value
    pub const STRING_VALUE_FIELD_NUMBER: i32 = 7;
    /// A constant value representing the default value of the [`string_value`] field
    ///
    /// [`string_value`]: #method.string_value
    pub const STRING_VALUE_DEFAULT_VALUE: &'static [u8] = &[];
    pub fn string_value(&self) -> &[u8] {
        &self.string_value.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::STRING_VALUE_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`string_value`] field
    ///
    /// [`string_value`]: #method.string_value
    pub fn string_value_mut(&mut self) -> &mut ::std::vec::Vec<u8> {
        self.string_value.get_or_insert_with(::std::vec::Vec::new)
    }
    /// Returns a bool indicating the presence of the [`string_value`] field
    ///
    /// [`string_value`]: #method.string_value
    pub fn has_string_value(&self) -> bool {
        self.string_value.is_some()
    }
    /// Sets the value of the [`string_value`] field
    ///
    /// [`string_value`]: #method.string_value
    pub fn set_string_value(&mut self, value: ::std::vec::Vec<u8>) {
        self.string_value = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`string_value`] field, leaving it empty
    ///
    /// [`string_value`]: #method.string_value
    pub fn take_string_value(&mut self) -> ::std::option::Option<::std::vec::Vec<u8>> {
        self.string_value.take()
    }
    /// Clears the value of the [`string_value`] field
    ///
    /// [`string_value`]: #method.string_value
    pub fn clear_string_value(&mut self) {
        self.string_value = ::std::option::Option::None
    }
    /// Gets the field number of the [`aggregate_value`] field
    ///
    /// [`aggregate_value`]: #method.aggregate_value
    pub const AGGREGATE_VALUE_FIELD_NUMBER: i32 = 8;
    /// A constant value representing the default value of the [`aggregate_value`] field
    ///
    /// [`aggregate_value`]: #method.aggregate_value
    pub const AGGREGATE_VALUE_DEFAULT_VALUE: &'static str = "";
    pub fn aggregate_value(&self) -> &str {
        &self.aggregate_value.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::AGGREGATE_VALUE_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`aggregate_value`] field
    ///
    /// [`aggregate_value`]: #method.aggregate_value
    pub fn aggregate_value_mut(&mut self) -> &mut ::std::string::String {
        self.aggregate_value.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`aggregate_value`] field
    ///
    /// [`aggregate_value`]: #method.aggregate_value
    pub fn has_aggregate_value(&self) -> bool {
        self.aggregate_value.is_some()
    }
    /// Sets the value of the [`aggregate_value`] field
    ///
    /// [`aggregate_value`]: #method.aggregate_value
    pub fn set_aggregate_value(&mut self, value: ::std::string::String) {
        self.aggregate_value = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`aggregate_value`] field, leaving it empty
    ///
    /// [`aggregate_value`]: #method.aggregate_value
    pub fn take_aggregate_value(&mut self) -> ::std::option::Option<::std::string::String> {
        self.aggregate_value.take()
    }
    /// Clears the value of the [`aggregate_value`] field
    ///
    /// [`aggregate_value`]: #method.aggregate_value
    pub fn clear_aggregate_value(&mut self) {
        self.aggregate_value = ::std::option::Option::None
    }
}
/// The name of the uninterpreted option.  Each string represents a segment in
/// a dot-separated name.  is_extension is true iff a segment represents an
/// extension (denoted with parentheses in options specs in .proto files).
/// E.g.,{ ["foo", false], ["bar.baz", true], ["qux", false] } represents
/// "foo.(bar.baz).qux".
#[derive(Clone, Debug, PartialEq)]
pub struct UninterpretedOption_NamePart {
    name_part: ::std::option::Option<::std::string::String>,
    is_extension: ::std::option::Option<bool>,
    unknown_fields: crate::UnknownFieldSet
}
impl crate::CodedMessage for self::UninterpretedOption_NamePart {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.name_part = ::std::option::Option::Some(input.read_string()?),
                16 => self.is_extension = ::std::option::Option::Some(input.read_bool()?),
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let name_part = &self.name_part;
        if let ::std::option::Option::Some(name_part) = name_part {
            if name_part != Self::NAME_PART_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(name_part);
            }
        }
        let is_extension = self.is_extension;
        if let ::std::option::Option::Some(is_extension) = is_extension {
            if is_extension != Self::IS_EXTENSION_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(is_extension);
            }
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let name_part = &self.name_part;
        if let ::std::option::Option::Some(name_part) = name_part {
            if name_part != Self::NAME_PART_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name_part)?;
            }
        }
        let is_extension = self.is_extension;
        if let ::std::option::Option::Some(is_extension) = is_extension {
            if is_extension != Self::IS_EXTENSION_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_bool(is_extension)?;
            }
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::UninterpretedOption_NamePart {
    fn new() -> Self {
        Self {
            name_part: ::std::option::Option::None,
            is_extension: ::std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
    fn merge(&mut self, other: &Self) {
        self.name_part = other.name_part.clone();
        self.is_extension = other.is_extension;
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl crate::Message for self::UninterpretedOption_NamePart {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[18].messages()[0]
    }
}
impl self::UninterpretedOption_NamePart {
    /// Gets the field number of the [`name_part`] field
    ///
    /// [`name_part`]: #method.name_part
    pub const NAME_PART_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`name_part`] field
    ///
    /// [`name_part`]: #method.name_part
    pub const NAME_PART_DEFAULT_VALUE: &'static str = "";
    pub fn name_part(&self) -> &str {
        &self.name_part.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::NAME_PART_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`name_part`] field
    ///
    /// [`name_part`]: #method.name_part
    pub fn name_part_mut(&mut self) -> &mut ::std::string::String {
        self.name_part.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`name_part`] field
    ///
    /// [`name_part`]: #method.name_part
    pub fn has_name_part(&self) -> bool {
        self.name_part.is_some()
    }
    /// Sets the value of the [`name_part`] field
    ///
    /// [`name_part`]: #method.name_part
    pub fn set_name_part(&mut self, value: ::std::string::String) {
        self.name_part = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`name_part`] field, leaving it empty
    ///
    /// [`name_part`]: #method.name_part
    pub fn take_name_part(&mut self) -> ::std::option::Option<::std::string::String> {
        self.name_part.take()
    }
    /// Clears the value of the [`name_part`] field
    ///
    /// [`name_part`]: #method.name_part
    pub fn clear_name_part(&mut self) {
        self.name_part = ::std::option::Option::None
    }
    /// Gets the field number of the [`is_extension`] field
    ///
    /// [`is_extension`]: #method.is_extension
    pub const IS_EXTENSION_FIELD_NUMBER: i32 = 2;
    /// A constant value representing the default value of the [`is_extension`] field
    ///
    /// [`is_extension`]: #method.is_extension
    pub const IS_EXTENSION_DEFAULT_VALUE: bool = false;
    pub fn is_extension(&self) -> bool {
        self.is_extension.unwrap_or(Self::IS_EXTENSION_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`is_extension`] field
    ///
    /// [`is_extension`]: #method.is_extension
    pub fn has_is_extension(&self) -> bool {
        self.is_extension.is_some()
    }
    /// Sets the value of the [`is_extension`] field
    ///
    /// [`is_extension`]: #method.is_extension
    pub fn set_is_extension(&mut self, value: bool) {
        self.is_extension = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`is_extension`] field
    ///
    /// [`is_extension`]: #method.is_extension
    pub fn clear_is_extension(&mut self) {
        self.is_extension = ::std::option::Option::None
    }
}
/// Encapsulates information about the original source file from which a
/// FileDescriptorProto was generated.
#[derive(Clone, Debug, PartialEq)]
pub struct SourceCodeInfo {
    location: crate::collections::RepeatedField<self::SourceCodeInfo_Location>,
    unknown_fields: crate::UnknownFieldSet
}
static SOURCE_CODE_INFO_LOCATION_CODEC: crate::Codec<self::SourceCodeInfo_Location> = crate::Codec::message(10);
impl crate::CodedMessage for self::SourceCodeInfo {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.location.add_entries(tag.get(), input, &SOURCE_CODE_INFO_LOCATION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.location.calculate_size(&SOURCE_CODE_INFO_LOCATION_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        self.location.write_to(output, &SOURCE_CODE_INFO_LOCATION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::SourceCodeInfo {
    fn new() -> Self {
        Self {
            location: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
    fn merge(&mut self, other: &Self) {
        self.location.merge(&other.location);
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl crate::Message for self::SourceCodeInfo {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[19]
    }
}
impl self::SourceCodeInfo {
    /// Gets the field number of the [`location`] field
    ///
    /// [`location`]: #method.location
    pub const LOCATION_FIELD_NUMBER: i32 = 1;
    /// A Location identifies a piece of source code in a .proto file which
    /// corresponds to a particular definition.  This information is intended
    /// to be useful to IDEs, code indexers, documentation generators, and similar
    /// tools.
    ///
    /// For example, say we have a file like:
    ///   message Foo {
    ///     optional string foo = 1;
    ///   }
    /// Let's look at just the field definition:
    ///   optional string foo = 1;
    ///   ^       ^^     ^^  ^  ^^^
    ///   a       bc     de  f  ghi
    /// We have the following locations:
    ///   span   path               represents
    ///   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
    ///   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
    ///   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
    ///   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
    ///   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
    ///
    /// Notes:
    /// - A location may refer to a repeated field itself (i.e. not to any
    ///   particular index within it).  This is used whenever a set of elements are
    ///   logically enclosed in a single code segment.  For example, an entire
    ///   extend block (possibly containing multiple extension definitions) will
    ///   have an outer location whose path refers to the "extensions" repeated
    ///   field without an index.
    /// - Multiple locations may have the same path.  This happens when a single
    ///   logical declaration is spread out across multiple places.  The most
    ///   obvious example is the "extend" block again -- there may be multiple
    ///   extend blocks in the same scope, each of which will have the same path.
    /// - A location's span is not always a subset of its parent's span.  For
    ///   example, the "extendee" of an extension declaration appears at the
    ///   beginning of the "extend" block and is shared by all extensions within
    ///   the block.
    /// - Just because a location's span is a subset of some other location's span
    ///   does not mean that it is a descendent.  For example, a "group" defines
    ///   both a type and a field in a single declaration.  Thus, the locations
    ///   corresponding to the type and field and their components will overlap.
    /// - Code which tries to interpret locations should probably be designed to
    ///   ignore those that it doesn't understand, as more types of locations could
    ///   be recorded in the future.
    pub fn location(&self) -> &crate::collections::RepeatedField<self::SourceCodeInfo_Location> {
        &self.location
    }
    /// Returns a unique reference to the [`location`] field
    ///
    /// [`location`]: #method.location
    pub fn location_mut(&mut self) -> &mut crate::collections::RepeatedField<self::SourceCodeInfo_Location> {
        &mut self.location
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct SourceCodeInfo_Location {
    path: crate::collections::RepeatedField<i32>,
    span: crate::collections::RepeatedField<i32>,
    leading_comments: ::std::option::Option<::std::string::String>,
    trailing_comments: ::std::option::Option<::std::string::String>,
    leading_detached_comments: crate::collections::RepeatedField<::std::string::String>,
    unknown_fields: crate::UnknownFieldSet
}
static SOURCE_CODE_INFO__LOCATION_PATH_CODEC: crate::Codec<i32> = crate::Codec::int32(10);
static SOURCE_CODE_INFO__LOCATION_SPAN_CODEC: crate::Codec<i32> = crate::Codec::int32(18);
static SOURCE_CODE_INFO__LOCATION_LEADING_DETACHED_COMMENTS_CODEC: crate::Codec<::std::string::String> = crate::Codec::string(50);
impl crate::CodedMessage for self::SourceCodeInfo_Location {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 | 10 => self.path.add_entries(tag.get(), input, &SOURCE_CODE_INFO__LOCATION_PATH_CODEC)?,
                16 | 18 => self.span.add_entries(tag.get(), input, &SOURCE_CODE_INFO__LOCATION_SPAN_CODEC)?,
                26 => self.leading_comments = ::std::option::Option::Some(input.read_string()?),
                34 => self.trailing_comments = ::std::option::Option::Some(input.read_string()?),
                50 => self.leading_detached_comments.add_entries(tag.get(), input, &SOURCE_CODE_INFO__LOCATION_LEADING_DETACHED_COMMENTS_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.path.calculate_size(&SOURCE_CODE_INFO__LOCATION_PATH_CODEC);
        size += self.span.calculate_size(&SOURCE_CODE_INFO__LOCATION_SPAN_CODEC);
        let leading_comments = &self.leading_comments;
        if let ::std::option::Option::Some(leading_comments) = leading_comments {
            if leading_comments != Self::LEADING_COMMENTS_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(leading_comments);
            }
        }
        let trailing_comments = &self.trailing_comments;
        if let ::std::option::Option::Some(trailing_comments) = trailing_comments {
            if trailing_comments != Self::TRAILING_COMMENTS_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(trailing_comments);
            }
        }
        size += self.leading_detached_comments.calculate_size(&SOURCE_CODE_INFO__LOCATION_LEADING_DETACHED_COMMENTS_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        self.path.write_to(output, &SOURCE_CODE_INFO__LOCATION_PATH_CODEC)?;
        self.span.write_to(output, &SOURCE_CODE_INFO__LOCATION_SPAN_CODEC)?;
        let leading_comments = &self.leading_comments;
        if let ::std::option::Option::Some(leading_comments) = leading_comments {
            if leading_comments != Self::LEADING_COMMENTS_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[26])?;
                output.write_string(leading_comments)?;
            }
        }
        let trailing_comments = &self.trailing_comments;
        if let ::std::option::Option::Some(trailing_comments) = trailing_comments {
            if trailing_comments != Self::TRAILING_COMMENTS_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[34])?;
                output.write_string(trailing_comments)?;
            }
        }
        self.leading_detached_comments.write_to(output, &SOURCE_CODE_INFO__LOCATION_LEADING_DETACHED_COMMENTS_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::SourceCodeInfo_Location {
    fn new() -> Self {
        Self {
            path: crate::collections::RepeatedField::new(),
            span: crate::collections::RepeatedField::new(),
            leading_comments: ::std::option::Option::None,
            trailing_comments: ::std::option::Option::None,
            leading_detached_comments: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
    fn merge(&mut self, other: &Self) {
        self.path.merge(&other.path);
        self.span.merge(&other.span);
        self.leading_comments = other.leading_comments.clone();
        self.trailing_comments = other.trailing_comments.clone();
        self.leading_detached_comments.merge(&other.leading_detached_comments);
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl crate::Message for self::SourceCodeInfo_Location {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[19].messages()[0]
    }
}
impl self::SourceCodeInfo_Location {
    /// Gets the field number of the [`path`] field
    ///
    /// [`path`]: #method.path
    pub const PATH_FIELD_NUMBER: i32 = 1;
    /// Identifies which part of the FileDescriptorProto was defined at this
    /// location.
    ///
    /// Each element is a field number or an index.  They form a path from
    /// the root FileDescriptorProto to the place where the definition.  For
    /// example, this path:
    ///   [ 4, 3, 2, 7, 1 ]
    /// refers to:
    ///   file.message_type(3)  // 4, 3
    ///       .field(7)         // 2, 7
    ///       .name()           // 1
    /// This is because FileDescriptorProto.message_type has field number 4:
    ///   repeated DescriptorProto message_type = 4;
    /// and DescriptorProto.field has field number 2:
    ///   repeated FieldDescriptorProto field = 2;
    /// and FieldDescriptorProto.name has field number 1:
    ///   optional string name = 1;
    ///
    /// Thus, the above path gives the location of a field name.  If we removed
    /// the last element:
    ///   [ 4, 3, 2, 7 ]
    /// this path refers to the whole field declaration (from the beginning
    /// of the label to the terminating semicolon).
    pub fn path(&self) -> &crate::collections::RepeatedField<i32> {
        &self.path
    }
    /// Returns a unique reference to the [`path`] field
    ///
    /// [`path`]: #method.path
    pub fn path_mut(&mut self) -> &mut crate::collections::RepeatedField<i32> {
        &mut self.path
    }
    /// Gets the field number of the [`span`] field
    ///
    /// [`span`]: #method.span
    pub const SPAN_FIELD_NUMBER: i32 = 2;
    /// Always has exactly three or four elements: start line, start column,
    /// end line (optional, otherwise assumed same as start line), end column.
    /// These are packed into a single field for efficiency.  Note that line
    /// and column numbers are zero-based -- typically you will want to add
    /// 1 to each before displaying to a user.
    pub fn span(&self) -> &crate::collections::RepeatedField<i32> {
        &self.span
    }
    /// Returns a unique reference to the [`span`] field
    ///
    /// [`span`]: #method.span
    pub fn span_mut(&mut self) -> &mut crate::collections::RepeatedField<i32> {
        &mut self.span
    }
    /// Gets the field number of the [`leading_comments`] field
    ///
    /// [`leading_comments`]: #method.leading_comments
    pub const LEADING_COMMENTS_FIELD_NUMBER: i32 = 3;
    /// A constant value representing the default value of the [`leading_comments`] field
    ///
    /// [`leading_comments`]: #method.leading_comments
    pub const LEADING_COMMENTS_DEFAULT_VALUE: &'static str = "";
    /// If this SourceCodeInfo represents a complete declaration, these are any
    /// comments appearing before and after the declaration which appear to be
    /// attached to the declaration.
    ///
    /// A series of line comments appearing on consecutive lines, with no other
    /// tokens appearing on those lines, will be treated as a single comment.
    ///
    /// leading_detached_comments will keep paragraphs of comments that appear
    /// before (but not connected to) the current element. Each paragraph,
    /// separated by empty lines, will be one comment element in the repeated
    /// field.
    ///
    /// Only the comment content is provided; comment markers (e.g. //) are
    /// stripped out.  For block comments, leading whitespace and an asterisk
    /// will be stripped from the beginning of each line other than the first.
    /// Newlines are included in the output.
    ///
    /// Examples:
    ///
    ///   optional int32 foo = 1;  // Comment attached to foo.
    ///   // Comment attached to bar.
    ///   optional int32 bar = 2;
    ///
    ///   optional string baz = 3;
    ///   // Comment attached to baz.
    ///   // Another line attached to baz.
    ///
    ///   // Comment attached to qux.
    ///   //
    ///   // Another line attached to qux.
    ///   optional double qux = 4;
    ///
    ///   // Detached comment for corge. This is not leading or trailing comments
    ///   // to qux or corge because there are blank lines separating it from
    ///   // both.
    ///
    ///   // Detached comment for corge paragraph 2.
    ///
    ///   optional string corge = 5;
    ///   /* Block comment attached
    ///    * to corge.  Leading asterisks
    ///    * will be removed. */
    ///   /* Block comment attached to
    ///    * grault. */
    ///   optional int32 grault = 6;
    ///
    ///   // ignored detached comments.
    pub fn leading_comments(&self) -> &str {
        &self.leading_comments.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::LEADING_COMMENTS_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`leading_comments`] field
    ///
    /// [`leading_comments`]: #method.leading_comments
    pub fn leading_comments_mut(&mut self) -> &mut ::std::string::String {
        self.leading_comments.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`leading_comments`] field
    ///
    /// [`leading_comments`]: #method.leading_comments
    pub fn has_leading_comments(&self) -> bool {
        self.leading_comments.is_some()
    }
    /// Sets the value of the [`leading_comments`] field
    ///
    /// [`leading_comments`]: #method.leading_comments
    pub fn set_leading_comments(&mut self, value: ::std::string::String) {
        self.leading_comments = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`leading_comments`] field, leaving it empty
    ///
    /// [`leading_comments`]: #method.leading_comments
    pub fn take_leading_comments(&mut self) -> ::std::option::Option<::std::string::String> {
        self.leading_comments.take()
    }
    /// Clears the value of the [`leading_comments`] field
    ///
    /// [`leading_comments`]: #method.leading_comments
    pub fn clear_leading_comments(&mut self) {
        self.leading_comments = ::std::option::Option::None
    }
    /// Gets the field number of the [`trailing_comments`] field
    ///
    /// [`trailing_comments`]: #method.trailing_comments
    pub const TRAILING_COMMENTS_FIELD_NUMBER: i32 = 4;
    /// A constant value representing the default value of the [`trailing_comments`] field
    ///
    /// [`trailing_comments`]: #method.trailing_comments
    pub const TRAILING_COMMENTS_DEFAULT_VALUE: &'static str = "";
    pub fn trailing_comments(&self) -> &str {
        &self.trailing_comments.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::TRAILING_COMMENTS_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`trailing_comments`] field
    ///
    /// [`trailing_comments`]: #method.trailing_comments
    pub fn trailing_comments_mut(&mut self) -> &mut ::std::string::String {
        self.trailing_comments.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`trailing_comments`] field
    ///
    /// [`trailing_comments`]: #method.trailing_comments
    pub fn has_trailing_comments(&self) -> bool {
        self.trailing_comments.is_some()
    }
    /// Sets the value of the [`trailing_comments`] field
    ///
    /// [`trailing_comments`]: #method.trailing_comments
    pub fn set_trailing_comments(&mut self, value: ::std::string::String) {
        self.trailing_comments = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`trailing_comments`] field, leaving it empty
    ///
    /// [`trailing_comments`]: #method.trailing_comments
    pub fn take_trailing_comments(&mut self) -> ::std::option::Option<::std::string::String> {
        self.trailing_comments.take()
    }
    /// Clears the value of the [`trailing_comments`] field
    ///
    /// [`trailing_comments`]: #method.trailing_comments
    pub fn clear_trailing_comments(&mut self) {
        self.trailing_comments = ::std::option::Option::None
    }
    /// Gets the field number of the [`leading_detached_comments`] field
    ///
    /// [`leading_detached_comments`]: #method.leading_detached_comments
    pub const LEADING_DETACHED_COMMENTS_FIELD_NUMBER: i32 = 6;
    pub fn leading_detached_comments(&self) -> &crate::collections::RepeatedField<::std::string::String> {
        &self.leading_detached_comments
    }
    /// Returns a unique reference to the [`leading_detached_comments`] field
    ///
    /// [`leading_detached_comments`]: #method.leading_detached_comments
    pub fn leading_detached_comments_mut(&mut self) -> &mut crate::collections::RepeatedField<::std::string::String> {
        &mut self.leading_detached_comments
    }
}
/// Describes the relationship between generated code and its original source
/// file. A GeneratedCodeInfo message is associated with only one generated
/// source file, but may contain references to different source .proto files.
#[derive(Clone, Debug, PartialEq)]
pub struct GeneratedCodeInfo {
    annotation: crate::collections::RepeatedField<self::GeneratedCodeInfo_Annotation>,
    unknown_fields: crate::UnknownFieldSet
}
static GENERATED_CODE_INFO_ANNOTATION_CODEC: crate::Codec<self::GeneratedCodeInfo_Annotation> = crate::Codec::message(10);
impl crate::CodedMessage for self::GeneratedCodeInfo {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.annotation.add_entries(tag.get(), input, &GENERATED_CODE_INFO_ANNOTATION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.annotation.calculate_size(&GENERATED_CODE_INFO_ANNOTATION_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        self.annotation.write_to(output, &GENERATED_CODE_INFO_ANNOTATION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::GeneratedCodeInfo {
    fn new() -> Self {
        Self {
            annotation: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
    fn merge(&mut self, other: &Self) {
        self.annotation.merge(&other.annotation);
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl crate::Message for self::GeneratedCodeInfo {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[20]
    }
}
impl self::GeneratedCodeInfo {
    /// Gets the field number of the [`annotation`] field
    ///
    /// [`annotation`]: #method.annotation
    pub const ANNOTATION_FIELD_NUMBER: i32 = 1;
    /// An Annotation connects some span of text in generated code to an element
    /// of its generating .proto file.
    pub fn annotation(&self) -> &crate::collections::RepeatedField<self::GeneratedCodeInfo_Annotation> {
        &self.annotation
    }
    /// Returns a unique reference to the [`annotation`] field
    ///
    /// [`annotation`]: #method.annotation
    pub fn annotation_mut(&mut self) -> &mut crate::collections::RepeatedField<self::GeneratedCodeInfo_Annotation> {
        &mut self.annotation
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct GeneratedCodeInfo_Annotation {
    path: crate::collections::RepeatedField<i32>,
    source_file: ::std::option::Option<::std::string::String>,
    begin: ::std::option::Option<i32>,
    end: ::std::option::Option<i32>,
    unknown_fields: crate::UnknownFieldSet
}
static GENERATED_CODE_INFO__ANNOTATION_PATH_CODEC: crate::Codec<i32> = crate::Codec::int32(10);
impl crate::CodedMessage for self::GeneratedCodeInfo_Annotation {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 | 10 => self.path.add_entries(tag.get(), input, &GENERATED_CODE_INFO__ANNOTATION_PATH_CODEC)?,
                18 => self.source_file = ::std::option::Option::Some(input.read_string()?),
                24 => self.begin = ::std::option::Option::Some(input.read_int32()?),
                32 => self.end = ::std::option::Option::Some(input.read_int32()?),
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.path.calculate_size(&GENERATED_CODE_INFO__ANNOTATION_PATH_CODEC);
        let source_file = &self.source_file;
        if let ::std::option::Option::Some(source_file) = source_file {
            if source_file != Self::SOURCE_FILE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(source_file);
            }
        }
        let begin = self.begin;
        if let ::std::option::Option::Some(begin) = begin {
            if begin != Self::BEGIN_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::int32(begin);
            }
        }
        let end = self.end;
        if let ::std::option::Option::Some(end) = end {
            if end != Self::END_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::int32(end);
            }
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        self.path.write_to(output, &GENERATED_CODE_INFO__ANNOTATION_PATH_CODEC)?;
        let source_file = &self.source_file;
        if let ::std::option::Option::Some(source_file) = source_file {
            if source_file != Self::SOURCE_FILE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[18])?;
                output.write_string(source_file)?;
            }
        }
        let begin = self.begin;
        if let ::std::option::Option::Some(begin) = begin {
            if begin != Self::BEGIN_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[24])?;
                output.write_int32(begin)?;
            }
        }
        let end = self.end;
        if let ::std::option::Option::Some(end) = end {
            if end != Self::END_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[32])?;
                output.write_int32(end)?;
            }
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::GeneratedCodeInfo_Annotation {
    fn new() -> Self {
        Self {
            path: crate::collections::RepeatedField::new(),
            source_file: ::std::option::Option::None,
            begin: ::std::option::Option::None,
            end: ::std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
    fn merge(&mut self, other: &Self) {
        self.path.merge(&other.path);
        self.source_file = other.source_file.clone();
        self.begin = other.begin;
        self.end = other.end;
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl crate::Message for self::GeneratedCodeInfo_Annotation {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[20].messages()[0]
    }
}
impl self::GeneratedCodeInfo_Annotation {
    /// Gets the field number of the [`path`] field
    ///
    /// [`path`]: #method.path
    pub const PATH_FIELD_NUMBER: i32 = 1;
    /// Identifies the element in the original source .proto file. This field
    /// is formatted the same as SourceCodeInfo.Location.path.
    pub fn path(&self) -> &crate::collections::RepeatedField<i32> {
        &self.path
    }
    /// Returns a unique reference to the [`path`] field
    ///
    /// [`path`]: #method.path
    pub fn path_mut(&mut self) -> &mut crate::collections::RepeatedField<i32> {
        &mut self.path
    }
    /// Gets the field number of the [`source_file`] field
    ///
    /// [`source_file`]: #method.source_file
    pub const SOURCE_FILE_FIELD_NUMBER: i32 = 2;
    /// A constant value representing the default value of the [`source_file`] field
    ///
    /// [`source_file`]: #method.source_file
    pub const SOURCE_FILE_DEFAULT_VALUE: &'static str = "";
    /// Identifies the filesystem path to the original source .proto.
    pub fn source_file(&self) -> &str {
        &self.source_file.as_ref().map(::std::convert::AsRef::as_ref).unwrap_or(Self::SOURCE_FILE_DEFAULT_VALUE)
    }
    /// Returns a unique reference to the [`source_file`] field
    ///
    /// [`source_file`]: #method.source_file
    pub fn source_file_mut(&mut self) -> &mut ::std::string::String {
        self.source_file.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`source_file`] field
    ///
    /// [`source_file`]: #method.source_file
    pub fn has_source_file(&self) -> bool {
        self.source_file.is_some()
    }
    /// Sets the value of the [`source_file`] field
    ///
    /// [`source_file`]: #method.source_file
    pub fn set_source_file(&mut self, value: ::std::string::String) {
        self.source_file = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`source_file`] field, leaving it empty
    ///
    /// [`source_file`]: #method.source_file
    pub fn take_source_file(&mut self) -> ::std::option::Option<::std::string::String> {
        self.source_file.take()
    }
    /// Clears the value of the [`source_file`] field
    ///
    /// [`source_file`]: #method.source_file
    pub fn clear_source_file(&mut self) {
        self.source_file = ::std::option::Option::None
    }
    /// Gets the field number of the [`begin`] field
    ///
    /// [`begin`]: #method.begin
    pub const BEGIN_FIELD_NUMBER: i32 = 3;
    /// A constant value representing the default value of the [`begin`] field
    ///
    /// [`begin`]: #method.begin
    pub const BEGIN_DEFAULT_VALUE: i32 = 0;
    /// Identifies the starting offset in bytes in the generated code
    /// that relates to the identified object.
    pub fn begin(&self) -> i32 {
        self.begin.unwrap_or(Self::BEGIN_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`begin`] field
    ///
    /// [`begin`]: #method.begin
    pub fn has_begin(&self) -> bool {
        self.begin.is_some()
    }
    /// Sets the value of the [`begin`] field
    ///
    /// [`begin`]: #method.begin
    pub fn set_begin(&mut self, value: i32) {
        self.begin = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`begin`] field
    ///
    /// [`begin`]: #method.begin
    pub fn clear_begin(&mut self) {
        self.begin = ::std::option::Option::None
    }
    /// Gets the field number of the [`end`] field
    ///
    /// [`end`]: #method.end
    pub const END_FIELD_NUMBER: i32 = 4;
    /// A constant value representing the default value of the [`end`] field
    ///
    /// [`end`]: #method.end
    pub const END_DEFAULT_VALUE: i32 = 0;
    /// Identifies the ending offset in bytes in the generated code that
    /// relates to the identified offset. The end offset should be one past
    /// the last relevant byte (so the length of the text = end - begin).
    pub fn end(&self) -> i32 {
        self.end.unwrap_or(Self::END_DEFAULT_VALUE)
    }
    /// Returns a bool indicating the presence of the [`end`] field
    ///
    /// [`end`]: #method.end
    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }
    /// Sets the value of the [`end`] field
    ///
    /// [`end`]: #method.end
    pub fn set_end(&mut self, value: i32) {
        self.end = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`end`] field
    ///
    /// [`end`]: #method.end
    pub fn clear_end(&mut self) {
        self.end = ::std::option::Option::None
    }
}