//! DO NOT EDIT!
//! Generated by protoc-gen-rust, part of the protrust crate.
//!
//! Source: google/protobuf/descriptor.proto

static FILE_ONCE: ::std::sync::Once = ::std::sync::Once::new();
static mut FILE_POOL: ::std::option::Option<crate::reflect::DescriptorPool<'static>> = ::std::option::Option::None;
static mut FILE_PROTO: ::std::option::Option<[crate::descriptor::FileDescriptorProto; 1]> = ::std::option::Option::None;
static mut FILE_DESCRIPTOR: ::std::option::Option<&'static crate::reflect::FileDescriptor> = ::std::option::Option::None;
static mut FILE_DEPS: ::std::option::Option<[&'static crate::reflect::DescriptorPool<'static>; 0]> = ::std::option::Option::None;

fn file_once_init() {
    unsafe {
        FILE_PROTO = ::std::option::Option::Some([crate::LiteMessage::read_new(&mut [
            10, 32, 103, 111, 111, 103, 108, 101, 47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 100, 101, 
            115, 99, 114, 105, 112, 116, 111, 114, 46, 112, 114, 111, 116, 111, 18, 15, 103, 111, 111, 103, 
            108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 34, 77, 10, 17, 70, 105, 108, 101, 68, 
            101, 115, 99, 114, 105, 112, 116, 111, 114, 83, 101, 116, 18, 56, 10, 4, 102, 105, 108, 101, 
            24, 1, 32, 3, 40, 11, 50, 36, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 
            111, 98, 117, 102, 46, 70, 105, 108, 101, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 
            114, 111, 116, 111, 82, 4, 102, 105, 108, 101, 34, 228, 4, 10, 19, 70, 105, 108, 101, 68, 
            101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 18, 18, 10, 4, 110, 97, 
            109, 101, 24, 1, 32, 1, 40, 9, 82, 4, 110, 97, 109, 101, 18, 24, 10, 7, 112, 97, 
            99, 107, 97, 103, 101, 24, 2, 32, 1, 40, 9, 82, 7, 112, 97, 99, 107, 97, 103, 101, 
            18, 30, 10, 10, 100, 101, 112, 101, 110, 100, 101, 110, 99, 121, 24, 3, 32, 3, 40, 9, 
            82, 10, 100, 101, 112, 101, 110, 100, 101, 110, 99, 121, 18, 43, 10, 17, 112, 117, 98, 108, 
            105, 99, 95, 100, 101, 112, 101, 110, 100, 101, 110, 99, 121, 24, 10, 32, 3, 40, 5, 82, 
            16, 112, 117, 98, 108, 105, 99, 68, 101, 112, 101, 110, 100, 101, 110, 99, 121, 18, 39, 10, 
            15, 119, 101, 97, 107, 95, 100, 101, 112, 101, 110, 100, 101, 110, 99, 121, 24, 11, 32, 3, 
            40, 5, 82, 14, 119, 101, 97, 107, 68, 101, 112, 101, 110, 100, 101, 110, 99, 121, 18, 67, 
            10, 12, 109, 101, 115, 115, 97, 103, 101, 95, 116, 121, 112, 101, 24, 4, 32, 3, 40, 11, 
            50, 32, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 68, 
            101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 82, 11, 109, 101, 115, 115, 
            97, 103, 101, 84, 121, 112, 101, 18, 65, 10, 9, 101, 110, 117, 109, 95, 116, 121, 112, 101, 
            24, 5, 32, 3, 40, 11, 50, 36, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 
            111, 98, 117, 102, 46, 69, 110, 117, 109, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 
            114, 111, 116, 111, 82, 8, 101, 110, 117, 109, 84, 121, 112, 101, 18, 65, 10, 7, 115, 101, 
            114, 118, 105, 99, 101, 24, 6, 32, 3, 40, 11, 50, 39, 46, 103, 111, 111, 103, 108, 101, 
            46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 83, 101, 114, 118, 105, 99, 101, 68, 101, 115, 
            99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 82, 7, 115, 101, 114, 118, 105, 99, 
            101, 18, 67, 10, 9, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 7, 32, 3, 40, 11, 
            50, 37, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 70, 
            105, 101, 108, 100, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 82, 
            9, 101, 120, 116, 101, 110, 115, 105, 111, 110, 18, 54, 10, 7, 111, 112, 116, 105, 111, 110, 
            115, 24, 8, 32, 1, 40, 11, 50, 28, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 
            116, 111, 98, 117, 102, 46, 70, 105, 108, 101, 79, 112, 116, 105, 111, 110, 115, 82, 7, 111, 
            112, 116, 105, 111, 110, 115, 18, 73, 10, 16, 115, 111, 117, 114, 99, 101, 95, 99, 111, 100, 
            101, 95, 105, 110, 102, 111, 24, 9, 32, 1, 40, 11, 50, 31, 46, 103, 111, 111, 103, 108, 
            101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 83, 111, 117, 114, 99, 101, 67, 111, 100, 
            101, 73, 110, 102, 111, 82, 14, 115, 111, 117, 114, 99, 101, 67, 111, 100, 101, 73, 110, 102, 
            111, 18, 22, 10, 6, 115, 121, 110, 116, 97, 120, 24, 12, 32, 1, 40, 9, 82, 6, 115, 
            121, 110, 116, 97, 120, 34, 185, 6, 10, 15, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 
            80, 114, 111, 116, 111, 18, 18, 10, 4, 110, 97, 109, 101, 24, 1, 32, 1, 40, 9, 82, 
            4, 110, 97, 109, 101, 18, 59, 10, 5, 102, 105, 101, 108, 100, 24, 2, 32, 3, 40, 11, 
            50, 37, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 70, 
            105, 101, 108, 100, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 82, 
            5, 102, 105, 101, 108, 100, 18, 67, 10, 9, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 
            6, 32, 3, 40, 11, 50, 37, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 
            98, 117, 102, 46, 70, 105, 101, 108, 100, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 
            114, 111, 116, 111, 82, 9, 101, 120, 116, 101, 110, 115, 105, 111, 110, 18, 65, 10, 11, 110, 
            101, 115, 116, 101, 100, 95, 116, 121, 112, 101, 24, 3, 32, 3, 40, 11, 50, 32, 46, 103, 
            111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 68, 101, 115, 99, 114, 
            105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 82, 10, 110, 101, 115, 116, 101, 100, 84, 121, 
            112, 101, 18, 65, 10, 9, 101, 110, 117, 109, 95, 116, 121, 112, 101, 24, 4, 32, 3, 40, 
            11, 50, 36, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 
            69, 110, 117, 109, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 82, 
            8, 101, 110, 117, 109, 84, 121, 112, 101, 18, 88, 10, 15, 101, 120, 116, 101, 110, 115, 105, 
            111, 110, 95, 114, 97, 110, 103, 101, 24, 5, 32, 3, 40, 11, 50, 47, 46, 103, 111, 111, 
            103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 68, 101, 115, 99, 114, 105, 112, 
            116, 111, 114, 80, 114, 111, 116, 111, 46, 69, 120, 116, 101, 110, 115, 105, 111, 110, 82, 97, 
            110, 103, 101, 82, 14, 101, 120, 116, 101, 110, 115, 105, 111, 110, 82, 97, 110, 103, 101, 18, 
            68, 10, 10, 111, 110, 101, 111, 102, 95, 100, 101, 99, 108, 24, 8, 32, 3, 40, 11, 50, 
            37, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 79, 110, 
            101, 111, 102, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 82, 9, 
            111, 110, 101, 111, 102, 68, 101, 99, 108, 18, 57, 10, 7, 111, 112, 116, 105, 111, 110, 115, 
            24, 7, 32, 1, 40, 11, 50, 31, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 
            111, 98, 117, 102, 46, 77, 101, 115, 115, 97, 103, 101, 79, 112, 116, 105, 111, 110, 115, 82, 
            7, 111, 112, 116, 105, 111, 110, 115, 18, 85, 10, 14, 114, 101, 115, 101, 114, 118, 101, 100, 
            95, 114, 97, 110, 103, 101, 24, 9, 32, 3, 40, 11, 50, 46, 46, 103, 111, 111, 103, 108, 
            101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 68, 101, 115, 99, 114, 105, 112, 116, 111, 
            114, 80, 114, 111, 116, 111, 46, 82, 101, 115, 101, 114, 118, 101, 100, 82, 97, 110, 103, 101, 
            82, 13, 114, 101, 115, 101, 114, 118, 101, 100, 82, 97, 110, 103, 101, 18, 35, 10, 13, 114, 
            101, 115, 101, 114, 118, 101, 100, 95, 110, 97, 109, 101, 24, 10, 32, 3, 40, 9, 82, 12, 
            114, 101, 115, 101, 114, 118, 101, 100, 78, 97, 109, 101, 26, 122, 10, 14, 69, 120, 116, 101, 
            110, 115, 105, 111, 110, 82, 97, 110, 103, 101, 18, 20, 10, 5, 115, 116, 97, 114, 116, 24, 
            1, 32, 1, 40, 5, 82, 5, 115, 116, 97, 114, 116, 18, 16, 10, 3, 101, 110, 100, 24, 
            2, 32, 1, 40, 5, 82, 3, 101, 110, 100, 18, 64, 10, 7, 111, 112, 116, 105, 111, 110, 
            115, 24, 3, 32, 1, 40, 11, 50, 38, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 
            116, 111, 98, 117, 102, 46, 69, 120, 116, 101, 110, 115, 105, 111, 110, 82, 97, 110, 103, 101, 
            79, 112, 116, 105, 111, 110, 115, 82, 7, 111, 112, 116, 105, 111, 110, 115, 26, 55, 10, 13, 
            82, 101, 115, 101, 114, 118, 101, 100, 82, 97, 110, 103, 101, 18, 20, 10, 5, 115, 116, 97, 
            114, 116, 24, 1, 32, 1, 40, 5, 82, 5, 115, 116, 97, 114, 116, 18, 16, 10, 3, 101, 
            110, 100, 24, 2, 32, 1, 40, 5, 82, 3, 101, 110, 100, 34, 124, 10, 21, 69, 120, 116, 
            101, 110, 115, 105, 111, 110, 82, 97, 110, 103, 101, 79, 112, 116, 105, 111, 110, 115, 18, 88, 
            10, 20, 117, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 95, 111, 112, 116, 105, 
            111, 110, 24, 231, 7, 32, 3, 40, 11, 50, 36, 46, 103, 111, 111, 103, 108, 101, 46, 112, 
            114, 111, 116, 111, 98, 117, 102, 46, 85, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 
            100, 79, 112, 116, 105, 111, 110, 82, 19, 117, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 
            101, 100, 79, 112, 116, 105, 111, 110, 42, 9, 8, 232, 7, 16, 128, 128, 128, 128, 2, 34, 
            152, 6, 10, 20, 70, 105, 101, 108, 100, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 
            114, 111, 116, 111, 18, 18, 10, 4, 110, 97, 109, 101, 24, 1, 32, 1, 40, 9, 82, 4, 
            110, 97, 109, 101, 18, 22, 10, 6, 110, 117, 109, 98, 101, 114, 24, 3, 32, 1, 40, 5, 
            82, 6, 110, 117, 109, 98, 101, 114, 18, 65, 10, 5, 108, 97, 98, 101, 108, 24, 4, 32, 
            1, 40, 14, 50, 43, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 
            102, 46, 70, 105, 101, 108, 100, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 
            116, 111, 46, 76, 97, 98, 101, 108, 82, 5, 108, 97, 98, 101, 108, 18, 62, 10, 4, 116, 
            121, 112, 101, 24, 5, 32, 1, 40, 14, 50, 42, 46, 103, 111, 111, 103, 108, 101, 46, 112, 
            114, 111, 116, 111, 98, 117, 102, 46, 70, 105, 101, 108, 100, 68, 101, 115, 99, 114, 105, 112, 
            116, 111, 114, 80, 114, 111, 116, 111, 46, 84, 121, 112, 101, 82, 4, 116, 121, 112, 101, 18, 
            27, 10, 9, 116, 121, 112, 101, 95, 110, 97, 109, 101, 24, 6, 32, 1, 40, 9, 82, 8, 
            116, 121, 112, 101, 78, 97, 109, 101, 18, 26, 10, 8, 101, 120, 116, 101, 110, 100, 101, 101, 
            24, 2, 32, 1, 40, 9, 82, 8, 101, 120, 116, 101, 110, 100, 101, 101, 18, 35, 10, 13, 
            100, 101, 102, 97, 117, 108, 116, 95, 118, 97, 108, 117, 101, 24, 7, 32, 1, 40, 9, 82, 
            12, 100, 101, 102, 97, 117, 108, 116, 86, 97, 108, 117, 101, 18, 31, 10, 11, 111, 110, 101, 
            111, 102, 95, 105, 110, 100, 101, 120, 24, 9, 32, 1, 40, 5, 82, 10, 111, 110, 101, 111, 
            102, 73, 110, 100, 101, 120, 18, 27, 10, 9, 106, 115, 111, 110, 95, 110, 97, 109, 101, 24, 
            10, 32, 1, 40, 9, 82, 8, 106, 115, 111, 110, 78, 97, 109, 101, 18, 55, 10, 7, 111, 
            112, 116, 105, 111, 110, 115, 24, 8, 32, 1, 40, 11, 50, 29, 46, 103, 111, 111, 103, 108, 
            101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 70, 105, 101, 108, 100, 79, 112, 116, 105, 
            111, 110, 115, 82, 7, 111, 112, 116, 105, 111, 110, 115, 34, 182, 2, 10, 4, 84, 121, 112, 
            101, 18, 15, 10, 11, 84, 89, 80, 69, 95, 68, 79, 85, 66, 76, 69, 16, 1, 18, 14, 
            10, 10, 84, 89, 80, 69, 95, 70, 76, 79, 65, 84, 16, 2, 18, 14, 10, 10, 84, 89, 
            80, 69, 95, 73, 78, 84, 54, 52, 16, 3, 18, 15, 10, 11, 84, 89, 80, 69, 95, 85, 
            73, 78, 84, 54, 52, 16, 4, 18, 14, 10, 10, 84, 89, 80, 69, 95, 73, 78, 84, 51, 
            50, 16, 5, 18, 16, 10, 12, 84, 89, 80, 69, 95, 70, 73, 88, 69, 68, 54, 52, 16, 
            6, 18, 16, 10, 12, 84, 89, 80, 69, 95, 70, 73, 88, 69, 68, 51, 50, 16, 7, 18, 
            13, 10, 9, 84, 89, 80, 69, 95, 66, 79, 79, 76, 16, 8, 18, 15, 10, 11, 84, 89, 
            80, 69, 95, 83, 84, 82, 73, 78, 71, 16, 9, 18, 14, 10, 10, 84, 89, 80, 69, 95, 
            71, 82, 79, 85, 80, 16, 10, 18, 16, 10, 12, 84, 89, 80, 69, 95, 77, 69, 83, 83, 
            65, 71, 69, 16, 11, 18, 14, 10, 10, 84, 89, 80, 69, 95, 66, 89, 84, 69, 83, 16, 
            12, 18, 15, 10, 11, 84, 89, 80, 69, 95, 85, 73, 78, 84, 51, 50, 16, 13, 18, 13, 
            10, 9, 84, 89, 80, 69, 95, 69, 78, 85, 77, 16, 14, 18, 17, 10, 13, 84, 89, 80, 
            69, 95, 83, 70, 73, 88, 69, 68, 51, 50, 16, 15, 18, 17, 10, 13, 84, 89, 80, 69, 
            95, 83, 70, 73, 88, 69, 68, 54, 52, 16, 16, 18, 15, 10, 11, 84, 89, 80, 69, 95, 
            83, 73, 78, 84, 51, 50, 16, 17, 18, 15, 10, 11, 84, 89, 80, 69, 95, 83, 73, 78, 
            84, 54, 52, 16, 18, 34, 67, 10, 5, 76, 97, 98, 101, 108, 18, 18, 10, 14, 76, 65, 
            66, 69, 76, 95, 79, 80, 84, 73, 79, 78, 65, 76, 16, 1, 18, 18, 10, 14, 76, 65, 
            66, 69, 76, 95, 82, 69, 81, 85, 73, 82, 69, 68, 16, 2, 18, 18, 10, 14, 76, 65, 
            66, 69, 76, 95, 82, 69, 80, 69, 65, 84, 69, 68, 16, 3, 34, 99, 10, 20, 79, 110, 
            101, 111, 102, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 18, 18, 
            10, 4, 110, 97, 109, 101, 24, 1, 32, 1, 40, 9, 82, 4, 110, 97, 109, 101, 18, 55, 
            10, 7, 111, 112, 116, 105, 111, 110, 115, 24, 2, 32, 1, 40, 11, 50, 29, 46, 103, 111, 
            111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 79, 110, 101, 111, 102, 79, 
            112, 116, 105, 111, 110, 115, 82, 7, 111, 112, 116, 105, 111, 110, 115, 34, 227, 2, 10, 19, 
            69, 110, 117, 109, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 18, 
            18, 10, 4, 110, 97, 109, 101, 24, 1, 32, 1, 40, 9, 82, 4, 110, 97, 109, 101, 18, 
            63, 10, 5, 118, 97, 108, 117, 101, 24, 2, 32, 3, 40, 11, 50, 41, 46, 103, 111, 111, 
            103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 69, 110, 117, 109, 86, 97, 108, 
            117, 101, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 82, 5, 118, 
            97, 108, 117, 101, 18, 54, 10, 7, 111, 112, 116, 105, 111, 110, 115, 24, 3, 32, 1, 40, 
            11, 50, 28, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 
            69, 110, 117, 109, 79, 112, 116, 105, 111, 110, 115, 82, 7, 111, 112, 116, 105, 111, 110, 115, 
            18, 93, 10, 14, 114, 101, 115, 101, 114, 118, 101, 100, 95, 114, 97, 110, 103, 101, 24, 4, 
            32, 3, 40, 11, 50, 54, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 
            117, 102, 46, 69, 110, 117, 109, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 
            116, 111, 46, 69, 110, 117, 109, 82, 101, 115, 101, 114, 118, 101, 100, 82, 97, 110, 103, 101, 
            82, 13, 114, 101, 115, 101, 114, 118, 101, 100, 82, 97, 110, 103, 101, 18, 35, 10, 13, 114, 
            101, 115, 101, 114, 118, 101, 100, 95, 110, 97, 109, 101, 24, 5, 32, 3, 40, 9, 82, 12, 
            114, 101, 115, 101, 114, 118, 101, 100, 78, 97, 109, 101, 26, 59, 10, 17, 69, 110, 117, 109, 
            82, 101, 115, 101, 114, 118, 101, 100, 82, 97, 110, 103, 101, 18, 20, 10, 5, 115, 116, 97, 
            114, 116, 24, 1, 32, 1, 40, 5, 82, 5, 115, 116, 97, 114, 116, 18, 16, 10, 3, 101, 
            110, 100, 24, 2, 32, 1, 40, 5, 82, 3, 101, 110, 100, 34, 131, 1, 10, 24, 69, 110, 
            117, 109, 86, 97, 108, 117, 101, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 
            116, 111, 18, 18, 10, 4, 110, 97, 109, 101, 24, 1, 32, 1, 40, 9, 82, 4, 110, 97, 
            109, 101, 18, 22, 10, 6, 110, 117, 109, 98, 101, 114, 24, 2, 32, 1, 40, 5, 82, 6, 
            110, 117, 109, 98, 101, 114, 18, 59, 10, 7, 111, 112, 116, 105, 111, 110, 115, 24, 3, 32, 
            1, 40, 11, 50, 33, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 
            102, 46, 69, 110, 117, 109, 86, 97, 108, 117, 101, 79, 112, 116, 105, 111, 110, 115, 82, 7, 
            111, 112, 116, 105, 111, 110, 115, 34, 167, 1, 10, 22, 83, 101, 114, 118, 105, 99, 101, 68, 
            101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 18, 18, 10, 4, 110, 97, 
            109, 101, 24, 1, 32, 1, 40, 9, 82, 4, 110, 97, 109, 101, 18, 62, 10, 6, 109, 101, 
            116, 104, 111, 100, 24, 2, 32, 3, 40, 11, 50, 38, 46, 103, 111, 111, 103, 108, 101, 46, 
            112, 114, 111, 116, 111, 98, 117, 102, 46, 77, 101, 116, 104, 111, 100, 68, 101, 115, 99, 114, 
            105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 82, 6, 109, 101, 116, 104, 111, 100, 18, 57, 
            10, 7, 111, 112, 116, 105, 111, 110, 115, 24, 3, 32, 1, 40, 11, 50, 31, 46, 103, 111, 
            111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 83, 101, 114, 118, 105, 99, 
            101, 79, 112, 116, 105, 111, 110, 115, 82, 7, 111, 112, 116, 105, 111, 110, 115, 34, 137, 2, 
            10, 21, 77, 101, 116, 104, 111, 100, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 
            111, 116, 111, 18, 18, 10, 4, 110, 97, 109, 101, 24, 1, 32, 1, 40, 9, 82, 4, 110, 
            97, 109, 101, 18, 29, 10, 10, 105, 110, 112, 117, 116, 95, 116, 121, 112, 101, 24, 2, 32, 
            1, 40, 9, 82, 9, 105, 110, 112, 117, 116, 84, 121, 112, 101, 18, 31, 10, 11, 111, 117, 
            116, 112, 117, 116, 95, 116, 121, 112, 101, 24, 3, 32, 1, 40, 9, 82, 10, 111, 117, 116, 
            112, 117, 116, 84, 121, 112, 101, 18, 56, 10, 7, 111, 112, 116, 105, 111, 110, 115, 24, 4, 
            32, 1, 40, 11, 50, 30, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 
            117, 102, 46, 77, 101, 116, 104, 111, 100, 79, 112, 116, 105, 111, 110, 115, 82, 7, 111, 112, 
            116, 105, 111, 110, 115, 18, 48, 10, 16, 99, 108, 105, 101, 110, 116, 95, 115, 116, 114, 101, 
            97, 109, 105, 110, 103, 24, 5, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 82, 15, 
            99, 108, 105, 101, 110, 116, 83, 116, 114, 101, 97, 109, 105, 110, 103, 18, 48, 10, 16, 115, 
            101, 114, 118, 101, 114, 95, 115, 116, 114, 101, 97, 109, 105, 110, 103, 24, 6, 32, 1, 40, 
            8, 58, 5, 102, 97, 108, 115, 101, 82, 15, 115, 101, 114, 118, 101, 114, 83, 116, 114, 101, 
            97, 109, 105, 110, 103, 34, 146, 9, 10, 11, 70, 105, 108, 101, 79, 112, 116, 105, 111, 110, 
            115, 18, 33, 10, 12, 106, 97, 118, 97, 95, 112, 97, 99, 107, 97, 103, 101, 24, 1, 32, 
            1, 40, 9, 82, 11, 106, 97, 118, 97, 80, 97, 99, 107, 97, 103, 101, 18, 48, 10, 20, 
            106, 97, 118, 97, 95, 111, 117, 116, 101, 114, 95, 99, 108, 97, 115, 115, 110, 97, 109, 101, 
            24, 8, 32, 1, 40, 9, 82, 18, 106, 97, 118, 97, 79, 117, 116, 101, 114, 67, 108, 97, 
            115, 115, 110, 97, 109, 101, 18, 53, 10, 19, 106, 97, 118, 97, 95, 109, 117, 108, 116, 105, 
            112, 108, 101, 95, 102, 105, 108, 101, 115, 24, 10, 32, 1, 40, 8, 58, 5, 102, 97, 108, 
            115, 101, 82, 17, 106, 97, 118, 97, 77, 117, 108, 116, 105, 112, 108, 101, 70, 105, 108, 101, 
            115, 18, 68, 10, 29, 106, 97, 118, 97, 95, 103, 101, 110, 101, 114, 97, 116, 101, 95, 101, 
            113, 117, 97, 108, 115, 95, 97, 110, 100, 95, 104, 97, 115, 104, 24, 20, 32, 1, 40, 8, 
            82, 25, 106, 97, 118, 97, 71, 101, 110, 101, 114, 97, 116, 101, 69, 113, 117, 97, 108, 115, 
            65, 110, 100, 72, 97, 115, 104, 66, 2, 24, 1, 18, 58, 10, 22, 106, 97, 118, 97, 95, 
            115, 116, 114, 105, 110, 103, 95, 99, 104, 101, 99, 107, 95, 117, 116, 102, 56, 24, 27, 32, 
            1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 82, 19, 106, 97, 118, 97, 83, 116, 114, 105, 
            110, 103, 67, 104, 101, 99, 107, 85, 116, 102, 56, 18, 83, 10, 12, 111, 112, 116, 105, 109, 
            105, 122, 101, 95, 102, 111, 114, 24, 9, 32, 1, 40, 14, 50, 41, 46, 103, 111, 111, 103, 
            108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 70, 105, 108, 101, 79, 112, 116, 105, 
            111, 110, 115, 46, 79, 112, 116, 105, 109, 105, 122, 101, 77, 111, 100, 101, 58, 5, 83, 80, 
            69, 69, 68, 82, 11, 111, 112, 116, 105, 109, 105, 122, 101, 70, 111, 114, 18, 29, 10, 10, 
            103, 111, 95, 112, 97, 99, 107, 97, 103, 101, 24, 11, 32, 1, 40, 9, 82, 9, 103, 111, 
            80, 97, 99, 107, 97, 103, 101, 18, 53, 10, 19, 99, 99, 95, 103, 101, 110, 101, 114, 105, 
            99, 95, 115, 101, 114, 118, 105, 99, 101, 115, 24, 16, 32, 1, 40, 8, 58, 5, 102, 97, 
            108, 115, 101, 82, 17, 99, 99, 71, 101, 110, 101, 114, 105, 99, 83, 101, 114, 118, 105, 99, 
            101, 115, 18, 57, 10, 21, 106, 97, 118, 97, 95, 103, 101, 110, 101, 114, 105, 99, 95, 115, 
            101, 114, 118, 105, 99, 101, 115, 24, 17, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 
            82, 19, 106, 97, 118, 97, 71, 101, 110, 101, 114, 105, 99, 83, 101, 114, 118, 105, 99, 101, 
            115, 18, 53, 10, 19, 112, 121, 95, 103, 101, 110, 101, 114, 105, 99, 95, 115, 101, 114, 118, 
            105, 99, 101, 115, 24, 18, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 82, 17, 112, 
            121, 71, 101, 110, 101, 114, 105, 99, 83, 101, 114, 118, 105, 99, 101, 115, 18, 55, 10, 20, 
            112, 104, 112, 95, 103, 101, 110, 101, 114, 105, 99, 95, 115, 101, 114, 118, 105, 99, 101, 115, 
            24, 42, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 82, 18, 112, 104, 112, 71, 101, 
            110, 101, 114, 105, 99, 83, 101, 114, 118, 105, 99, 101, 115, 18, 37, 10, 10, 100, 101, 112, 
            114, 101, 99, 97, 116, 101, 100, 24, 23, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 
            82, 10, 100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 18, 47, 10, 16, 99, 99, 95, 101, 
            110, 97, 98, 108, 101, 95, 97, 114, 101, 110, 97, 115, 24, 31, 32, 1, 40, 8, 58, 5, 
            102, 97, 108, 115, 101, 82, 14, 99, 99, 69, 110, 97, 98, 108, 101, 65, 114, 101, 110, 97, 
            115, 18, 42, 10, 17, 111, 98, 106, 99, 95, 99, 108, 97, 115, 115, 95, 112, 114, 101, 102, 
            105, 120, 24, 36, 32, 1, 40, 9, 82, 15, 111, 98, 106, 99, 67, 108, 97, 115, 115, 80, 
            114, 101, 102, 105, 120, 18, 41, 10, 16, 99, 115, 104, 97, 114, 112, 95, 110, 97, 109, 101, 
            115, 112, 97, 99, 101, 24, 37, 32, 1, 40, 9, 82, 15, 99, 115, 104, 97, 114, 112, 78, 
            97, 109, 101, 115, 112, 97, 99, 101, 18, 33, 10, 12, 115, 119, 105, 102, 116, 95, 112, 114, 
            101, 102, 105, 120, 24, 39, 32, 1, 40, 9, 82, 11, 115, 119, 105, 102, 116, 80, 114, 101, 
            102, 105, 120, 18, 40, 10, 16, 112, 104, 112, 95, 99, 108, 97, 115, 115, 95, 112, 114, 101, 
            102, 105, 120, 24, 40, 32, 1, 40, 9, 82, 14, 112, 104, 112, 67, 108, 97, 115, 115, 80, 
            114, 101, 102, 105, 120, 18, 35, 10, 13, 112, 104, 112, 95, 110, 97, 109, 101, 115, 112, 97, 
            99, 101, 24, 41, 32, 1, 40, 9, 82, 12, 112, 104, 112, 78, 97, 109, 101, 115, 112, 97, 
            99, 101, 18, 52, 10, 22, 112, 104, 112, 95, 109, 101, 116, 97, 100, 97, 116, 97, 95, 110, 
            97, 109, 101, 115, 112, 97, 99, 101, 24, 44, 32, 1, 40, 9, 82, 20, 112, 104, 112, 77, 
            101, 116, 97, 100, 97, 116, 97, 78, 97, 109, 101, 115, 112, 97, 99, 101, 18, 33, 10, 12, 
            114, 117, 98, 121, 95, 112, 97, 99, 107, 97, 103, 101, 24, 45, 32, 1, 40, 9, 82, 11, 
            114, 117, 98, 121, 80, 97, 99, 107, 97, 103, 101, 18, 88, 10, 20, 117, 110, 105, 110, 116, 
            101, 114, 112, 114, 101, 116, 101, 100, 95, 111, 112, 116, 105, 111, 110, 24, 231, 7, 32, 3, 
            40, 11, 50, 36, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 
            46, 85, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 
            82, 19, 117, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 
            110, 34, 58, 10, 12, 79, 112, 116, 105, 109, 105, 122, 101, 77, 111, 100, 101, 18, 9, 10, 
            5, 83, 80, 69, 69, 68, 16, 1, 18, 13, 10, 9, 67, 79, 68, 69, 95, 83, 73, 90, 
            69, 16, 2, 18, 16, 10, 12, 76, 73, 84, 69, 95, 82, 85, 78, 84, 73, 77, 69, 16, 
            3, 42, 9, 8, 232, 7, 16, 128, 128, 128, 128, 2, 74, 4, 8, 38, 16, 39, 34, 209, 
            2, 10, 14, 77, 101, 115, 115, 97, 103, 101, 79, 112, 116, 105, 111, 110, 115, 18, 60, 10, 
            23, 109, 101, 115, 115, 97, 103, 101, 95, 115, 101, 116, 95, 119, 105, 114, 101, 95, 102, 111, 
            114, 109, 97, 116, 24, 1, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 82, 20, 109, 
            101, 115, 115, 97, 103, 101, 83, 101, 116, 87, 105, 114, 101, 70, 111, 114, 109, 97, 116, 18, 
            76, 10, 31, 110, 111, 95, 115, 116, 97, 110, 100, 97, 114, 100, 95, 100, 101, 115, 99, 114, 
            105, 112, 116, 111, 114, 95, 97, 99, 99, 101, 115, 115, 111, 114, 24, 2, 32, 1, 40, 8, 
            58, 5, 102, 97, 108, 115, 101, 82, 28, 110, 111, 83, 116, 97, 110, 100, 97, 114, 100, 68, 
            101, 115, 99, 114, 105, 112, 116, 111, 114, 65, 99, 99, 101, 115, 115, 111, 114, 18, 37, 10, 
            10, 100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 24, 3, 32, 1, 40, 8, 58, 5, 102, 
            97, 108, 115, 101, 82, 10, 100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 18, 27, 10, 9, 
            109, 97, 112, 95, 101, 110, 116, 114, 121, 24, 7, 32, 1, 40, 8, 82, 8, 109, 97, 112, 
            69, 110, 116, 114, 121, 18, 88, 10, 20, 117, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 
            101, 100, 95, 111, 112, 116, 105, 111, 110, 24, 231, 7, 32, 3, 40, 11, 50, 36, 46, 103, 
            111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 85, 110, 105, 110, 116, 
            101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 82, 19, 117, 110, 105, 110, 
            116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 42, 9, 8, 232, 7, 
            16, 128, 128, 128, 128, 2, 74, 4, 8, 8, 16, 9, 74, 4, 8, 9, 16, 10, 34, 222, 
            3, 10, 12, 70, 105, 101, 108, 100, 79, 112, 116, 105, 111, 110, 115, 18, 65, 10, 5, 99, 
            116, 121, 112, 101, 24, 1, 32, 1, 40, 14, 50, 35, 46, 103, 111, 111, 103, 108, 101, 46, 
            112, 114, 111, 116, 111, 98, 117, 102, 46, 70, 105, 101, 108, 100, 79, 112, 116, 105, 111, 110, 
            115, 46, 67, 84, 121, 112, 101, 58, 6, 83, 84, 82, 73, 78, 71, 82, 5, 99, 116, 121, 
            112, 101, 18, 22, 10, 6, 112, 97, 99, 107, 101, 100, 24, 2, 32, 1, 40, 8, 82, 6, 
            112, 97, 99, 107, 101, 100, 18, 71, 10, 6, 106, 115, 116, 121, 112, 101, 24, 6, 32, 1, 
            40, 14, 50, 36, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 
            46, 70, 105, 101, 108, 100, 79, 112, 116, 105, 111, 110, 115, 46, 74, 83, 84, 121, 112, 101, 
            58, 9, 74, 83, 95, 78, 79, 82, 77, 65, 76, 82, 6, 106, 115, 116, 121, 112, 101, 18, 
            25, 10, 4, 108, 97, 122, 121, 24, 5, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 
            82, 4, 108, 97, 122, 121, 18, 37, 10, 10, 100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 
            24, 3, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 82, 10, 100, 101, 112, 114, 101, 
            99, 97, 116, 101, 100, 18, 25, 10, 4, 119, 101, 97, 107, 24, 10, 32, 1, 40, 8, 58, 
            5, 102, 97, 108, 115, 101, 82, 4, 119, 101, 97, 107, 18, 88, 10, 20, 117, 110, 105, 110, 
            116, 101, 114, 112, 114, 101, 116, 101, 100, 95, 111, 112, 116, 105, 111, 110, 24, 231, 7, 32, 
            3, 40, 11, 50, 36, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 
            102, 46, 85, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 
            110, 82, 19, 117, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 
            111, 110, 34, 45, 10, 5, 67, 84, 121, 112, 101, 18, 8, 10, 6, 83, 84, 82, 73, 78, 
            71, 18, 8, 10, 4, 67, 79, 82, 68, 16, 1, 18, 16, 10, 12, 83, 84, 82, 73, 78, 
            71, 95, 80, 73, 69, 67, 69, 16, 2, 34, 51, 10, 6, 74, 83, 84, 121, 112, 101, 18, 
            11, 10, 9, 74, 83, 95, 78, 79, 82, 77, 65, 76, 18, 13, 10, 9, 74, 83, 95, 83, 
            84, 82, 73, 78, 71, 16, 1, 18, 13, 10, 9, 74, 83, 95, 78, 85, 77, 66, 69, 82, 
            16, 2, 42, 9, 8, 232, 7, 16, 128, 128, 128, 128, 2, 74, 4, 8, 4, 16, 5, 34, 
            115, 10, 12, 79, 110, 101, 111, 102, 79, 112, 116, 105, 111, 110, 115, 18, 88, 10, 20, 117, 
            110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 95, 111, 112, 116, 105, 111, 110, 24, 
            231, 7, 32, 3, 40, 11, 50, 36, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 
            111, 98, 117, 102, 46, 85, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 
            116, 105, 111, 110, 82, 19, 117, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 
            112, 116, 105, 111, 110, 42, 9, 8, 232, 7, 16, 128, 128, 128, 128, 2, 34, 192, 1, 10, 
            11, 69, 110, 117, 109, 79, 112, 116, 105, 111, 110, 115, 18, 31, 10, 11, 97, 108, 108, 111, 
            119, 95, 97, 108, 105, 97, 115, 24, 2, 32, 1, 40, 8, 82, 10, 97, 108, 108, 111, 119, 
            65, 108, 105, 97, 115, 18, 37, 10, 10, 100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 24, 
            3, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 82, 10, 100, 101, 112, 114, 101, 99, 
            97, 116, 101, 100, 18, 88, 10, 20, 117, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 
            100, 95, 111, 112, 116, 105, 111, 110, 24, 231, 7, 32, 3, 40, 11, 50, 36, 46, 103, 111, 
            111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 85, 110, 105, 110, 116, 101, 
            114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 82, 19, 117, 110, 105, 110, 116, 
            101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 42, 9, 8, 232, 7, 16, 
            128, 128, 128, 128, 2, 74, 4, 8, 5, 16, 6, 34, 158, 1, 10, 16, 69, 110, 117, 109, 
            86, 97, 108, 117, 101, 79, 112, 116, 105, 111, 110, 115, 18, 37, 10, 10, 100, 101, 112, 114, 
            101, 99, 97, 116, 101, 100, 24, 1, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 82, 
            10, 100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 18, 88, 10, 20, 117, 110, 105, 110, 116, 
            101, 114, 112, 114, 101, 116, 101, 100, 95, 111, 112, 116, 105, 111, 110, 24, 231, 7, 32, 3, 
            40, 11, 50, 36, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 
            46, 85, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 
            82, 19, 117, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 
            110, 42, 9, 8, 232, 7, 16, 128, 128, 128, 128, 2, 34, 156, 1, 10, 14, 83, 101, 114, 
            118, 105, 99, 101, 79, 112, 116, 105, 111, 110, 115, 18, 37, 10, 10, 100, 101, 112, 114, 101, 
            99, 97, 116, 101, 100, 24, 33, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 82, 10, 
            100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 18, 88, 10, 20, 117, 110, 105, 110, 116, 101, 
            114, 112, 114, 101, 116, 101, 100, 95, 111, 112, 116, 105, 111, 110, 24, 231, 7, 32, 3, 40, 
            11, 50, 36, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 
            85, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 82, 
            19, 117, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 
            42, 9, 8, 232, 7, 16, 128, 128, 128, 128, 2, 34, 222, 2, 10, 13, 77, 101, 116, 104, 
            111, 100, 79, 112, 116, 105, 111, 110, 115, 18, 37, 10, 10, 100, 101, 112, 114, 101, 99, 97, 
            116, 101, 100, 24, 33, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 82, 10, 100, 101, 
            112, 114, 101, 99, 97, 116, 101, 100, 18, 113, 10, 17, 105, 100, 101, 109, 112, 111, 116, 101, 
            110, 99, 121, 95, 108, 101, 118, 101, 108, 24, 34, 32, 1, 40, 14, 50, 47, 46, 103, 111, 
            111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 77, 101, 116, 104, 111, 100, 
            79, 112, 116, 105, 111, 110, 115, 46, 73, 100, 101, 109, 112, 111, 116, 101, 110, 99, 121, 76, 
            101, 118, 101, 108, 58, 19, 73, 68, 69, 77, 80, 79, 84, 69, 78, 67, 89, 95, 85, 78, 
            75, 78, 79, 87, 78, 82, 16, 105, 100, 101, 109, 112, 111, 116, 101, 110, 99, 121, 76, 101, 
            118, 101, 108, 18, 88, 10, 20, 117, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 
            95, 111, 112, 116, 105, 111, 110, 24, 231, 7, 32, 3, 40, 11, 50, 36, 46, 103, 111, 111, 
            103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 85, 110, 105, 110, 116, 101, 114, 
            112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 82, 19, 117, 110, 105, 110, 116, 101, 
            114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 34, 78, 10, 16, 73, 100, 101, 
            109, 112, 111, 116, 101, 110, 99, 121, 76, 101, 118, 101, 108, 18, 21, 10, 19, 73, 68, 69, 
            77, 80, 79, 84, 69, 78, 67, 89, 95, 85, 78, 75, 78, 79, 87, 78, 18, 19, 10, 15, 
            78, 79, 95, 83, 73, 68, 69, 95, 69, 70, 70, 69, 67, 84, 83, 16, 1, 18, 14, 10, 
            10, 73, 68, 69, 77, 80, 79, 84, 69, 78, 84, 16, 2, 42, 9, 8, 232, 7, 16, 128, 
            128, 128, 128, 2, 34, 154, 3, 10, 19, 85, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 
            101, 100, 79, 112, 116, 105, 111, 110, 18, 65, 10, 4, 110, 97, 109, 101, 24, 2, 32, 3, 
            40, 11, 50, 45, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 
            46, 85, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 
            46, 78, 97, 109, 101, 80, 97, 114, 116, 82, 4, 110, 97, 109, 101, 18, 41, 10, 16, 105, 
            100, 101, 110, 116, 105, 102, 105, 101, 114, 95, 118, 97, 108, 117, 101, 24, 3, 32, 1, 40, 
            9, 82, 15, 105, 100, 101, 110, 116, 105, 102, 105, 101, 114, 86, 97, 108, 117, 101, 18, 44, 
            10, 18, 112, 111, 115, 105, 116, 105, 118, 101, 95, 105, 110, 116, 95, 118, 97, 108, 117, 101, 
            24, 4, 32, 1, 40, 4, 82, 16, 112, 111, 115, 105, 116, 105, 118, 101, 73, 110, 116, 86, 
            97, 108, 117, 101, 18, 44, 10, 18, 110, 101, 103, 97, 116, 105, 118, 101, 95, 105, 110, 116, 
            95, 118, 97, 108, 117, 101, 24, 5, 32, 1, 40, 3, 82, 16, 110, 101, 103, 97, 116, 105, 
            118, 101, 73, 110, 116, 86, 97, 108, 117, 101, 18, 33, 10, 12, 100, 111, 117, 98, 108, 101, 
            95, 118, 97, 108, 117, 101, 24, 6, 32, 1, 40, 1, 82, 11, 100, 111, 117, 98, 108, 101, 
            86, 97, 108, 117, 101, 18, 33, 10, 12, 115, 116, 114, 105, 110, 103, 95, 118, 97, 108, 117, 
            101, 24, 7, 32, 1, 40, 12, 82, 11, 115, 116, 114, 105, 110, 103, 86, 97, 108, 117, 101, 
            18, 39, 10, 15, 97, 103, 103, 114, 101, 103, 97, 116, 101, 95, 118, 97, 108, 117, 101, 24, 
            8, 32, 1, 40, 9, 82, 14, 97, 103, 103, 114, 101, 103, 97, 116, 101, 86, 97, 108, 117, 
            101, 26, 74, 10, 8, 78, 97, 109, 101, 80, 97, 114, 116, 18, 27, 10, 9, 110, 97, 109, 
            101, 95, 112, 97, 114, 116, 24, 1, 32, 2, 40, 9, 82, 8, 110, 97, 109, 101, 80, 97, 
            114, 116, 18, 33, 10, 12, 105, 115, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 2, 
            32, 2, 40, 8, 82, 11, 105, 115, 69, 120, 116, 101, 110, 115, 105, 111, 110, 34, 167, 2, 
            10, 14, 83, 111, 117, 114, 99, 101, 67, 111, 100, 101, 73, 110, 102, 111, 18, 68, 10, 8, 
            108, 111, 99, 97, 116, 105, 111, 110, 24, 1, 32, 3, 40, 11, 50, 40, 46, 103, 111, 111, 
            103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 83, 111, 117, 114, 99, 101, 67, 
            111, 100, 101, 73, 110, 102, 111, 46, 76, 111, 99, 97, 116, 105, 111, 110, 82, 8, 108, 111, 
            99, 97, 116, 105, 111, 110, 26, 206, 1, 10, 8, 76, 111, 99, 97, 116, 105, 111, 110, 18, 
            22, 10, 4, 112, 97, 116, 104, 24, 1, 32, 3, 40, 5, 82, 4, 112, 97, 116, 104, 66, 
            2, 16, 1, 18, 22, 10, 4, 115, 112, 97, 110, 24, 2, 32, 3, 40, 5, 82, 4, 115, 
            112, 97, 110, 66, 2, 16, 1, 18, 41, 10, 16, 108, 101, 97, 100, 105, 110, 103, 95, 99, 
            111, 109, 109, 101, 110, 116, 115, 24, 3, 32, 1, 40, 9, 82, 15, 108, 101, 97, 100, 105, 
            110, 103, 67, 111, 109, 109, 101, 110, 116, 115, 18, 43, 10, 17, 116, 114, 97, 105, 108, 105, 
            110, 103, 95, 99, 111, 109, 109, 101, 110, 116, 115, 24, 4, 32, 1, 40, 9, 82, 16, 116, 
            114, 97, 105, 108, 105, 110, 103, 67, 111, 109, 109, 101, 110, 116, 115, 18, 58, 10, 25, 108, 
            101, 97, 100, 105, 110, 103, 95, 100, 101, 116, 97, 99, 104, 101, 100, 95, 99, 111, 109, 109, 
            101, 110, 116, 115, 24, 6, 32, 3, 40, 9, 82, 23, 108, 101, 97, 100, 105, 110, 103, 68, 
            101, 116, 97, 99, 104, 101, 100, 67, 111, 109, 109, 101, 110, 116, 115, 34, 209, 1, 10, 17, 
            71, 101, 110, 101, 114, 97, 116, 101, 100, 67, 111, 100, 101, 73, 110, 102, 111, 18, 77, 10, 
            10, 97, 110, 110, 111, 116, 97, 116, 105, 111, 110, 24, 1, 32, 3, 40, 11, 50, 45, 46, 
            103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 71, 101, 110, 101, 
            114, 97, 116, 101, 100, 67, 111, 100, 101, 73, 110, 102, 111, 46, 65, 110, 110, 111, 116, 97, 
            116, 105, 111, 110, 82, 10, 97, 110, 110, 111, 116, 97, 116, 105, 111, 110, 26, 109, 10, 10, 
            65, 110, 110, 111, 116, 97, 116, 105, 111, 110, 18, 22, 10, 4, 112, 97, 116, 104, 24, 1, 
            32, 3, 40, 5, 82, 4, 112, 97, 116, 104, 66, 2, 16, 1, 18, 31, 10, 11, 115, 111, 
            117, 114, 99, 101, 95, 102, 105, 108, 101, 24, 2, 32, 1, 40, 9, 82, 10, 115, 111, 117, 
            114, 99, 101, 70, 105, 108, 101, 18, 20, 10, 5, 98, 101, 103, 105, 110, 24, 3, 32, 1, 
            40, 5, 82, 5, 98, 101, 103, 105, 110, 18, 16, 10, 3, 101, 110, 100, 24, 4, 32, 1, 
            40, 5, 82, 3, 101, 110, 100, 66, 141, 1, 10, 19, 99, 111, 109, 46, 103, 111, 111, 103, 
            108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 66, 16, 68, 101, 115, 99, 114, 105, 112, 
            116, 111, 114, 80, 114, 111, 116, 111, 115, 90, 62, 103, 105, 116, 104, 117, 98, 46, 99, 111, 
            109, 47, 103, 111, 108, 97, 110, 103, 47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 112, 114, 
            111, 116, 111, 99, 45, 103, 101, 110, 45, 103, 111, 47, 100, 101, 115, 99, 114, 105, 112, 116, 
            111, 114, 59, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 248, 1, 1, 162, 2, 3, 71, 
            80, 66, 170, 2, 26, 71, 111, 111, 103, 108, 101, 46, 80, 114, 111, 116, 111, 98, 117, 102, 
            46, 82, 101, 102, 108, 101, 99, 116, 105, 111, 110, 
        ].as_ref()).expect("Could not read file descriptor")]);
        FILE_DEPS = ::std::option::Option::Some([]);
        FILE_POOL = ::std::option::Option::Some(crate::reflect::DescriptorPool::build_generated_pool(
            FILE_PROTO.as_ref().unwrap(),
            FILE_DEPS.as_ref().unwrap()
        ));
        FILE_DESCRIPTOR = ::std::option::Option::Some(FILE_POOL.as_ref().unwrap().find_file_by_name("google/protobuf/descriptor.proto").unwrap());
    }
}

/// Gets the pool containing all the symbols in this proto file and its dependencies
pub fn pool() -> &'static crate::reflect::DescriptorPool<'static> {
    unsafe {
        FILE_ONCE.call_once(file_once_init);
        FILE_POOL.as_ref().unwrap()
    }
}
/// Gets the file descriptor representing the proto that created this generated file
pub fn file() -> &'static crate::reflect::FileDescriptor {
    unsafe {
        FILE_ONCE.call_once(file_once_init);
        FILE_DESCRIPTOR.as_ref().unwrap()
    }
}
#[derive(Debug, PartialEq)]
pub struct FileDescriptorSet {
    pub file: crate::collections::RepeatedField<self::FileDescriptorProto>,
    unknown_fields: crate::UnknownFieldSet
}
static FILE_DESCRIPTOR_SET_FILE_CODEC: crate::Codec<self::FileDescriptorProto> = crate::Codec::message(10);
impl crate::CodedMessage for self::FileDescriptorSet {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.file.add_entries(tag.get(), input, &FILE_DESCRIPTOR_SET_FILE_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.file.calculate_size(&FILE_DESCRIPTOR_SET_FILE_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        self.file.write_to(output, &FILE_DESCRIPTOR_SET_FILE_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::FileDescriptorSet {
    fn new() -> Self {
        Self {
            file: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl ::std::clone::Clone for self::FileDescriptorSet {
    fn clone(&self) -> Self {
        Self {
            file: self.file.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.file.clone_from(&other.file);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::FileDescriptorSet {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[0]
    }
}
impl self::FileDescriptorSet {
    /// Gets the field number of the 'file' field
    pub const FILE_FIELD_NUMBER: i32 = 1;
}
#[derive(Debug, PartialEq)]
pub struct FileDescriptorProto {
    pub name: ::std::option::Option<::std::string::String>,
    pub package: ::std::option::Option<::std::string::String>,
    pub dependency: crate::collections::RepeatedField<::std::string::String>,
    pub public_dependency: crate::collections::RepeatedField<i32>,
    pub weak_dependency: crate::collections::RepeatedField<i32>,
    pub message_type: crate::collections::RepeatedField<self::DescriptorProto>,
    pub enum_type: crate::collections::RepeatedField<self::EnumDescriptorProto>,
    pub service: crate::collections::RepeatedField<self::ServiceDescriptorProto>,
    pub extension: crate::collections::RepeatedField<self::FieldDescriptorProto>,
    pub options: ::std::option::Option<::std::boxed::Box<self::FileOptions>>,
    pub source_code_info: ::std::option::Option<::std::boxed::Box<self::SourceCodeInfo>>,
    pub syntax: ::std::option::Option<::std::string::String>,
    unknown_fields: crate::UnknownFieldSet
}
static FILE_DESCRIPTOR_PROTO_DEPENDENCY_CODEC: crate::Codec<::std::string::String> = crate::Codec::string(26);
static FILE_DESCRIPTOR_PROTO_PUBLIC_DEPENDENCY_CODEC: crate::Codec<i32> = crate::Codec::int32(80);
static FILE_DESCRIPTOR_PROTO_WEAK_DEPENDENCY_CODEC: crate::Codec<i32> = crate::Codec::int32(88);
static FILE_DESCRIPTOR_PROTO_MESSAGE_TYPE_CODEC: crate::Codec<self::DescriptorProto> = crate::Codec::message(34);
static FILE_DESCRIPTOR_PROTO_ENUM_TYPE_CODEC: crate::Codec<self::EnumDescriptorProto> = crate::Codec::message(42);
static FILE_DESCRIPTOR_PROTO_SERVICE_CODEC: crate::Codec<self::ServiceDescriptorProto> = crate::Codec::message(50);
static FILE_DESCRIPTOR_PROTO_EXTENSION_CODEC: crate::Codec<self::FieldDescriptorProto> = crate::Codec::message(58);
impl crate::CodedMessage for self::FileDescriptorProto {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.name = ::std::option::Option::Some(input.read_string()?),
                18 => self.package = ::std::option::Option::Some(input.read_string()?),
                26 => self.dependency.add_entries(tag.get(), input, &FILE_DESCRIPTOR_PROTO_DEPENDENCY_CODEC)?,
                80 => self.public_dependency.add_entries(tag.get(), input, &FILE_DESCRIPTOR_PROTO_PUBLIC_DEPENDENCY_CODEC)?,
                88 => self.weak_dependency.add_entries(tag.get(), input, &FILE_DESCRIPTOR_PROTO_WEAK_DEPENDENCY_CODEC)?,
                34 => self.message_type.add_entries(tag.get(), input, &FILE_DESCRIPTOR_PROTO_MESSAGE_TYPE_CODEC)?,
                42 => self.enum_type.add_entries(tag.get(), input, &FILE_DESCRIPTOR_PROTO_ENUM_TYPE_CODEC)?,
                50 => self.service.add_entries(tag.get(), input, &FILE_DESCRIPTOR_PROTO_SERVICE_CODEC)?,
                58 => self.extension.add_entries(tag.get(), input, &FILE_DESCRIPTOR_PROTO_EXTENSION_CODEC)?,
                66 => input.read_message(self.options.get_or_insert_with(crate::LiteMessage::new))?,
                74 => input.read_message(self.source_code_info.get_or_insert_with(crate::LiteMessage::new))?,
                98 => self.syntax = ::std::option::Option::Some(input.read_string()?),
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(name);
            }
        }
        let package = &self.package;
        if let ::std::option::Option::Some(package) = package {
            if package != Self::PACKAGE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(package);
            }
        }
        size += self.dependency.calculate_size(&FILE_DESCRIPTOR_PROTO_DEPENDENCY_CODEC);
        size += self.public_dependency.calculate_size(&FILE_DESCRIPTOR_PROTO_PUBLIC_DEPENDENCY_CODEC);
        size += self.weak_dependency.calculate_size(&FILE_DESCRIPTOR_PROTO_WEAK_DEPENDENCY_CODEC);
        size += self.message_type.calculate_size(&FILE_DESCRIPTOR_PROTO_MESSAGE_TYPE_CODEC);
        size += self.enum_type.calculate_size(&FILE_DESCRIPTOR_PROTO_ENUM_TYPE_CODEC);
        size += self.service.calculate_size(&FILE_DESCRIPTOR_PROTO_SERVICE_CODEC);
        size += self.extension.calculate_size(&FILE_DESCRIPTOR_PROTO_EXTENSION_CODEC);
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            size += 1;
            size += crate::io::sizes::message(options);
        }
        let source_code_info = &self.source_code_info;
        if let ::std::option::Option::Some(source_code_info) = source_code_info {
            size += 1;
            size += crate::io::sizes::message(source_code_info);
        }
        let syntax = &self.syntax;
        if let ::std::option::Option::Some(syntax) = syntax {
            if syntax != Self::SYNTAX_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(syntax);
            }
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
        }
        let package = &self.package;
        if let ::std::option::Option::Some(package) = package {
            if package != Self::PACKAGE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[18])?;
                output.write_string(package)?;
            }
        }
        self.dependency.write_to(output, &FILE_DESCRIPTOR_PROTO_DEPENDENCY_CODEC)?;
        self.public_dependency.write_to(output, &FILE_DESCRIPTOR_PROTO_PUBLIC_DEPENDENCY_CODEC)?;
        self.weak_dependency.write_to(output, &FILE_DESCRIPTOR_PROTO_WEAK_DEPENDENCY_CODEC)?;
        self.message_type.write_to(output, &FILE_DESCRIPTOR_PROTO_MESSAGE_TYPE_CODEC)?;
        self.enum_type.write_to(output, &FILE_DESCRIPTOR_PROTO_ENUM_TYPE_CODEC)?;
        self.service.write_to(output, &FILE_DESCRIPTOR_PROTO_SERVICE_CODEC)?;
        self.extension.write_to(output, &FILE_DESCRIPTOR_PROTO_EXTENSION_CODEC)?;
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            output.write_raw_tag_bytes(&[66])?;
            output.write_message(options)?;
        }
        let source_code_info = &self.source_code_info;
        if let ::std::option::Option::Some(source_code_info) = source_code_info {
            output.write_raw_tag_bytes(&[74])?;
            output.write_message(source_code_info)?;
        }
        let syntax = &self.syntax;
        if let ::std::option::Option::Some(syntax) = syntax {
            if syntax != Self::SYNTAX_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[98])?;
                output.write_string(syntax)?;
            }
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::FileDescriptorProto {
    fn new() -> Self {
        Self {
            name: ::std::option::Option::None,
            package: ::std::option::Option::None,
            dependency: crate::collections::RepeatedField::new(),
            public_dependency: crate::collections::RepeatedField::new(),
            weak_dependency: crate::collections::RepeatedField::new(),
            message_type: crate::collections::RepeatedField::new(),
            enum_type: crate::collections::RepeatedField::new(),
            service: crate::collections::RepeatedField::new(),
            extension: crate::collections::RepeatedField::new(),
            options: ::std::option::Option::None,
            source_code_info: ::std::option::Option::None,
            syntax: ::std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl ::std::clone::Clone for self::FileDescriptorProto {
    fn clone(&self) -> Self {
        Self {
            name: self.name.clone(),
            package: self.package.clone(),
            dependency: self.dependency.clone(),
            public_dependency: self.public_dependency.clone(),
            weak_dependency: self.weak_dependency.clone(),
            message_type: self.message_type.clone(),
            enum_type: self.enum_type.clone(),
            service: self.service.clone(),
            extension: self.extension.clone(),
            options: self.options.clone(),
            source_code_info: self.source_code_info.clone(),
            syntax: self.syntax.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.name = other.name.clone();
        self.package = other.package.clone();
        self.dependency.clone_from(&other.dependency);
        self.public_dependency.clone_from(&other.public_dependency);
        self.weak_dependency.clone_from(&other.weak_dependency);
        self.message_type.clone_from(&other.message_type);
        self.enum_type.clone_from(&other.enum_type);
        self.service.clone_from(&other.service);
        self.extension.clone_from(&other.extension);
        if let ::std::option::Option::Some(options) = &other.options {
            self.options.get_or_insert_with(crate::LiteMessage::new).clone_from(options);
        }
        if let ::std::option::Option::Some(source_code_info) = &other.source_code_info {
            self.source_code_info.get_or_insert_with(crate::LiteMessage::new).clone_from(source_code_info);
        }
        self.syntax = other.syntax.clone();
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::FileDescriptorProto {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[1]
    }
}
impl self::FileDescriptorProto {
    /// Gets the field number of the 'name' field
    pub const NAME_FIELD_NUMBER: i32 = 1;
    pub const NAME_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'package' field
    pub const PACKAGE_FIELD_NUMBER: i32 = 2;
    pub const PACKAGE_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'dependency' field
    pub const DEPENDENCY_FIELD_NUMBER: i32 = 3;
    /// Gets the field number of the 'public_dependency' field
    pub const PUBLIC_DEPENDENCY_FIELD_NUMBER: i32 = 10;
    /// Gets the field number of the 'weak_dependency' field
    pub const WEAK_DEPENDENCY_FIELD_NUMBER: i32 = 11;
    /// Gets the field number of the 'message_type' field
    pub const MESSAGE_TYPE_FIELD_NUMBER: i32 = 4;
    /// Gets the field number of the 'enum_type' field
    pub const ENUM_TYPE_FIELD_NUMBER: i32 = 5;
    /// Gets the field number of the 'service' field
    pub const SERVICE_FIELD_NUMBER: i32 = 6;
    /// Gets the field number of the 'extension' field
    pub const EXTENSION_FIELD_NUMBER: i32 = 7;
    /// Gets the field number of the 'options' field
    pub const OPTIONS_FIELD_NUMBER: i32 = 8;
    /// Gets the field number of the 'source_code_info' field
    pub const SOURCE_CODE_INFO_FIELD_NUMBER: i32 = 9;
    /// Gets the field number of the 'syntax' field
    pub const SYNTAX_FIELD_NUMBER: i32 = 12;
    pub const SYNTAX_DEFAULT_VALUE: &'static str = "";
}
#[derive(Debug, PartialEq)]
pub struct DescriptorProto {
    pub name: ::std::option::Option<::std::string::String>,
    pub field: crate::collections::RepeatedField<self::FieldDescriptorProto>,
    pub extension: crate::collections::RepeatedField<self::FieldDescriptorProto>,
    pub nested_type: crate::collections::RepeatedField<self::DescriptorProto>,
    pub enum_type: crate::collections::RepeatedField<self::EnumDescriptorProto>,
    pub extension_range: crate::collections::RepeatedField<self::DescriptorProto_ExtensionRange>,
    pub oneof_decl: crate::collections::RepeatedField<self::OneofDescriptorProto>,
    pub options: ::std::option::Option<::std::boxed::Box<self::MessageOptions>>,
    pub reserved_range: crate::collections::RepeatedField<self::DescriptorProto_ReservedRange>,
    pub reserved_name: crate::collections::RepeatedField<::std::string::String>,
    unknown_fields: crate::UnknownFieldSet
}
static DESCRIPTOR_PROTO_FIELD_CODEC: crate::Codec<self::FieldDescriptorProto> = crate::Codec::message(18);
static DESCRIPTOR_PROTO_EXTENSION_CODEC: crate::Codec<self::FieldDescriptorProto> = crate::Codec::message(50);
static DESCRIPTOR_PROTO_NESTED_TYPE_CODEC: crate::Codec<self::DescriptorProto> = crate::Codec::message(26);
static DESCRIPTOR_PROTO_ENUM_TYPE_CODEC: crate::Codec<self::EnumDescriptorProto> = crate::Codec::message(34);
static DESCRIPTOR_PROTO_EXTENSION_RANGE_CODEC: crate::Codec<self::DescriptorProto_ExtensionRange> = crate::Codec::message(42);
static DESCRIPTOR_PROTO_ONEOF_DECL_CODEC: crate::Codec<self::OneofDescriptorProto> = crate::Codec::message(66);
static DESCRIPTOR_PROTO_RESERVED_RANGE_CODEC: crate::Codec<self::DescriptorProto_ReservedRange> = crate::Codec::message(74);
static DESCRIPTOR_PROTO_RESERVED_NAME_CODEC: crate::Codec<::std::string::String> = crate::Codec::string(82);
impl crate::CodedMessage for self::DescriptorProto {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.name = ::std::option::Option::Some(input.read_string()?),
                18 => self.field.add_entries(tag.get(), input, &DESCRIPTOR_PROTO_FIELD_CODEC)?,
                50 => self.extension.add_entries(tag.get(), input, &DESCRIPTOR_PROTO_EXTENSION_CODEC)?,
                26 => self.nested_type.add_entries(tag.get(), input, &DESCRIPTOR_PROTO_NESTED_TYPE_CODEC)?,
                34 => self.enum_type.add_entries(tag.get(), input, &DESCRIPTOR_PROTO_ENUM_TYPE_CODEC)?,
                42 => self.extension_range.add_entries(tag.get(), input, &DESCRIPTOR_PROTO_EXTENSION_RANGE_CODEC)?,
                66 => self.oneof_decl.add_entries(tag.get(), input, &DESCRIPTOR_PROTO_ONEOF_DECL_CODEC)?,
                58 => input.read_message(self.options.get_or_insert_with(crate::LiteMessage::new))?,
                74 => self.reserved_range.add_entries(tag.get(), input, &DESCRIPTOR_PROTO_RESERVED_RANGE_CODEC)?,
                82 => self.reserved_name.add_entries(tag.get(), input, &DESCRIPTOR_PROTO_RESERVED_NAME_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(name);
            }
        }
        size += self.field.calculate_size(&DESCRIPTOR_PROTO_FIELD_CODEC);
        size += self.extension.calculate_size(&DESCRIPTOR_PROTO_EXTENSION_CODEC);
        size += self.nested_type.calculate_size(&DESCRIPTOR_PROTO_NESTED_TYPE_CODEC);
        size += self.enum_type.calculate_size(&DESCRIPTOR_PROTO_ENUM_TYPE_CODEC);
        size += self.extension_range.calculate_size(&DESCRIPTOR_PROTO_EXTENSION_RANGE_CODEC);
        size += self.oneof_decl.calculate_size(&DESCRIPTOR_PROTO_ONEOF_DECL_CODEC);
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            size += 1;
            size += crate::io::sizes::message(options);
        }
        size += self.reserved_range.calculate_size(&DESCRIPTOR_PROTO_RESERVED_RANGE_CODEC);
        size += self.reserved_name.calculate_size(&DESCRIPTOR_PROTO_RESERVED_NAME_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
        }
        self.field.write_to(output, &DESCRIPTOR_PROTO_FIELD_CODEC)?;
        self.extension.write_to(output, &DESCRIPTOR_PROTO_EXTENSION_CODEC)?;
        self.nested_type.write_to(output, &DESCRIPTOR_PROTO_NESTED_TYPE_CODEC)?;
        self.enum_type.write_to(output, &DESCRIPTOR_PROTO_ENUM_TYPE_CODEC)?;
        self.extension_range.write_to(output, &DESCRIPTOR_PROTO_EXTENSION_RANGE_CODEC)?;
        self.oneof_decl.write_to(output, &DESCRIPTOR_PROTO_ONEOF_DECL_CODEC)?;
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            output.write_raw_tag_bytes(&[58])?;
            output.write_message(options)?;
        }
        self.reserved_range.write_to(output, &DESCRIPTOR_PROTO_RESERVED_RANGE_CODEC)?;
        self.reserved_name.write_to(output, &DESCRIPTOR_PROTO_RESERVED_NAME_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::DescriptorProto {
    fn new() -> Self {
        Self {
            name: ::std::option::Option::None,
            field: crate::collections::RepeatedField::new(),
            extension: crate::collections::RepeatedField::new(),
            nested_type: crate::collections::RepeatedField::new(),
            enum_type: crate::collections::RepeatedField::new(),
            extension_range: crate::collections::RepeatedField::new(),
            oneof_decl: crate::collections::RepeatedField::new(),
            options: ::std::option::Option::None,
            reserved_range: crate::collections::RepeatedField::new(),
            reserved_name: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl ::std::clone::Clone for self::DescriptorProto {
    fn clone(&self) -> Self {
        Self {
            name: self.name.clone(),
            field: self.field.clone(),
            extension: self.extension.clone(),
            nested_type: self.nested_type.clone(),
            enum_type: self.enum_type.clone(),
            extension_range: self.extension_range.clone(),
            oneof_decl: self.oneof_decl.clone(),
            options: self.options.clone(),
            reserved_range: self.reserved_range.clone(),
            reserved_name: self.reserved_name.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.name = other.name.clone();
        self.field.clone_from(&other.field);
        self.extension.clone_from(&other.extension);
        self.nested_type.clone_from(&other.nested_type);
        self.enum_type.clone_from(&other.enum_type);
        self.extension_range.clone_from(&other.extension_range);
        self.oneof_decl.clone_from(&other.oneof_decl);
        if let ::std::option::Option::Some(options) = &other.options {
            self.options.get_or_insert_with(crate::LiteMessage::new).clone_from(options);
        }
        self.reserved_range.clone_from(&other.reserved_range);
        self.reserved_name.clone_from(&other.reserved_name);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::DescriptorProto {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[2]
    }
}
impl self::DescriptorProto {
    /// Gets the field number of the 'name' field
    pub const NAME_FIELD_NUMBER: i32 = 1;
    pub const NAME_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'field' field
    pub const FIELD_FIELD_NUMBER: i32 = 2;
    /// Gets the field number of the 'extension' field
    pub const EXTENSION_FIELD_NUMBER: i32 = 6;
    /// Gets the field number of the 'nested_type' field
    pub const NESTED_TYPE_FIELD_NUMBER: i32 = 3;
    /// Gets the field number of the 'enum_type' field
    pub const ENUM_TYPE_FIELD_NUMBER: i32 = 4;
    /// Gets the field number of the 'extension_range' field
    pub const EXTENSION_RANGE_FIELD_NUMBER: i32 = 5;
    /// Gets the field number of the 'oneof_decl' field
    pub const ONEOF_DECL_FIELD_NUMBER: i32 = 8;
    /// Gets the field number of the 'options' field
    pub const OPTIONS_FIELD_NUMBER: i32 = 7;
    /// Gets the field number of the 'reserved_range' field
    pub const RESERVED_RANGE_FIELD_NUMBER: i32 = 9;
    /// Gets the field number of the 'reserved_name' field
    pub const RESERVED_NAME_FIELD_NUMBER: i32 = 10;
}
#[derive(Debug, PartialEq)]
pub struct DescriptorProto_ExtensionRange {
    pub start: ::std::option::Option<i32>,
    pub end: ::std::option::Option<i32>,
    pub options: ::std::option::Option<::std::boxed::Box<self::ExtensionRangeOptions>>,
    unknown_fields: crate::UnknownFieldSet
}
impl crate::CodedMessage for self::DescriptorProto_ExtensionRange {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 => self.start = ::std::option::Option::Some(input.read_int32()?),
                16 => self.end = ::std::option::Option::Some(input.read_int32()?),
                26 => input.read_message(self.options.get_or_insert_with(crate::LiteMessage::new))?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let start = self.start;
        if let ::std::option::Option::Some(start) = start {
            if start != Self::START_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::int32(start);
            }
        }
        let end = self.end;
        if let ::std::option::Option::Some(end) = end {
            if end != Self::END_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::int32(end);
            }
        }
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            size += 1;
            size += crate::io::sizes::message(options);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let start = self.start;
        if let ::std::option::Option::Some(start) = start {
            if start != Self::START_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(start)?;
            }
        }
        let end = self.end;
        if let ::std::option::Option::Some(end) = end {
            if end != Self::END_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_int32(end)?;
            }
        }
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            output.write_raw_tag_bytes(&[26])?;
            output.write_message(options)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::DescriptorProto_ExtensionRange {
    fn new() -> Self {
        Self {
            start: ::std::option::Option::None,
            end: ::std::option::Option::None,
            options: ::std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl ::std::clone::Clone for self::DescriptorProto_ExtensionRange {
    fn clone(&self) -> Self {
        Self {
            start: self.start.clone(),
            end: self.end.clone(),
            options: self.options.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.start = other.start;
        self.end = other.end;
        if let ::std::option::Option::Some(options) = &other.options {
            self.options.get_or_insert_with(crate::LiteMessage::new).clone_from(options);
        }
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::DescriptorProto_ExtensionRange {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[2].messages()[0]
    }
}
impl self::DescriptorProto_ExtensionRange {
    /// Gets the field number of the 'start' field
    pub const START_FIELD_NUMBER: i32 = 1;
    pub const START_DEFAULT_VALUE: i32 = 0;
    /// Gets the field number of the 'end' field
    pub const END_FIELD_NUMBER: i32 = 2;
    pub const END_DEFAULT_VALUE: i32 = 0;
    /// Gets the field number of the 'options' field
    pub const OPTIONS_FIELD_NUMBER: i32 = 3;
}
#[derive(Debug, PartialEq)]
pub struct DescriptorProto_ReservedRange {
    pub start: ::std::option::Option<i32>,
    pub end: ::std::option::Option<i32>,
    unknown_fields: crate::UnknownFieldSet
}
impl crate::CodedMessage for self::DescriptorProto_ReservedRange {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 => self.start = ::std::option::Option::Some(input.read_int32()?),
                16 => self.end = ::std::option::Option::Some(input.read_int32()?),
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let start = self.start;
        if let ::std::option::Option::Some(start) = start {
            if start != Self::START_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::int32(start);
            }
        }
        let end = self.end;
        if let ::std::option::Option::Some(end) = end {
            if end != Self::END_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::int32(end);
            }
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let start = self.start;
        if let ::std::option::Option::Some(start) = start {
            if start != Self::START_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(start)?;
            }
        }
        let end = self.end;
        if let ::std::option::Option::Some(end) = end {
            if end != Self::END_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_int32(end)?;
            }
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::DescriptorProto_ReservedRange {
    fn new() -> Self {
        Self {
            start: ::std::option::Option::None,
            end: ::std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl ::std::clone::Clone for self::DescriptorProto_ReservedRange {
    fn clone(&self) -> Self {
        Self {
            start: self.start.clone(),
            end: self.end.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.start = other.start;
        self.end = other.end;
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::DescriptorProto_ReservedRange {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[2].messages()[1]
    }
}
impl self::DescriptorProto_ReservedRange {
    /// Gets the field number of the 'start' field
    pub const START_FIELD_NUMBER: i32 = 1;
    pub const START_DEFAULT_VALUE: i32 = 0;
    /// Gets the field number of the 'end' field
    pub const END_FIELD_NUMBER: i32 = 2;
    pub const END_DEFAULT_VALUE: i32 = 0;
}
#[derive(Debug, PartialEq)]
pub struct ExtensionRangeOptions {
    pub uninterpreted_option: crate::collections::RepeatedField<self::UninterpretedOption>,
    unknown_fields: crate::UnknownFieldSet
}
static EXTENSION_RANGE_OPTIONS_UNINTERPRETED_OPTION_CODEC: crate::Codec<self::UninterpretedOption> = crate::Codec::message(7994);
impl crate::CodedMessage for self::ExtensionRangeOptions {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                7994 => self.uninterpreted_option.add_entries(tag.get(), input, &EXTENSION_RANGE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.uninterpreted_option.calculate_size(&EXTENSION_RANGE_OPTIONS_UNINTERPRETED_OPTION_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        self.uninterpreted_option.write_to(output, &EXTENSION_RANGE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::ExtensionRangeOptions {
    fn new() -> Self {
        Self {
            uninterpreted_option: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl ::std::clone::Clone for self::ExtensionRangeOptions {
    fn clone(&self) -> Self {
        Self {
            uninterpreted_option: self.uninterpreted_option.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.uninterpreted_option.clone_from(&other.uninterpreted_option);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::ExtensionRangeOptions {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[3]
    }
}
impl self::ExtensionRangeOptions {
    /// Gets the field number of the 'uninterpreted_option' field
    pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
}
#[derive(Debug, PartialEq)]
pub struct FieldDescriptorProto {
    pub name: ::std::option::Option<::std::string::String>,
    pub number: ::std::option::Option<i32>,
    pub label: ::std::option::Option<crate::EnumValue<self::FieldDescriptorProto_Label>>,
    pub r#type: ::std::option::Option<crate::EnumValue<self::FieldDescriptorProto_Type>>,
    pub type_name: ::std::option::Option<::std::string::String>,
    pub extendee: ::std::option::Option<::std::string::String>,
    pub default_value: ::std::option::Option<::std::string::String>,
    pub oneof_index: ::std::option::Option<i32>,
    pub json_name: ::std::option::Option<::std::string::String>,
    pub options: ::std::option::Option<::std::boxed::Box<self::FieldOptions>>,
    unknown_fields: crate::UnknownFieldSet
}
impl crate::CodedMessage for self::FieldDescriptorProto {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.name = ::std::option::Option::Some(input.read_string()?),
                24 => self.number = ::std::option::Option::Some(input.read_int32()?),
                32 => self.label = ::std::option::Option::Some(input.read_enum_value()?),
                40 => self.r#type = ::std::option::Option::Some(input.read_enum_value()?),
                50 => self.type_name = ::std::option::Option::Some(input.read_string()?),
                18 => self.extendee = ::std::option::Option::Some(input.read_string()?),
                58 => self.default_value = ::std::option::Option::Some(input.read_string()?),
                72 => self.oneof_index = ::std::option::Option::Some(input.read_int32()?),
                82 => self.json_name = ::std::option::Option::Some(input.read_string()?),
                66 => input.read_message(self.options.get_or_insert_with(crate::LiteMessage::new))?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(name);
            }
        }
        let number = self.number;
        if let ::std::option::Option::Some(number) = number {
            if number != Self::NUMBER_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::int32(number);
            }
        }
        let label = self.label;
        if let ::std::option::Option::Some(label) = label {
            if label != Self::LABEL_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::enum_value(label);
            }
        }
        let r#type = self.r#type;
        if let ::std::option::Option::Some(r#type) = r#type {
            if r#type != Self::TYPE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::enum_value(r#type);
            }
        }
        let type_name = &self.type_name;
        if let ::std::option::Option::Some(type_name) = type_name {
            if type_name != Self::TYPE_NAME_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(type_name);
            }
        }
        let extendee = &self.extendee;
        if let ::std::option::Option::Some(extendee) = extendee {
            if extendee != Self::EXTENDEE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(extendee);
            }
        }
        let default_value = &self.default_value;
        if let ::std::option::Option::Some(default_value) = default_value {
            if default_value != Self::DEFAULT_VALUE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(default_value);
            }
        }
        let oneof_index = self.oneof_index;
        if let ::std::option::Option::Some(oneof_index) = oneof_index {
            if oneof_index != Self::ONEOF_INDEX_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::int32(oneof_index);
            }
        }
        let json_name = &self.json_name;
        if let ::std::option::Option::Some(json_name) = json_name {
            if json_name != Self::JSON_NAME_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(json_name);
            }
        }
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            size += 1;
            size += crate::io::sizes::message(options);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
        }
        let number = self.number;
        if let ::std::option::Option::Some(number) = number {
            if number != Self::NUMBER_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[24])?;
                output.write_int32(number)?;
            }
        }
        let label = self.label;
        if let ::std::option::Option::Some(label) = label {
            if label != Self::LABEL_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[32])?;
                output.write_enum_value(label)?;
            }
        }
        let r#type = self.r#type;
        if let ::std::option::Option::Some(r#type) = r#type {
            if r#type != Self::TYPE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[40])?;
                output.write_enum_value(r#type)?;
            }
        }
        let type_name = &self.type_name;
        if let ::std::option::Option::Some(type_name) = type_name {
            if type_name != Self::TYPE_NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[50])?;
                output.write_string(type_name)?;
            }
        }
        let extendee = &self.extendee;
        if let ::std::option::Option::Some(extendee) = extendee {
            if extendee != Self::EXTENDEE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[18])?;
                output.write_string(extendee)?;
            }
        }
        let default_value = &self.default_value;
        if let ::std::option::Option::Some(default_value) = default_value {
            if default_value != Self::DEFAULT_VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[58])?;
                output.write_string(default_value)?;
            }
        }
        let oneof_index = self.oneof_index;
        if let ::std::option::Option::Some(oneof_index) = oneof_index {
            if oneof_index != Self::ONEOF_INDEX_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[72])?;
                output.write_int32(oneof_index)?;
            }
        }
        let json_name = &self.json_name;
        if let ::std::option::Option::Some(json_name) = json_name {
            if json_name != Self::JSON_NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[82])?;
                output.write_string(json_name)?;
            }
        }
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            output.write_raw_tag_bytes(&[66])?;
            output.write_message(options)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::FieldDescriptorProto {
    fn new() -> Self {
        Self {
            name: ::std::option::Option::None,
            number: ::std::option::Option::None,
            label: ::std::option::Option::None,
            r#type: ::std::option::Option::None,
            type_name: ::std::option::Option::None,
            extendee: ::std::option::Option::None,
            default_value: ::std::option::Option::None,
            oneof_index: ::std::option::Option::None,
            json_name: ::std::option::Option::None,
            options: ::std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl ::std::clone::Clone for self::FieldDescriptorProto {
    fn clone(&self) -> Self {
        Self {
            name: self.name.clone(),
            number: self.number.clone(),
            label: self.label.clone(),
            r#type: self.r#type.clone(),
            type_name: self.type_name.clone(),
            extendee: self.extendee.clone(),
            default_value: self.default_value.clone(),
            oneof_index: self.oneof_index.clone(),
            json_name: self.json_name.clone(),
            options: self.options.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.name = other.name.clone();
        self.number = other.number;
        self.label = other.label;
        self.r#type = other.r#type;
        self.type_name = other.type_name.clone();
        self.extendee = other.extendee.clone();
        self.default_value = other.default_value.clone();
        self.oneof_index = other.oneof_index;
        self.json_name = other.json_name.clone();
        if let ::std::option::Option::Some(options) = &other.options {
            self.options.get_or_insert_with(crate::LiteMessage::new).clone_from(options);
        }
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::FieldDescriptorProto {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[4]
    }
}
impl self::FieldDescriptorProto {
    /// Gets the field number of the 'name' field
    pub const NAME_FIELD_NUMBER: i32 = 1;
    pub const NAME_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'number' field
    pub const NUMBER_FIELD_NUMBER: i32 = 3;
    pub const NUMBER_DEFAULT_VALUE: i32 = 0;
    /// Gets the field number of the 'label' field
    pub const LABEL_FIELD_NUMBER: i32 = 4;
    pub const LABEL_DEFAULT_VALUE: crate::EnumValue<self::FieldDescriptorProto_Label> = crate::EnumValue::Undefined(0);
    /// Gets the field number of the 'type' field
    pub const TYPE_FIELD_NUMBER: i32 = 5;
    pub const TYPE_DEFAULT_VALUE: crate::EnumValue<self::FieldDescriptorProto_Type> = crate::EnumValue::Undefined(0);
    /// Gets the field number of the 'type_name' field
    pub const TYPE_NAME_FIELD_NUMBER: i32 = 6;
    pub const TYPE_NAME_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'extendee' field
    pub const EXTENDEE_FIELD_NUMBER: i32 = 2;
    pub const EXTENDEE_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'default_value' field
    pub const DEFAULT_VALUE_FIELD_NUMBER: i32 = 7;
    pub const DEFAULT_VALUE_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'oneof_index' field
    pub const ONEOF_INDEX_FIELD_NUMBER: i32 = 9;
    pub const ONEOF_INDEX_DEFAULT_VALUE: i32 = 0;
    /// Gets the field number of the 'json_name' field
    pub const JSON_NAME_FIELD_NUMBER: i32 = 10;
    pub const JSON_NAME_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'options' field
    pub const OPTIONS_FIELD_NUMBER: i32 = 8;
}
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum FieldDescriptorProto_Type {
    Double = 1,
    Float = 2,
    Int64 = 3,
    Uint64 = 4,
    Int32 = 5,
    Fixed64 = 6,
    Fixed32 = 7,
    Bool = 8,
    String = 9,
    Group = 10,
    Message = 11,
    Bytes = 12,
    Uint32 = 13,
    Enum = 14,
    Sfixed32 = 15,
    Sfixed64 = 16,
    Sint32 = 17,
    Sint64 = 18,
}
impl ::std::convert::TryFrom<i32> for self::FieldDescriptorProto_Type {
    type Error = crate::VariantUndefinedError;
    fn try_from(value: i32) -> ::std::result::Result<Self, crate::VariantUndefinedError> {
        match value {
            1 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Double),
            2 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Float),
            3 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Int64),
            4 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Uint64),
            5 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Int32),
            6 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Fixed64),
            7 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Fixed32),
            8 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Bool),
            9 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::String),
            10 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Group),
            11 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Message),
            12 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Bytes),
            13 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Uint32),
            14 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Enum),
            15 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Sfixed32),
            16 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Sfixed64),
            17 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Sint32),
            18 => ::std::result::Result::Ok(self::FieldDescriptorProto_Type::Sint64),
            _ => ::std::result::Result::Err(crate::VariantUndefinedError)
        }
    }
}
impl ::std::convert::From<self::FieldDescriptorProto_Type> for i32 {
    fn from(value: self::FieldDescriptorProto_Type) -> i32 {
        value as i32
    }
}
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum FieldDescriptorProto_Label {
    Optional = 1,
    Required = 2,
    Repeated = 3,
}
impl ::std::convert::TryFrom<i32> for self::FieldDescriptorProto_Label {
    type Error = crate::VariantUndefinedError;
    fn try_from(value: i32) -> ::std::result::Result<Self, crate::VariantUndefinedError> {
        match value {
            1 => ::std::result::Result::Ok(self::FieldDescriptorProto_Label::Optional),
            2 => ::std::result::Result::Ok(self::FieldDescriptorProto_Label::Required),
            3 => ::std::result::Result::Ok(self::FieldDescriptorProto_Label::Repeated),
            _ => ::std::result::Result::Err(crate::VariantUndefinedError)
        }
    }
}
impl ::std::convert::From<self::FieldDescriptorProto_Label> for i32 {
    fn from(value: self::FieldDescriptorProto_Label) -> i32 {
        value as i32
    }
}
#[derive(Debug, PartialEq)]
pub struct OneofDescriptorProto {
    pub name: ::std::option::Option<::std::string::String>,
    pub options: ::std::option::Option<::std::boxed::Box<self::OneofOptions>>,
    unknown_fields: crate::UnknownFieldSet
}
impl crate::CodedMessage for self::OneofDescriptorProto {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.name = ::std::option::Option::Some(input.read_string()?),
                18 => input.read_message(self.options.get_or_insert_with(crate::LiteMessage::new))?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(name);
            }
        }
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            size += 1;
            size += crate::io::sizes::message(options);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
        }
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            output.write_raw_tag_bytes(&[18])?;
            output.write_message(options)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::OneofDescriptorProto {
    fn new() -> Self {
        Self {
            name: ::std::option::Option::None,
            options: ::std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl ::std::clone::Clone for self::OneofDescriptorProto {
    fn clone(&self) -> Self {
        Self {
            name: self.name.clone(),
            options: self.options.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.name = other.name.clone();
        if let ::std::option::Option::Some(options) = &other.options {
            self.options.get_or_insert_with(crate::LiteMessage::new).clone_from(options);
        }
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::OneofDescriptorProto {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[5]
    }
}
impl self::OneofDescriptorProto {
    /// Gets the field number of the 'name' field
    pub const NAME_FIELD_NUMBER: i32 = 1;
    pub const NAME_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'options' field
    pub const OPTIONS_FIELD_NUMBER: i32 = 2;
}
#[derive(Debug, PartialEq)]
pub struct EnumDescriptorProto {
    pub name: ::std::option::Option<::std::string::String>,
    pub value: crate::collections::RepeatedField<self::EnumValueDescriptorProto>,
    pub options: ::std::option::Option<::std::boxed::Box<self::EnumOptions>>,
    pub reserved_range: crate::collections::RepeatedField<self::EnumDescriptorProto_EnumReservedRange>,
    pub reserved_name: crate::collections::RepeatedField<::std::string::String>,
    unknown_fields: crate::UnknownFieldSet
}
static ENUM_DESCRIPTOR_PROTO_VALUE_CODEC: crate::Codec<self::EnumValueDescriptorProto> = crate::Codec::message(18);
static ENUM_DESCRIPTOR_PROTO_RESERVED_RANGE_CODEC: crate::Codec<self::EnumDescriptorProto_EnumReservedRange> = crate::Codec::message(34);
static ENUM_DESCRIPTOR_PROTO_RESERVED_NAME_CODEC: crate::Codec<::std::string::String> = crate::Codec::string(42);
impl crate::CodedMessage for self::EnumDescriptorProto {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.name = ::std::option::Option::Some(input.read_string()?),
                18 => self.value.add_entries(tag.get(), input, &ENUM_DESCRIPTOR_PROTO_VALUE_CODEC)?,
                26 => input.read_message(self.options.get_or_insert_with(crate::LiteMessage::new))?,
                34 => self.reserved_range.add_entries(tag.get(), input, &ENUM_DESCRIPTOR_PROTO_RESERVED_RANGE_CODEC)?,
                42 => self.reserved_name.add_entries(tag.get(), input, &ENUM_DESCRIPTOR_PROTO_RESERVED_NAME_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(name);
            }
        }
        size += self.value.calculate_size(&ENUM_DESCRIPTOR_PROTO_VALUE_CODEC);
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            size += 1;
            size += crate::io::sizes::message(options);
        }
        size += self.reserved_range.calculate_size(&ENUM_DESCRIPTOR_PROTO_RESERVED_RANGE_CODEC);
        size += self.reserved_name.calculate_size(&ENUM_DESCRIPTOR_PROTO_RESERVED_NAME_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
        }
        self.value.write_to(output, &ENUM_DESCRIPTOR_PROTO_VALUE_CODEC)?;
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            output.write_raw_tag_bytes(&[26])?;
            output.write_message(options)?;
        }
        self.reserved_range.write_to(output, &ENUM_DESCRIPTOR_PROTO_RESERVED_RANGE_CODEC)?;
        self.reserved_name.write_to(output, &ENUM_DESCRIPTOR_PROTO_RESERVED_NAME_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::EnumDescriptorProto {
    fn new() -> Self {
        Self {
            name: ::std::option::Option::None,
            value: crate::collections::RepeatedField::new(),
            options: ::std::option::Option::None,
            reserved_range: crate::collections::RepeatedField::new(),
            reserved_name: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl ::std::clone::Clone for self::EnumDescriptorProto {
    fn clone(&self) -> Self {
        Self {
            name: self.name.clone(),
            value: self.value.clone(),
            options: self.options.clone(),
            reserved_range: self.reserved_range.clone(),
            reserved_name: self.reserved_name.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.name = other.name.clone();
        self.value.clone_from(&other.value);
        if let ::std::option::Option::Some(options) = &other.options {
            self.options.get_or_insert_with(crate::LiteMessage::new).clone_from(options);
        }
        self.reserved_range.clone_from(&other.reserved_range);
        self.reserved_name.clone_from(&other.reserved_name);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::EnumDescriptorProto {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[6]
    }
}
impl self::EnumDescriptorProto {
    /// Gets the field number of the 'name' field
    pub const NAME_FIELD_NUMBER: i32 = 1;
    pub const NAME_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'value' field
    pub const VALUE_FIELD_NUMBER: i32 = 2;
    /// Gets the field number of the 'options' field
    pub const OPTIONS_FIELD_NUMBER: i32 = 3;
    /// Gets the field number of the 'reserved_range' field
    pub const RESERVED_RANGE_FIELD_NUMBER: i32 = 4;
    /// Gets the field number of the 'reserved_name' field
    pub const RESERVED_NAME_FIELD_NUMBER: i32 = 5;
}
#[derive(Debug, PartialEq)]
pub struct EnumDescriptorProto_EnumReservedRange {
    pub start: ::std::option::Option<i32>,
    pub end: ::std::option::Option<i32>,
    unknown_fields: crate::UnknownFieldSet
}
impl crate::CodedMessage for self::EnumDescriptorProto_EnumReservedRange {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 => self.start = ::std::option::Option::Some(input.read_int32()?),
                16 => self.end = ::std::option::Option::Some(input.read_int32()?),
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let start = self.start;
        if let ::std::option::Option::Some(start) = start {
            if start != Self::START_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::int32(start);
            }
        }
        let end = self.end;
        if let ::std::option::Option::Some(end) = end {
            if end != Self::END_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::int32(end);
            }
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let start = self.start;
        if let ::std::option::Option::Some(start) = start {
            if start != Self::START_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(start)?;
            }
        }
        let end = self.end;
        if let ::std::option::Option::Some(end) = end {
            if end != Self::END_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_int32(end)?;
            }
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::EnumDescriptorProto_EnumReservedRange {
    fn new() -> Self {
        Self {
            start: ::std::option::Option::None,
            end: ::std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl ::std::clone::Clone for self::EnumDescriptorProto_EnumReservedRange {
    fn clone(&self) -> Self {
        Self {
            start: self.start.clone(),
            end: self.end.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.start = other.start;
        self.end = other.end;
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::EnumDescriptorProto_EnumReservedRange {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[6].messages()[0]
    }
}
impl self::EnumDescriptorProto_EnumReservedRange {
    /// Gets the field number of the 'start' field
    pub const START_FIELD_NUMBER: i32 = 1;
    pub const START_DEFAULT_VALUE: i32 = 0;
    /// Gets the field number of the 'end' field
    pub const END_FIELD_NUMBER: i32 = 2;
    pub const END_DEFAULT_VALUE: i32 = 0;
}
#[derive(Debug, PartialEq)]
pub struct EnumValueDescriptorProto {
    pub name: ::std::option::Option<::std::string::String>,
    pub number: ::std::option::Option<i32>,
    pub options: ::std::option::Option<::std::boxed::Box<self::EnumValueOptions>>,
    unknown_fields: crate::UnknownFieldSet
}
impl crate::CodedMessage for self::EnumValueDescriptorProto {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.name = ::std::option::Option::Some(input.read_string()?),
                16 => self.number = ::std::option::Option::Some(input.read_int32()?),
                26 => input.read_message(self.options.get_or_insert_with(crate::LiteMessage::new))?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(name);
            }
        }
        let number = self.number;
        if let ::std::option::Option::Some(number) = number {
            if number != Self::NUMBER_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::int32(number);
            }
        }
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            size += 1;
            size += crate::io::sizes::message(options);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
        }
        let number = self.number;
        if let ::std::option::Option::Some(number) = number {
            if number != Self::NUMBER_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_int32(number)?;
            }
        }
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            output.write_raw_tag_bytes(&[26])?;
            output.write_message(options)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::EnumValueDescriptorProto {
    fn new() -> Self {
        Self {
            name: ::std::option::Option::None,
            number: ::std::option::Option::None,
            options: ::std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl ::std::clone::Clone for self::EnumValueDescriptorProto {
    fn clone(&self) -> Self {
        Self {
            name: self.name.clone(),
            number: self.number.clone(),
            options: self.options.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.name = other.name.clone();
        self.number = other.number;
        if let ::std::option::Option::Some(options) = &other.options {
            self.options.get_or_insert_with(crate::LiteMessage::new).clone_from(options);
        }
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::EnumValueDescriptorProto {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[7]
    }
}
impl self::EnumValueDescriptorProto {
    /// Gets the field number of the 'name' field
    pub const NAME_FIELD_NUMBER: i32 = 1;
    pub const NAME_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'number' field
    pub const NUMBER_FIELD_NUMBER: i32 = 2;
    pub const NUMBER_DEFAULT_VALUE: i32 = 0;
    /// Gets the field number of the 'options' field
    pub const OPTIONS_FIELD_NUMBER: i32 = 3;
}
#[derive(Debug, PartialEq)]
pub struct ServiceDescriptorProto {
    pub name: ::std::option::Option<::std::string::String>,
    pub method: crate::collections::RepeatedField<self::MethodDescriptorProto>,
    pub options: ::std::option::Option<::std::boxed::Box<self::ServiceOptions>>,
    unknown_fields: crate::UnknownFieldSet
}
static SERVICE_DESCRIPTOR_PROTO_METHOD_CODEC: crate::Codec<self::MethodDescriptorProto> = crate::Codec::message(18);
impl crate::CodedMessage for self::ServiceDescriptorProto {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.name = ::std::option::Option::Some(input.read_string()?),
                18 => self.method.add_entries(tag.get(), input, &SERVICE_DESCRIPTOR_PROTO_METHOD_CODEC)?,
                26 => input.read_message(self.options.get_or_insert_with(crate::LiteMessage::new))?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(name);
            }
        }
        size += self.method.calculate_size(&SERVICE_DESCRIPTOR_PROTO_METHOD_CODEC);
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            size += 1;
            size += crate::io::sizes::message(options);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
        }
        self.method.write_to(output, &SERVICE_DESCRIPTOR_PROTO_METHOD_CODEC)?;
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            output.write_raw_tag_bytes(&[26])?;
            output.write_message(options)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::ServiceDescriptorProto {
    fn new() -> Self {
        Self {
            name: ::std::option::Option::None,
            method: crate::collections::RepeatedField::new(),
            options: ::std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl ::std::clone::Clone for self::ServiceDescriptorProto {
    fn clone(&self) -> Self {
        Self {
            name: self.name.clone(),
            method: self.method.clone(),
            options: self.options.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.name = other.name.clone();
        self.method.clone_from(&other.method);
        if let ::std::option::Option::Some(options) = &other.options {
            self.options.get_or_insert_with(crate::LiteMessage::new).clone_from(options);
        }
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::ServiceDescriptorProto {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[8]
    }
}
impl self::ServiceDescriptorProto {
    /// Gets the field number of the 'name' field
    pub const NAME_FIELD_NUMBER: i32 = 1;
    pub const NAME_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'method' field
    pub const METHOD_FIELD_NUMBER: i32 = 2;
    /// Gets the field number of the 'options' field
    pub const OPTIONS_FIELD_NUMBER: i32 = 3;
}
#[derive(Debug, PartialEq)]
pub struct MethodDescriptorProto {
    pub name: ::std::option::Option<::std::string::String>,
    pub input_type: ::std::option::Option<::std::string::String>,
    pub output_type: ::std::option::Option<::std::string::String>,
    pub options: ::std::option::Option<::std::boxed::Box<self::MethodOptions>>,
    pub client_streaming: ::std::option::Option<bool>,
    pub server_streaming: ::std::option::Option<bool>,
    unknown_fields: crate::UnknownFieldSet
}
impl crate::CodedMessage for self::MethodDescriptorProto {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.name = ::std::option::Option::Some(input.read_string()?),
                18 => self.input_type = ::std::option::Option::Some(input.read_string()?),
                26 => self.output_type = ::std::option::Option::Some(input.read_string()?),
                34 => input.read_message(self.options.get_or_insert_with(crate::LiteMessage::new))?,
                40 => self.client_streaming = ::std::option::Option::Some(input.read_bool()?),
                48 => self.server_streaming = ::std::option::Option::Some(input.read_bool()?),
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(name);
            }
        }
        let input_type = &self.input_type;
        if let ::std::option::Option::Some(input_type) = input_type {
            if input_type != Self::INPUT_TYPE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(input_type);
            }
        }
        let output_type = &self.output_type;
        if let ::std::option::Option::Some(output_type) = output_type {
            if output_type != Self::OUTPUT_TYPE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(output_type);
            }
        }
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            size += 1;
            size += crate::io::sizes::message(options);
        }
        let client_streaming = self.client_streaming;
        if let ::std::option::Option::Some(client_streaming) = client_streaming {
            if client_streaming != Self::CLIENT_STREAMING_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(client_streaming);
            }
        }
        let server_streaming = self.server_streaming;
        if let ::std::option::Option::Some(server_streaming) = server_streaming {
            if server_streaming != Self::SERVER_STREAMING_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(server_streaming);
            }
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let name = &self.name;
        if let ::std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
        }
        let input_type = &self.input_type;
        if let ::std::option::Option::Some(input_type) = input_type {
            if input_type != Self::INPUT_TYPE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[18])?;
                output.write_string(input_type)?;
            }
        }
        let output_type = &self.output_type;
        if let ::std::option::Option::Some(output_type) = output_type {
            if output_type != Self::OUTPUT_TYPE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[26])?;
                output.write_string(output_type)?;
            }
        }
        let options = &self.options;
        if let ::std::option::Option::Some(options) = options {
            output.write_raw_tag_bytes(&[34])?;
            output.write_message(options)?;
        }
        let client_streaming = self.client_streaming;
        if let ::std::option::Option::Some(client_streaming) = client_streaming {
            if client_streaming != Self::CLIENT_STREAMING_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[40])?;
                output.write_bool(client_streaming)?;
            }
        }
        let server_streaming = self.server_streaming;
        if let ::std::option::Option::Some(server_streaming) = server_streaming {
            if server_streaming != Self::SERVER_STREAMING_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[48])?;
                output.write_bool(server_streaming)?;
            }
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::MethodDescriptorProto {
    fn new() -> Self {
        Self {
            name: ::std::option::Option::None,
            input_type: ::std::option::Option::None,
            output_type: ::std::option::Option::None,
            options: ::std::option::Option::None,
            client_streaming: ::std::option::Option::None,
            server_streaming: ::std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl ::std::clone::Clone for self::MethodDescriptorProto {
    fn clone(&self) -> Self {
        Self {
            name: self.name.clone(),
            input_type: self.input_type.clone(),
            output_type: self.output_type.clone(),
            options: self.options.clone(),
            client_streaming: self.client_streaming.clone(),
            server_streaming: self.server_streaming.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.name = other.name.clone();
        self.input_type = other.input_type.clone();
        self.output_type = other.output_type.clone();
        if let ::std::option::Option::Some(options) = &other.options {
            self.options.get_or_insert_with(crate::LiteMessage::new).clone_from(options);
        }
        self.client_streaming = other.client_streaming;
        self.server_streaming = other.server_streaming;
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::MethodDescriptorProto {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[9]
    }
}
impl self::MethodDescriptorProto {
    /// Gets the field number of the 'name' field
    pub const NAME_FIELD_NUMBER: i32 = 1;
    pub const NAME_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'input_type' field
    pub const INPUT_TYPE_FIELD_NUMBER: i32 = 2;
    pub const INPUT_TYPE_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'output_type' field
    pub const OUTPUT_TYPE_FIELD_NUMBER: i32 = 3;
    pub const OUTPUT_TYPE_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'options' field
    pub const OPTIONS_FIELD_NUMBER: i32 = 4;
    /// Gets the field number of the 'client_streaming' field
    pub const CLIENT_STREAMING_FIELD_NUMBER: i32 = 5;
    pub const CLIENT_STREAMING_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'server_streaming' field
    pub const SERVER_STREAMING_FIELD_NUMBER: i32 = 6;
    pub const SERVER_STREAMING_DEFAULT_VALUE: bool = false;
}
#[derive(Debug, PartialEq)]
pub struct FileOptions {
    pub java_package: ::std::option::Option<::std::string::String>,
    pub java_outer_classname: ::std::option::Option<::std::string::String>,
    pub java_multiple_files: ::std::option::Option<bool>,
    pub java_generate_equals_and_hash: ::std::option::Option<bool>,
    pub java_string_check_utf8: ::std::option::Option<bool>,
    pub optimize_for: ::std::option::Option<crate::EnumValue<self::FileOptions_OptimizeMode>>,
    pub go_package: ::std::option::Option<::std::string::String>,
    pub cc_generic_services: ::std::option::Option<bool>,
    pub java_generic_services: ::std::option::Option<bool>,
    pub py_generic_services: ::std::option::Option<bool>,
    pub php_generic_services: ::std::option::Option<bool>,
    pub deprecated: ::std::option::Option<bool>,
    pub cc_enable_arenas: ::std::option::Option<bool>,
    pub objc_class_prefix: ::std::option::Option<::std::string::String>,
    pub csharp_namespace: ::std::option::Option<::std::string::String>,
    pub swift_prefix: ::std::option::Option<::std::string::String>,
    pub php_class_prefix: ::std::option::Option<::std::string::String>,
    pub php_namespace: ::std::option::Option<::std::string::String>,
    pub php_metadata_namespace: ::std::option::Option<::std::string::String>,
    pub ruby_package: ::std::option::Option<::std::string::String>,
    pub uninterpreted_option: crate::collections::RepeatedField<self::UninterpretedOption>,
    unknown_fields: crate::UnknownFieldSet
}
static FILE_OPTIONS_UNINTERPRETED_OPTION_CODEC: crate::Codec<self::UninterpretedOption> = crate::Codec::message(7994);
impl crate::CodedMessage for self::FileOptions {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.java_package = ::std::option::Option::Some(input.read_string()?),
                66 => self.java_outer_classname = ::std::option::Option::Some(input.read_string()?),
                80 => self.java_multiple_files = ::std::option::Option::Some(input.read_bool()?),
                160 => self.java_generate_equals_and_hash = ::std::option::Option::Some(input.read_bool()?),
                216 => self.java_string_check_utf8 = ::std::option::Option::Some(input.read_bool()?),
                72 => self.optimize_for = ::std::option::Option::Some(input.read_enum_value()?),
                90 => self.go_package = ::std::option::Option::Some(input.read_string()?),
                128 => self.cc_generic_services = ::std::option::Option::Some(input.read_bool()?),
                136 => self.java_generic_services = ::std::option::Option::Some(input.read_bool()?),
                144 => self.py_generic_services = ::std::option::Option::Some(input.read_bool()?),
                336 => self.php_generic_services = ::std::option::Option::Some(input.read_bool()?),
                184 => self.deprecated = ::std::option::Option::Some(input.read_bool()?),
                248 => self.cc_enable_arenas = ::std::option::Option::Some(input.read_bool()?),
                290 => self.objc_class_prefix = ::std::option::Option::Some(input.read_string()?),
                298 => self.csharp_namespace = ::std::option::Option::Some(input.read_string()?),
                314 => self.swift_prefix = ::std::option::Option::Some(input.read_string()?),
                322 => self.php_class_prefix = ::std::option::Option::Some(input.read_string()?),
                330 => self.php_namespace = ::std::option::Option::Some(input.read_string()?),
                354 => self.php_metadata_namespace = ::std::option::Option::Some(input.read_string()?),
                362 => self.ruby_package = ::std::option::Option::Some(input.read_string()?),
                7994 => self.uninterpreted_option.add_entries(tag.get(), input, &FILE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let java_package = &self.java_package;
        if let ::std::option::Option::Some(java_package) = java_package {
            if java_package != Self::JAVA_PACKAGE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(java_package);
            }
        }
        let java_outer_classname = &self.java_outer_classname;
        if let ::std::option::Option::Some(java_outer_classname) = java_outer_classname {
            if java_outer_classname != Self::JAVA_OUTER_CLASSNAME_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(java_outer_classname);
            }
        }
        let java_multiple_files = self.java_multiple_files;
        if let ::std::option::Option::Some(java_multiple_files) = java_multiple_files {
            if java_multiple_files != Self::JAVA_MULTIPLE_FILES_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(java_multiple_files);
            }
        }
        let java_generate_equals_and_hash = self.java_generate_equals_and_hash;
        if let ::std::option::Option::Some(java_generate_equals_and_hash) = java_generate_equals_and_hash {
            if java_generate_equals_and_hash != Self::JAVA_GENERATE_EQUALS_AND_HASH_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::bool(java_generate_equals_and_hash);
            }
        }
        let java_string_check_utf8 = self.java_string_check_utf8;
        if let ::std::option::Option::Some(java_string_check_utf8) = java_string_check_utf8 {
            if java_string_check_utf8 != Self::JAVA_STRING_CHECK_UTF8_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::bool(java_string_check_utf8);
            }
        }
        let optimize_for = self.optimize_for;
        if let ::std::option::Option::Some(optimize_for) = optimize_for {
            if optimize_for != Self::OPTIMIZE_FOR_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::enum_value(optimize_for);
            }
        }
        let go_package = &self.go_package;
        if let ::std::option::Option::Some(go_package) = go_package {
            if go_package != Self::GO_PACKAGE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(go_package);
            }
        }
        let cc_generic_services = self.cc_generic_services;
        if let ::std::option::Option::Some(cc_generic_services) = cc_generic_services {
            if cc_generic_services != Self::CC_GENERIC_SERVICES_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::bool(cc_generic_services);
            }
        }
        let java_generic_services = self.java_generic_services;
        if let ::std::option::Option::Some(java_generic_services) = java_generic_services {
            if java_generic_services != Self::JAVA_GENERIC_SERVICES_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::bool(java_generic_services);
            }
        }
        let py_generic_services = self.py_generic_services;
        if let ::std::option::Option::Some(py_generic_services) = py_generic_services {
            if py_generic_services != Self::PY_GENERIC_SERVICES_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::bool(py_generic_services);
            }
        }
        let php_generic_services = self.php_generic_services;
        if let ::std::option::Option::Some(php_generic_services) = php_generic_services {
            if php_generic_services != Self::PHP_GENERIC_SERVICES_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::bool(php_generic_services);
            }
        }
        let deprecated = self.deprecated;
        if let ::std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::bool(deprecated);
            }
        }
        let cc_enable_arenas = self.cc_enable_arenas;
        if let ::std::option::Option::Some(cc_enable_arenas) = cc_enable_arenas {
            if cc_enable_arenas != Self::CC_ENABLE_ARENAS_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::bool(cc_enable_arenas);
            }
        }
        let objc_class_prefix = &self.objc_class_prefix;
        if let ::std::option::Option::Some(objc_class_prefix) = objc_class_prefix {
            if objc_class_prefix != Self::OBJC_CLASS_PREFIX_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::string(objc_class_prefix);
            }
        }
        let csharp_namespace = &self.csharp_namespace;
        if let ::std::option::Option::Some(csharp_namespace) = csharp_namespace {
            if csharp_namespace != Self::CSHARP_NAMESPACE_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::string(csharp_namespace);
            }
        }
        let swift_prefix = &self.swift_prefix;
        if let ::std::option::Option::Some(swift_prefix) = swift_prefix {
            if swift_prefix != Self::SWIFT_PREFIX_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::string(swift_prefix);
            }
        }
        let php_class_prefix = &self.php_class_prefix;
        if let ::std::option::Option::Some(php_class_prefix) = php_class_prefix {
            if php_class_prefix != Self::PHP_CLASS_PREFIX_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::string(php_class_prefix);
            }
        }
        let php_namespace = &self.php_namespace;
        if let ::std::option::Option::Some(php_namespace) = php_namespace {
            if php_namespace != Self::PHP_NAMESPACE_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::string(php_namespace);
            }
        }
        let php_metadata_namespace = &self.php_metadata_namespace;
        if let ::std::option::Option::Some(php_metadata_namespace) = php_metadata_namespace {
            if php_metadata_namespace != Self::PHP_METADATA_NAMESPACE_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::string(php_metadata_namespace);
            }
        }
        let ruby_package = &self.ruby_package;
        if let ::std::option::Option::Some(ruby_package) = ruby_package {
            if ruby_package != Self::RUBY_PACKAGE_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::string(ruby_package);
            }
        }
        size += self.uninterpreted_option.calculate_size(&FILE_OPTIONS_UNINTERPRETED_OPTION_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let java_package = &self.java_package;
        if let ::std::option::Option::Some(java_package) = java_package {
            if java_package != Self::JAVA_PACKAGE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(java_package)?;
            }
        }
        let java_outer_classname = &self.java_outer_classname;
        if let ::std::option::Option::Some(java_outer_classname) = java_outer_classname {
            if java_outer_classname != Self::JAVA_OUTER_CLASSNAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[66])?;
                output.write_string(java_outer_classname)?;
            }
        }
        let java_multiple_files = self.java_multiple_files;
        if let ::std::option::Option::Some(java_multiple_files) = java_multiple_files {
            if java_multiple_files != Self::JAVA_MULTIPLE_FILES_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[80])?;
                output.write_bool(java_multiple_files)?;
            }
        }
        let java_generate_equals_and_hash = self.java_generate_equals_and_hash;
        if let ::std::option::Option::Some(java_generate_equals_and_hash) = java_generate_equals_and_hash {
            if java_generate_equals_and_hash != Self::JAVA_GENERATE_EQUALS_AND_HASH_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[160, 1])?;
                output.write_bool(java_generate_equals_and_hash)?;
            }
        }
        let java_string_check_utf8 = self.java_string_check_utf8;
        if let ::std::option::Option::Some(java_string_check_utf8) = java_string_check_utf8 {
            if java_string_check_utf8 != Self::JAVA_STRING_CHECK_UTF8_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[216, 1])?;
                output.write_bool(java_string_check_utf8)?;
            }
        }
        let optimize_for = self.optimize_for;
        if let ::std::option::Option::Some(optimize_for) = optimize_for {
            if optimize_for != Self::OPTIMIZE_FOR_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[72])?;
                output.write_enum_value(optimize_for)?;
            }
        }
        let go_package = &self.go_package;
        if let ::std::option::Option::Some(go_package) = go_package {
            if go_package != Self::GO_PACKAGE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[90])?;
                output.write_string(go_package)?;
            }
        }
        let cc_generic_services = self.cc_generic_services;
        if let ::std::option::Option::Some(cc_generic_services) = cc_generic_services {
            if cc_generic_services != Self::CC_GENERIC_SERVICES_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[128, 1])?;
                output.write_bool(cc_generic_services)?;
            }
        }
        let java_generic_services = self.java_generic_services;
        if let ::std::option::Option::Some(java_generic_services) = java_generic_services {
            if java_generic_services != Self::JAVA_GENERIC_SERVICES_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[136, 1])?;
                output.write_bool(java_generic_services)?;
            }
        }
        let py_generic_services = self.py_generic_services;
        if let ::std::option::Option::Some(py_generic_services) = py_generic_services {
            if py_generic_services != Self::PY_GENERIC_SERVICES_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[144, 1])?;
                output.write_bool(py_generic_services)?;
            }
        }
        let php_generic_services = self.php_generic_services;
        if let ::std::option::Option::Some(php_generic_services) = php_generic_services {
            if php_generic_services != Self::PHP_GENERIC_SERVICES_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[208, 2])?;
                output.write_bool(php_generic_services)?;
            }
        }
        let deprecated = self.deprecated;
        if let ::std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[184, 1])?;
                output.write_bool(deprecated)?;
            }
        }
        let cc_enable_arenas = self.cc_enable_arenas;
        if let ::std::option::Option::Some(cc_enable_arenas) = cc_enable_arenas {
            if cc_enable_arenas != Self::CC_ENABLE_ARENAS_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[248, 1])?;
                output.write_bool(cc_enable_arenas)?;
            }
        }
        let objc_class_prefix = &self.objc_class_prefix;
        if let ::std::option::Option::Some(objc_class_prefix) = objc_class_prefix {
            if objc_class_prefix != Self::OBJC_CLASS_PREFIX_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[162, 2])?;
                output.write_string(objc_class_prefix)?;
            }
        }
        let csharp_namespace = &self.csharp_namespace;
        if let ::std::option::Option::Some(csharp_namespace) = csharp_namespace {
            if csharp_namespace != Self::CSHARP_NAMESPACE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[170, 2])?;
                output.write_string(csharp_namespace)?;
            }
        }
        let swift_prefix = &self.swift_prefix;
        if let ::std::option::Option::Some(swift_prefix) = swift_prefix {
            if swift_prefix != Self::SWIFT_PREFIX_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[186, 2])?;
                output.write_string(swift_prefix)?;
            }
        }
        let php_class_prefix = &self.php_class_prefix;
        if let ::std::option::Option::Some(php_class_prefix) = php_class_prefix {
            if php_class_prefix != Self::PHP_CLASS_PREFIX_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[194, 2])?;
                output.write_string(php_class_prefix)?;
            }
        }
        let php_namespace = &self.php_namespace;
        if let ::std::option::Option::Some(php_namespace) = php_namespace {
            if php_namespace != Self::PHP_NAMESPACE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[202, 2])?;
                output.write_string(php_namespace)?;
            }
        }
        let php_metadata_namespace = &self.php_metadata_namespace;
        if let ::std::option::Option::Some(php_metadata_namespace) = php_metadata_namespace {
            if php_metadata_namespace != Self::PHP_METADATA_NAMESPACE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[226, 2])?;
                output.write_string(php_metadata_namespace)?;
            }
        }
        let ruby_package = &self.ruby_package;
        if let ::std::option::Option::Some(ruby_package) = ruby_package {
            if ruby_package != Self::RUBY_PACKAGE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[234, 2])?;
                output.write_string(ruby_package)?;
            }
        }
        self.uninterpreted_option.write_to(output, &FILE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::FileOptions {
    fn new() -> Self {
        Self {
            java_package: ::std::option::Option::None,
            java_outer_classname: ::std::option::Option::None,
            java_multiple_files: ::std::option::Option::None,
            java_generate_equals_and_hash: ::std::option::Option::None,
            java_string_check_utf8: ::std::option::Option::None,
            optimize_for: ::std::option::Option::None,
            go_package: ::std::option::Option::None,
            cc_generic_services: ::std::option::Option::None,
            java_generic_services: ::std::option::Option::None,
            py_generic_services: ::std::option::Option::None,
            php_generic_services: ::std::option::Option::None,
            deprecated: ::std::option::Option::None,
            cc_enable_arenas: ::std::option::Option::None,
            objc_class_prefix: ::std::option::Option::None,
            csharp_namespace: ::std::option::Option::None,
            swift_prefix: ::std::option::Option::None,
            php_class_prefix: ::std::option::Option::None,
            php_namespace: ::std::option::Option::None,
            php_metadata_namespace: ::std::option::Option::None,
            ruby_package: ::std::option::Option::None,
            uninterpreted_option: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl ::std::clone::Clone for self::FileOptions {
    fn clone(&self) -> Self {
        Self {
            java_package: self.java_package.clone(),
            java_outer_classname: self.java_outer_classname.clone(),
            java_multiple_files: self.java_multiple_files.clone(),
            java_generate_equals_and_hash: self.java_generate_equals_and_hash.clone(),
            java_string_check_utf8: self.java_string_check_utf8.clone(),
            optimize_for: self.optimize_for.clone(),
            go_package: self.go_package.clone(),
            cc_generic_services: self.cc_generic_services.clone(),
            java_generic_services: self.java_generic_services.clone(),
            py_generic_services: self.py_generic_services.clone(),
            php_generic_services: self.php_generic_services.clone(),
            deprecated: self.deprecated.clone(),
            cc_enable_arenas: self.cc_enable_arenas.clone(),
            objc_class_prefix: self.objc_class_prefix.clone(),
            csharp_namespace: self.csharp_namespace.clone(),
            swift_prefix: self.swift_prefix.clone(),
            php_class_prefix: self.php_class_prefix.clone(),
            php_namespace: self.php_namespace.clone(),
            php_metadata_namespace: self.php_metadata_namespace.clone(),
            ruby_package: self.ruby_package.clone(),
            uninterpreted_option: self.uninterpreted_option.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.java_package = other.java_package.clone();
        self.java_outer_classname = other.java_outer_classname.clone();
        self.java_multiple_files = other.java_multiple_files;
        self.java_generate_equals_and_hash = other.java_generate_equals_and_hash;
        self.java_string_check_utf8 = other.java_string_check_utf8;
        self.optimize_for = other.optimize_for;
        self.go_package = other.go_package.clone();
        self.cc_generic_services = other.cc_generic_services;
        self.java_generic_services = other.java_generic_services;
        self.py_generic_services = other.py_generic_services;
        self.php_generic_services = other.php_generic_services;
        self.deprecated = other.deprecated;
        self.cc_enable_arenas = other.cc_enable_arenas;
        self.objc_class_prefix = other.objc_class_prefix.clone();
        self.csharp_namespace = other.csharp_namespace.clone();
        self.swift_prefix = other.swift_prefix.clone();
        self.php_class_prefix = other.php_class_prefix.clone();
        self.php_namespace = other.php_namespace.clone();
        self.php_metadata_namespace = other.php_metadata_namespace.clone();
        self.ruby_package = other.ruby_package.clone();
        self.uninterpreted_option.clone_from(&other.uninterpreted_option);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::FileOptions {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[10]
    }
}
impl self::FileOptions {
    /// Gets the field number of the 'java_package' field
    pub const JAVA_PACKAGE_FIELD_NUMBER: i32 = 1;
    pub const JAVA_PACKAGE_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'java_outer_classname' field
    pub const JAVA_OUTER_CLASSNAME_FIELD_NUMBER: i32 = 8;
    pub const JAVA_OUTER_CLASSNAME_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'java_multiple_files' field
    pub const JAVA_MULTIPLE_FILES_FIELD_NUMBER: i32 = 10;
    pub const JAVA_MULTIPLE_FILES_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'java_generate_equals_and_hash' field
    pub const JAVA_GENERATE_EQUALS_AND_HASH_FIELD_NUMBER: i32 = 20;
    pub const JAVA_GENERATE_EQUALS_AND_HASH_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'java_string_check_utf8' field
    pub const JAVA_STRING_CHECK_UTF8_FIELD_NUMBER: i32 = 27;
    pub const JAVA_STRING_CHECK_UTF8_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'optimize_for' field
    pub const OPTIMIZE_FOR_FIELD_NUMBER: i32 = 9;
    pub const OPTIMIZE_FOR_DEFAULT_VALUE: crate::EnumValue<self::FileOptions_OptimizeMode> = crate::EnumValue::Defined(self::FileOptions_OptimizeMode::Speed);
    /// Gets the field number of the 'go_package' field
    pub const GO_PACKAGE_FIELD_NUMBER: i32 = 11;
    pub const GO_PACKAGE_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'cc_generic_services' field
    pub const CC_GENERIC_SERVICES_FIELD_NUMBER: i32 = 16;
    pub const CC_GENERIC_SERVICES_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'java_generic_services' field
    pub const JAVA_GENERIC_SERVICES_FIELD_NUMBER: i32 = 17;
    pub const JAVA_GENERIC_SERVICES_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'py_generic_services' field
    pub const PY_GENERIC_SERVICES_FIELD_NUMBER: i32 = 18;
    pub const PY_GENERIC_SERVICES_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'php_generic_services' field
    pub const PHP_GENERIC_SERVICES_FIELD_NUMBER: i32 = 42;
    pub const PHP_GENERIC_SERVICES_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'deprecated' field
    pub const DEPRECATED_FIELD_NUMBER: i32 = 23;
    pub const DEPRECATED_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'cc_enable_arenas' field
    pub const CC_ENABLE_ARENAS_FIELD_NUMBER: i32 = 31;
    pub const CC_ENABLE_ARENAS_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'objc_class_prefix' field
    pub const OBJC_CLASS_PREFIX_FIELD_NUMBER: i32 = 36;
    pub const OBJC_CLASS_PREFIX_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'csharp_namespace' field
    pub const CSHARP_NAMESPACE_FIELD_NUMBER: i32 = 37;
    pub const CSHARP_NAMESPACE_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'swift_prefix' field
    pub const SWIFT_PREFIX_FIELD_NUMBER: i32 = 39;
    pub const SWIFT_PREFIX_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'php_class_prefix' field
    pub const PHP_CLASS_PREFIX_FIELD_NUMBER: i32 = 40;
    pub const PHP_CLASS_PREFIX_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'php_namespace' field
    pub const PHP_NAMESPACE_FIELD_NUMBER: i32 = 41;
    pub const PHP_NAMESPACE_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'php_metadata_namespace' field
    pub const PHP_METADATA_NAMESPACE_FIELD_NUMBER: i32 = 44;
    pub const PHP_METADATA_NAMESPACE_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'ruby_package' field
    pub const RUBY_PACKAGE_FIELD_NUMBER: i32 = 45;
    pub const RUBY_PACKAGE_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'uninterpreted_option' field
    pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
}
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum FileOptions_OptimizeMode {
    Speed = 1,
    CodeSize = 2,
    LiteRuntime = 3,
}
impl ::std::convert::TryFrom<i32> for self::FileOptions_OptimizeMode {
    type Error = crate::VariantUndefinedError;
    fn try_from(value: i32) -> ::std::result::Result<Self, crate::VariantUndefinedError> {
        match value {
            1 => ::std::result::Result::Ok(self::FileOptions_OptimizeMode::Speed),
            2 => ::std::result::Result::Ok(self::FileOptions_OptimizeMode::CodeSize),
            3 => ::std::result::Result::Ok(self::FileOptions_OptimizeMode::LiteRuntime),
            _ => ::std::result::Result::Err(crate::VariantUndefinedError)
        }
    }
}
impl ::std::convert::From<self::FileOptions_OptimizeMode> for i32 {
    fn from(value: self::FileOptions_OptimizeMode) -> i32 {
        value as i32
    }
}
#[derive(Debug, PartialEq)]
pub struct MessageOptions {
    pub message_set_wire_format: ::std::option::Option<bool>,
    pub no_standard_descriptor_accessor: ::std::option::Option<bool>,
    pub deprecated: ::std::option::Option<bool>,
    pub map_entry: ::std::option::Option<bool>,
    pub uninterpreted_option: crate::collections::RepeatedField<self::UninterpretedOption>,
    unknown_fields: crate::UnknownFieldSet
}
static MESSAGE_OPTIONS_UNINTERPRETED_OPTION_CODEC: crate::Codec<self::UninterpretedOption> = crate::Codec::message(7994);
impl crate::CodedMessage for self::MessageOptions {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 => self.message_set_wire_format = ::std::option::Option::Some(input.read_bool()?),
                16 => self.no_standard_descriptor_accessor = ::std::option::Option::Some(input.read_bool()?),
                24 => self.deprecated = ::std::option::Option::Some(input.read_bool()?),
                56 => self.map_entry = ::std::option::Option::Some(input.read_bool()?),
                7994 => self.uninterpreted_option.add_entries(tag.get(), input, &MESSAGE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let message_set_wire_format = self.message_set_wire_format;
        if let ::std::option::Option::Some(message_set_wire_format) = message_set_wire_format {
            if message_set_wire_format != Self::MESSAGE_SET_WIRE_FORMAT_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(message_set_wire_format);
            }
        }
        let no_standard_descriptor_accessor = self.no_standard_descriptor_accessor;
        if let ::std::option::Option::Some(no_standard_descriptor_accessor) = no_standard_descriptor_accessor {
            if no_standard_descriptor_accessor != Self::NO_STANDARD_DESCRIPTOR_ACCESSOR_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(no_standard_descriptor_accessor);
            }
        }
        let deprecated = self.deprecated;
        if let ::std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(deprecated);
            }
        }
        let map_entry = self.map_entry;
        if let ::std::option::Option::Some(map_entry) = map_entry {
            if map_entry != Self::MAP_ENTRY_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(map_entry);
            }
        }
        size += self.uninterpreted_option.calculate_size(&MESSAGE_OPTIONS_UNINTERPRETED_OPTION_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let message_set_wire_format = self.message_set_wire_format;
        if let ::std::option::Option::Some(message_set_wire_format) = message_set_wire_format {
            if message_set_wire_format != Self::MESSAGE_SET_WIRE_FORMAT_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_bool(message_set_wire_format)?;
            }
        }
        let no_standard_descriptor_accessor = self.no_standard_descriptor_accessor;
        if let ::std::option::Option::Some(no_standard_descriptor_accessor) = no_standard_descriptor_accessor {
            if no_standard_descriptor_accessor != Self::NO_STANDARD_DESCRIPTOR_ACCESSOR_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_bool(no_standard_descriptor_accessor)?;
            }
        }
        let deprecated = self.deprecated;
        if let ::std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[24])?;
                output.write_bool(deprecated)?;
            }
        }
        let map_entry = self.map_entry;
        if let ::std::option::Option::Some(map_entry) = map_entry {
            if map_entry != Self::MAP_ENTRY_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[56])?;
                output.write_bool(map_entry)?;
            }
        }
        self.uninterpreted_option.write_to(output, &MESSAGE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::MessageOptions {
    fn new() -> Self {
        Self {
            message_set_wire_format: ::std::option::Option::None,
            no_standard_descriptor_accessor: ::std::option::Option::None,
            deprecated: ::std::option::Option::None,
            map_entry: ::std::option::Option::None,
            uninterpreted_option: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl ::std::clone::Clone for self::MessageOptions {
    fn clone(&self) -> Self {
        Self {
            message_set_wire_format: self.message_set_wire_format.clone(),
            no_standard_descriptor_accessor: self.no_standard_descriptor_accessor.clone(),
            deprecated: self.deprecated.clone(),
            map_entry: self.map_entry.clone(),
            uninterpreted_option: self.uninterpreted_option.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.message_set_wire_format = other.message_set_wire_format;
        self.no_standard_descriptor_accessor = other.no_standard_descriptor_accessor;
        self.deprecated = other.deprecated;
        self.map_entry = other.map_entry;
        self.uninterpreted_option.clone_from(&other.uninterpreted_option);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::MessageOptions {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[11]
    }
}
impl self::MessageOptions {
    /// Gets the field number of the 'message_set_wire_format' field
    pub const MESSAGE_SET_WIRE_FORMAT_FIELD_NUMBER: i32 = 1;
    pub const MESSAGE_SET_WIRE_FORMAT_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'no_standard_descriptor_accessor' field
    pub const NO_STANDARD_DESCRIPTOR_ACCESSOR_FIELD_NUMBER: i32 = 2;
    pub const NO_STANDARD_DESCRIPTOR_ACCESSOR_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'deprecated' field
    pub const DEPRECATED_FIELD_NUMBER: i32 = 3;
    pub const DEPRECATED_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'map_entry' field
    pub const MAP_ENTRY_FIELD_NUMBER: i32 = 7;
    pub const MAP_ENTRY_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'uninterpreted_option' field
    pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
}
#[derive(Debug, PartialEq)]
pub struct FieldOptions {
    pub ctype: ::std::option::Option<crate::EnumValue<self::FieldOptions_CType>>,
    pub packed: ::std::option::Option<bool>,
    pub jstype: ::std::option::Option<crate::EnumValue<self::FieldOptions_JSType>>,
    pub lazy: ::std::option::Option<bool>,
    pub deprecated: ::std::option::Option<bool>,
    pub weak: ::std::option::Option<bool>,
    pub uninterpreted_option: crate::collections::RepeatedField<self::UninterpretedOption>,
    unknown_fields: crate::UnknownFieldSet
}
static FIELD_OPTIONS_UNINTERPRETED_OPTION_CODEC: crate::Codec<self::UninterpretedOption> = crate::Codec::message(7994);
impl crate::CodedMessage for self::FieldOptions {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 => self.ctype = ::std::option::Option::Some(input.read_enum_value()?),
                16 => self.packed = ::std::option::Option::Some(input.read_bool()?),
                48 => self.jstype = ::std::option::Option::Some(input.read_enum_value()?),
                40 => self.lazy = ::std::option::Option::Some(input.read_bool()?),
                24 => self.deprecated = ::std::option::Option::Some(input.read_bool()?),
                80 => self.weak = ::std::option::Option::Some(input.read_bool()?),
                7994 => self.uninterpreted_option.add_entries(tag.get(), input, &FIELD_OPTIONS_UNINTERPRETED_OPTION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let ctype = self.ctype;
        if let ::std::option::Option::Some(ctype) = ctype {
            if ctype != Self::CTYPE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::enum_value(ctype);
            }
        }
        let packed = self.packed;
        if let ::std::option::Option::Some(packed) = packed {
            if packed != Self::PACKED_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(packed);
            }
        }
        let jstype = self.jstype;
        if let ::std::option::Option::Some(jstype) = jstype {
            if jstype != Self::JSTYPE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::enum_value(jstype);
            }
        }
        let lazy = self.lazy;
        if let ::std::option::Option::Some(lazy) = lazy {
            if lazy != Self::LAZY_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(lazy);
            }
        }
        let deprecated = self.deprecated;
        if let ::std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(deprecated);
            }
        }
        let weak = self.weak;
        if let ::std::option::Option::Some(weak) = weak {
            if weak != Self::WEAK_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(weak);
            }
        }
        size += self.uninterpreted_option.calculate_size(&FIELD_OPTIONS_UNINTERPRETED_OPTION_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let ctype = self.ctype;
        if let ::std::option::Option::Some(ctype) = ctype {
            if ctype != Self::CTYPE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_enum_value(ctype)?;
            }
        }
        let packed = self.packed;
        if let ::std::option::Option::Some(packed) = packed {
            if packed != Self::PACKED_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_bool(packed)?;
            }
        }
        let jstype = self.jstype;
        if let ::std::option::Option::Some(jstype) = jstype {
            if jstype != Self::JSTYPE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[48])?;
                output.write_enum_value(jstype)?;
            }
        }
        let lazy = self.lazy;
        if let ::std::option::Option::Some(lazy) = lazy {
            if lazy != Self::LAZY_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[40])?;
                output.write_bool(lazy)?;
            }
        }
        let deprecated = self.deprecated;
        if let ::std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[24])?;
                output.write_bool(deprecated)?;
            }
        }
        let weak = self.weak;
        if let ::std::option::Option::Some(weak) = weak {
            if weak != Self::WEAK_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[80])?;
                output.write_bool(weak)?;
            }
        }
        self.uninterpreted_option.write_to(output, &FIELD_OPTIONS_UNINTERPRETED_OPTION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::FieldOptions {
    fn new() -> Self {
        Self {
            ctype: ::std::option::Option::None,
            packed: ::std::option::Option::None,
            jstype: ::std::option::Option::None,
            lazy: ::std::option::Option::None,
            deprecated: ::std::option::Option::None,
            weak: ::std::option::Option::None,
            uninterpreted_option: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl ::std::clone::Clone for self::FieldOptions {
    fn clone(&self) -> Self {
        Self {
            ctype: self.ctype.clone(),
            packed: self.packed.clone(),
            jstype: self.jstype.clone(),
            lazy: self.lazy.clone(),
            deprecated: self.deprecated.clone(),
            weak: self.weak.clone(),
            uninterpreted_option: self.uninterpreted_option.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.ctype = other.ctype;
        self.packed = other.packed;
        self.jstype = other.jstype;
        self.lazy = other.lazy;
        self.deprecated = other.deprecated;
        self.weak = other.weak;
        self.uninterpreted_option.clone_from(&other.uninterpreted_option);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::FieldOptions {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[12]
    }
}
impl self::FieldOptions {
    /// Gets the field number of the 'ctype' field
    pub const CTYPE_FIELD_NUMBER: i32 = 1;
    pub const CTYPE_DEFAULT_VALUE: crate::EnumValue<self::FieldOptions_CType> = crate::EnumValue::Defined(self::FieldOptions_CType::String);
    /// Gets the field number of the 'packed' field
    pub const PACKED_FIELD_NUMBER: i32 = 2;
    pub const PACKED_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'jstype' field
    pub const JSTYPE_FIELD_NUMBER: i32 = 6;
    pub const JSTYPE_DEFAULT_VALUE: crate::EnumValue<self::FieldOptions_JSType> = crate::EnumValue::Defined(self::FieldOptions_JSType::Normal);
    /// Gets the field number of the 'lazy' field
    pub const LAZY_FIELD_NUMBER: i32 = 5;
    pub const LAZY_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'deprecated' field
    pub const DEPRECATED_FIELD_NUMBER: i32 = 3;
    pub const DEPRECATED_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'weak' field
    pub const WEAK_FIELD_NUMBER: i32 = 10;
    pub const WEAK_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'uninterpreted_option' field
    pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
}
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum FieldOptions_CType {
    String = 0,
    Ord = 1,
    StringPiece = 2,
}
impl ::std::convert::TryFrom<i32> for self::FieldOptions_CType {
    type Error = crate::VariantUndefinedError;
    fn try_from(value: i32) -> ::std::result::Result<Self, crate::VariantUndefinedError> {
        match value {
            0 => ::std::result::Result::Ok(self::FieldOptions_CType::String),
            1 => ::std::result::Result::Ok(self::FieldOptions_CType::Ord),
            2 => ::std::result::Result::Ok(self::FieldOptions_CType::StringPiece),
            _ => ::std::result::Result::Err(crate::VariantUndefinedError)
        }
    }
}
impl ::std::convert::From<self::FieldOptions_CType> for i32 {
    fn from(value: self::FieldOptions_CType) -> i32 {
        value as i32
    }
}
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum FieldOptions_JSType {
    Normal = 0,
    String = 1,
    Number = 2,
}
impl ::std::convert::TryFrom<i32> for self::FieldOptions_JSType {
    type Error = crate::VariantUndefinedError;
    fn try_from(value: i32) -> ::std::result::Result<Self, crate::VariantUndefinedError> {
        match value {
            0 => ::std::result::Result::Ok(self::FieldOptions_JSType::Normal),
            1 => ::std::result::Result::Ok(self::FieldOptions_JSType::String),
            2 => ::std::result::Result::Ok(self::FieldOptions_JSType::Number),
            _ => ::std::result::Result::Err(crate::VariantUndefinedError)
        }
    }
}
impl ::std::convert::From<self::FieldOptions_JSType> for i32 {
    fn from(value: self::FieldOptions_JSType) -> i32 {
        value as i32
    }
}
#[derive(Debug, PartialEq)]
pub struct OneofOptions {
    pub uninterpreted_option: crate::collections::RepeatedField<self::UninterpretedOption>,
    unknown_fields: crate::UnknownFieldSet
}
static ONEOF_OPTIONS_UNINTERPRETED_OPTION_CODEC: crate::Codec<self::UninterpretedOption> = crate::Codec::message(7994);
impl crate::CodedMessage for self::OneofOptions {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                7994 => self.uninterpreted_option.add_entries(tag.get(), input, &ONEOF_OPTIONS_UNINTERPRETED_OPTION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.uninterpreted_option.calculate_size(&ONEOF_OPTIONS_UNINTERPRETED_OPTION_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        self.uninterpreted_option.write_to(output, &ONEOF_OPTIONS_UNINTERPRETED_OPTION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::OneofOptions {
    fn new() -> Self {
        Self {
            uninterpreted_option: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl ::std::clone::Clone for self::OneofOptions {
    fn clone(&self) -> Self {
        Self {
            uninterpreted_option: self.uninterpreted_option.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.uninterpreted_option.clone_from(&other.uninterpreted_option);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::OneofOptions {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[13]
    }
}
impl self::OneofOptions {
    /// Gets the field number of the 'uninterpreted_option' field
    pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
}
#[derive(Debug, PartialEq)]
pub struct EnumOptions {
    pub allow_alias: ::std::option::Option<bool>,
    pub deprecated: ::std::option::Option<bool>,
    pub uninterpreted_option: crate::collections::RepeatedField<self::UninterpretedOption>,
    unknown_fields: crate::UnknownFieldSet
}
static ENUM_OPTIONS_UNINTERPRETED_OPTION_CODEC: crate::Codec<self::UninterpretedOption> = crate::Codec::message(7994);
impl crate::CodedMessage for self::EnumOptions {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                16 => self.allow_alias = ::std::option::Option::Some(input.read_bool()?),
                24 => self.deprecated = ::std::option::Option::Some(input.read_bool()?),
                7994 => self.uninterpreted_option.add_entries(tag.get(), input, &ENUM_OPTIONS_UNINTERPRETED_OPTION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let allow_alias = self.allow_alias;
        if let ::std::option::Option::Some(allow_alias) = allow_alias {
            if allow_alias != Self::ALLOW_ALIAS_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(allow_alias);
            }
        }
        let deprecated = self.deprecated;
        if let ::std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(deprecated);
            }
        }
        size += self.uninterpreted_option.calculate_size(&ENUM_OPTIONS_UNINTERPRETED_OPTION_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let allow_alias = self.allow_alias;
        if let ::std::option::Option::Some(allow_alias) = allow_alias {
            if allow_alias != Self::ALLOW_ALIAS_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_bool(allow_alias)?;
            }
        }
        let deprecated = self.deprecated;
        if let ::std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[24])?;
                output.write_bool(deprecated)?;
            }
        }
        self.uninterpreted_option.write_to(output, &ENUM_OPTIONS_UNINTERPRETED_OPTION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::EnumOptions {
    fn new() -> Self {
        Self {
            allow_alias: ::std::option::Option::None,
            deprecated: ::std::option::Option::None,
            uninterpreted_option: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl ::std::clone::Clone for self::EnumOptions {
    fn clone(&self) -> Self {
        Self {
            allow_alias: self.allow_alias.clone(),
            deprecated: self.deprecated.clone(),
            uninterpreted_option: self.uninterpreted_option.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.allow_alias = other.allow_alias;
        self.deprecated = other.deprecated;
        self.uninterpreted_option.clone_from(&other.uninterpreted_option);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::EnumOptions {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[14]
    }
}
impl self::EnumOptions {
    /// Gets the field number of the 'allow_alias' field
    pub const ALLOW_ALIAS_FIELD_NUMBER: i32 = 2;
    pub const ALLOW_ALIAS_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'deprecated' field
    pub const DEPRECATED_FIELD_NUMBER: i32 = 3;
    pub const DEPRECATED_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'uninterpreted_option' field
    pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
}
#[derive(Debug, PartialEq)]
pub struct EnumValueOptions {
    pub deprecated: ::std::option::Option<bool>,
    pub uninterpreted_option: crate::collections::RepeatedField<self::UninterpretedOption>,
    unknown_fields: crate::UnknownFieldSet
}
static ENUM_VALUE_OPTIONS_UNINTERPRETED_OPTION_CODEC: crate::Codec<self::UninterpretedOption> = crate::Codec::message(7994);
impl crate::CodedMessage for self::EnumValueOptions {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 => self.deprecated = ::std::option::Option::Some(input.read_bool()?),
                7994 => self.uninterpreted_option.add_entries(tag.get(), input, &ENUM_VALUE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let deprecated = self.deprecated;
        if let ::std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(deprecated);
            }
        }
        size += self.uninterpreted_option.calculate_size(&ENUM_VALUE_OPTIONS_UNINTERPRETED_OPTION_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let deprecated = self.deprecated;
        if let ::std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_bool(deprecated)?;
            }
        }
        self.uninterpreted_option.write_to(output, &ENUM_VALUE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::EnumValueOptions {
    fn new() -> Self {
        Self {
            deprecated: ::std::option::Option::None,
            uninterpreted_option: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl ::std::clone::Clone for self::EnumValueOptions {
    fn clone(&self) -> Self {
        Self {
            deprecated: self.deprecated.clone(),
            uninterpreted_option: self.uninterpreted_option.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.deprecated = other.deprecated;
        self.uninterpreted_option.clone_from(&other.uninterpreted_option);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::EnumValueOptions {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[15]
    }
}
impl self::EnumValueOptions {
    /// Gets the field number of the 'deprecated' field
    pub const DEPRECATED_FIELD_NUMBER: i32 = 1;
    pub const DEPRECATED_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'uninterpreted_option' field
    pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
}
#[derive(Debug, PartialEq)]
pub struct ServiceOptions {
    pub deprecated: ::std::option::Option<bool>,
    pub uninterpreted_option: crate::collections::RepeatedField<self::UninterpretedOption>,
    unknown_fields: crate::UnknownFieldSet
}
static SERVICE_OPTIONS_UNINTERPRETED_OPTION_CODEC: crate::Codec<self::UninterpretedOption> = crate::Codec::message(7994);
impl crate::CodedMessage for self::ServiceOptions {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                264 => self.deprecated = ::std::option::Option::Some(input.read_bool()?),
                7994 => self.uninterpreted_option.add_entries(tag.get(), input, &SERVICE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let deprecated = self.deprecated;
        if let ::std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::bool(deprecated);
            }
        }
        size += self.uninterpreted_option.calculate_size(&SERVICE_OPTIONS_UNINTERPRETED_OPTION_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let deprecated = self.deprecated;
        if let ::std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[136, 2])?;
                output.write_bool(deprecated)?;
            }
        }
        self.uninterpreted_option.write_to(output, &SERVICE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::ServiceOptions {
    fn new() -> Self {
        Self {
            deprecated: ::std::option::Option::None,
            uninterpreted_option: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl ::std::clone::Clone for self::ServiceOptions {
    fn clone(&self) -> Self {
        Self {
            deprecated: self.deprecated.clone(),
            uninterpreted_option: self.uninterpreted_option.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.deprecated = other.deprecated;
        self.uninterpreted_option.clone_from(&other.uninterpreted_option);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::ServiceOptions {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[16]
    }
}
impl self::ServiceOptions {
    /// Gets the field number of the 'deprecated' field
    pub const DEPRECATED_FIELD_NUMBER: i32 = 33;
    pub const DEPRECATED_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'uninterpreted_option' field
    pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
}
#[derive(Debug, PartialEq)]
pub struct MethodOptions {
    pub deprecated: ::std::option::Option<bool>,
    pub idempotency_level: ::std::option::Option<crate::EnumValue<self::MethodOptions_IdempotencyLevel>>,
    pub uninterpreted_option: crate::collections::RepeatedField<self::UninterpretedOption>,
    unknown_fields: crate::UnknownFieldSet
}
static METHOD_OPTIONS_UNINTERPRETED_OPTION_CODEC: crate::Codec<self::UninterpretedOption> = crate::Codec::message(7994);
impl crate::CodedMessage for self::MethodOptions {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                264 => self.deprecated = ::std::option::Option::Some(input.read_bool()?),
                272 => self.idempotency_level = ::std::option::Option::Some(input.read_enum_value()?),
                7994 => self.uninterpreted_option.add_entries(tag.get(), input, &METHOD_OPTIONS_UNINTERPRETED_OPTION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let deprecated = self.deprecated;
        if let ::std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::bool(deprecated);
            }
        }
        let idempotency_level = self.idempotency_level;
        if let ::std::option::Option::Some(idempotency_level) = idempotency_level {
            if idempotency_level != Self::IDEMPOTENCY_LEVEL_DEFAULT_VALUE {
                size += 2;
                size += crate::io::sizes::enum_value(idempotency_level);
            }
        }
        size += self.uninterpreted_option.calculate_size(&METHOD_OPTIONS_UNINTERPRETED_OPTION_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let deprecated = self.deprecated;
        if let ::std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[136, 2])?;
                output.write_bool(deprecated)?;
            }
        }
        let idempotency_level = self.idempotency_level;
        if let ::std::option::Option::Some(idempotency_level) = idempotency_level {
            if idempotency_level != Self::IDEMPOTENCY_LEVEL_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[144, 2])?;
                output.write_enum_value(idempotency_level)?;
            }
        }
        self.uninterpreted_option.write_to(output, &METHOD_OPTIONS_UNINTERPRETED_OPTION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::MethodOptions {
    fn new() -> Self {
        Self {
            deprecated: ::std::option::Option::None,
            idempotency_level: ::std::option::Option::None,
            uninterpreted_option: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl ::std::clone::Clone for self::MethodOptions {
    fn clone(&self) -> Self {
        Self {
            deprecated: self.deprecated.clone(),
            idempotency_level: self.idempotency_level.clone(),
            uninterpreted_option: self.uninterpreted_option.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.deprecated = other.deprecated;
        self.idempotency_level = other.idempotency_level;
        self.uninterpreted_option.clone_from(&other.uninterpreted_option);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::MethodOptions {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[17]
    }
}
impl self::MethodOptions {
    /// Gets the field number of the 'deprecated' field
    pub const DEPRECATED_FIELD_NUMBER: i32 = 33;
    pub const DEPRECATED_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'idempotency_level' field
    pub const IDEMPOTENCY_LEVEL_FIELD_NUMBER: i32 = 34;
    pub const IDEMPOTENCY_LEVEL_DEFAULT_VALUE: crate::EnumValue<self::MethodOptions_IdempotencyLevel> = crate::EnumValue::Defined(self::MethodOptions_IdempotencyLevel::Unknown);
    /// Gets the field number of the 'uninterpreted_option' field
    pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
}
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum MethodOptions_IdempotencyLevel {
    Unknown = 0,
    NoSideEffects = 1,
    T = 2,
}
impl ::std::convert::TryFrom<i32> for self::MethodOptions_IdempotencyLevel {
    type Error = crate::VariantUndefinedError;
    fn try_from(value: i32) -> ::std::result::Result<Self, crate::VariantUndefinedError> {
        match value {
            0 => ::std::result::Result::Ok(self::MethodOptions_IdempotencyLevel::Unknown),
            1 => ::std::result::Result::Ok(self::MethodOptions_IdempotencyLevel::NoSideEffects),
            2 => ::std::result::Result::Ok(self::MethodOptions_IdempotencyLevel::T),
            _ => ::std::result::Result::Err(crate::VariantUndefinedError)
        }
    }
}
impl ::std::convert::From<self::MethodOptions_IdempotencyLevel> for i32 {
    fn from(value: self::MethodOptions_IdempotencyLevel) -> i32 {
        value as i32
    }
}
#[derive(Debug, PartialEq)]
pub struct UninterpretedOption {
    pub name: crate::collections::RepeatedField<self::UninterpretedOption_NamePart>,
    pub identifier_value: ::std::option::Option<::std::string::String>,
    pub positive_int_value: ::std::option::Option<u64>,
    pub negative_int_value: ::std::option::Option<i64>,
    pub double_value: ::std::option::Option<f64>,
    pub string_value: ::std::option::Option<::std::vec::Vec<u8>>,
    pub aggregate_value: ::std::option::Option<::std::string::String>,
    unknown_fields: crate::UnknownFieldSet
}
static UNINTERPRETED_OPTION_NAME_CODEC: crate::Codec<self::UninterpretedOption_NamePart> = crate::Codec::message(18);
impl crate::CodedMessage for self::UninterpretedOption {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                18 => self.name.add_entries(tag.get(), input, &UNINTERPRETED_OPTION_NAME_CODEC)?,
                26 => self.identifier_value = ::std::option::Option::Some(input.read_string()?),
                32 => self.positive_int_value = ::std::option::Option::Some(input.read_uint64()?),
                40 => self.negative_int_value = ::std::option::Option::Some(input.read_int64()?),
                49 => self.double_value = ::std::option::Option::Some(input.read_double()?),
                58 => self.string_value = ::std::option::Option::Some(input.read_bytes()?),
                66 => self.aggregate_value = ::std::option::Option::Some(input.read_string()?),
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.name.calculate_size(&UNINTERPRETED_OPTION_NAME_CODEC);
        let identifier_value = &self.identifier_value;
        if let ::std::option::Option::Some(identifier_value) = identifier_value {
            if identifier_value != Self::IDENTIFIER_VALUE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(identifier_value);
            }
        }
        let positive_int_value = self.positive_int_value;
        if let ::std::option::Option::Some(positive_int_value) = positive_int_value {
            if positive_int_value != Self::POSITIVE_INT_VALUE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::uint64(positive_int_value);
            }
        }
        let negative_int_value = self.negative_int_value;
        if let ::std::option::Option::Some(negative_int_value) = negative_int_value {
            if negative_int_value != Self::NEGATIVE_INT_VALUE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::int64(negative_int_value);
            }
        }
        let double_value = self.double_value;
        if let ::std::option::Option::Some(double_value) = double_value {
            if double_value != Self::DOUBLE_VALUE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::double(double_value);
            }
        }
        let string_value = &self.string_value;
        if let ::std::option::Option::Some(string_value) = string_value {
            if string_value.as_slice() != Self::STRING_VALUE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bytes(string_value);
            }
        }
        let aggregate_value = &self.aggregate_value;
        if let ::std::option::Option::Some(aggregate_value) = aggregate_value {
            if aggregate_value != Self::AGGREGATE_VALUE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(aggregate_value);
            }
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        self.name.write_to(output, &UNINTERPRETED_OPTION_NAME_CODEC)?;
        let identifier_value = &self.identifier_value;
        if let ::std::option::Option::Some(identifier_value) = identifier_value {
            if identifier_value != Self::IDENTIFIER_VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[26])?;
                output.write_string(identifier_value)?;
            }
        }
        let positive_int_value = self.positive_int_value;
        if let ::std::option::Option::Some(positive_int_value) = positive_int_value {
            if positive_int_value != Self::POSITIVE_INT_VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[32])?;
                output.write_uint64(positive_int_value)?;
            }
        }
        let negative_int_value = self.negative_int_value;
        if let ::std::option::Option::Some(negative_int_value) = negative_int_value {
            if negative_int_value != Self::NEGATIVE_INT_VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[40])?;
                output.write_int64(negative_int_value)?;
            }
        }
        let double_value = self.double_value;
        if let ::std::option::Option::Some(double_value) = double_value {
            if double_value != Self::DOUBLE_VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[49])?;
                output.write_double(double_value)?;
            }
        }
        let string_value = &self.string_value;
        if let ::std::option::Option::Some(string_value) = string_value {
            if string_value.as_slice() != Self::STRING_VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[58])?;
                output.write_bytes(string_value)?;
            }
        }
        let aggregate_value = &self.aggregate_value;
        if let ::std::option::Option::Some(aggregate_value) = aggregate_value {
            if aggregate_value != Self::AGGREGATE_VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[66])?;
                output.write_string(aggregate_value)?;
            }
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::UninterpretedOption {
    fn new() -> Self {
        Self {
            name: crate::collections::RepeatedField::new(),
            identifier_value: ::std::option::Option::None,
            positive_int_value: ::std::option::Option::None,
            negative_int_value: ::std::option::Option::None,
            double_value: ::std::option::Option::None,
            string_value: ::std::option::Option::None,
            aggregate_value: ::std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl ::std::clone::Clone for self::UninterpretedOption {
    fn clone(&self) -> Self {
        Self {
            name: self.name.clone(),
            identifier_value: self.identifier_value.clone(),
            positive_int_value: self.positive_int_value.clone(),
            negative_int_value: self.negative_int_value.clone(),
            double_value: self.double_value.clone(),
            string_value: self.string_value.clone(),
            aggregate_value: self.aggregate_value.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.name.clone_from(&other.name);
        self.identifier_value = other.identifier_value.clone();
        self.positive_int_value = other.positive_int_value;
        self.negative_int_value = other.negative_int_value;
        self.double_value = other.double_value;
        self.string_value = other.string_value.clone();
        self.aggregate_value = other.aggregate_value.clone();
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::UninterpretedOption {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[18]
    }
}
impl self::UninterpretedOption {
    /// Gets the field number of the 'name' field
    pub const NAME_FIELD_NUMBER: i32 = 2;
    /// Gets the field number of the 'identifier_value' field
    pub const IDENTIFIER_VALUE_FIELD_NUMBER: i32 = 3;
    pub const IDENTIFIER_VALUE_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'positive_int_value' field
    pub const POSITIVE_INT_VALUE_FIELD_NUMBER: i32 = 4;
    pub const POSITIVE_INT_VALUE_DEFAULT_VALUE: u64 = 0;
    /// Gets the field number of the 'negative_int_value' field
    pub const NEGATIVE_INT_VALUE_FIELD_NUMBER: i32 = 5;
    pub const NEGATIVE_INT_VALUE_DEFAULT_VALUE: i64 = 0;
    /// Gets the field number of the 'double_value' field
    pub const DOUBLE_VALUE_FIELD_NUMBER: i32 = 6;
    pub const DOUBLE_VALUE_DEFAULT_VALUE: f64 = 0.0;
    /// Gets the field number of the 'string_value' field
    pub const STRING_VALUE_FIELD_NUMBER: i32 = 7;
    pub const STRING_VALUE_DEFAULT_VALUE: &'static [u8] = &[];
    /// Gets the field number of the 'aggregate_value' field
    pub const AGGREGATE_VALUE_FIELD_NUMBER: i32 = 8;
    pub const AGGREGATE_VALUE_DEFAULT_VALUE: &'static str = "";
}
#[derive(Debug, PartialEq)]
pub struct UninterpretedOption_NamePart {
    pub name_part: ::std::option::Option<::std::string::String>,
    pub is_extension: ::std::option::Option<bool>,
    unknown_fields: crate::UnknownFieldSet
}
impl crate::CodedMessage for self::UninterpretedOption_NamePart {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.name_part = ::std::option::Option::Some(input.read_string()?),
                16 => self.is_extension = ::std::option::Option::Some(input.read_bool()?),
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let name_part = &self.name_part;
        if let ::std::option::Option::Some(name_part) = name_part {
            if name_part != Self::NAME_PART_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(name_part);
            }
        }
        let is_extension = self.is_extension;
        if let ::std::option::Option::Some(is_extension) = is_extension {
            if is_extension != Self::IS_EXTENSION_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::bool(is_extension);
            }
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let name_part = &self.name_part;
        if let ::std::option::Option::Some(name_part) = name_part {
            if name_part != Self::NAME_PART_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name_part)?;
            }
        }
        let is_extension = self.is_extension;
        if let ::std::option::Option::Some(is_extension) = is_extension {
            if is_extension != Self::IS_EXTENSION_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_bool(is_extension)?;
            }
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::UninterpretedOption_NamePart {
    fn new() -> Self {
        Self {
            name_part: ::std::option::Option::None,
            is_extension: ::std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl ::std::clone::Clone for self::UninterpretedOption_NamePart {
    fn clone(&self) -> Self {
        Self {
            name_part: self.name_part.clone(),
            is_extension: self.is_extension.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.name_part = other.name_part.clone();
        self.is_extension = other.is_extension;
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::UninterpretedOption_NamePart {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[18].messages()[0]
    }
}
impl self::UninterpretedOption_NamePart {
    /// Gets the field number of the 'name_part' field
    pub const NAME_PART_FIELD_NUMBER: i32 = 1;
    pub const NAME_PART_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'is_extension' field
    pub const IS_EXTENSION_FIELD_NUMBER: i32 = 2;
    pub const IS_EXTENSION_DEFAULT_VALUE: bool = false;
}
#[derive(Debug, PartialEq)]
pub struct SourceCodeInfo {
    pub location: crate::collections::RepeatedField<self::SourceCodeInfo_Location>,
    unknown_fields: crate::UnknownFieldSet
}
static SOURCE_CODE_INFO_LOCATION_CODEC: crate::Codec<self::SourceCodeInfo_Location> = crate::Codec::message(10);
impl crate::CodedMessage for self::SourceCodeInfo {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.location.add_entries(tag.get(), input, &SOURCE_CODE_INFO_LOCATION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.location.calculate_size(&SOURCE_CODE_INFO_LOCATION_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        self.location.write_to(output, &SOURCE_CODE_INFO_LOCATION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::SourceCodeInfo {
    fn new() -> Self {
        Self {
            location: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl ::std::clone::Clone for self::SourceCodeInfo {
    fn clone(&self) -> Self {
        Self {
            location: self.location.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.location.clone_from(&other.location);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::SourceCodeInfo {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[19]
    }
}
impl self::SourceCodeInfo {
    /// Gets the field number of the 'location' field
    pub const LOCATION_FIELD_NUMBER: i32 = 1;
}
#[derive(Debug, PartialEq)]
pub struct SourceCodeInfo_Location {
    pub path: crate::collections::RepeatedField<i32>,
    pub span: crate::collections::RepeatedField<i32>,
    pub leading_comments: ::std::option::Option<::std::string::String>,
    pub trailing_comments: ::std::option::Option<::std::string::String>,
    pub leading_detached_comments: crate::collections::RepeatedField<::std::string::String>,
    unknown_fields: crate::UnknownFieldSet
}
static SOURCE_CODE_INFO__LOCATION_PATH_CODEC: crate::Codec<i32> = crate::Codec::int32(10);
static SOURCE_CODE_INFO__LOCATION_SPAN_CODEC: crate::Codec<i32> = crate::Codec::int32(18);
static SOURCE_CODE_INFO__LOCATION_LEADING_DETACHED_COMMENTS_CODEC: crate::Codec<::std::string::String> = crate::Codec::string(50);
impl crate::CodedMessage for self::SourceCodeInfo_Location {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 | 10 => self.path.add_entries(tag.get(), input, &SOURCE_CODE_INFO__LOCATION_PATH_CODEC)?,
                16 | 18 => self.span.add_entries(tag.get(), input, &SOURCE_CODE_INFO__LOCATION_SPAN_CODEC)?,
                26 => self.leading_comments = ::std::option::Option::Some(input.read_string()?),
                34 => self.trailing_comments = ::std::option::Option::Some(input.read_string()?),
                50 => self.leading_detached_comments.add_entries(tag.get(), input, &SOURCE_CODE_INFO__LOCATION_LEADING_DETACHED_COMMENTS_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.path.calculate_size(&SOURCE_CODE_INFO__LOCATION_PATH_CODEC);
        size += self.span.calculate_size(&SOURCE_CODE_INFO__LOCATION_SPAN_CODEC);
        let leading_comments = &self.leading_comments;
        if let ::std::option::Option::Some(leading_comments) = leading_comments {
            if leading_comments != Self::LEADING_COMMENTS_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(leading_comments);
            }
        }
        let trailing_comments = &self.trailing_comments;
        if let ::std::option::Option::Some(trailing_comments) = trailing_comments {
            if trailing_comments != Self::TRAILING_COMMENTS_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(trailing_comments);
            }
        }
        size += self.leading_detached_comments.calculate_size(&SOURCE_CODE_INFO__LOCATION_LEADING_DETACHED_COMMENTS_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        self.path.write_to(output, &SOURCE_CODE_INFO__LOCATION_PATH_CODEC)?;
        self.span.write_to(output, &SOURCE_CODE_INFO__LOCATION_SPAN_CODEC)?;
        let leading_comments = &self.leading_comments;
        if let ::std::option::Option::Some(leading_comments) = leading_comments {
            if leading_comments != Self::LEADING_COMMENTS_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[26])?;
                output.write_string(leading_comments)?;
            }
        }
        let trailing_comments = &self.trailing_comments;
        if let ::std::option::Option::Some(trailing_comments) = trailing_comments {
            if trailing_comments != Self::TRAILING_COMMENTS_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[34])?;
                output.write_string(trailing_comments)?;
            }
        }
        self.leading_detached_comments.write_to(output, &SOURCE_CODE_INFO__LOCATION_LEADING_DETACHED_COMMENTS_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::SourceCodeInfo_Location {
    fn new() -> Self {
        Self {
            path: crate::collections::RepeatedField::new(),
            span: crate::collections::RepeatedField::new(),
            leading_comments: ::std::option::Option::None,
            trailing_comments: ::std::option::Option::None,
            leading_detached_comments: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl ::std::clone::Clone for self::SourceCodeInfo_Location {
    fn clone(&self) -> Self {
        Self {
            path: self.path.clone(),
            span: self.span.clone(),
            leading_comments: self.leading_comments.clone(),
            trailing_comments: self.trailing_comments.clone(),
            leading_detached_comments: self.leading_detached_comments.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.path.clone_from(&other.path);
        self.span.clone_from(&other.span);
        self.leading_comments = other.leading_comments.clone();
        self.trailing_comments = other.trailing_comments.clone();
        self.leading_detached_comments.clone_from(&other.leading_detached_comments);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::SourceCodeInfo_Location {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[19].messages()[0]
    }
}
impl self::SourceCodeInfo_Location {
    /// Gets the field number of the 'path' field
    pub const PATH_FIELD_NUMBER: i32 = 1;
    /// Gets the field number of the 'span' field
    pub const SPAN_FIELD_NUMBER: i32 = 2;
    /// Gets the field number of the 'leading_comments' field
    pub const LEADING_COMMENTS_FIELD_NUMBER: i32 = 3;
    pub const LEADING_COMMENTS_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'trailing_comments' field
    pub const TRAILING_COMMENTS_FIELD_NUMBER: i32 = 4;
    pub const TRAILING_COMMENTS_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'leading_detached_comments' field
    pub const LEADING_DETACHED_COMMENTS_FIELD_NUMBER: i32 = 6;
}
#[derive(Debug, PartialEq)]
pub struct GeneratedCodeInfo {
    pub annotation: crate::collections::RepeatedField<self::GeneratedCodeInfo_Annotation>,
    unknown_fields: crate::UnknownFieldSet
}
static GENERATED_CODE_INFO_ANNOTATION_CODEC: crate::Codec<self::GeneratedCodeInfo_Annotation> = crate::Codec::message(10);
impl crate::CodedMessage for self::GeneratedCodeInfo {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.annotation.add_entries(tag.get(), input, &GENERATED_CODE_INFO_ANNOTATION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.annotation.calculate_size(&GENERATED_CODE_INFO_ANNOTATION_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        self.annotation.write_to(output, &GENERATED_CODE_INFO_ANNOTATION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::GeneratedCodeInfo {
    fn new() -> Self {
        Self {
            annotation: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl ::std::clone::Clone for self::GeneratedCodeInfo {
    fn clone(&self) -> Self {
        Self {
            annotation: self.annotation.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.annotation.clone_from(&other.annotation);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::GeneratedCodeInfo {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[20]
    }
}
impl self::GeneratedCodeInfo {
    /// Gets the field number of the 'annotation' field
    pub const ANNOTATION_FIELD_NUMBER: i32 = 1;
}
#[derive(Debug, PartialEq)]
pub struct GeneratedCodeInfo_Annotation {
    pub path: crate::collections::RepeatedField<i32>,
    pub source_file: ::std::option::Option<::std::string::String>,
    pub begin: ::std::option::Option<i32>,
    pub end: ::std::option::Option<i32>,
    unknown_fields: crate::UnknownFieldSet
}
static GENERATED_CODE_INFO__ANNOTATION_PATH_CODEC: crate::Codec<i32> = crate::Codec::int32(10);
impl crate::CodedMessage for self::GeneratedCodeInfo_Annotation {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 | 10 => self.path.add_entries(tag.get(), input, &GENERATED_CODE_INFO__ANNOTATION_PATH_CODEC)?,
                18 => self.source_file = ::std::option::Option::Some(input.read_string()?),
                24 => self.begin = ::std::option::Option::Some(input.read_int32()?),
                32 => self.end = ::std::option::Option::Some(input.read_int32()?),
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.path.calculate_size(&GENERATED_CODE_INFO__ANNOTATION_PATH_CODEC);
        let source_file = &self.source_file;
        if let ::std::option::Option::Some(source_file) = source_file {
            if source_file != Self::SOURCE_FILE_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::string(source_file);
            }
        }
        let begin = self.begin;
        if let ::std::option::Option::Some(begin) = begin {
            if begin != Self::BEGIN_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::int32(begin);
            }
        }
        let end = self.end;
        if let ::std::option::Option::Some(end) = end {
            if end != Self::END_DEFAULT_VALUE {
                size += 1;
                size += crate::io::sizes::int32(end);
            }
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        self.path.write_to(output, &GENERATED_CODE_INFO__ANNOTATION_PATH_CODEC)?;
        let source_file = &self.source_file;
        if let ::std::option::Option::Some(source_file) = source_file {
            if source_file != Self::SOURCE_FILE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[18])?;
                output.write_string(source_file)?;
            }
        }
        let begin = self.begin;
        if let ::std::option::Option::Some(begin) = begin {
            if begin != Self::BEGIN_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[24])?;
                output.write_int32(begin)?;
            }
        }
        let end = self.end;
        if let ::std::option::Option::Some(end) = end {
            if end != Self::END_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[32])?;
                output.write_int32(end)?;
            }
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::GeneratedCodeInfo_Annotation {
    fn new() -> Self {
        Self {
            path: crate::collections::RepeatedField::new(),
            source_file: ::std::option::Option::None,
            begin: ::std::option::Option::None,
            end: ::std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl ::std::clone::Clone for self::GeneratedCodeInfo_Annotation {
    fn clone(&self) -> Self {
        Self {
            path: self.path.clone(),
            source_file: self.source_file.clone(),
            begin: self.begin.clone(),
            end: self.end.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.path.clone_from(&other.path);
        self.source_file = other.source_file.clone();
        self.begin = other.begin;
        self.end = other.end;
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::GeneratedCodeInfo_Annotation {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        &self::file().messages()[20].messages()[0]
    }
}
impl self::GeneratedCodeInfo_Annotation {
    /// Gets the field number of the 'path' field
    pub const PATH_FIELD_NUMBER: i32 = 1;
    /// Gets the field number of the 'source_file' field
    pub const SOURCE_FILE_FIELD_NUMBER: i32 = 2;
    pub const SOURCE_FILE_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'begin' field
    pub const BEGIN_FIELD_NUMBER: i32 = 3;
    pub const BEGIN_DEFAULT_VALUE: i32 = 0;
    /// Gets the field number of the 'end' field
    pub const END_FIELD_NUMBER: i32 = 4;
    pub const END_DEFAULT_VALUE: i32 = 0;
}