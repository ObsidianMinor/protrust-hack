//! DO NOT EDIT!
//! Generated by protoc-gen-rust, part of the protrust crate.
//! 
//! Source: google/protobuf/descriptor.proto

#[derive(Debug, PartialEq)]
pub struct FileDescriptorSet {
    pub file: crate::collections::RepeatedField<std::boxed::Box<self::FileDescriptorProto>>,
    unknown_fields: crate::UnknownFieldSet
}
static FILE_DESCRIPTOR_SET_FILE_CODEC: crate::Codec<std::boxed::Box<self::FileDescriptorProto>> = crate::Codec::message(10);
impl crate::CodedMessage for self::FileDescriptorSet {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.file.add_entries(tag.get(), input, &FILE_DESCRIPTOR_SET_FILE_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> std::option::Option<i32> {
        let mut size = 0i32;
        size = size.checked_add(self.file.calculate_size(&FILE_DESCRIPTOR_SET_FILE_CODEC)?)?;
        size = size.checked_add(self.unknown_fields.calculate_size()?)?;
        std::option::Option::Some(size)
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        self.file.write_to(output, &FILE_DESCRIPTOR_SET_FILE_CODEC)?;
        self.unknown_fields.write_to(output)?;
        std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::FileDescriptorSet {
    fn new() -> Self {
        Self {
            file: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl std::clone::Clone for self::FileDescriptorSet {
    fn clone(&self) -> Self {
        Self {
            file: self.file.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.file.clone_from(&other.file);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::FileDescriptorSet {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        unimplemented!()
    }
}
impl self::FileDescriptorSet {
    /// Gets the field number of the 'file' field
    pub const FILE_FIELD_NUMBER: i32 = 1;
}
#[derive(Debug, PartialEq)]
pub struct FileDescriptorProto {
    pub name: std::option::Option<std::string::String>,
    pub package: std::option::Option<std::string::String>,
    pub dependency: crate::collections::RepeatedField<std::string::String>,
    pub public_dependency: crate::collections::RepeatedField<i32>,
    pub weak_dependency: crate::collections::RepeatedField<i32>,
    pub message_type: crate::collections::RepeatedField<std::boxed::Box<self::DescriptorProto>>,
    pub enum_type: crate::collections::RepeatedField<std::boxed::Box<self::EnumDescriptorProto>>,
    pub service: crate::collections::RepeatedField<std::boxed::Box<self::ServiceDescriptorProto>>,
    pub extension: crate::collections::RepeatedField<std::boxed::Box<self::FieldDescriptorProto>>,
    pub options: std::option::Option<std::boxed::Box<self::FileOptions>>,
    pub source_code_info: std::option::Option<std::boxed::Box<self::SourceCodeInfo>>,
    pub syntax: std::option::Option<std::string::String>,
    unknown_fields: crate::UnknownFieldSet
}
static FILE_DESCRIPTOR_PROTO_DEPENDENCY_CODEC: crate::Codec<std::string::String> = crate::Codec::string(26);
static FILE_DESCRIPTOR_PROTO_PUBLIC_DEPENDENCY_CODEC: crate::Codec<i32> = crate::Codec::int32(80);
static FILE_DESCRIPTOR_PROTO_WEAK_DEPENDENCY_CODEC: crate::Codec<i32> = crate::Codec::int32(88);
static FILE_DESCRIPTOR_PROTO_MESSAGE_TYPE_CODEC: crate::Codec<std::boxed::Box<self::DescriptorProto>> = crate::Codec::message(34);
static FILE_DESCRIPTOR_PROTO_ENUM_TYPE_CODEC: crate::Codec<std::boxed::Box<self::EnumDescriptorProto>> = crate::Codec::message(42);
static FILE_DESCRIPTOR_PROTO_SERVICE_CODEC: crate::Codec<std::boxed::Box<self::ServiceDescriptorProto>> = crate::Codec::message(50);
static FILE_DESCRIPTOR_PROTO_EXTENSION_CODEC: crate::Codec<std::boxed::Box<self::FieldDescriptorProto>> = crate::Codec::message(58);
impl crate::CodedMessage for self::FileDescriptorProto {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.name = std::option::Option::Some(input.read_string()?),
                18 => self.package = std::option::Option::Some(input.read_string()?),
                26 => self.dependency.add_entries(tag.get(), input, &FILE_DESCRIPTOR_PROTO_DEPENDENCY_CODEC)?,
                80 => self.public_dependency.add_entries(tag.get(), input, &FILE_DESCRIPTOR_PROTO_PUBLIC_DEPENDENCY_CODEC)?,
                88 => self.weak_dependency.add_entries(tag.get(), input, &FILE_DESCRIPTOR_PROTO_WEAK_DEPENDENCY_CODEC)?,
                34 => self.message_type.add_entries(tag.get(), input, &FILE_DESCRIPTOR_PROTO_MESSAGE_TYPE_CODEC)?,
                42 => self.enum_type.add_entries(tag.get(), input, &FILE_DESCRIPTOR_PROTO_ENUM_TYPE_CODEC)?,
                50 => self.service.add_entries(tag.get(), input, &FILE_DESCRIPTOR_PROTO_SERVICE_CODEC)?,
                58 => self.extension.add_entries(tag.get(), input, &FILE_DESCRIPTOR_PROTO_EXTENSION_CODEC)?,
                66 => input.read_message(self.options.get_or_insert_with(crate::LiteMessage::new))?,
                74 => input.read_message(self.source_code_info.get_or_insert_with(crate::LiteMessage::new))?,
                98 => self.syntax = std::option::Option::Some(input.read_string()?),
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> std::option::Option<i32> {
        let mut size = 0i32;
        let name = &self.name;
        if let std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(name)?)?;
            }
        }
        let package = &self.package;
        if let std::option::Option::Some(package) = package {
            if package != Self::PACKAGE_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(package)?)?;
            }
        }
        size = size.checked_add(self.dependency.calculate_size(&FILE_DESCRIPTOR_PROTO_DEPENDENCY_CODEC)?)?;
        size = size.checked_add(self.public_dependency.calculate_size(&FILE_DESCRIPTOR_PROTO_PUBLIC_DEPENDENCY_CODEC)?)?;
        size = size.checked_add(self.weak_dependency.calculate_size(&FILE_DESCRIPTOR_PROTO_WEAK_DEPENDENCY_CODEC)?)?;
        size = size.checked_add(self.message_type.calculate_size(&FILE_DESCRIPTOR_PROTO_MESSAGE_TYPE_CODEC)?)?;
        size = size.checked_add(self.enum_type.calculate_size(&FILE_DESCRIPTOR_PROTO_ENUM_TYPE_CODEC)?)?;
        size = size.checked_add(self.service.calculate_size(&FILE_DESCRIPTOR_PROTO_SERVICE_CODEC)?)?;
        size = size.checked_add(self.extension.calculate_size(&FILE_DESCRIPTOR_PROTO_EXTENSION_CODEC)?)?;
        let options = &self.options;
        if let std::option::Option::Some(options) = options {
            size = size.checked_add(1)?;
            size = size.checked_add(crate::io::sizes::message(options)?)?;
        }
        let source_code_info = &self.source_code_info;
        if let std::option::Option::Some(source_code_info) = source_code_info {
            size = size.checked_add(1)?;
            size = size.checked_add(crate::io::sizes::message(source_code_info)?)?;
        }
        let syntax = &self.syntax;
        if let std::option::Option::Some(syntax) = syntax {
            if syntax != Self::SYNTAX_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(syntax)?)?;
            }
        }
        size = size.checked_add(self.unknown_fields.calculate_size()?)?;
        std::option::Option::Some(size)
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let name = &self.name;
        if let std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
        }
        let package = &self.package;
        if let std::option::Option::Some(package) = package {
            if package != Self::PACKAGE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[18])?;
                output.write_string(package)?;
            }
        }
        self.dependency.write_to(output, &FILE_DESCRIPTOR_PROTO_DEPENDENCY_CODEC)?;
        self.public_dependency.write_to(output, &FILE_DESCRIPTOR_PROTO_PUBLIC_DEPENDENCY_CODEC)?;
        self.weak_dependency.write_to(output, &FILE_DESCRIPTOR_PROTO_WEAK_DEPENDENCY_CODEC)?;
        self.message_type.write_to(output, &FILE_DESCRIPTOR_PROTO_MESSAGE_TYPE_CODEC)?;
        self.enum_type.write_to(output, &FILE_DESCRIPTOR_PROTO_ENUM_TYPE_CODEC)?;
        self.service.write_to(output, &FILE_DESCRIPTOR_PROTO_SERVICE_CODEC)?;
        self.extension.write_to(output, &FILE_DESCRIPTOR_PROTO_EXTENSION_CODEC)?;
        let options = &self.options;
        if let std::option::Option::Some(options) = options {
            output.write_raw_tag_bytes(&[66])?;
            output.write_message(options)?;
        }
        let source_code_info = &self.source_code_info;
        if let std::option::Option::Some(source_code_info) = source_code_info {
            output.write_raw_tag_bytes(&[74])?;
            output.write_message(source_code_info)?;
        }
        let syntax = &self.syntax;
        if let std::option::Option::Some(syntax) = syntax {
            if syntax != Self::SYNTAX_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[98])?;
                output.write_string(syntax)?;
            }
        }
        self.unknown_fields.write_to(output)?;
        std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::FileDescriptorProto {
    fn new() -> Self {
        Self {
            name: std::option::Option::None,
            package: std::option::Option::None,
            dependency: crate::collections::RepeatedField::new(),
            public_dependency: crate::collections::RepeatedField::new(),
            weak_dependency: crate::collections::RepeatedField::new(),
            message_type: crate::collections::RepeatedField::new(),
            enum_type: crate::collections::RepeatedField::new(),
            service: crate::collections::RepeatedField::new(),
            extension: crate::collections::RepeatedField::new(),
            options: std::option::Option::None,
            source_code_info: std::option::Option::None,
            syntax: std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl std::clone::Clone for self::FileDescriptorProto {
    fn clone(&self) -> Self {
        Self {
            name: self.name.clone(),
            package: self.package.clone(),
            dependency: self.dependency.clone(),
            public_dependency: self.public_dependency.clone(),
            weak_dependency: self.weak_dependency.clone(),
            message_type: self.message_type.clone(),
            enum_type: self.enum_type.clone(),
            service: self.service.clone(),
            extension: self.extension.clone(),
            options: self.options.clone(),
            source_code_info: self.source_code_info.clone(),
            syntax: self.syntax.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.name = other.name.clone();
        self.package = other.package.clone();
        self.dependency.clone_from(&other.dependency);
        self.public_dependency.clone_from(&other.public_dependency);
        self.weak_dependency.clone_from(&other.weak_dependency);
        self.message_type.clone_from(&other.message_type);
        self.enum_type.clone_from(&other.enum_type);
        self.service.clone_from(&other.service);
        self.extension.clone_from(&other.extension);
        if let std::option::Option::Some(options) = &other.options {
            self.options.get_or_insert_with(crate::LiteMessage::new).clone_from(options);
        }
        if let std::option::Option::Some(source_code_info) = &other.source_code_info {
            self.source_code_info.get_or_insert_with(crate::LiteMessage::new).clone_from(source_code_info);
        }
        self.syntax = other.syntax.clone();
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::FileDescriptorProto {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        unimplemented!()
    }
}
impl self::FileDescriptorProto {
    /// Gets the field number of the 'name' field
    pub const NAME_FIELD_NUMBER: i32 = 1;
    pub const NAME_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'package' field
    pub const PACKAGE_FIELD_NUMBER: i32 = 2;
    pub const PACKAGE_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'dependency' field
    pub const DEPENDENCY_FIELD_NUMBER: i32 = 3;
    /// Gets the field number of the 'public_dependency' field
    pub const PUBLIC_DEPENDENCY_FIELD_NUMBER: i32 = 10;
    /// Gets the field number of the 'weak_dependency' field
    pub const WEAK_DEPENDENCY_FIELD_NUMBER: i32 = 11;
    /// Gets the field number of the 'message_type' field
    pub const MESSAGE_TYPE_FIELD_NUMBER: i32 = 4;
    /// Gets the field number of the 'enum_type' field
    pub const ENUM_TYPE_FIELD_NUMBER: i32 = 5;
    /// Gets the field number of the 'service' field
    pub const SERVICE_FIELD_NUMBER: i32 = 6;
    /// Gets the field number of the 'extension' field
    pub const EXTENSION_FIELD_NUMBER: i32 = 7;
    /// Gets the field number of the 'options' field
    pub const OPTIONS_FIELD_NUMBER: i32 = 8;
    /// Gets the field number of the 'source_code_info' field
    pub const SOURCE_CODE_INFO_FIELD_NUMBER: i32 = 9;
    /// Gets the field number of the 'syntax' field
    pub const SYNTAX_FIELD_NUMBER: i32 = 12;
    pub const SYNTAX_DEFAULT_VALUE: &'static str = "";
}
#[derive(Debug, PartialEq)]
pub struct DescriptorProto {
    pub name: std::option::Option<std::string::String>,
    pub field: crate::collections::RepeatedField<std::boxed::Box<self::FieldDescriptorProto>>,
    pub extension: crate::collections::RepeatedField<std::boxed::Box<self::FieldDescriptorProto>>,
    pub nested_type: crate::collections::RepeatedField<std::boxed::Box<self::DescriptorProto>>,
    pub enum_type: crate::collections::RepeatedField<std::boxed::Box<self::EnumDescriptorProto>>,
    pub extension_range: crate::collections::RepeatedField<std::boxed::Box<self::DescriptorProto_ExtensionRange>>,
    pub oneof_decl: crate::collections::RepeatedField<std::boxed::Box<self::OneofDescriptorProto>>,
    pub options: std::option::Option<std::boxed::Box<self::MessageOptions>>,
    pub reserved_range: crate::collections::RepeatedField<std::boxed::Box<self::DescriptorProto_ReservedRange>>,
    pub reserved_name: crate::collections::RepeatedField<std::string::String>,
    unknown_fields: crate::UnknownFieldSet
}
static DESCRIPTOR_PROTO_FIELD_CODEC: crate::Codec<std::boxed::Box<self::FieldDescriptorProto>> = crate::Codec::message(18);
static DESCRIPTOR_PROTO_EXTENSION_CODEC: crate::Codec<std::boxed::Box<self::FieldDescriptorProto>> = crate::Codec::message(50);
static DESCRIPTOR_PROTO_NESTED_TYPE_CODEC: crate::Codec<std::boxed::Box<self::DescriptorProto>> = crate::Codec::message(26);
static DESCRIPTOR_PROTO_ENUM_TYPE_CODEC: crate::Codec<std::boxed::Box<self::EnumDescriptorProto>> = crate::Codec::message(34);
static DESCRIPTOR_PROTO_EXTENSION_RANGE_CODEC: crate::Codec<std::boxed::Box<self::DescriptorProto_ExtensionRange>> = crate::Codec::message(42);
static DESCRIPTOR_PROTO_ONEOF_DECL_CODEC: crate::Codec<std::boxed::Box<self::OneofDescriptorProto>> = crate::Codec::message(66);
static DESCRIPTOR_PROTO_RESERVED_RANGE_CODEC: crate::Codec<std::boxed::Box<self::DescriptorProto_ReservedRange>> = crate::Codec::message(74);
static DESCRIPTOR_PROTO_RESERVED_NAME_CODEC: crate::Codec<std::string::String> = crate::Codec::string(82);
impl crate::CodedMessage for self::DescriptorProto {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.name = std::option::Option::Some(input.read_string()?),
                18 => self.field.add_entries(tag.get(), input, &DESCRIPTOR_PROTO_FIELD_CODEC)?,
                50 => self.extension.add_entries(tag.get(), input, &DESCRIPTOR_PROTO_EXTENSION_CODEC)?,
                26 => self.nested_type.add_entries(tag.get(), input, &DESCRIPTOR_PROTO_NESTED_TYPE_CODEC)?,
                34 => self.enum_type.add_entries(tag.get(), input, &DESCRIPTOR_PROTO_ENUM_TYPE_CODEC)?,
                42 => self.extension_range.add_entries(tag.get(), input, &DESCRIPTOR_PROTO_EXTENSION_RANGE_CODEC)?,
                66 => self.oneof_decl.add_entries(tag.get(), input, &DESCRIPTOR_PROTO_ONEOF_DECL_CODEC)?,
                58 => input.read_message(self.options.get_or_insert_with(crate::LiteMessage::new))?,
                74 => self.reserved_range.add_entries(tag.get(), input, &DESCRIPTOR_PROTO_RESERVED_RANGE_CODEC)?,
                82 => self.reserved_name.add_entries(tag.get(), input, &DESCRIPTOR_PROTO_RESERVED_NAME_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> std::option::Option<i32> {
        let mut size = 0i32;
        let name = &self.name;
        if let std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(name)?)?;
            }
        }
        size = size.checked_add(self.field.calculate_size(&DESCRIPTOR_PROTO_FIELD_CODEC)?)?;
        size = size.checked_add(self.extension.calculate_size(&DESCRIPTOR_PROTO_EXTENSION_CODEC)?)?;
        size = size.checked_add(self.nested_type.calculate_size(&DESCRIPTOR_PROTO_NESTED_TYPE_CODEC)?)?;
        size = size.checked_add(self.enum_type.calculate_size(&DESCRIPTOR_PROTO_ENUM_TYPE_CODEC)?)?;
        size = size.checked_add(self.extension_range.calculate_size(&DESCRIPTOR_PROTO_EXTENSION_RANGE_CODEC)?)?;
        size = size.checked_add(self.oneof_decl.calculate_size(&DESCRIPTOR_PROTO_ONEOF_DECL_CODEC)?)?;
        let options = &self.options;
        if let std::option::Option::Some(options) = options {
            size = size.checked_add(1)?;
            size = size.checked_add(crate::io::sizes::message(options)?)?;
        }
        size = size.checked_add(self.reserved_range.calculate_size(&DESCRIPTOR_PROTO_RESERVED_RANGE_CODEC)?)?;
        size = size.checked_add(self.reserved_name.calculate_size(&DESCRIPTOR_PROTO_RESERVED_NAME_CODEC)?)?;
        size = size.checked_add(self.unknown_fields.calculate_size()?)?;
        std::option::Option::Some(size)
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let name = &self.name;
        if let std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
        }
        self.field.write_to(output, &DESCRIPTOR_PROTO_FIELD_CODEC)?;
        self.extension.write_to(output, &DESCRIPTOR_PROTO_EXTENSION_CODEC)?;
        self.nested_type.write_to(output, &DESCRIPTOR_PROTO_NESTED_TYPE_CODEC)?;
        self.enum_type.write_to(output, &DESCRIPTOR_PROTO_ENUM_TYPE_CODEC)?;
        self.extension_range.write_to(output, &DESCRIPTOR_PROTO_EXTENSION_RANGE_CODEC)?;
        self.oneof_decl.write_to(output, &DESCRIPTOR_PROTO_ONEOF_DECL_CODEC)?;
        let options = &self.options;
        if let std::option::Option::Some(options) = options {
            output.write_raw_tag_bytes(&[58])?;
            output.write_message(options)?;
        }
        self.reserved_range.write_to(output, &DESCRIPTOR_PROTO_RESERVED_RANGE_CODEC)?;
        self.reserved_name.write_to(output, &DESCRIPTOR_PROTO_RESERVED_NAME_CODEC)?;
        self.unknown_fields.write_to(output)?;
        std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::DescriptorProto {
    fn new() -> Self {
        Self {
            name: std::option::Option::None,
            field: crate::collections::RepeatedField::new(),
            extension: crate::collections::RepeatedField::new(),
            nested_type: crate::collections::RepeatedField::new(),
            enum_type: crate::collections::RepeatedField::new(),
            extension_range: crate::collections::RepeatedField::new(),
            oneof_decl: crate::collections::RepeatedField::new(),
            options: std::option::Option::None,
            reserved_range: crate::collections::RepeatedField::new(),
            reserved_name: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl std::clone::Clone for self::DescriptorProto {
    fn clone(&self) -> Self {
        Self {
            name: self.name.clone(),
            field: self.field.clone(),
            extension: self.extension.clone(),
            nested_type: self.nested_type.clone(),
            enum_type: self.enum_type.clone(),
            extension_range: self.extension_range.clone(),
            oneof_decl: self.oneof_decl.clone(),
            options: self.options.clone(),
            reserved_range: self.reserved_range.clone(),
            reserved_name: self.reserved_name.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.name = other.name.clone();
        self.field.clone_from(&other.field);
        self.extension.clone_from(&other.extension);
        self.nested_type.clone_from(&other.nested_type);
        self.enum_type.clone_from(&other.enum_type);
        self.extension_range.clone_from(&other.extension_range);
        self.oneof_decl.clone_from(&other.oneof_decl);
        if let std::option::Option::Some(options) = &other.options {
            self.options.get_or_insert_with(crate::LiteMessage::new).clone_from(options);
        }
        self.reserved_range.clone_from(&other.reserved_range);
        self.reserved_name.clone_from(&other.reserved_name);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::DescriptorProto {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        unimplemented!()
    }
}
impl self::DescriptorProto {
    /// Gets the field number of the 'name' field
    pub const NAME_FIELD_NUMBER: i32 = 1;
    pub const NAME_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'field' field
    pub const FIELD_FIELD_NUMBER: i32 = 2;
    /// Gets the field number of the 'extension' field
    pub const EXTENSION_FIELD_NUMBER: i32 = 6;
    /// Gets the field number of the 'nested_type' field
    pub const NESTED_TYPE_FIELD_NUMBER: i32 = 3;
    /// Gets the field number of the 'enum_type' field
    pub const ENUM_TYPE_FIELD_NUMBER: i32 = 4;
    /// Gets the field number of the 'extension_range' field
    pub const EXTENSION_RANGE_FIELD_NUMBER: i32 = 5;
    /// Gets the field number of the 'oneof_decl' field
    pub const ONEOF_DECL_FIELD_NUMBER: i32 = 8;
    /// Gets the field number of the 'options' field
    pub const OPTIONS_FIELD_NUMBER: i32 = 7;
    /// Gets the field number of the 'reserved_range' field
    pub const RESERVED_RANGE_FIELD_NUMBER: i32 = 9;
    /// Gets the field number of the 'reserved_name' field
    pub const RESERVED_NAME_FIELD_NUMBER: i32 = 10;
}
#[derive(Debug, PartialEq)]
pub struct DescriptorProto_ExtensionRange {
    pub start: std::option::Option<i32>,
    pub end: std::option::Option<i32>,
    pub options: std::option::Option<std::boxed::Box<self::ExtensionRangeOptions>>,
    unknown_fields: crate::UnknownFieldSet
}
impl crate::CodedMessage for self::DescriptorProto_ExtensionRange {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 => self.start = std::option::Option::Some(input.read_int32()?),
                16 => self.end = std::option::Option::Some(input.read_int32()?),
                26 => input.read_message(self.options.get_or_insert_with(crate::LiteMessage::new))?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> std::option::Option<i32> {
        let mut size = 0i32;
        let start = self.start;
        if let std::option::Option::Some(start) = start {
            if start != Self::START_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::int32(start))?;
            }
        }
        let end = self.end;
        if let std::option::Option::Some(end) = end {
            if end != Self::END_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::int32(end))?;
            }
        }
        let options = &self.options;
        if let std::option::Option::Some(options) = options {
            size = size.checked_add(1)?;
            size = size.checked_add(crate::io::sizes::message(options)?)?;
        }
        size = size.checked_add(self.unknown_fields.calculate_size()?)?;
        std::option::Option::Some(size)
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let start = self.start;
        if let std::option::Option::Some(start) = start {
            if start != Self::START_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(start)?;
            }
        }
        let end = self.end;
        if let std::option::Option::Some(end) = end {
            if end != Self::END_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_int32(end)?;
            }
        }
        let options = &self.options;
        if let std::option::Option::Some(options) = options {
            output.write_raw_tag_bytes(&[26])?;
            output.write_message(options)?;
        }
        self.unknown_fields.write_to(output)?;
        std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::DescriptorProto_ExtensionRange {
    fn new() -> Self {
        Self {
            start: std::option::Option::None,
            end: std::option::Option::None,
            options: std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl std::clone::Clone for self::DescriptorProto_ExtensionRange {
    fn clone(&self) -> Self {
        Self {
            start: self.start.clone(),
            end: self.end.clone(),
            options: self.options.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.start = other.start;
        self.end = other.end;
        if let std::option::Option::Some(options) = &other.options {
            self.options.get_or_insert_with(crate::LiteMessage::new).clone_from(options);
        }
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::DescriptorProto_ExtensionRange {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        unimplemented!()
    }
}
impl self::DescriptorProto_ExtensionRange {
    /// Gets the field number of the 'start' field
    pub const START_FIELD_NUMBER: i32 = 1;
    pub const START_DEFAULT_VALUE: i32 = 0;
    /// Gets the field number of the 'end' field
    pub const END_FIELD_NUMBER: i32 = 2;
    pub const END_DEFAULT_VALUE: i32 = 0;
    /// Gets the field number of the 'options' field
    pub const OPTIONS_FIELD_NUMBER: i32 = 3;
}
#[derive(Debug, PartialEq)]
pub struct DescriptorProto_ReservedRange {
    pub start: std::option::Option<i32>,
    pub end: std::option::Option<i32>,
    unknown_fields: crate::UnknownFieldSet
}
impl crate::CodedMessage for self::DescriptorProto_ReservedRange {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 => self.start = std::option::Option::Some(input.read_int32()?),
                16 => self.end = std::option::Option::Some(input.read_int32()?),
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> std::option::Option<i32> {
        let mut size = 0i32;
        let start = self.start;
        if let std::option::Option::Some(start) = start {
            if start != Self::START_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::int32(start))?;
            }
        }
        let end = self.end;
        if let std::option::Option::Some(end) = end {
            if end != Self::END_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::int32(end))?;
            }
        }
        size = size.checked_add(self.unknown_fields.calculate_size()?)?;
        std::option::Option::Some(size)
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let start = self.start;
        if let std::option::Option::Some(start) = start {
            if start != Self::START_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(start)?;
            }
        }
        let end = self.end;
        if let std::option::Option::Some(end) = end {
            if end != Self::END_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_int32(end)?;
            }
        }
        self.unknown_fields.write_to(output)?;
        std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::DescriptorProto_ReservedRange {
    fn new() -> Self {
        Self {
            start: std::option::Option::None,
            end: std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl std::clone::Clone for self::DescriptorProto_ReservedRange {
    fn clone(&self) -> Self {
        Self {
            start: self.start.clone(),
            end: self.end.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.start = other.start;
        self.end = other.end;
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::DescriptorProto_ReservedRange {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        unimplemented!()
    }
}
impl self::DescriptorProto_ReservedRange {
    /// Gets the field number of the 'start' field
    pub const START_FIELD_NUMBER: i32 = 1;
    pub const START_DEFAULT_VALUE: i32 = 0;
    /// Gets the field number of the 'end' field
    pub const END_FIELD_NUMBER: i32 = 2;
    pub const END_DEFAULT_VALUE: i32 = 0;
}
#[derive(Debug, PartialEq)]
pub struct ExtensionRangeOptions {
    pub uninterpreted_option: crate::collections::RepeatedField<std::boxed::Box<self::UninterpretedOption>>,
    unknown_fields: crate::UnknownFieldSet
}
static EXTENSION_RANGE_OPTIONS_UNINTERPRETED_OPTION_CODEC: crate::Codec<std::boxed::Box<self::UninterpretedOption>> = crate::Codec::message(7994);
impl crate::CodedMessage for self::ExtensionRangeOptions {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                7994 => self.uninterpreted_option.add_entries(tag.get(), input, &EXTENSION_RANGE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> std::option::Option<i32> {
        let mut size = 0i32;
        size = size.checked_add(self.uninterpreted_option.calculate_size(&EXTENSION_RANGE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?)?;
        size = size.checked_add(self.unknown_fields.calculate_size()?)?;
        std::option::Option::Some(size)
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        self.uninterpreted_option.write_to(output, &EXTENSION_RANGE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::ExtensionRangeOptions {
    fn new() -> Self {
        Self {
            uninterpreted_option: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl std::clone::Clone for self::ExtensionRangeOptions {
    fn clone(&self) -> Self {
        Self {
            uninterpreted_option: self.uninterpreted_option.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.uninterpreted_option.clone_from(&other.uninterpreted_option);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::ExtensionRangeOptions {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        unimplemented!()
    }
}
impl self::ExtensionRangeOptions {
    /// Gets the field number of the 'uninterpreted_option' field
    pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
}
#[derive(Debug, PartialEq)]
pub struct FieldDescriptorProto {
    pub name: std::option::Option<std::string::String>,
    pub number: std::option::Option<i32>,
    pub label: std::option::Option<crate::EnumValue<self::FieldDescriptorProto_Label>>,
    pub r#type: std::option::Option<crate::EnumValue<self::FieldDescriptorProto_Type>>,
    pub type_name: std::option::Option<std::string::String>,
    pub extendee: std::option::Option<std::string::String>,
    pub default_value: std::option::Option<std::string::String>,
    pub oneof_index: std::option::Option<i32>,
    pub json_name: std::option::Option<std::string::String>,
    pub options: std::option::Option<std::boxed::Box<self::FieldOptions>>,
    unknown_fields: crate::UnknownFieldSet
}
impl crate::CodedMessage for self::FieldDescriptorProto {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.name = std::option::Option::Some(input.read_string()?),
                24 => self.number = std::option::Option::Some(input.read_int32()?),
                32 => self.label = std::option::Option::Some(input.read_enum_value()?),
                40 => self.r#type = std::option::Option::Some(input.read_enum_value()?),
                50 => self.type_name = std::option::Option::Some(input.read_string()?),
                18 => self.extendee = std::option::Option::Some(input.read_string()?),
                58 => self.default_value = std::option::Option::Some(input.read_string()?),
                72 => self.oneof_index = std::option::Option::Some(input.read_int32()?),
                82 => self.json_name = std::option::Option::Some(input.read_string()?),
                66 => input.read_message(self.options.get_or_insert_with(crate::LiteMessage::new))?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> std::option::Option<i32> {
        let mut size = 0i32;
        let name = &self.name;
        if let std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(name)?)?;
            }
        }
        let number = self.number;
        if let std::option::Option::Some(number) = number {
            if number != Self::NUMBER_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::int32(number))?;
            }
        }
        let label = self.label;
        if let std::option::Option::Some(label) = label {
            if label != Self::LABEL_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::enum_value(label))?;
            }
        }
        let r#type = self.r#type;
        if let std::option::Option::Some(r#type) = r#type {
            if r#type != Self::TYPE_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::enum_value(r#type))?;
            }
        }
        let type_name = &self.type_name;
        if let std::option::Option::Some(type_name) = type_name {
            if type_name != Self::TYPE_NAME_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(type_name)?)?;
            }
        }
        let extendee = &self.extendee;
        if let std::option::Option::Some(extendee) = extendee {
            if extendee != Self::EXTENDEE_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(extendee)?)?;
            }
        }
        let default_value = &self.default_value;
        if let std::option::Option::Some(default_value) = default_value {
            if default_value != Self::DEFAULT_VALUE_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(default_value)?)?;
            }
        }
        let oneof_index = self.oneof_index;
        if let std::option::Option::Some(oneof_index) = oneof_index {
            if oneof_index != Self::ONEOF_INDEX_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::int32(oneof_index))?;
            }
        }
        let json_name = &self.json_name;
        if let std::option::Option::Some(json_name) = json_name {
            if json_name != Self::JSON_NAME_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(json_name)?)?;
            }
        }
        let options = &self.options;
        if let std::option::Option::Some(options) = options {
            size = size.checked_add(1)?;
            size = size.checked_add(crate::io::sizes::message(options)?)?;
        }
        size = size.checked_add(self.unknown_fields.calculate_size()?)?;
        std::option::Option::Some(size)
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let name = &self.name;
        if let std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
        }
        let number = self.number;
        if let std::option::Option::Some(number) = number {
            if number != Self::NUMBER_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[24])?;
                output.write_int32(number)?;
            }
        }
        let label = self.label;
        if let std::option::Option::Some(label) = label {
            if label != Self::LABEL_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[32])?;
                output.write_enum_value(label)?;
            }
        }
        let r#type = self.r#type;
        if let std::option::Option::Some(r#type) = r#type {
            if r#type != Self::TYPE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[40])?;
                output.write_enum_value(r#type)?;
            }
        }
        let type_name = &self.type_name;
        if let std::option::Option::Some(type_name) = type_name {
            if type_name != Self::TYPE_NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[50])?;
                output.write_string(type_name)?;
            }
        }
        let extendee = &self.extendee;
        if let std::option::Option::Some(extendee) = extendee {
            if extendee != Self::EXTENDEE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[18])?;
                output.write_string(extendee)?;
            }
        }
        let default_value = &self.default_value;
        if let std::option::Option::Some(default_value) = default_value {
            if default_value != Self::DEFAULT_VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[58])?;
                output.write_string(default_value)?;
            }
        }
        let oneof_index = self.oneof_index;
        if let std::option::Option::Some(oneof_index) = oneof_index {
            if oneof_index != Self::ONEOF_INDEX_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[72])?;
                output.write_int32(oneof_index)?;
            }
        }
        let json_name = &self.json_name;
        if let std::option::Option::Some(json_name) = json_name {
            if json_name != Self::JSON_NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[82])?;
                output.write_string(json_name)?;
            }
        }
        let options = &self.options;
        if let std::option::Option::Some(options) = options {
            output.write_raw_tag_bytes(&[66])?;
            output.write_message(options)?;
        }
        self.unknown_fields.write_to(output)?;
        std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::FieldDescriptorProto {
    fn new() -> Self {
        Self {
            name: std::option::Option::None,
            number: std::option::Option::None,
            label: std::option::Option::None,
            r#type: std::option::Option::None,
            type_name: std::option::Option::None,
            extendee: std::option::Option::None,
            default_value: std::option::Option::None,
            oneof_index: std::option::Option::None,
            json_name: std::option::Option::None,
            options: std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl std::clone::Clone for self::FieldDescriptorProto {
    fn clone(&self) -> Self {
        Self {
            name: self.name.clone(),
            number: self.number.clone(),
            label: self.label.clone(),
            r#type: self.r#type.clone(),
            type_name: self.type_name.clone(),
            extendee: self.extendee.clone(),
            default_value: self.default_value.clone(),
            oneof_index: self.oneof_index.clone(),
            json_name: self.json_name.clone(),
            options: self.options.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.name = other.name.clone();
        self.number = other.number;
        self.label = other.label;
        self.r#type = other.r#type;
        self.type_name = other.type_name.clone();
        self.extendee = other.extendee.clone();
        self.default_value = other.default_value.clone();
        self.oneof_index = other.oneof_index;
        self.json_name = other.json_name.clone();
        if let std::option::Option::Some(options) = &other.options {
            self.options.get_or_insert_with(crate::LiteMessage::new).clone_from(options);
        }
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::FieldDescriptorProto {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        unimplemented!()
    }
}
impl self::FieldDescriptorProto {
    /// Gets the field number of the 'name' field
    pub const NAME_FIELD_NUMBER: i32 = 1;
    pub const NAME_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'number' field
    pub const NUMBER_FIELD_NUMBER: i32 = 3;
    pub const NUMBER_DEFAULT_VALUE: i32 = 0;
    /// Gets the field number of the 'label' field
    pub const LABEL_FIELD_NUMBER: i32 = 4;
    pub const LABEL_DEFAULT_VALUE: crate::EnumValue<self::FieldDescriptorProto_Label> = crate::EnumValue::Undefined(0);
    /// Gets the field number of the 'type' field
    pub const TYPE_FIELD_NUMBER: i32 = 5;
    pub const TYPE_DEFAULT_VALUE: crate::EnumValue<self::FieldDescriptorProto_Type> = crate::EnumValue::Undefined(0);
    /// Gets the field number of the 'type_name' field
    pub const TYPE_NAME_FIELD_NUMBER: i32 = 6;
    pub const TYPE_NAME_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'extendee' field
    pub const EXTENDEE_FIELD_NUMBER: i32 = 2;
    pub const EXTENDEE_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'default_value' field
    pub const DEFAULT_VALUE_FIELD_NUMBER: i32 = 7;
    pub const DEFAULT_VALUE_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'oneof_index' field
    pub const ONEOF_INDEX_FIELD_NUMBER: i32 = 9;
    pub const ONEOF_INDEX_DEFAULT_VALUE: i32 = 0;
    /// Gets the field number of the 'json_name' field
    pub const JSON_NAME_FIELD_NUMBER: i32 = 10;
    pub const JSON_NAME_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'options' field
    pub const OPTIONS_FIELD_NUMBER: i32 = 8;
}
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum FieldDescriptorProto_Type {
    Double = 1,
    Float = 2,
    Int64 = 3,
    Uint64 = 4,
    Int32 = 5,
    Fixed64 = 6,
    Fixed32 = 7,
    Bool = 8,
    String = 9,
    Group = 10,
    Message = 11,
    Bytes = 12,
    Uint32 = 13,
    Enum = 14,
    Sfixed32 = 15,
    Sfixed64 = 16,
    Sint32 = 17,
    Sint64 = 18,
}
impl std::convert::TryFrom<i32> for self::FieldDescriptorProto_Type {
    type Error = crate::VariantUndefinedError;
    
    fn try_from(value: i32) -> std::result::Result<Self, crate::VariantUndefinedError> {
        match value {
            1 => std::result::Result::Ok(self::FieldDescriptorProto_Type::Double),
            2 => std::result::Result::Ok(self::FieldDescriptorProto_Type::Float),
            3 => std::result::Result::Ok(self::FieldDescriptorProto_Type::Int64),
            4 => std::result::Result::Ok(self::FieldDescriptorProto_Type::Uint64),
            5 => std::result::Result::Ok(self::FieldDescriptorProto_Type::Int32),
            6 => std::result::Result::Ok(self::FieldDescriptorProto_Type::Fixed64),
            7 => std::result::Result::Ok(self::FieldDescriptorProto_Type::Fixed32),
            8 => std::result::Result::Ok(self::FieldDescriptorProto_Type::Bool),
            9 => std::result::Result::Ok(self::FieldDescriptorProto_Type::String),
            10 => std::result::Result::Ok(self::FieldDescriptorProto_Type::Group),
            11 => std::result::Result::Ok(self::FieldDescriptorProto_Type::Message),
            12 => std::result::Result::Ok(self::FieldDescriptorProto_Type::Bytes),
            13 => std::result::Result::Ok(self::FieldDescriptorProto_Type::Uint32),
            14 => std::result::Result::Ok(self::FieldDescriptorProto_Type::Enum),
            15 => std::result::Result::Ok(self::FieldDescriptorProto_Type::Sfixed32),
            16 => std::result::Result::Ok(self::FieldDescriptorProto_Type::Sfixed64),
            17 => std::result::Result::Ok(self::FieldDescriptorProto_Type::Sint32),
            18 => std::result::Result::Ok(self::FieldDescriptorProto_Type::Sint64),
            _ => std::result::Result::Err(crate::VariantUndefinedError)
        }
    }
}
impl std::convert::From<self::FieldDescriptorProto_Type> for i32 {
    fn from(value: self::FieldDescriptorProto_Type) -> i32 {
        value as i32
    }
}
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum FieldDescriptorProto_Label {
    Optional = 1,
    Required = 2,
    Repeated = 3,
}
impl std::convert::TryFrom<i32> for self::FieldDescriptorProto_Label {
    type Error = crate::VariantUndefinedError;
    
    fn try_from(value: i32) -> std::result::Result<Self, crate::VariantUndefinedError> {
        match value {
            1 => std::result::Result::Ok(self::FieldDescriptorProto_Label::Optional),
            2 => std::result::Result::Ok(self::FieldDescriptorProto_Label::Required),
            3 => std::result::Result::Ok(self::FieldDescriptorProto_Label::Repeated),
            _ => std::result::Result::Err(crate::VariantUndefinedError)
        }
    }
}
impl std::convert::From<self::FieldDescriptorProto_Label> for i32 {
    fn from(value: self::FieldDescriptorProto_Label) -> i32 {
        value as i32
    }
}
#[derive(Debug, PartialEq)]
pub struct OneofDescriptorProto {
    pub name: std::option::Option<std::string::String>,
    pub options: std::option::Option<std::boxed::Box<self::OneofOptions>>,
    unknown_fields: crate::UnknownFieldSet
}
impl crate::CodedMessage for self::OneofDescriptorProto {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.name = std::option::Option::Some(input.read_string()?),
                18 => input.read_message(self.options.get_or_insert_with(crate::LiteMessage::new))?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> std::option::Option<i32> {
        let mut size = 0i32;
        let name = &self.name;
        if let std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(name)?)?;
            }
        }
        let options = &self.options;
        if let std::option::Option::Some(options) = options {
            size = size.checked_add(1)?;
            size = size.checked_add(crate::io::sizes::message(options)?)?;
        }
        size = size.checked_add(self.unknown_fields.calculate_size()?)?;
        std::option::Option::Some(size)
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let name = &self.name;
        if let std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
        }
        let options = &self.options;
        if let std::option::Option::Some(options) = options {
            output.write_raw_tag_bytes(&[18])?;
            output.write_message(options)?;
        }
        self.unknown_fields.write_to(output)?;
        std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::OneofDescriptorProto {
    fn new() -> Self {
        Self {
            name: std::option::Option::None,
            options: std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl std::clone::Clone for self::OneofDescriptorProto {
    fn clone(&self) -> Self {
        Self {
            name: self.name.clone(),
            options: self.options.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.name = other.name.clone();
        if let std::option::Option::Some(options) = &other.options {
            self.options.get_or_insert_with(crate::LiteMessage::new).clone_from(options);
        }
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::OneofDescriptorProto {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        unimplemented!()
    }
}
impl self::OneofDescriptorProto {
    /// Gets the field number of the 'name' field
    pub const NAME_FIELD_NUMBER: i32 = 1;
    pub const NAME_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'options' field
    pub const OPTIONS_FIELD_NUMBER: i32 = 2;
}
#[derive(Debug, PartialEq)]
pub struct EnumDescriptorProto {
    pub name: std::option::Option<std::string::String>,
    pub value: crate::collections::RepeatedField<std::boxed::Box<self::EnumValueDescriptorProto>>,
    pub options: std::option::Option<std::boxed::Box<self::EnumOptions>>,
    pub reserved_range: crate::collections::RepeatedField<std::boxed::Box<self::EnumDescriptorProto_EnumReservedRange>>,
    pub reserved_name: crate::collections::RepeatedField<std::string::String>,
    unknown_fields: crate::UnknownFieldSet
}
static ENUM_DESCRIPTOR_PROTO_VALUE_CODEC: crate::Codec<std::boxed::Box<self::EnumValueDescriptorProto>> = crate::Codec::message(18);
static ENUM_DESCRIPTOR_PROTO_RESERVED_RANGE_CODEC: crate::Codec<std::boxed::Box<self::EnumDescriptorProto_EnumReservedRange>> = crate::Codec::message(34);
static ENUM_DESCRIPTOR_PROTO_RESERVED_NAME_CODEC: crate::Codec<std::string::String> = crate::Codec::string(42);
impl crate::CodedMessage for self::EnumDescriptorProto {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.name = std::option::Option::Some(input.read_string()?),
                18 => self.value.add_entries(tag.get(), input, &ENUM_DESCRIPTOR_PROTO_VALUE_CODEC)?,
                26 => input.read_message(self.options.get_or_insert_with(crate::LiteMessage::new))?,
                34 => self.reserved_range.add_entries(tag.get(), input, &ENUM_DESCRIPTOR_PROTO_RESERVED_RANGE_CODEC)?,
                42 => self.reserved_name.add_entries(tag.get(), input, &ENUM_DESCRIPTOR_PROTO_RESERVED_NAME_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> std::option::Option<i32> {
        let mut size = 0i32;
        let name = &self.name;
        if let std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(name)?)?;
            }
        }
        size = size.checked_add(self.value.calculate_size(&ENUM_DESCRIPTOR_PROTO_VALUE_CODEC)?)?;
        let options = &self.options;
        if let std::option::Option::Some(options) = options {
            size = size.checked_add(1)?;
            size = size.checked_add(crate::io::sizes::message(options)?)?;
        }
        size = size.checked_add(self.reserved_range.calculate_size(&ENUM_DESCRIPTOR_PROTO_RESERVED_RANGE_CODEC)?)?;
        size = size.checked_add(self.reserved_name.calculate_size(&ENUM_DESCRIPTOR_PROTO_RESERVED_NAME_CODEC)?)?;
        size = size.checked_add(self.unknown_fields.calculate_size()?)?;
        std::option::Option::Some(size)
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let name = &self.name;
        if let std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
        }
        self.value.write_to(output, &ENUM_DESCRIPTOR_PROTO_VALUE_CODEC)?;
        let options = &self.options;
        if let std::option::Option::Some(options) = options {
            output.write_raw_tag_bytes(&[26])?;
            output.write_message(options)?;
        }
        self.reserved_range.write_to(output, &ENUM_DESCRIPTOR_PROTO_RESERVED_RANGE_CODEC)?;
        self.reserved_name.write_to(output, &ENUM_DESCRIPTOR_PROTO_RESERVED_NAME_CODEC)?;
        self.unknown_fields.write_to(output)?;
        std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::EnumDescriptorProto {
    fn new() -> Self {
        Self {
            name: std::option::Option::None,
            value: crate::collections::RepeatedField::new(),
            options: std::option::Option::None,
            reserved_range: crate::collections::RepeatedField::new(),
            reserved_name: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl std::clone::Clone for self::EnumDescriptorProto {
    fn clone(&self) -> Self {
        Self {
            name: self.name.clone(),
            value: self.value.clone(),
            options: self.options.clone(),
            reserved_range: self.reserved_range.clone(),
            reserved_name: self.reserved_name.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.name = other.name.clone();
        self.value.clone_from(&other.value);
        if let std::option::Option::Some(options) = &other.options {
            self.options.get_or_insert_with(crate::LiteMessage::new).clone_from(options);
        }
        self.reserved_range.clone_from(&other.reserved_range);
        self.reserved_name.clone_from(&other.reserved_name);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::EnumDescriptorProto {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        unimplemented!()
    }
}
impl self::EnumDescriptorProto {
    /// Gets the field number of the 'name' field
    pub const NAME_FIELD_NUMBER: i32 = 1;
    pub const NAME_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'value' field
    pub const VALUE_FIELD_NUMBER: i32 = 2;
    /// Gets the field number of the 'options' field
    pub const OPTIONS_FIELD_NUMBER: i32 = 3;
    /// Gets the field number of the 'reserved_range' field
    pub const RESERVED_RANGE_FIELD_NUMBER: i32 = 4;
    /// Gets the field number of the 'reserved_name' field
    pub const RESERVED_NAME_FIELD_NUMBER: i32 = 5;
}
#[derive(Debug, PartialEq)]
pub struct EnumDescriptorProto_EnumReservedRange {
    pub start: std::option::Option<i32>,
    pub end: std::option::Option<i32>,
    unknown_fields: crate::UnknownFieldSet
}
impl crate::CodedMessage for self::EnumDescriptorProto_EnumReservedRange {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 => self.start = std::option::Option::Some(input.read_int32()?),
                16 => self.end = std::option::Option::Some(input.read_int32()?),
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> std::option::Option<i32> {
        let mut size = 0i32;
        let start = self.start;
        if let std::option::Option::Some(start) = start {
            if start != Self::START_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::int32(start))?;
            }
        }
        let end = self.end;
        if let std::option::Option::Some(end) = end {
            if end != Self::END_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::int32(end))?;
            }
        }
        size = size.checked_add(self.unknown_fields.calculate_size()?)?;
        std::option::Option::Some(size)
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let start = self.start;
        if let std::option::Option::Some(start) = start {
            if start != Self::START_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(start)?;
            }
        }
        let end = self.end;
        if let std::option::Option::Some(end) = end {
            if end != Self::END_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_int32(end)?;
            }
        }
        self.unknown_fields.write_to(output)?;
        std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::EnumDescriptorProto_EnumReservedRange {
    fn new() -> Self {
        Self {
            start: std::option::Option::None,
            end: std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl std::clone::Clone for self::EnumDescriptorProto_EnumReservedRange {
    fn clone(&self) -> Self {
        Self {
            start: self.start.clone(),
            end: self.end.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.start = other.start;
        self.end = other.end;
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::EnumDescriptorProto_EnumReservedRange {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        unimplemented!()
    }
}
impl self::EnumDescriptorProto_EnumReservedRange {
    /// Gets the field number of the 'start' field
    pub const START_FIELD_NUMBER: i32 = 1;
    pub const START_DEFAULT_VALUE: i32 = 0;
    /// Gets the field number of the 'end' field
    pub const END_FIELD_NUMBER: i32 = 2;
    pub const END_DEFAULT_VALUE: i32 = 0;
}
#[derive(Debug, PartialEq)]
pub struct EnumValueDescriptorProto {
    pub name: std::option::Option<std::string::String>,
    pub number: std::option::Option<i32>,
    pub options: std::option::Option<std::boxed::Box<self::EnumValueOptions>>,
    unknown_fields: crate::UnknownFieldSet
}
impl crate::CodedMessage for self::EnumValueDescriptorProto {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.name = std::option::Option::Some(input.read_string()?),
                16 => self.number = std::option::Option::Some(input.read_int32()?),
                26 => input.read_message(self.options.get_or_insert_with(crate::LiteMessage::new))?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> std::option::Option<i32> {
        let mut size = 0i32;
        let name = &self.name;
        if let std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(name)?)?;
            }
        }
        let number = self.number;
        if let std::option::Option::Some(number) = number {
            if number != Self::NUMBER_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::int32(number))?;
            }
        }
        let options = &self.options;
        if let std::option::Option::Some(options) = options {
            size = size.checked_add(1)?;
            size = size.checked_add(crate::io::sizes::message(options)?)?;
        }
        size = size.checked_add(self.unknown_fields.calculate_size()?)?;
        std::option::Option::Some(size)
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let name = &self.name;
        if let std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
        }
        let number = self.number;
        if let std::option::Option::Some(number) = number {
            if number != Self::NUMBER_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_int32(number)?;
            }
        }
        let options = &self.options;
        if let std::option::Option::Some(options) = options {
            output.write_raw_tag_bytes(&[26])?;
            output.write_message(options)?;
        }
        self.unknown_fields.write_to(output)?;
        std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::EnumValueDescriptorProto {
    fn new() -> Self {
        Self {
            name: std::option::Option::None,
            number: std::option::Option::None,
            options: std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl std::clone::Clone for self::EnumValueDescriptorProto {
    fn clone(&self) -> Self {
        Self {
            name: self.name.clone(),
            number: self.number.clone(),
            options: self.options.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.name = other.name.clone();
        self.number = other.number;
        if let std::option::Option::Some(options) = &other.options {
            self.options.get_or_insert_with(crate::LiteMessage::new).clone_from(options);
        }
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::EnumValueDescriptorProto {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        unimplemented!()
    }
}
impl self::EnumValueDescriptorProto {
    /// Gets the field number of the 'name' field
    pub const NAME_FIELD_NUMBER: i32 = 1;
    pub const NAME_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'number' field
    pub const NUMBER_FIELD_NUMBER: i32 = 2;
    pub const NUMBER_DEFAULT_VALUE: i32 = 0;
    /// Gets the field number of the 'options' field
    pub const OPTIONS_FIELD_NUMBER: i32 = 3;
}
#[derive(Debug, PartialEq)]
pub struct ServiceDescriptorProto {
    pub name: std::option::Option<std::string::String>,
    pub method: crate::collections::RepeatedField<std::boxed::Box<self::MethodDescriptorProto>>,
    pub options: std::option::Option<std::boxed::Box<self::ServiceOptions>>,
    unknown_fields: crate::UnknownFieldSet
}
static SERVICE_DESCRIPTOR_PROTO_METHOD_CODEC: crate::Codec<std::boxed::Box<self::MethodDescriptorProto>> = crate::Codec::message(18);
impl crate::CodedMessage for self::ServiceDescriptorProto {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.name = std::option::Option::Some(input.read_string()?),
                18 => self.method.add_entries(tag.get(), input, &SERVICE_DESCRIPTOR_PROTO_METHOD_CODEC)?,
                26 => input.read_message(self.options.get_or_insert_with(crate::LiteMessage::new))?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> std::option::Option<i32> {
        let mut size = 0i32;
        let name = &self.name;
        if let std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(name)?)?;
            }
        }
        size = size.checked_add(self.method.calculate_size(&SERVICE_DESCRIPTOR_PROTO_METHOD_CODEC)?)?;
        let options = &self.options;
        if let std::option::Option::Some(options) = options {
            size = size.checked_add(1)?;
            size = size.checked_add(crate::io::sizes::message(options)?)?;
        }
        size = size.checked_add(self.unknown_fields.calculate_size()?)?;
        std::option::Option::Some(size)
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let name = &self.name;
        if let std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
        }
        self.method.write_to(output, &SERVICE_DESCRIPTOR_PROTO_METHOD_CODEC)?;
        let options = &self.options;
        if let std::option::Option::Some(options) = options {
            output.write_raw_tag_bytes(&[26])?;
            output.write_message(options)?;
        }
        self.unknown_fields.write_to(output)?;
        std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::ServiceDescriptorProto {
    fn new() -> Self {
        Self {
            name: std::option::Option::None,
            method: crate::collections::RepeatedField::new(),
            options: std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl std::clone::Clone for self::ServiceDescriptorProto {
    fn clone(&self) -> Self {
        Self {
            name: self.name.clone(),
            method: self.method.clone(),
            options: self.options.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.name = other.name.clone();
        self.method.clone_from(&other.method);
        if let std::option::Option::Some(options) = &other.options {
            self.options.get_or_insert_with(crate::LiteMessage::new).clone_from(options);
        }
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::ServiceDescriptorProto {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        unimplemented!()
    }
}
impl self::ServiceDescriptorProto {
    /// Gets the field number of the 'name' field
    pub const NAME_FIELD_NUMBER: i32 = 1;
    pub const NAME_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'method' field
    pub const METHOD_FIELD_NUMBER: i32 = 2;
    /// Gets the field number of the 'options' field
    pub const OPTIONS_FIELD_NUMBER: i32 = 3;
}
#[derive(Debug, PartialEq)]
pub struct MethodDescriptorProto {
    pub name: std::option::Option<std::string::String>,
    pub input_type: std::option::Option<std::string::String>,
    pub output_type: std::option::Option<std::string::String>,
    pub options: std::option::Option<std::boxed::Box<self::MethodOptions>>,
    pub client_streaming: std::option::Option<bool>,
    pub server_streaming: std::option::Option<bool>,
    unknown_fields: crate::UnknownFieldSet
}
impl crate::CodedMessage for self::MethodDescriptorProto {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.name = std::option::Option::Some(input.read_string()?),
                18 => self.input_type = std::option::Option::Some(input.read_string()?),
                26 => self.output_type = std::option::Option::Some(input.read_string()?),
                34 => input.read_message(self.options.get_or_insert_with(crate::LiteMessage::new))?,
                40 => self.client_streaming = std::option::Option::Some(input.read_bool()?),
                48 => self.server_streaming = std::option::Option::Some(input.read_bool()?),
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> std::option::Option<i32> {
        let mut size = 0i32;
        let name = &self.name;
        if let std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(name)?)?;
            }
        }
        let input_type = &self.input_type;
        if let std::option::Option::Some(input_type) = input_type {
            if input_type != Self::INPUT_TYPE_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(input_type)?)?;
            }
        }
        let output_type = &self.output_type;
        if let std::option::Option::Some(output_type) = output_type {
            if output_type != Self::OUTPUT_TYPE_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(output_type)?)?;
            }
        }
        let options = &self.options;
        if let std::option::Option::Some(options) = options {
            size = size.checked_add(1)?;
            size = size.checked_add(crate::io::sizes::message(options)?)?;
        }
        let client_streaming = self.client_streaming;
        if let std::option::Option::Some(client_streaming) = client_streaming {
            if client_streaming != Self::CLIENT_STREAMING_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(client_streaming))?;
            }
        }
        let server_streaming = self.server_streaming;
        if let std::option::Option::Some(server_streaming) = server_streaming {
            if server_streaming != Self::SERVER_STREAMING_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(server_streaming))?;
            }
        }
        size = size.checked_add(self.unknown_fields.calculate_size()?)?;
        std::option::Option::Some(size)
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let name = &self.name;
        if let std::option::Option::Some(name) = name {
            if name != Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
        }
        let input_type = &self.input_type;
        if let std::option::Option::Some(input_type) = input_type {
            if input_type != Self::INPUT_TYPE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[18])?;
                output.write_string(input_type)?;
            }
        }
        let output_type = &self.output_type;
        if let std::option::Option::Some(output_type) = output_type {
            if output_type != Self::OUTPUT_TYPE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[26])?;
                output.write_string(output_type)?;
            }
        }
        let options = &self.options;
        if let std::option::Option::Some(options) = options {
            output.write_raw_tag_bytes(&[34])?;
            output.write_message(options)?;
        }
        let client_streaming = self.client_streaming;
        if let std::option::Option::Some(client_streaming) = client_streaming {
            if client_streaming != Self::CLIENT_STREAMING_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[40])?;
                output.write_bool(client_streaming)?;
            }
        }
        let server_streaming = self.server_streaming;
        if let std::option::Option::Some(server_streaming) = server_streaming {
            if server_streaming != Self::SERVER_STREAMING_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[48])?;
                output.write_bool(server_streaming)?;
            }
        }
        self.unknown_fields.write_to(output)?;
        std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::MethodDescriptorProto {
    fn new() -> Self {
        Self {
            name: std::option::Option::None,
            input_type: std::option::Option::None,
            output_type: std::option::Option::None,
            options: std::option::Option::None,
            client_streaming: std::option::Option::None,
            server_streaming: std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl std::clone::Clone for self::MethodDescriptorProto {
    fn clone(&self) -> Self {
        Self {
            name: self.name.clone(),
            input_type: self.input_type.clone(),
            output_type: self.output_type.clone(),
            options: self.options.clone(),
            client_streaming: self.client_streaming.clone(),
            server_streaming: self.server_streaming.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.name = other.name.clone();
        self.input_type = other.input_type.clone();
        self.output_type = other.output_type.clone();
        if let std::option::Option::Some(options) = &other.options {
            self.options.get_or_insert_with(crate::LiteMessage::new).clone_from(options);
        }
        self.client_streaming = other.client_streaming;
        self.server_streaming = other.server_streaming;
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::MethodDescriptorProto {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        unimplemented!()
    }
}
impl self::MethodDescriptorProto {
    /// Gets the field number of the 'name' field
    pub const NAME_FIELD_NUMBER: i32 = 1;
    pub const NAME_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'input_type' field
    pub const INPUT_TYPE_FIELD_NUMBER: i32 = 2;
    pub const INPUT_TYPE_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'output_type' field
    pub const OUTPUT_TYPE_FIELD_NUMBER: i32 = 3;
    pub const OUTPUT_TYPE_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'options' field
    pub const OPTIONS_FIELD_NUMBER: i32 = 4;
    /// Gets the field number of the 'client_streaming' field
    pub const CLIENT_STREAMING_FIELD_NUMBER: i32 = 5;
    pub const CLIENT_STREAMING_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'server_streaming' field
    pub const SERVER_STREAMING_FIELD_NUMBER: i32 = 6;
    pub const SERVER_STREAMING_DEFAULT_VALUE: bool = false;
}
#[derive(Debug, PartialEq)]
pub struct FileOptions {
    pub java_package: std::option::Option<std::string::String>,
    pub java_outer_classname: std::option::Option<std::string::String>,
    pub java_multiple_files: std::option::Option<bool>,
    pub java_generate_equals_and_hash: std::option::Option<bool>,
    pub java_string_check_utf8: std::option::Option<bool>,
    pub optimize_for: std::option::Option<crate::EnumValue<self::FileOptions_OptimizeMode>>,
    pub go_package: std::option::Option<std::string::String>,
    pub cc_generic_services: std::option::Option<bool>,
    pub java_generic_services: std::option::Option<bool>,
    pub py_generic_services: std::option::Option<bool>,
    pub php_generic_services: std::option::Option<bool>,
    pub deprecated: std::option::Option<bool>,
    pub cc_enable_arenas: std::option::Option<bool>,
    pub objc_class_prefix: std::option::Option<std::string::String>,
    pub csharp_namespace: std::option::Option<std::string::String>,
    pub swift_prefix: std::option::Option<std::string::String>,
    pub php_class_prefix: std::option::Option<std::string::String>,
    pub php_namespace: std::option::Option<std::string::String>,
    pub php_metadata_namespace: std::option::Option<std::string::String>,
    pub ruby_package: std::option::Option<std::string::String>,
    pub uninterpreted_option: crate::collections::RepeatedField<std::boxed::Box<self::UninterpretedOption>>,
    unknown_fields: crate::UnknownFieldSet
}
static FILE_OPTIONS_UNINTERPRETED_OPTION_CODEC: crate::Codec<std::boxed::Box<self::UninterpretedOption>> = crate::Codec::message(7994);
impl crate::CodedMessage for self::FileOptions {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.java_package = std::option::Option::Some(input.read_string()?),
                66 => self.java_outer_classname = std::option::Option::Some(input.read_string()?),
                80 => self.java_multiple_files = std::option::Option::Some(input.read_bool()?),
                160 => self.java_generate_equals_and_hash = std::option::Option::Some(input.read_bool()?),
                216 => self.java_string_check_utf8 = std::option::Option::Some(input.read_bool()?),
                72 => self.optimize_for = std::option::Option::Some(input.read_enum_value()?),
                90 => self.go_package = std::option::Option::Some(input.read_string()?),
                128 => self.cc_generic_services = std::option::Option::Some(input.read_bool()?),
                136 => self.java_generic_services = std::option::Option::Some(input.read_bool()?),
                144 => self.py_generic_services = std::option::Option::Some(input.read_bool()?),
                336 => self.php_generic_services = std::option::Option::Some(input.read_bool()?),
                184 => self.deprecated = std::option::Option::Some(input.read_bool()?),
                248 => self.cc_enable_arenas = std::option::Option::Some(input.read_bool()?),
                290 => self.objc_class_prefix = std::option::Option::Some(input.read_string()?),
                298 => self.csharp_namespace = std::option::Option::Some(input.read_string()?),
                314 => self.swift_prefix = std::option::Option::Some(input.read_string()?),
                322 => self.php_class_prefix = std::option::Option::Some(input.read_string()?),
                330 => self.php_namespace = std::option::Option::Some(input.read_string()?),
                354 => self.php_metadata_namespace = std::option::Option::Some(input.read_string()?),
                362 => self.ruby_package = std::option::Option::Some(input.read_string()?),
                7994 => self.uninterpreted_option.add_entries(tag.get(), input, &FILE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> std::option::Option<i32> {
        let mut size = 0i32;
        let java_package = &self.java_package;
        if let std::option::Option::Some(java_package) = java_package {
            if java_package != Self::JAVA_PACKAGE_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(java_package)?)?;
            }
        }
        let java_outer_classname = &self.java_outer_classname;
        if let std::option::Option::Some(java_outer_classname) = java_outer_classname {
            if java_outer_classname != Self::JAVA_OUTER_CLASSNAME_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(java_outer_classname)?)?;
            }
        }
        let java_multiple_files = self.java_multiple_files;
        if let std::option::Option::Some(java_multiple_files) = java_multiple_files {
            if java_multiple_files != Self::JAVA_MULTIPLE_FILES_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(java_multiple_files))?;
            }
        }
        let java_generate_equals_and_hash = self.java_generate_equals_and_hash;
        if let std::option::Option::Some(java_generate_equals_and_hash) = java_generate_equals_and_hash {
            if java_generate_equals_and_hash != Self::JAVA_GENERATE_EQUALS_AND_HASH_DEFAULT_VALUE {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::bool(java_generate_equals_and_hash))?;
            }
        }
        let java_string_check_utf8 = self.java_string_check_utf8;
        if let std::option::Option::Some(java_string_check_utf8) = java_string_check_utf8 {
            if java_string_check_utf8 != Self::JAVA_STRING_CHECK_UTF8_DEFAULT_VALUE {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::bool(java_string_check_utf8))?;
            }
        }
        let optimize_for = self.optimize_for;
        if let std::option::Option::Some(optimize_for) = optimize_for {
            if optimize_for != Self::OPTIMIZE_FOR_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::enum_value(optimize_for))?;
            }
        }
        let go_package = &self.go_package;
        if let std::option::Option::Some(go_package) = go_package {
            if go_package != Self::GO_PACKAGE_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(go_package)?)?;
            }
        }
        let cc_generic_services = self.cc_generic_services;
        if let std::option::Option::Some(cc_generic_services) = cc_generic_services {
            if cc_generic_services != Self::CC_GENERIC_SERVICES_DEFAULT_VALUE {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::bool(cc_generic_services))?;
            }
        }
        let java_generic_services = self.java_generic_services;
        if let std::option::Option::Some(java_generic_services) = java_generic_services {
            if java_generic_services != Self::JAVA_GENERIC_SERVICES_DEFAULT_VALUE {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::bool(java_generic_services))?;
            }
        }
        let py_generic_services = self.py_generic_services;
        if let std::option::Option::Some(py_generic_services) = py_generic_services {
            if py_generic_services != Self::PY_GENERIC_SERVICES_DEFAULT_VALUE {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::bool(py_generic_services))?;
            }
        }
        let php_generic_services = self.php_generic_services;
        if let std::option::Option::Some(php_generic_services) = php_generic_services {
            if php_generic_services != Self::PHP_GENERIC_SERVICES_DEFAULT_VALUE {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::bool(php_generic_services))?;
            }
        }
        let deprecated = self.deprecated;
        if let std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::bool(deprecated))?;
            }
        }
        let cc_enable_arenas = self.cc_enable_arenas;
        if let std::option::Option::Some(cc_enable_arenas) = cc_enable_arenas {
            if cc_enable_arenas != Self::CC_ENABLE_ARENAS_DEFAULT_VALUE {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::bool(cc_enable_arenas))?;
            }
        }
        let objc_class_prefix = &self.objc_class_prefix;
        if let std::option::Option::Some(objc_class_prefix) = objc_class_prefix {
            if objc_class_prefix != Self::OBJC_CLASS_PREFIX_DEFAULT_VALUE {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::string(objc_class_prefix)?)?;
            }
        }
        let csharp_namespace = &self.csharp_namespace;
        if let std::option::Option::Some(csharp_namespace) = csharp_namespace {
            if csharp_namespace != Self::CSHARP_NAMESPACE_DEFAULT_VALUE {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::string(csharp_namespace)?)?;
            }
        }
        let swift_prefix = &self.swift_prefix;
        if let std::option::Option::Some(swift_prefix) = swift_prefix {
            if swift_prefix != Self::SWIFT_PREFIX_DEFAULT_VALUE {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::string(swift_prefix)?)?;
            }
        }
        let php_class_prefix = &self.php_class_prefix;
        if let std::option::Option::Some(php_class_prefix) = php_class_prefix {
            if php_class_prefix != Self::PHP_CLASS_PREFIX_DEFAULT_VALUE {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::string(php_class_prefix)?)?;
            }
        }
        let php_namespace = &self.php_namespace;
        if let std::option::Option::Some(php_namespace) = php_namespace {
            if php_namespace != Self::PHP_NAMESPACE_DEFAULT_VALUE {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::string(php_namespace)?)?;
            }
        }
        let php_metadata_namespace = &self.php_metadata_namespace;
        if let std::option::Option::Some(php_metadata_namespace) = php_metadata_namespace {
            if php_metadata_namespace != Self::PHP_METADATA_NAMESPACE_DEFAULT_VALUE {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::string(php_metadata_namespace)?)?;
            }
        }
        let ruby_package = &self.ruby_package;
        if let std::option::Option::Some(ruby_package) = ruby_package {
            if ruby_package != Self::RUBY_PACKAGE_DEFAULT_VALUE {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::string(ruby_package)?)?;
            }
        }
        size = size.checked_add(self.uninterpreted_option.calculate_size(&FILE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?)?;
        size = size.checked_add(self.unknown_fields.calculate_size()?)?;
        std::option::Option::Some(size)
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let java_package = &self.java_package;
        if let std::option::Option::Some(java_package) = java_package {
            if java_package != Self::JAVA_PACKAGE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(java_package)?;
            }
        }
        let java_outer_classname = &self.java_outer_classname;
        if let std::option::Option::Some(java_outer_classname) = java_outer_classname {
            if java_outer_classname != Self::JAVA_OUTER_CLASSNAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[66])?;
                output.write_string(java_outer_classname)?;
            }
        }
        let java_multiple_files = self.java_multiple_files;
        if let std::option::Option::Some(java_multiple_files) = java_multiple_files {
            if java_multiple_files != Self::JAVA_MULTIPLE_FILES_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[80])?;
                output.write_bool(java_multiple_files)?;
            }
        }
        let java_generate_equals_and_hash = self.java_generate_equals_and_hash;
        if let std::option::Option::Some(java_generate_equals_and_hash) = java_generate_equals_and_hash {
            if java_generate_equals_and_hash != Self::JAVA_GENERATE_EQUALS_AND_HASH_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[160, 1])?;
                output.write_bool(java_generate_equals_and_hash)?;
            }
        }
        let java_string_check_utf8 = self.java_string_check_utf8;
        if let std::option::Option::Some(java_string_check_utf8) = java_string_check_utf8 {
            if java_string_check_utf8 != Self::JAVA_STRING_CHECK_UTF8_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[216, 1])?;
                output.write_bool(java_string_check_utf8)?;
            }
        }
        let optimize_for = self.optimize_for;
        if let std::option::Option::Some(optimize_for) = optimize_for {
            if optimize_for != Self::OPTIMIZE_FOR_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[72])?;
                output.write_enum_value(optimize_for)?;
            }
        }
        let go_package = &self.go_package;
        if let std::option::Option::Some(go_package) = go_package {
            if go_package != Self::GO_PACKAGE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[90])?;
                output.write_string(go_package)?;
            }
        }
        let cc_generic_services = self.cc_generic_services;
        if let std::option::Option::Some(cc_generic_services) = cc_generic_services {
            if cc_generic_services != Self::CC_GENERIC_SERVICES_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[128, 1])?;
                output.write_bool(cc_generic_services)?;
            }
        }
        let java_generic_services = self.java_generic_services;
        if let std::option::Option::Some(java_generic_services) = java_generic_services {
            if java_generic_services != Self::JAVA_GENERIC_SERVICES_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[136, 1])?;
                output.write_bool(java_generic_services)?;
            }
        }
        let py_generic_services = self.py_generic_services;
        if let std::option::Option::Some(py_generic_services) = py_generic_services {
            if py_generic_services != Self::PY_GENERIC_SERVICES_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[144, 1])?;
                output.write_bool(py_generic_services)?;
            }
        }
        let php_generic_services = self.php_generic_services;
        if let std::option::Option::Some(php_generic_services) = php_generic_services {
            if php_generic_services != Self::PHP_GENERIC_SERVICES_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[208, 2])?;
                output.write_bool(php_generic_services)?;
            }
        }
        let deprecated = self.deprecated;
        if let std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[184, 1])?;
                output.write_bool(deprecated)?;
            }
        }
        let cc_enable_arenas = self.cc_enable_arenas;
        if let std::option::Option::Some(cc_enable_arenas) = cc_enable_arenas {
            if cc_enable_arenas != Self::CC_ENABLE_ARENAS_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[248, 1])?;
                output.write_bool(cc_enable_arenas)?;
            }
        }
        let objc_class_prefix = &self.objc_class_prefix;
        if let std::option::Option::Some(objc_class_prefix) = objc_class_prefix {
            if objc_class_prefix != Self::OBJC_CLASS_PREFIX_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[162, 2])?;
                output.write_string(objc_class_prefix)?;
            }
        }
        let csharp_namespace = &self.csharp_namespace;
        if let std::option::Option::Some(csharp_namespace) = csharp_namespace {
            if csharp_namespace != Self::CSHARP_NAMESPACE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[170, 2])?;
                output.write_string(csharp_namespace)?;
            }
        }
        let swift_prefix = &self.swift_prefix;
        if let std::option::Option::Some(swift_prefix) = swift_prefix {
            if swift_prefix != Self::SWIFT_PREFIX_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[186, 2])?;
                output.write_string(swift_prefix)?;
            }
        }
        let php_class_prefix = &self.php_class_prefix;
        if let std::option::Option::Some(php_class_prefix) = php_class_prefix {
            if php_class_prefix != Self::PHP_CLASS_PREFIX_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[194, 2])?;
                output.write_string(php_class_prefix)?;
            }
        }
        let php_namespace = &self.php_namespace;
        if let std::option::Option::Some(php_namespace) = php_namespace {
            if php_namespace != Self::PHP_NAMESPACE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[202, 2])?;
                output.write_string(php_namespace)?;
            }
        }
        let php_metadata_namespace = &self.php_metadata_namespace;
        if let std::option::Option::Some(php_metadata_namespace) = php_metadata_namespace {
            if php_metadata_namespace != Self::PHP_METADATA_NAMESPACE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[226, 2])?;
                output.write_string(php_metadata_namespace)?;
            }
        }
        let ruby_package = &self.ruby_package;
        if let std::option::Option::Some(ruby_package) = ruby_package {
            if ruby_package != Self::RUBY_PACKAGE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[234, 2])?;
                output.write_string(ruby_package)?;
            }
        }
        self.uninterpreted_option.write_to(output, &FILE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::FileOptions {
    fn new() -> Self {
        Self {
            java_package: std::option::Option::None,
            java_outer_classname: std::option::Option::None,
            java_multiple_files: std::option::Option::None,
            java_generate_equals_and_hash: std::option::Option::None,
            java_string_check_utf8: std::option::Option::None,
            optimize_for: std::option::Option::None,
            go_package: std::option::Option::None,
            cc_generic_services: std::option::Option::None,
            java_generic_services: std::option::Option::None,
            py_generic_services: std::option::Option::None,
            php_generic_services: std::option::Option::None,
            deprecated: std::option::Option::None,
            cc_enable_arenas: std::option::Option::None,
            objc_class_prefix: std::option::Option::None,
            csharp_namespace: std::option::Option::None,
            swift_prefix: std::option::Option::None,
            php_class_prefix: std::option::Option::None,
            php_namespace: std::option::Option::None,
            php_metadata_namespace: std::option::Option::None,
            ruby_package: std::option::Option::None,
            uninterpreted_option: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl std::clone::Clone for self::FileOptions {
    fn clone(&self) -> Self {
        Self {
            java_package: self.java_package.clone(),
            java_outer_classname: self.java_outer_classname.clone(),
            java_multiple_files: self.java_multiple_files.clone(),
            java_generate_equals_and_hash: self.java_generate_equals_and_hash.clone(),
            java_string_check_utf8: self.java_string_check_utf8.clone(),
            optimize_for: self.optimize_for.clone(),
            go_package: self.go_package.clone(),
            cc_generic_services: self.cc_generic_services.clone(),
            java_generic_services: self.java_generic_services.clone(),
            py_generic_services: self.py_generic_services.clone(),
            php_generic_services: self.php_generic_services.clone(),
            deprecated: self.deprecated.clone(),
            cc_enable_arenas: self.cc_enable_arenas.clone(),
            objc_class_prefix: self.objc_class_prefix.clone(),
            csharp_namespace: self.csharp_namespace.clone(),
            swift_prefix: self.swift_prefix.clone(),
            php_class_prefix: self.php_class_prefix.clone(),
            php_namespace: self.php_namespace.clone(),
            php_metadata_namespace: self.php_metadata_namespace.clone(),
            ruby_package: self.ruby_package.clone(),
            uninterpreted_option: self.uninterpreted_option.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.java_package = other.java_package.clone();
        self.java_outer_classname = other.java_outer_classname.clone();
        self.java_multiple_files = other.java_multiple_files;
        self.java_generate_equals_and_hash = other.java_generate_equals_and_hash;
        self.java_string_check_utf8 = other.java_string_check_utf8;
        self.optimize_for = other.optimize_for;
        self.go_package = other.go_package.clone();
        self.cc_generic_services = other.cc_generic_services;
        self.java_generic_services = other.java_generic_services;
        self.py_generic_services = other.py_generic_services;
        self.php_generic_services = other.php_generic_services;
        self.deprecated = other.deprecated;
        self.cc_enable_arenas = other.cc_enable_arenas;
        self.objc_class_prefix = other.objc_class_prefix.clone();
        self.csharp_namespace = other.csharp_namespace.clone();
        self.swift_prefix = other.swift_prefix.clone();
        self.php_class_prefix = other.php_class_prefix.clone();
        self.php_namespace = other.php_namespace.clone();
        self.php_metadata_namespace = other.php_metadata_namespace.clone();
        self.ruby_package = other.ruby_package.clone();
        self.uninterpreted_option.clone_from(&other.uninterpreted_option);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::FileOptions {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        unimplemented!()
    }
}
impl self::FileOptions {
    /// Gets the field number of the 'java_package' field
    pub const JAVA_PACKAGE_FIELD_NUMBER: i32 = 1;
    pub const JAVA_PACKAGE_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'java_outer_classname' field
    pub const JAVA_OUTER_CLASSNAME_FIELD_NUMBER: i32 = 8;
    pub const JAVA_OUTER_CLASSNAME_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'java_multiple_files' field
    pub const JAVA_MULTIPLE_FILES_FIELD_NUMBER: i32 = 10;
    pub const JAVA_MULTIPLE_FILES_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'java_generate_equals_and_hash' field
    pub const JAVA_GENERATE_EQUALS_AND_HASH_FIELD_NUMBER: i32 = 20;
    pub const JAVA_GENERATE_EQUALS_AND_HASH_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'java_string_check_utf8' field
    pub const JAVA_STRING_CHECK_UTF8_FIELD_NUMBER: i32 = 27;
    pub const JAVA_STRING_CHECK_UTF8_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'optimize_for' field
    pub const OPTIMIZE_FOR_FIELD_NUMBER: i32 = 9;
    pub const OPTIMIZE_FOR_DEFAULT_VALUE: crate::EnumValue<self::FileOptions_OptimizeMode> = crate::EnumValue::Defined(self::FileOptions_OptimizeMode::Speed);
    /// Gets the field number of the 'go_package' field
    pub const GO_PACKAGE_FIELD_NUMBER: i32 = 11;
    pub const GO_PACKAGE_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'cc_generic_services' field
    pub const CC_GENERIC_SERVICES_FIELD_NUMBER: i32 = 16;
    pub const CC_GENERIC_SERVICES_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'java_generic_services' field
    pub const JAVA_GENERIC_SERVICES_FIELD_NUMBER: i32 = 17;
    pub const JAVA_GENERIC_SERVICES_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'py_generic_services' field
    pub const PY_GENERIC_SERVICES_FIELD_NUMBER: i32 = 18;
    pub const PY_GENERIC_SERVICES_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'php_generic_services' field
    pub const PHP_GENERIC_SERVICES_FIELD_NUMBER: i32 = 42;
    pub const PHP_GENERIC_SERVICES_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'deprecated' field
    pub const DEPRECATED_FIELD_NUMBER: i32 = 23;
    pub const DEPRECATED_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'cc_enable_arenas' field
    pub const CC_ENABLE_ARENAS_FIELD_NUMBER: i32 = 31;
    pub const CC_ENABLE_ARENAS_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'objc_class_prefix' field
    pub const OBJC_CLASS_PREFIX_FIELD_NUMBER: i32 = 36;
    pub const OBJC_CLASS_PREFIX_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'csharp_namespace' field
    pub const CSHARP_NAMESPACE_FIELD_NUMBER: i32 = 37;
    pub const CSHARP_NAMESPACE_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'swift_prefix' field
    pub const SWIFT_PREFIX_FIELD_NUMBER: i32 = 39;
    pub const SWIFT_PREFIX_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'php_class_prefix' field
    pub const PHP_CLASS_PREFIX_FIELD_NUMBER: i32 = 40;
    pub const PHP_CLASS_PREFIX_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'php_namespace' field
    pub const PHP_NAMESPACE_FIELD_NUMBER: i32 = 41;
    pub const PHP_NAMESPACE_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'php_metadata_namespace' field
    pub const PHP_METADATA_NAMESPACE_FIELD_NUMBER: i32 = 44;
    pub const PHP_METADATA_NAMESPACE_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'ruby_package' field
    pub const RUBY_PACKAGE_FIELD_NUMBER: i32 = 45;
    pub const RUBY_PACKAGE_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'uninterpreted_option' field
    pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
}
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum FileOptions_OptimizeMode {
    Speed = 1,
    CodeSize = 2,
    LiteRuntime = 3,
}
impl std::convert::TryFrom<i32> for self::FileOptions_OptimizeMode {
    type Error = crate::VariantUndefinedError;
    
    fn try_from(value: i32) -> std::result::Result<Self, crate::VariantUndefinedError> {
        match value {
            1 => std::result::Result::Ok(self::FileOptions_OptimizeMode::Speed),
            2 => std::result::Result::Ok(self::FileOptions_OptimizeMode::CodeSize),
            3 => std::result::Result::Ok(self::FileOptions_OptimizeMode::LiteRuntime),
            _ => std::result::Result::Err(crate::VariantUndefinedError)
        }
    }
}
impl std::convert::From<self::FileOptions_OptimizeMode> for i32 {
    fn from(value: self::FileOptions_OptimizeMode) -> i32 {
        value as i32
    }
}
#[derive(Debug, PartialEq)]
pub struct MessageOptions {
    pub message_set_wire_format: std::option::Option<bool>,
    pub no_standard_descriptor_accessor: std::option::Option<bool>,
    pub deprecated: std::option::Option<bool>,
    pub map_entry: std::option::Option<bool>,
    pub uninterpreted_option: crate::collections::RepeatedField<std::boxed::Box<self::UninterpretedOption>>,
    unknown_fields: crate::UnknownFieldSet
}
static MESSAGE_OPTIONS_UNINTERPRETED_OPTION_CODEC: crate::Codec<std::boxed::Box<self::UninterpretedOption>> = crate::Codec::message(7994);
impl crate::CodedMessage for self::MessageOptions {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 => self.message_set_wire_format = std::option::Option::Some(input.read_bool()?),
                16 => self.no_standard_descriptor_accessor = std::option::Option::Some(input.read_bool()?),
                24 => self.deprecated = std::option::Option::Some(input.read_bool()?),
                56 => self.map_entry = std::option::Option::Some(input.read_bool()?),
                7994 => self.uninterpreted_option.add_entries(tag.get(), input, &MESSAGE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> std::option::Option<i32> {
        let mut size = 0i32;
        let message_set_wire_format = self.message_set_wire_format;
        if let std::option::Option::Some(message_set_wire_format) = message_set_wire_format {
            if message_set_wire_format != Self::MESSAGE_SET_WIRE_FORMAT_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(message_set_wire_format))?;
            }
        }
        let no_standard_descriptor_accessor = self.no_standard_descriptor_accessor;
        if let std::option::Option::Some(no_standard_descriptor_accessor) = no_standard_descriptor_accessor {
            if no_standard_descriptor_accessor != Self::NO_STANDARD_DESCRIPTOR_ACCESSOR_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(no_standard_descriptor_accessor))?;
            }
        }
        let deprecated = self.deprecated;
        if let std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(deprecated))?;
            }
        }
        let map_entry = self.map_entry;
        if let std::option::Option::Some(map_entry) = map_entry {
            if map_entry != Self::MAP_ENTRY_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(map_entry))?;
            }
        }
        size = size.checked_add(self.uninterpreted_option.calculate_size(&MESSAGE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?)?;
        size = size.checked_add(self.unknown_fields.calculate_size()?)?;
        std::option::Option::Some(size)
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let message_set_wire_format = self.message_set_wire_format;
        if let std::option::Option::Some(message_set_wire_format) = message_set_wire_format {
            if message_set_wire_format != Self::MESSAGE_SET_WIRE_FORMAT_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_bool(message_set_wire_format)?;
            }
        }
        let no_standard_descriptor_accessor = self.no_standard_descriptor_accessor;
        if let std::option::Option::Some(no_standard_descriptor_accessor) = no_standard_descriptor_accessor {
            if no_standard_descriptor_accessor != Self::NO_STANDARD_DESCRIPTOR_ACCESSOR_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_bool(no_standard_descriptor_accessor)?;
            }
        }
        let deprecated = self.deprecated;
        if let std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[24])?;
                output.write_bool(deprecated)?;
            }
        }
        let map_entry = self.map_entry;
        if let std::option::Option::Some(map_entry) = map_entry {
            if map_entry != Self::MAP_ENTRY_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[56])?;
                output.write_bool(map_entry)?;
            }
        }
        self.uninterpreted_option.write_to(output, &MESSAGE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::MessageOptions {
    fn new() -> Self {
        Self {
            message_set_wire_format: std::option::Option::None,
            no_standard_descriptor_accessor: std::option::Option::None,
            deprecated: std::option::Option::None,
            map_entry: std::option::Option::None,
            uninterpreted_option: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl std::clone::Clone for self::MessageOptions {
    fn clone(&self) -> Self {
        Self {
            message_set_wire_format: self.message_set_wire_format.clone(),
            no_standard_descriptor_accessor: self.no_standard_descriptor_accessor.clone(),
            deprecated: self.deprecated.clone(),
            map_entry: self.map_entry.clone(),
            uninterpreted_option: self.uninterpreted_option.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.message_set_wire_format = other.message_set_wire_format;
        self.no_standard_descriptor_accessor = other.no_standard_descriptor_accessor;
        self.deprecated = other.deprecated;
        self.map_entry = other.map_entry;
        self.uninterpreted_option.clone_from(&other.uninterpreted_option);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::MessageOptions {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        unimplemented!()
    }
}
impl self::MessageOptions {
    /// Gets the field number of the 'message_set_wire_format' field
    pub const MESSAGE_SET_WIRE_FORMAT_FIELD_NUMBER: i32 = 1;
    pub const MESSAGE_SET_WIRE_FORMAT_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'no_standard_descriptor_accessor' field
    pub const NO_STANDARD_DESCRIPTOR_ACCESSOR_FIELD_NUMBER: i32 = 2;
    pub const NO_STANDARD_DESCRIPTOR_ACCESSOR_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'deprecated' field
    pub const DEPRECATED_FIELD_NUMBER: i32 = 3;
    pub const DEPRECATED_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'map_entry' field
    pub const MAP_ENTRY_FIELD_NUMBER: i32 = 7;
    pub const MAP_ENTRY_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'uninterpreted_option' field
    pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
}
#[derive(Debug, PartialEq)]
pub struct FieldOptions {
    pub ctype: std::option::Option<crate::EnumValue<self::FieldOptions_CType>>,
    pub packed: std::option::Option<bool>,
    pub jstype: std::option::Option<crate::EnumValue<self::FieldOptions_JSType>>,
    pub lazy: std::option::Option<bool>,
    pub deprecated: std::option::Option<bool>,
    pub weak: std::option::Option<bool>,
    pub uninterpreted_option: crate::collections::RepeatedField<std::boxed::Box<self::UninterpretedOption>>,
    unknown_fields: crate::UnknownFieldSet
}
static FIELD_OPTIONS_UNINTERPRETED_OPTION_CODEC: crate::Codec<std::boxed::Box<self::UninterpretedOption>> = crate::Codec::message(7994);
impl crate::CodedMessage for self::FieldOptions {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 => self.ctype = std::option::Option::Some(input.read_enum_value()?),
                16 => self.packed = std::option::Option::Some(input.read_bool()?),
                48 => self.jstype = std::option::Option::Some(input.read_enum_value()?),
                40 => self.lazy = std::option::Option::Some(input.read_bool()?),
                24 => self.deprecated = std::option::Option::Some(input.read_bool()?),
                80 => self.weak = std::option::Option::Some(input.read_bool()?),
                7994 => self.uninterpreted_option.add_entries(tag.get(), input, &FIELD_OPTIONS_UNINTERPRETED_OPTION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> std::option::Option<i32> {
        let mut size = 0i32;
        let ctype = self.ctype;
        if let std::option::Option::Some(ctype) = ctype {
            if ctype != Self::CTYPE_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::enum_value(ctype))?;
            }
        }
        let packed = self.packed;
        if let std::option::Option::Some(packed) = packed {
            if packed != Self::PACKED_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(packed))?;
            }
        }
        let jstype = self.jstype;
        if let std::option::Option::Some(jstype) = jstype {
            if jstype != Self::JSTYPE_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::enum_value(jstype))?;
            }
        }
        let lazy = self.lazy;
        if let std::option::Option::Some(lazy) = lazy {
            if lazy != Self::LAZY_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(lazy))?;
            }
        }
        let deprecated = self.deprecated;
        if let std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(deprecated))?;
            }
        }
        let weak = self.weak;
        if let std::option::Option::Some(weak) = weak {
            if weak != Self::WEAK_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(weak))?;
            }
        }
        size = size.checked_add(self.uninterpreted_option.calculate_size(&FIELD_OPTIONS_UNINTERPRETED_OPTION_CODEC)?)?;
        size = size.checked_add(self.unknown_fields.calculate_size()?)?;
        std::option::Option::Some(size)
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let ctype = self.ctype;
        if let std::option::Option::Some(ctype) = ctype {
            if ctype != Self::CTYPE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_enum_value(ctype)?;
            }
        }
        let packed = self.packed;
        if let std::option::Option::Some(packed) = packed {
            if packed != Self::PACKED_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_bool(packed)?;
            }
        }
        let jstype = self.jstype;
        if let std::option::Option::Some(jstype) = jstype {
            if jstype != Self::JSTYPE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[48])?;
                output.write_enum_value(jstype)?;
            }
        }
        let lazy = self.lazy;
        if let std::option::Option::Some(lazy) = lazy {
            if lazy != Self::LAZY_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[40])?;
                output.write_bool(lazy)?;
            }
        }
        let deprecated = self.deprecated;
        if let std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[24])?;
                output.write_bool(deprecated)?;
            }
        }
        let weak = self.weak;
        if let std::option::Option::Some(weak) = weak {
            if weak != Self::WEAK_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[80])?;
                output.write_bool(weak)?;
            }
        }
        self.uninterpreted_option.write_to(output, &FIELD_OPTIONS_UNINTERPRETED_OPTION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::FieldOptions {
    fn new() -> Self {
        Self {
            ctype: std::option::Option::None,
            packed: std::option::Option::None,
            jstype: std::option::Option::None,
            lazy: std::option::Option::None,
            deprecated: std::option::Option::None,
            weak: std::option::Option::None,
            uninterpreted_option: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl std::clone::Clone for self::FieldOptions {
    fn clone(&self) -> Self {
        Self {
            ctype: self.ctype.clone(),
            packed: self.packed.clone(),
            jstype: self.jstype.clone(),
            lazy: self.lazy.clone(),
            deprecated: self.deprecated.clone(),
            weak: self.weak.clone(),
            uninterpreted_option: self.uninterpreted_option.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.ctype = other.ctype;
        self.packed = other.packed;
        self.jstype = other.jstype;
        self.lazy = other.lazy;
        self.deprecated = other.deprecated;
        self.weak = other.weak;
        self.uninterpreted_option.clone_from(&other.uninterpreted_option);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::FieldOptions {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        unimplemented!()
    }
}
impl self::FieldOptions {
    /// Gets the field number of the 'ctype' field
    pub const CTYPE_FIELD_NUMBER: i32 = 1;
    pub const CTYPE_DEFAULT_VALUE: crate::EnumValue<self::FieldOptions_CType> = crate::EnumValue::Defined(self::FieldOptions_CType::String);
    /// Gets the field number of the 'packed' field
    pub const PACKED_FIELD_NUMBER: i32 = 2;
    pub const PACKED_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'jstype' field
    pub const JSTYPE_FIELD_NUMBER: i32 = 6;
    pub const JSTYPE_DEFAULT_VALUE: crate::EnumValue<self::FieldOptions_JSType> = crate::EnumValue::Defined(self::FieldOptions_JSType::Normal);
    /// Gets the field number of the 'lazy' field
    pub const LAZY_FIELD_NUMBER: i32 = 5;
    pub const LAZY_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'deprecated' field
    pub const DEPRECATED_FIELD_NUMBER: i32 = 3;
    pub const DEPRECATED_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'weak' field
    pub const WEAK_FIELD_NUMBER: i32 = 10;
    pub const WEAK_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'uninterpreted_option' field
    pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
}
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum FieldOptions_CType {
    String = 0,
    Ord = 1,
    StringPiece = 2,
}
impl std::convert::TryFrom<i32> for self::FieldOptions_CType {
    type Error = crate::VariantUndefinedError;
    
    fn try_from(value: i32) -> std::result::Result<Self, crate::VariantUndefinedError> {
        match value {
            0 => std::result::Result::Ok(self::FieldOptions_CType::String),
            1 => std::result::Result::Ok(self::FieldOptions_CType::Ord),
            2 => std::result::Result::Ok(self::FieldOptions_CType::StringPiece),
            _ => std::result::Result::Err(crate::VariantUndefinedError)
        }
    }
}
impl std::convert::From<self::FieldOptions_CType> for i32 {
    fn from(value: self::FieldOptions_CType) -> i32 {
        value as i32
    }
}
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum FieldOptions_JSType {
    Normal = 0,
    String = 1,
    Number = 2,
}
impl std::convert::TryFrom<i32> for self::FieldOptions_JSType {
    type Error = crate::VariantUndefinedError;
    
    fn try_from(value: i32) -> std::result::Result<Self, crate::VariantUndefinedError> {
        match value {
            0 => std::result::Result::Ok(self::FieldOptions_JSType::Normal),
            1 => std::result::Result::Ok(self::FieldOptions_JSType::String),
            2 => std::result::Result::Ok(self::FieldOptions_JSType::Number),
            _ => std::result::Result::Err(crate::VariantUndefinedError)
        }
    }
}
impl std::convert::From<self::FieldOptions_JSType> for i32 {
    fn from(value: self::FieldOptions_JSType) -> i32 {
        value as i32
    }
}
#[derive(Debug, PartialEq)]
pub struct OneofOptions {
    pub uninterpreted_option: crate::collections::RepeatedField<std::boxed::Box<self::UninterpretedOption>>,
    unknown_fields: crate::UnknownFieldSet
}
static ONEOF_OPTIONS_UNINTERPRETED_OPTION_CODEC: crate::Codec<std::boxed::Box<self::UninterpretedOption>> = crate::Codec::message(7994);
impl crate::CodedMessage for self::OneofOptions {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                7994 => self.uninterpreted_option.add_entries(tag.get(), input, &ONEOF_OPTIONS_UNINTERPRETED_OPTION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> std::option::Option<i32> {
        let mut size = 0i32;
        size = size.checked_add(self.uninterpreted_option.calculate_size(&ONEOF_OPTIONS_UNINTERPRETED_OPTION_CODEC)?)?;
        size = size.checked_add(self.unknown_fields.calculate_size()?)?;
        std::option::Option::Some(size)
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        self.uninterpreted_option.write_to(output, &ONEOF_OPTIONS_UNINTERPRETED_OPTION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::OneofOptions {
    fn new() -> Self {
        Self {
            uninterpreted_option: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl std::clone::Clone for self::OneofOptions {
    fn clone(&self) -> Self {
        Self {
            uninterpreted_option: self.uninterpreted_option.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.uninterpreted_option.clone_from(&other.uninterpreted_option);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::OneofOptions {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        unimplemented!()
    }
}
impl self::OneofOptions {
    /// Gets the field number of the 'uninterpreted_option' field
    pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
}
#[derive(Debug, PartialEq)]
pub struct EnumOptions {
    pub allow_alias: std::option::Option<bool>,
    pub deprecated: std::option::Option<bool>,
    pub uninterpreted_option: crate::collections::RepeatedField<std::boxed::Box<self::UninterpretedOption>>,
    unknown_fields: crate::UnknownFieldSet
}
static ENUM_OPTIONS_UNINTERPRETED_OPTION_CODEC: crate::Codec<std::boxed::Box<self::UninterpretedOption>> = crate::Codec::message(7994);
impl crate::CodedMessage for self::EnumOptions {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                16 => self.allow_alias = std::option::Option::Some(input.read_bool()?),
                24 => self.deprecated = std::option::Option::Some(input.read_bool()?),
                7994 => self.uninterpreted_option.add_entries(tag.get(), input, &ENUM_OPTIONS_UNINTERPRETED_OPTION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> std::option::Option<i32> {
        let mut size = 0i32;
        let allow_alias = self.allow_alias;
        if let std::option::Option::Some(allow_alias) = allow_alias {
            if allow_alias != Self::ALLOW_ALIAS_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(allow_alias))?;
            }
        }
        let deprecated = self.deprecated;
        if let std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(deprecated))?;
            }
        }
        size = size.checked_add(self.uninterpreted_option.calculate_size(&ENUM_OPTIONS_UNINTERPRETED_OPTION_CODEC)?)?;
        size = size.checked_add(self.unknown_fields.calculate_size()?)?;
        std::option::Option::Some(size)
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let allow_alias = self.allow_alias;
        if let std::option::Option::Some(allow_alias) = allow_alias {
            if allow_alias != Self::ALLOW_ALIAS_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_bool(allow_alias)?;
            }
        }
        let deprecated = self.deprecated;
        if let std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[24])?;
                output.write_bool(deprecated)?;
            }
        }
        self.uninterpreted_option.write_to(output, &ENUM_OPTIONS_UNINTERPRETED_OPTION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::EnumOptions {
    fn new() -> Self {
        Self {
            allow_alias: std::option::Option::None,
            deprecated: std::option::Option::None,
            uninterpreted_option: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl std::clone::Clone for self::EnumOptions {
    fn clone(&self) -> Self {
        Self {
            allow_alias: self.allow_alias.clone(),
            deprecated: self.deprecated.clone(),
            uninterpreted_option: self.uninterpreted_option.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.allow_alias = other.allow_alias;
        self.deprecated = other.deprecated;
        self.uninterpreted_option.clone_from(&other.uninterpreted_option);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::EnumOptions {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        unimplemented!()
    }
}
impl self::EnumOptions {
    /// Gets the field number of the 'allow_alias' field
    pub const ALLOW_ALIAS_FIELD_NUMBER: i32 = 2;
    pub const ALLOW_ALIAS_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'deprecated' field
    pub const DEPRECATED_FIELD_NUMBER: i32 = 3;
    pub const DEPRECATED_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'uninterpreted_option' field
    pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
}
#[derive(Debug, PartialEq)]
pub struct EnumValueOptions {
    pub deprecated: std::option::Option<bool>,
    pub uninterpreted_option: crate::collections::RepeatedField<std::boxed::Box<self::UninterpretedOption>>,
    unknown_fields: crate::UnknownFieldSet
}
static ENUM_VALUE_OPTIONS_UNINTERPRETED_OPTION_CODEC: crate::Codec<std::boxed::Box<self::UninterpretedOption>> = crate::Codec::message(7994);
impl crate::CodedMessage for self::EnumValueOptions {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 => self.deprecated = std::option::Option::Some(input.read_bool()?),
                7994 => self.uninterpreted_option.add_entries(tag.get(), input, &ENUM_VALUE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> std::option::Option<i32> {
        let mut size = 0i32;
        let deprecated = self.deprecated;
        if let std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(deprecated))?;
            }
        }
        size = size.checked_add(self.uninterpreted_option.calculate_size(&ENUM_VALUE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?)?;
        size = size.checked_add(self.unknown_fields.calculate_size()?)?;
        std::option::Option::Some(size)
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let deprecated = self.deprecated;
        if let std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_bool(deprecated)?;
            }
        }
        self.uninterpreted_option.write_to(output, &ENUM_VALUE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::EnumValueOptions {
    fn new() -> Self {
        Self {
            deprecated: std::option::Option::None,
            uninterpreted_option: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl std::clone::Clone for self::EnumValueOptions {
    fn clone(&self) -> Self {
        Self {
            deprecated: self.deprecated.clone(),
            uninterpreted_option: self.uninterpreted_option.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.deprecated = other.deprecated;
        self.uninterpreted_option.clone_from(&other.uninterpreted_option);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::EnumValueOptions {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        unimplemented!()
    }
}
impl self::EnumValueOptions {
    /// Gets the field number of the 'deprecated' field
    pub const DEPRECATED_FIELD_NUMBER: i32 = 1;
    pub const DEPRECATED_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'uninterpreted_option' field
    pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
}
#[derive(Debug, PartialEq)]
pub struct ServiceOptions {
    pub deprecated: std::option::Option<bool>,
    pub uninterpreted_option: crate::collections::RepeatedField<std::boxed::Box<self::UninterpretedOption>>,
    unknown_fields: crate::UnknownFieldSet
}
static SERVICE_OPTIONS_UNINTERPRETED_OPTION_CODEC: crate::Codec<std::boxed::Box<self::UninterpretedOption>> = crate::Codec::message(7994);
impl crate::CodedMessage for self::ServiceOptions {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                264 => self.deprecated = std::option::Option::Some(input.read_bool()?),
                7994 => self.uninterpreted_option.add_entries(tag.get(), input, &SERVICE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> std::option::Option<i32> {
        let mut size = 0i32;
        let deprecated = self.deprecated;
        if let std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::bool(deprecated))?;
            }
        }
        size = size.checked_add(self.uninterpreted_option.calculate_size(&SERVICE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?)?;
        size = size.checked_add(self.unknown_fields.calculate_size()?)?;
        std::option::Option::Some(size)
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let deprecated = self.deprecated;
        if let std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[136, 2])?;
                output.write_bool(deprecated)?;
            }
        }
        self.uninterpreted_option.write_to(output, &SERVICE_OPTIONS_UNINTERPRETED_OPTION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::ServiceOptions {
    fn new() -> Self {
        Self {
            deprecated: std::option::Option::None,
            uninterpreted_option: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl std::clone::Clone for self::ServiceOptions {
    fn clone(&self) -> Self {
        Self {
            deprecated: self.deprecated.clone(),
            uninterpreted_option: self.uninterpreted_option.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.deprecated = other.deprecated;
        self.uninterpreted_option.clone_from(&other.uninterpreted_option);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::ServiceOptions {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        unimplemented!()
    }
}
impl self::ServiceOptions {
    /// Gets the field number of the 'deprecated' field
    pub const DEPRECATED_FIELD_NUMBER: i32 = 33;
    pub const DEPRECATED_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'uninterpreted_option' field
    pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
}
#[derive(Debug, PartialEq)]
pub struct MethodOptions {
    pub deprecated: std::option::Option<bool>,
    pub idempotency_level: std::option::Option<crate::EnumValue<self::MethodOptions_IdempotencyLevel>>,
    pub uninterpreted_option: crate::collections::RepeatedField<std::boxed::Box<self::UninterpretedOption>>,
    unknown_fields: crate::UnknownFieldSet
}
static METHOD_OPTIONS_UNINTERPRETED_OPTION_CODEC: crate::Codec<std::boxed::Box<self::UninterpretedOption>> = crate::Codec::message(7994);
impl crate::CodedMessage for self::MethodOptions {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                264 => self.deprecated = std::option::Option::Some(input.read_bool()?),
                272 => self.idempotency_level = std::option::Option::Some(input.read_enum_value()?),
                7994 => self.uninterpreted_option.add_entries(tag.get(), input, &METHOD_OPTIONS_UNINTERPRETED_OPTION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> std::option::Option<i32> {
        let mut size = 0i32;
        let deprecated = self.deprecated;
        if let std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::bool(deprecated))?;
            }
        }
        let idempotency_level = self.idempotency_level;
        if let std::option::Option::Some(idempotency_level) = idempotency_level {
            if idempotency_level != Self::IDEMPOTENCY_LEVEL_DEFAULT_VALUE {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::enum_value(idempotency_level))?;
            }
        }
        size = size.checked_add(self.uninterpreted_option.calculate_size(&METHOD_OPTIONS_UNINTERPRETED_OPTION_CODEC)?)?;
        size = size.checked_add(self.unknown_fields.calculate_size()?)?;
        std::option::Option::Some(size)
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let deprecated = self.deprecated;
        if let std::option::Option::Some(deprecated) = deprecated {
            if deprecated != Self::DEPRECATED_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[136, 2])?;
                output.write_bool(deprecated)?;
            }
        }
        let idempotency_level = self.idempotency_level;
        if let std::option::Option::Some(idempotency_level) = idempotency_level {
            if idempotency_level != Self::IDEMPOTENCY_LEVEL_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[144, 2])?;
                output.write_enum_value(idempotency_level)?;
            }
        }
        self.uninterpreted_option.write_to(output, &METHOD_OPTIONS_UNINTERPRETED_OPTION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::MethodOptions {
    fn new() -> Self {
        Self {
            deprecated: std::option::Option::None,
            idempotency_level: std::option::Option::None,
            uninterpreted_option: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl std::clone::Clone for self::MethodOptions {
    fn clone(&self) -> Self {
        Self {
            deprecated: self.deprecated.clone(),
            idempotency_level: self.idempotency_level.clone(),
            uninterpreted_option: self.uninterpreted_option.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.deprecated = other.deprecated;
        self.idempotency_level = other.idempotency_level;
        self.uninterpreted_option.clone_from(&other.uninterpreted_option);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::MethodOptions {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        unimplemented!()
    }
}
impl self::MethodOptions {
    /// Gets the field number of the 'deprecated' field
    pub const DEPRECATED_FIELD_NUMBER: i32 = 33;
    pub const DEPRECATED_DEFAULT_VALUE: bool = false;
    /// Gets the field number of the 'idempotency_level' field
    pub const IDEMPOTENCY_LEVEL_FIELD_NUMBER: i32 = 34;
    pub const IDEMPOTENCY_LEVEL_DEFAULT_VALUE: crate::EnumValue<self::MethodOptions_IdempotencyLevel> = crate::EnumValue::Defined(self::MethodOptions_IdempotencyLevel::Unknown);
    /// Gets the field number of the 'uninterpreted_option' field
    pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
}
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum MethodOptions_IdempotencyLevel {
    Unknown = 0,
    NoSideEffects = 1,
    T = 2,
}
impl std::convert::TryFrom<i32> for self::MethodOptions_IdempotencyLevel {
    type Error = crate::VariantUndefinedError;
    
    fn try_from(value: i32) -> std::result::Result<Self, crate::VariantUndefinedError> {
        match value {
            0 => std::result::Result::Ok(self::MethodOptions_IdempotencyLevel::Unknown),
            1 => std::result::Result::Ok(self::MethodOptions_IdempotencyLevel::NoSideEffects),
            2 => std::result::Result::Ok(self::MethodOptions_IdempotencyLevel::T),
            _ => std::result::Result::Err(crate::VariantUndefinedError)
        }
    }
}
impl std::convert::From<self::MethodOptions_IdempotencyLevel> for i32 {
    fn from(value: self::MethodOptions_IdempotencyLevel) -> i32 {
        value as i32
    }
}
#[derive(Debug, PartialEq)]
pub struct UninterpretedOption {
    pub name: crate::collections::RepeatedField<std::boxed::Box<self::UninterpretedOption_NamePart>>,
    pub identifier_value: std::option::Option<std::string::String>,
    pub positive_int_value: std::option::Option<u64>,
    pub negative_int_value: std::option::Option<i64>,
    pub double_value: std::option::Option<f64>,
    pub string_value: std::option::Option<std::vec::Vec<u8>>,
    pub aggregate_value: std::option::Option<std::string::String>,
    unknown_fields: crate::UnknownFieldSet
}
static UNINTERPRETED_OPTION_NAME_CODEC: crate::Codec<std::boxed::Box<self::UninterpretedOption_NamePart>> = crate::Codec::message(18);
impl crate::CodedMessage for self::UninterpretedOption {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                18 => self.name.add_entries(tag.get(), input, &UNINTERPRETED_OPTION_NAME_CODEC)?,
                26 => self.identifier_value = std::option::Option::Some(input.read_string()?),
                32 => self.positive_int_value = std::option::Option::Some(input.read_uint64()?),
                40 => self.negative_int_value = std::option::Option::Some(input.read_int64()?),
                49 => self.double_value = std::option::Option::Some(input.read_double()?),
                58 => self.string_value = std::option::Option::Some(input.read_bytes()?),
                66 => self.aggregate_value = std::option::Option::Some(input.read_string()?),
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> std::option::Option<i32> {
        let mut size = 0i32;
        size = size.checked_add(self.name.calculate_size(&UNINTERPRETED_OPTION_NAME_CODEC)?)?;
        let identifier_value = &self.identifier_value;
        if let std::option::Option::Some(identifier_value) = identifier_value {
            if identifier_value != Self::IDENTIFIER_VALUE_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(identifier_value)?)?;
            }
        }
        let positive_int_value = self.positive_int_value;
        if let std::option::Option::Some(positive_int_value) = positive_int_value {
            if positive_int_value != Self::POSITIVE_INT_VALUE_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::uint64(positive_int_value))?;
            }
        }
        let negative_int_value = self.negative_int_value;
        if let std::option::Option::Some(negative_int_value) = negative_int_value {
            if negative_int_value != Self::NEGATIVE_INT_VALUE_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::int64(negative_int_value))?;
            }
        }
        let double_value = self.double_value;
        if let std::option::Option::Some(double_value) = double_value {
            if double_value != Self::DOUBLE_VALUE_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::double(double_value))?;
            }
        }
        let string_value = &self.string_value;
        if let std::option::Option::Some(string_value) = string_value {
            if string_value.as_slice() != Self::STRING_VALUE_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bytes(string_value)?)?;
            }
        }
        let aggregate_value = &self.aggregate_value;
        if let std::option::Option::Some(aggregate_value) = aggregate_value {
            if aggregate_value != Self::AGGREGATE_VALUE_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(aggregate_value)?)?;
            }
        }
        size = size.checked_add(self.unknown_fields.calculate_size()?)?;
        std::option::Option::Some(size)
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        self.name.write_to(output, &UNINTERPRETED_OPTION_NAME_CODEC)?;
        let identifier_value = &self.identifier_value;
        if let std::option::Option::Some(identifier_value) = identifier_value {
            if identifier_value != Self::IDENTIFIER_VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[26])?;
                output.write_string(identifier_value)?;
            }
        }
        let positive_int_value = self.positive_int_value;
        if let std::option::Option::Some(positive_int_value) = positive_int_value {
            if positive_int_value != Self::POSITIVE_INT_VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[32])?;
                output.write_uint64(positive_int_value)?;
            }
        }
        let negative_int_value = self.negative_int_value;
        if let std::option::Option::Some(negative_int_value) = negative_int_value {
            if negative_int_value != Self::NEGATIVE_INT_VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[40])?;
                output.write_int64(negative_int_value)?;
            }
        }
        let double_value = self.double_value;
        if let std::option::Option::Some(double_value) = double_value {
            if double_value != Self::DOUBLE_VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[49])?;
                output.write_double(double_value)?;
            }
        }
        let string_value = &self.string_value;
        if let std::option::Option::Some(string_value) = string_value {
            if string_value.as_slice() != Self::STRING_VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[58])?;
                output.write_bytes(string_value)?;
            }
        }
        let aggregate_value = &self.aggregate_value;
        if let std::option::Option::Some(aggregate_value) = aggregate_value {
            if aggregate_value != Self::AGGREGATE_VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[66])?;
                output.write_string(aggregate_value)?;
            }
        }
        self.unknown_fields.write_to(output)?;
        std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::UninterpretedOption {
    fn new() -> Self {
        Self {
            name: crate::collections::RepeatedField::new(),
            identifier_value: std::option::Option::None,
            positive_int_value: std::option::Option::None,
            negative_int_value: std::option::Option::None,
            double_value: std::option::Option::None,
            string_value: std::option::Option::None,
            aggregate_value: std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl std::clone::Clone for self::UninterpretedOption {
    fn clone(&self) -> Self {
        Self {
            name: self.name.clone(),
            identifier_value: self.identifier_value.clone(),
            positive_int_value: self.positive_int_value.clone(),
            negative_int_value: self.negative_int_value.clone(),
            double_value: self.double_value.clone(),
            string_value: self.string_value.clone(),
            aggregate_value: self.aggregate_value.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.name.clone_from(&other.name);
        self.identifier_value = other.identifier_value.clone();
        self.positive_int_value = other.positive_int_value;
        self.negative_int_value = other.negative_int_value;
        self.double_value = other.double_value;
        self.string_value = other.string_value.clone();
        self.aggregate_value = other.aggregate_value.clone();
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::UninterpretedOption {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        unimplemented!()
    }
}
impl self::UninterpretedOption {
    /// Gets the field number of the 'name' field
    pub const NAME_FIELD_NUMBER: i32 = 2;
    /// Gets the field number of the 'identifier_value' field
    pub const IDENTIFIER_VALUE_FIELD_NUMBER: i32 = 3;
    pub const IDENTIFIER_VALUE_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'positive_int_value' field
    pub const POSITIVE_INT_VALUE_FIELD_NUMBER: i32 = 4;
    pub const POSITIVE_INT_VALUE_DEFAULT_VALUE: u64 = 0;
    /// Gets the field number of the 'negative_int_value' field
    pub const NEGATIVE_INT_VALUE_FIELD_NUMBER: i32 = 5;
    pub const NEGATIVE_INT_VALUE_DEFAULT_VALUE: i64 = 0;
    /// Gets the field number of the 'double_value' field
    pub const DOUBLE_VALUE_FIELD_NUMBER: i32 = 6;
    pub const DOUBLE_VALUE_DEFAULT_VALUE: f64 = 0.0;
    /// Gets the field number of the 'string_value' field
    pub const STRING_VALUE_FIELD_NUMBER: i32 = 7;
    pub const STRING_VALUE_DEFAULT_VALUE: &'static [u8] = &[];
    /// Gets the field number of the 'aggregate_value' field
    pub const AGGREGATE_VALUE_FIELD_NUMBER: i32 = 8;
    pub const AGGREGATE_VALUE_DEFAULT_VALUE: &'static str = "";
}
#[derive(Debug, PartialEq)]
pub struct UninterpretedOption_NamePart {
    pub name_part: std::option::Option<std::string::String>,
    pub is_extension: std::option::Option<bool>,
    unknown_fields: crate::UnknownFieldSet
}
impl crate::CodedMessage for self::UninterpretedOption_NamePart {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.name_part = std::option::Option::Some(input.read_string()?),
                16 => self.is_extension = std::option::Option::Some(input.read_bool()?),
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> std::option::Option<i32> {
        let mut size = 0i32;
        let name_part = &self.name_part;
        if let std::option::Option::Some(name_part) = name_part {
            if name_part != Self::NAME_PART_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(name_part)?)?;
            }
        }
        let is_extension = self.is_extension;
        if let std::option::Option::Some(is_extension) = is_extension {
            if is_extension != Self::IS_EXTENSION_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(is_extension))?;
            }
        }
        size = size.checked_add(self.unknown_fields.calculate_size()?)?;
        std::option::Option::Some(size)
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        let name_part = &self.name_part;
        if let std::option::Option::Some(name_part) = name_part {
            if name_part != Self::NAME_PART_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name_part)?;
            }
        }
        let is_extension = self.is_extension;
        if let std::option::Option::Some(is_extension) = is_extension {
            if is_extension != Self::IS_EXTENSION_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_bool(is_extension)?;
            }
        }
        self.unknown_fields.write_to(output)?;
        std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::UninterpretedOption_NamePart {
    fn new() -> Self {
        Self {
            name_part: std::option::Option::None,
            is_extension: std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl std::clone::Clone for self::UninterpretedOption_NamePart {
    fn clone(&self) -> Self {
        Self {
            name_part: self.name_part.clone(),
            is_extension: self.is_extension.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.name_part = other.name_part.clone();
        self.is_extension = other.is_extension;
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::UninterpretedOption_NamePart {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        unimplemented!()
    }
}
impl self::UninterpretedOption_NamePart {
    /// Gets the field number of the 'name_part' field
    pub const NAME_PART_FIELD_NUMBER: i32 = 1;
    pub const NAME_PART_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'is_extension' field
    pub const IS_EXTENSION_FIELD_NUMBER: i32 = 2;
    pub const IS_EXTENSION_DEFAULT_VALUE: bool = false;
}
#[derive(Debug, PartialEq)]
pub struct SourceCodeInfo {
    pub location: crate::collections::RepeatedField<std::boxed::Box<self::SourceCodeInfo_Location>>,
    unknown_fields: crate::UnknownFieldSet
}
static SOURCE_CODE_INFO_LOCATION_CODEC: crate::Codec<std::boxed::Box<self::SourceCodeInfo_Location>> = crate::Codec::message(10);
impl crate::CodedMessage for self::SourceCodeInfo {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.location.add_entries(tag.get(), input, &SOURCE_CODE_INFO_LOCATION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> std::option::Option<i32> {
        let mut size = 0i32;
        size = size.checked_add(self.location.calculate_size(&SOURCE_CODE_INFO_LOCATION_CODEC)?)?;
        size = size.checked_add(self.unknown_fields.calculate_size()?)?;
        std::option::Option::Some(size)
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        self.location.write_to(output, &SOURCE_CODE_INFO_LOCATION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::SourceCodeInfo {
    fn new() -> Self {
        Self {
            location: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl std::clone::Clone for self::SourceCodeInfo {
    fn clone(&self) -> Self {
        Self {
            location: self.location.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.location.clone_from(&other.location);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::SourceCodeInfo {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        unimplemented!()
    }
}
impl self::SourceCodeInfo {
    /// Gets the field number of the 'location' field
    pub const LOCATION_FIELD_NUMBER: i32 = 1;
}
#[derive(Debug, PartialEq)]
pub struct SourceCodeInfo_Location {
    pub path: crate::collections::RepeatedField<i32>,
    pub span: crate::collections::RepeatedField<i32>,
    pub leading_comments: std::option::Option<std::string::String>,
    pub trailing_comments: std::option::Option<std::string::String>,
    pub leading_detached_comments: crate::collections::RepeatedField<std::string::String>,
    unknown_fields: crate::UnknownFieldSet
}
static SOURCE_CODE_INFO__LOCATION_PATH_CODEC: crate::Codec<i32> = crate::Codec::int32(10);
static SOURCE_CODE_INFO__LOCATION_SPAN_CODEC: crate::Codec<i32> = crate::Codec::int32(18);
static SOURCE_CODE_INFO__LOCATION_LEADING_DETACHED_COMMENTS_CODEC: crate::Codec<std::string::String> = crate::Codec::string(50);
impl crate::CodedMessage for self::SourceCodeInfo_Location {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 | 10 => self.path.add_entries(tag.get(), input, &SOURCE_CODE_INFO__LOCATION_PATH_CODEC)?,
                16 | 18 => self.span.add_entries(tag.get(), input, &SOURCE_CODE_INFO__LOCATION_SPAN_CODEC)?,
                26 => self.leading_comments = std::option::Option::Some(input.read_string()?),
                34 => self.trailing_comments = std::option::Option::Some(input.read_string()?),
                50 => self.leading_detached_comments.add_entries(tag.get(), input, &SOURCE_CODE_INFO__LOCATION_LEADING_DETACHED_COMMENTS_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> std::option::Option<i32> {
        let mut size = 0i32;
        size = size.checked_add(self.path.calculate_size(&SOURCE_CODE_INFO__LOCATION_PATH_CODEC)?)?;
        size = size.checked_add(self.span.calculate_size(&SOURCE_CODE_INFO__LOCATION_SPAN_CODEC)?)?;
        let leading_comments = &self.leading_comments;
        if let std::option::Option::Some(leading_comments) = leading_comments {
            if leading_comments != Self::LEADING_COMMENTS_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(leading_comments)?)?;
            }
        }
        let trailing_comments = &self.trailing_comments;
        if let std::option::Option::Some(trailing_comments) = trailing_comments {
            if trailing_comments != Self::TRAILING_COMMENTS_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(trailing_comments)?)?;
            }
        }
        size = size.checked_add(self.leading_detached_comments.calculate_size(&SOURCE_CODE_INFO__LOCATION_LEADING_DETACHED_COMMENTS_CODEC)?)?;
        size = size.checked_add(self.unknown_fields.calculate_size()?)?;
        std::option::Option::Some(size)
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        self.path.write_to(output, &SOURCE_CODE_INFO__LOCATION_PATH_CODEC)?;
        self.span.write_to(output, &SOURCE_CODE_INFO__LOCATION_SPAN_CODEC)?;
        let leading_comments = &self.leading_comments;
        if let std::option::Option::Some(leading_comments) = leading_comments {
            if leading_comments != Self::LEADING_COMMENTS_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[26])?;
                output.write_string(leading_comments)?;
            }
        }
        let trailing_comments = &self.trailing_comments;
        if let std::option::Option::Some(trailing_comments) = trailing_comments {
            if trailing_comments != Self::TRAILING_COMMENTS_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[34])?;
                output.write_string(trailing_comments)?;
            }
        }
        self.leading_detached_comments.write_to(output, &SOURCE_CODE_INFO__LOCATION_LEADING_DETACHED_COMMENTS_CODEC)?;
        self.unknown_fields.write_to(output)?;
        std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::SourceCodeInfo_Location {
    fn new() -> Self {
        Self {
            path: crate::collections::RepeatedField::new(),
            span: crate::collections::RepeatedField::new(),
            leading_comments: std::option::Option::None,
            trailing_comments: std::option::Option::None,
            leading_detached_comments: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl std::clone::Clone for self::SourceCodeInfo_Location {
    fn clone(&self) -> Self {
        Self {
            path: self.path.clone(),
            span: self.span.clone(),
            leading_comments: self.leading_comments.clone(),
            trailing_comments: self.trailing_comments.clone(),
            leading_detached_comments: self.leading_detached_comments.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.path.clone_from(&other.path);
        self.span.clone_from(&other.span);
        self.leading_comments = other.leading_comments.clone();
        self.trailing_comments = other.trailing_comments.clone();
        self.leading_detached_comments.clone_from(&other.leading_detached_comments);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::SourceCodeInfo_Location {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        unimplemented!()
    }
}
impl self::SourceCodeInfo_Location {
    /// Gets the field number of the 'path' field
    pub const PATH_FIELD_NUMBER: i32 = 1;
    /// Gets the field number of the 'span' field
    pub const SPAN_FIELD_NUMBER: i32 = 2;
    /// Gets the field number of the 'leading_comments' field
    pub const LEADING_COMMENTS_FIELD_NUMBER: i32 = 3;
    pub const LEADING_COMMENTS_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'trailing_comments' field
    pub const TRAILING_COMMENTS_FIELD_NUMBER: i32 = 4;
    pub const TRAILING_COMMENTS_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'leading_detached_comments' field
    pub const LEADING_DETACHED_COMMENTS_FIELD_NUMBER: i32 = 6;
}
#[derive(Debug, PartialEq)]
pub struct GeneratedCodeInfo {
    pub annotation: crate::collections::RepeatedField<std::boxed::Box<self::GeneratedCodeInfo_Annotation>>,
    unknown_fields: crate::UnknownFieldSet
}
static GENERATED_CODE_INFO_ANNOTATION_CODEC: crate::Codec<std::boxed::Box<self::GeneratedCodeInfo_Annotation>> = crate::Codec::message(10);
impl crate::CodedMessage for self::GeneratedCodeInfo {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.annotation.add_entries(tag.get(), input, &GENERATED_CODE_INFO_ANNOTATION_CODEC)?,
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> std::option::Option<i32> {
        let mut size = 0i32;
        size = size.checked_add(self.annotation.calculate_size(&GENERATED_CODE_INFO_ANNOTATION_CODEC)?)?;
        size = size.checked_add(self.unknown_fields.calculate_size()?)?;
        std::option::Option::Some(size)
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        self.annotation.write_to(output, &GENERATED_CODE_INFO_ANNOTATION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::GeneratedCodeInfo {
    fn new() -> Self {
        Self {
            annotation: crate::collections::RepeatedField::new(),
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl std::clone::Clone for self::GeneratedCodeInfo {
    fn clone(&self) -> Self {
        Self {
            annotation: self.annotation.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.annotation.clone_from(&other.annotation);
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::GeneratedCodeInfo {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        unimplemented!()
    }
}
impl self::GeneratedCodeInfo {
    /// Gets the field number of the 'annotation' field
    pub const ANNOTATION_FIELD_NUMBER: i32 = 1;
}
#[derive(Debug, PartialEq)]
pub struct GeneratedCodeInfo_Annotation {
    pub path: crate::collections::RepeatedField<i32>,
    pub source_file: std::option::Option<std::string::String>,
    pub begin: std::option::Option<i32>,
    pub end: std::option::Option<i32>,
    unknown_fields: crate::UnknownFieldSet
}
static GENERATED_CODE_INFO__ANNOTATION_PATH_CODEC: crate::Codec<i32> = crate::Codec::int32(10);
impl crate::CodedMessage for self::GeneratedCodeInfo_Annotation {
    fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
        while let std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 | 10 => self.path.add_entries(tag.get(), input, &GENERATED_CODE_INFO__ANNOTATION_PATH_CODEC)?,
                18 => self.source_file = std::option::Option::Some(input.read_string()?),
                24 => self.begin = std::option::Option::Some(input.read_int32()?),
                32 => self.end = std::option::Option::Some(input.read_int32()?),
                tag => self.unknown_fields.merge_from(tag, input)?
            }
        }
        std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> std::option::Option<i32> {
        let mut size = 0i32;
        size = size.checked_add(self.path.calculate_size(&GENERATED_CODE_INFO__ANNOTATION_PATH_CODEC)?)?;
        let source_file = &self.source_file;
        if let std::option::Option::Some(source_file) = source_file {
            if source_file != Self::SOURCE_FILE_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(source_file)?)?;
            }
        }
        let begin = self.begin;
        if let std::option::Option::Some(begin) = begin {
            if begin != Self::BEGIN_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::int32(begin))?;
            }
        }
        let end = self.end;
        if let std::option::Option::Some(end) = end {
            if end != Self::END_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::int32(end))?;
            }
        }
        size = size.checked_add(self.unknown_fields.calculate_size()?)?;
        std::option::Option::Some(size)
    }
    fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
        self.path.write_to(output, &GENERATED_CODE_INFO__ANNOTATION_PATH_CODEC)?;
        let source_file = &self.source_file;
        if let std::option::Option::Some(source_file) = source_file {
            if source_file != Self::SOURCE_FILE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[18])?;
                output.write_string(source_file)?;
            }
        }
        let begin = self.begin;
        if let std::option::Option::Some(begin) = begin {
            if begin != Self::BEGIN_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[24])?;
                output.write_int32(begin)?;
            }
        }
        let end = self.end;
        if let std::option::Option::Some(end) = end {
            if end != Self::END_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[32])?;
                output.write_int32(end)?;
            }
        }
        self.unknown_fields.write_to(output)?;
        std::result::Result::Ok(())
    }
}
impl crate::LiteMessage for self::GeneratedCodeInfo_Annotation {
    fn new() -> Self {
        Self {
            path: crate::collections::RepeatedField::new(),
            source_file: std::option::Option::None,
            begin: std::option::Option::None,
            end: std::option::Option::None,
            unknown_fields: crate::UnknownFieldSet::new()
        }
    }
}
impl std::clone::Clone for self::GeneratedCodeInfo_Annotation {
    fn clone(&self) -> Self {
        Self {
            path: self.path.clone(),
            source_file: self.source_file.clone(),
            begin: self.begin.clone(),
            end: self.end.clone(),
            unknown_fields: self.unknown_fields.clone()
        }
    }
    fn clone_from(&mut self, other: &Self) {
        self.path.clone_from(&other.path);
        self.source_file = other.source_file.clone();
        self.begin = other.begin;
        self.end = other.end;
        self.unknown_fields.clone_from(&other.unknown_fields);
    }
}
impl crate::Message for self::GeneratedCodeInfo_Annotation {
    fn descriptor() -> &'static crate::reflect::MessageDescriptor {
        unimplemented!()
    }
}
impl self::GeneratedCodeInfo_Annotation {
    /// Gets the field number of the 'path' field
    pub const PATH_FIELD_NUMBER: i32 = 1;
    /// Gets the field number of the 'source_file' field
    pub const SOURCE_FILE_FIELD_NUMBER: i32 = 2;
    pub const SOURCE_FILE_DEFAULT_VALUE: &'static str = "";
    /// Gets the field number of the 'begin' field
    pub const BEGIN_FIELD_NUMBER: i32 = 3;
    pub const BEGIN_DEFAULT_VALUE: i32 = 0;
    /// Gets the field number of the 'end' field
    pub const END_FIELD_NUMBER: i32 = 4;
    pub const END_DEFAULT_VALUE: i32 = 0;
}