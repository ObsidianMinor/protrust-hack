/* generated by protoc-gen-rust */

mod externals {}
static mut EXTERNAL_REGISTRIES: ::std::option::Option<[&'static crate::ExtensionRegistry; 0]> =
    ::std::option::Option::None;
static mut EXTENSIONS_REGISTRY: ::std::option::Option<crate::ExtensionRegistry> =
    ::std::option::Option::None;
static EXTENSIONS_INIT: ::std::sync::Once = ::std::sync::Once::new();
fn extensions_init() {
    unsafe {
        self::EXTERNAL_REGISTRIES = ::std::option::Option::Some([]);
        self::EXTENSIONS_REGISTRY = ::std::option::Option::Some(crate::ExtensionRegistry::new(
            self::EXTERNAL_REGISTRIES.as_ref().unwrap(),
            &[],
        ));
    }
}
pub fn extensions() -> &'static crate::ExtensionRegistry {
    unsafe {
        self::EXTENSIONS_INIT.call_once(extensions_init);
        self::EXTENSIONS_REGISTRY.as_ref().unwrap()
    }
}
static mut EXTERNAL_DEPS: ::std::option::Option<
    [&'static crate::reflect::DescriptorPool<'static>; 0],
> = ::std::option::Option::None;
static mut FILES: ::std::option::Option<[crate::descriptor::FileDescriptorProto; 12]> =
    ::std::option::Option::None;
static mut POOL: ::std::option::Option<crate::reflect::DescriptorPool<'static>> =
    ::std::option::Option::None;
static POOL_INIT: ::std::sync::Once = ::std::sync::Once::new();
fn pool_init() {
    unsafe {
        self::EXTERNAL_DEPS = ::std::option::Option::Some([]);
        self::FILES = ::std::option::Option::Some([
            crate::LiteMessage::read_new_from_input(
                &mut crate::io::CodedInput::new(&mut GOOGLE_PROTOBUF_ANY_PROTO_BINARY.as_ref())
                    .with_registry(::std::option::Option::Some(self::extensions())),
            )
            .expect("couldn't read file descriptor"),
            crate::LiteMessage::read_new_from_input(
                &mut crate::io::CodedInput::new(&mut GOOGLE_PROTOBUF_API_PROTO_BINARY.as_ref())
                    .with_registry(::std::option::Option::Some(self::extensions())),
            )
            .expect("couldn't read file descriptor"),
            crate::LiteMessage::read_new_from_input(
                &mut crate::io::CodedInput::new(
                    &mut GOOGLE_PROTOBUF_DESCRIPTOR_PROTO_BINARY.as_ref(),
                )
                .with_registry(::std::option::Option::Some(self::extensions())),
            )
            .expect("couldn't read file descriptor"),
            crate::LiteMessage::read_new_from_input(
                &mut crate::io::CodedInput::new(
                    &mut GOOGLE_PROTOBUF_DURATION_PROTO_BINARY.as_ref(),
                )
                .with_registry(::std::option::Option::Some(self::extensions())),
            )
            .expect("couldn't read file descriptor"),
            crate::LiteMessage::read_new_from_input(
                &mut crate::io::CodedInput::new(&mut GOOGLE_PROTOBUF_EMPTY_PROTO_BINARY.as_ref())
                    .with_registry(::std::option::Option::Some(self::extensions())),
            )
            .expect("couldn't read file descriptor"),
            crate::LiteMessage::read_new_from_input(
                &mut crate::io::CodedInput::new(
                    &mut GOOGLE_PROTOBUF_FIELD_MASK_PROTO_BINARY.as_ref(),
                )
                .with_registry(::std::option::Option::Some(self::extensions())),
            )
            .expect("couldn't read file descriptor"),
            crate::LiteMessage::read_new_from_input(
                &mut crate::io::CodedInput::new(
                    &mut GOOGLE_PROTOBUF_SOURCE_CONTEXT_PROTO_BINARY.as_ref(),
                )
                .with_registry(::std::option::Option::Some(self::extensions())),
            )
            .expect("couldn't read file descriptor"),
            crate::LiteMessage::read_new_from_input(
                &mut crate::io::CodedInput::new(&mut GOOGLE_PROTOBUF_STRUCT_PROTO_BINARY.as_ref())
                    .with_registry(::std::option::Option::Some(self::extensions())),
            )
            .expect("couldn't read file descriptor"),
            crate::LiteMessage::read_new_from_input(
                &mut crate::io::CodedInput::new(
                    &mut GOOGLE_PROTOBUF_TIMESTAMP_PROTO_BINARY.as_ref(),
                )
                .with_registry(::std::option::Option::Some(self::extensions())),
            )
            .expect("couldn't read file descriptor"),
            crate::LiteMessage::read_new_from_input(
                &mut crate::io::CodedInput::new(&mut GOOGLE_PROTOBUF_TYPE_PROTO_BINARY.as_ref())
                    .with_registry(::std::option::Option::Some(self::extensions())),
            )
            .expect("couldn't read file descriptor"),
            crate::LiteMessage::read_new_from_input(
                &mut crate::io::CodedInput::new(
                    &mut GOOGLE_PROTOBUF_WRAPPERS_PROTO_BINARY.as_ref(),
                )
                .with_registry(::std::option::Option::Some(self::extensions())),
            )
            .expect("couldn't read file descriptor"),
            crate::LiteMessage::read_new_from_input(
                &mut crate::io::CodedInput::new(
                    &mut GOOGLE_PROTOBUF_COMPILER_PLUGIN_PROTO_BINARY.as_ref(),
                )
                .with_registry(::std::option::Option::Some(self::extensions())),
            )
            .expect("couldn't read file descriptor"),
        ]);
        self :: POOL = :: std :: option :: Option :: Some ( crate :: reflect :: DescriptorPool :: build_from_generated_code ( self :: FILES . as_ref ( ) . unwrap ( ) . as_ref ( ) , self :: EXTERNAL_DEPS . as_ref ( ) . unwrap ( ) , :: std :: boxed :: Box :: new ( [ crate :: reflect :: GeneratedCodeInfo { structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_any_proto :: Any as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_any_proto :: any :: TYPE_URL_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_any_proto :: any :: VALUE_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedCodeInfo { structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_api_proto :: Api as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_api_proto :: api :: NAME_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_api_proto :: api :: METHODS_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_api_proto :: api :: OPTIONS_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_api_proto :: api :: VERSION_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_api_proto :: api :: SOURCE_CONTEXT_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_api_proto :: api :: MIXINS_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_api_proto :: api :: SYNTAX_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_api_proto :: Method as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_api_proto :: method :: NAME_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_api_proto :: method :: REQUEST_TYPE_URL_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_api_proto :: method :: REQUEST_STREAMING_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_api_proto :: method :: RESPONSE_TYPE_URL_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_api_proto :: method :: RESPONSE_STREAMING_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_api_proto :: method :: OPTIONS_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_api_proto :: method :: SYNTAX_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_api_proto :: Mixin as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_api_proto :: mixin :: NAME_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_api_proto :: mixin :: ROOT_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedCodeInfo { structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_descriptor_proto :: FileDescriptorSet as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: file_descriptor_set :: FILE_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_descriptor_proto :: FileDescriptorProto as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: file_descriptor_proto :: NAME_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: file_descriptor_proto :: PACKAGE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: file_descriptor_proto :: DEPENDENCY_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: file_descriptor_proto :: PUBLIC_DEPENDENCY_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: file_descriptor_proto :: WEAK_DEPENDENCY_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: file_descriptor_proto :: MESSAGE_TYPE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: file_descriptor_proto :: ENUM_TYPE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: file_descriptor_proto :: SERVICE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: file_descriptor_proto :: EXTENSION_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: file_descriptor_proto :: OPTIONS_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: file_descriptor_proto :: SOURCE_CODE_INFO_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: file_descriptor_proto :: SYNTAX_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_descriptor_proto :: DescriptorProto as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_descriptor_proto :: descriptor_proto :: ExtensionRange as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: descriptor_proto :: extension_range :: START_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: descriptor_proto :: extension_range :: END_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: descriptor_proto :: extension_range :: OPTIONS_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_descriptor_proto :: descriptor_proto :: ReservedRange as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: descriptor_proto :: reserved_range :: START_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: descriptor_proto :: reserved_range :: END_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: descriptor_proto :: NAME_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: descriptor_proto :: FIELD_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: descriptor_proto :: EXTENSION_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: descriptor_proto :: NESTED_TYPE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: descriptor_proto :: ENUM_TYPE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: descriptor_proto :: EXTENSION_RANGE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: descriptor_proto :: ONEOF_DECL_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: descriptor_proto :: OPTIONS_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: descriptor_proto :: RESERVED_RANGE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: descriptor_proto :: RESERVED_NAME_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_descriptor_proto :: ExtensionRangeOptions as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: extension_range_options :: UNINTERPRETED_OPTION_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_descriptor_proto :: FieldDescriptorProto as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: field_descriptor_proto :: NAME_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: field_descriptor_proto :: NUMBER_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: field_descriptor_proto :: LABEL_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: field_descriptor_proto :: TYPE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: field_descriptor_proto :: TYPE_NAME_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: field_descriptor_proto :: EXTENDEE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: field_descriptor_proto :: DEFAULT_VALUE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: field_descriptor_proto :: ONEOF_INDEX_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: field_descriptor_proto :: JSON_NAME_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: field_descriptor_proto :: OPTIONS_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_descriptor_proto :: OneofDescriptorProto as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: oneof_descriptor_proto :: NAME_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: oneof_descriptor_proto :: OPTIONS_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_descriptor_proto :: EnumDescriptorProto as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_descriptor_proto :: enum_descriptor_proto :: EnumReservedRange as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: enum_descriptor_proto :: enum_reserved_range :: START_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: enum_descriptor_proto :: enum_reserved_range :: END_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: enum_descriptor_proto :: NAME_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: enum_descriptor_proto :: VALUE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: enum_descriptor_proto :: OPTIONS_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: enum_descriptor_proto :: RESERVED_RANGE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: enum_descriptor_proto :: RESERVED_NAME_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_descriptor_proto :: EnumValueDescriptorProto as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: enum_value_descriptor_proto :: NAME_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: enum_value_descriptor_proto :: NUMBER_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: enum_value_descriptor_proto :: OPTIONS_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_descriptor_proto :: ServiceDescriptorProto as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: service_descriptor_proto :: NAME_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: service_descriptor_proto :: METHOD_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: service_descriptor_proto :: OPTIONS_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_descriptor_proto :: MethodDescriptorProto as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: method_descriptor_proto :: NAME_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: method_descriptor_proto :: INPUT_TYPE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: method_descriptor_proto :: OUTPUT_TYPE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: method_descriptor_proto :: OPTIONS_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: method_descriptor_proto :: CLIENT_STREAMING_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: method_descriptor_proto :: SERVER_STREAMING_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_descriptor_proto :: FileOptions as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: file_options :: JAVA_PACKAGE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: file_options :: JAVA_OUTER_CLASSNAME_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: file_options :: JAVA_MULTIPLE_FILES_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: file_options :: JAVA_GENERATE_EQUALS_AND_HASH_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: file_options :: JAVA_STRING_CHECK_UTF8_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: file_options :: OPTIMIZE_FOR_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: file_options :: GO_PACKAGE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: file_options :: CC_GENERIC_SERVICES_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: file_options :: JAVA_GENERIC_SERVICES_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: file_options :: PY_GENERIC_SERVICES_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: file_options :: PHP_GENERIC_SERVICES_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: file_options :: DEPRECATED_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: file_options :: CC_ENABLE_ARENAS_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: file_options :: OBJC_CLASS_PREFIX_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: file_options :: CSHARP_NAMESPACE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: file_options :: SWIFT_PREFIX_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: file_options :: PHP_CLASS_PREFIX_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: file_options :: PHP_NAMESPACE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: file_options :: PHP_METADATA_NAMESPACE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: file_options :: RUBY_PACKAGE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: file_options :: UNINTERPRETED_OPTION_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_descriptor_proto :: MessageOptions as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: message_options :: MESSAGE_SET_WIRE_FORMAT_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: message_options :: NO_STANDARD_DESCRIPTOR_ACCESSOR_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: message_options :: DEPRECATED_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: message_options :: MAP_ENTRY_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: message_options :: UNINTERPRETED_OPTION_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_descriptor_proto :: FieldOptions as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: field_options :: CTYPE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: field_options :: PACKED_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: field_options :: JSTYPE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: field_options :: LAZY_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: field_options :: DEPRECATED_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: field_options :: WEAK_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: field_options :: UNINTERPRETED_OPTION_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_descriptor_proto :: OneofOptions as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: oneof_options :: UNINTERPRETED_OPTION_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_descriptor_proto :: EnumOptions as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: enum_options :: ALLOW_ALIAS_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: enum_options :: DEPRECATED_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: enum_options :: UNINTERPRETED_OPTION_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_descriptor_proto :: EnumValueOptions as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: enum_value_options :: DEPRECATED_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: enum_value_options :: UNINTERPRETED_OPTION_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_descriptor_proto :: ServiceOptions as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: service_options :: DEPRECATED_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: service_options :: UNINTERPRETED_OPTION_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_descriptor_proto :: MethodOptions as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: method_options :: DEPRECATED_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: method_options :: IDEMPOTENCY_LEVEL_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: method_options :: UNINTERPRETED_OPTION_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_descriptor_proto :: UninterpretedOption as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_descriptor_proto :: uninterpreted_option :: NamePart as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: uninterpreted_option :: name_part :: NAME_PART_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: uninterpreted_option :: name_part :: IS_EXTENSION_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: uninterpreted_option :: NAME_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: uninterpreted_option :: IDENTIFIER_VALUE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: uninterpreted_option :: POSITIVE_INT_VALUE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: uninterpreted_option :: NEGATIVE_INT_VALUE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: uninterpreted_option :: DOUBLE_VALUE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: uninterpreted_option :: STRING_VALUE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: uninterpreted_option :: AGGREGATE_VALUE_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_descriptor_proto :: SourceCodeInfo as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_descriptor_proto :: source_code_info :: Location as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: source_code_info :: location :: PATH_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: source_code_info :: location :: SPAN_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: source_code_info :: location :: LEADING_COMMENTS_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: source_code_info :: location :: TRAILING_COMMENTS_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: source_code_info :: location :: LEADING_DETACHED_COMMENTS_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: source_code_info :: LOCATION_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_descriptor_proto :: GeneratedCodeInfo as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_descriptor_proto :: generated_code_info :: Annotation as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: generated_code_info :: annotation :: PATH_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: generated_code_info :: annotation :: SOURCE_FILE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: generated_code_info :: annotation :: BEGIN_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_descriptor_proto :: generated_code_info :: annotation :: END_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_descriptor_proto :: generated_code_info :: ANNOTATION_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedCodeInfo { structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_duration_proto :: Duration as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_duration_proto :: duration :: SECONDS_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_duration_proto :: duration :: NANOS_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedCodeInfo { structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_empty_proto :: Empty as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: None , extensions : :: std :: option :: Option :: None , } , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedCodeInfo { structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_field_mask_proto :: FieldMask as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_field_mask_proto :: field_mask :: PATHS_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedCodeInfo { structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_source_context_proto :: SourceContext as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_source_context_proto :: source_context :: FILE_NAME_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedCodeInfo { structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_struct_proto :: Struct as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ ] ) ) , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Map ( & self :: google_protobuf_struct_proto :: r#struct :: FIELDS_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_struct_proto :: Value as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_struct_proto :: value :: NULL_VALUE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_struct_proto :: value :: NUMBER_VALUE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_struct_proto :: value :: STRING_VALUE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_struct_proto :: value :: BOOL_VALUE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_struct_proto :: value :: STRUCT_VALUE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_struct_proto :: value :: LIST_VALUE_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_struct_proto :: ListValue as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_struct_proto :: list_value :: VALUES_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedCodeInfo { structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_timestamp_proto :: Timestamp as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_timestamp_proto :: timestamp :: SECONDS_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_timestamp_proto :: timestamp :: NANOS_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedCodeInfo { structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_type_proto :: Type as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_type_proto :: r#type :: NAME_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_type_proto :: r#type :: FIELDS_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_type_proto :: r#type :: ONEOFS_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_type_proto :: r#type :: OPTIONS_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_type_proto :: r#type :: SOURCE_CONTEXT_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_type_proto :: r#type :: SYNTAX_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_type_proto :: Field as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_type_proto :: field :: KIND_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_type_proto :: field :: CARDINALITY_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_type_proto :: field :: NUMBER_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_type_proto :: field :: NAME_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_type_proto :: field :: TYPE_URL_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_type_proto :: field :: ONEOF_INDEX_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_type_proto :: field :: PACKED_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_type_proto :: field :: OPTIONS_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_type_proto :: field :: JSON_NAME_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_type_proto :: field :: DEFAULT_VALUE_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_type_proto :: Enum as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_type_proto :: r#enum :: NAME_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_type_proto :: r#enum :: ENUMVALUE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_type_proto :: r#enum :: OPTIONS_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_type_proto :: r#enum :: SOURCE_CONTEXT_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_type_proto :: r#enum :: SYNTAX_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_type_proto :: EnumValue as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_type_proto :: enum_value :: NAME_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_type_proto :: enum_value :: NUMBER_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_type_proto :: enum_value :: OPTIONS_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_type_proto :: Option as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_type_proto :: option :: NAME_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_type_proto :: option :: VALUE_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedCodeInfo { structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_wrappers_proto :: DoubleValue as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_wrappers_proto :: double_value :: VALUE_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_wrappers_proto :: FloatValue as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_wrappers_proto :: float_value :: VALUE_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_wrappers_proto :: Int64Value as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_wrappers_proto :: int64_value :: VALUE_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_wrappers_proto :: UInt64Value as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_wrappers_proto :: u_int64_value :: VALUE_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_wrappers_proto :: Int32Value as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_wrappers_proto :: int32_value :: VALUE_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_wrappers_proto :: UInt32Value as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_wrappers_proto :: u_int32_value :: VALUE_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_wrappers_proto :: BoolValue as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_wrappers_proto :: bool_value :: VALUE_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_wrappers_proto :: StringValue as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_wrappers_proto :: string_value :: VALUE_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_wrappers_proto :: BytesValue as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_wrappers_proto :: bytes_value :: VALUE_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedCodeInfo { structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_compiler_plugin_proto :: Version as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_compiler_plugin_proto :: version :: MAJOR_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_compiler_plugin_proto :: version :: MINOR_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_compiler_plugin_proto :: version :: PATCH_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_compiler_plugin_proto :: version :: SUFFIX_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_compiler_plugin_proto :: CodeGeneratorRequest as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_compiler_plugin_proto :: code_generator_request :: FILE_TO_GENERATE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_compiler_plugin_proto :: code_generator_request :: PARAMETER_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_compiler_plugin_proto :: code_generator_request :: PROTO_FILE_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_compiler_plugin_proto :: code_generator_request :: COMPILER_VERSION_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_compiler_plugin_proto :: CodeGeneratorResponse as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: google_protobuf_compiler_plugin_proto :: code_generator_response :: File as crate :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_compiler_plugin_proto :: code_generator_response :: file :: NAME_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_compiler_plugin_proto :: code_generator_response :: file :: INSERTION_POINT_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_compiler_plugin_proto :: code_generator_response :: file :: CONTENT_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ crate :: reflect :: access :: FieldAccessor :: Single ( & self :: google_protobuf_compiler_plugin_proto :: code_generator_response :: ERROR_REFLECTOR ) , crate :: reflect :: access :: FieldAccessor :: Repeated ( & self :: google_protobuf_compiler_plugin_proto :: code_generator_response :: FILE_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) ) ;
    }
}
pub fn pool() -> &'static crate::reflect::DescriptorPool<'static> {
    unsafe {
        self::POOL_INIT.call_once(pool_init);
        self::POOL.as_ref().unwrap()
    }
}
static GOOGLE_PROTOBUF_ANY_PROTO_BINARY: &'static [u8] = &[
    10, 25, 103, 111, 111, 103, 108, 101, 47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 97, 110,
    121, 46, 112, 114, 111, 116, 111, 18, 15, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116,
    111, 98, 117, 102, 34, 54, 10, 3, 65, 110, 121, 18, 25, 10, 8, 116, 121, 112, 101, 95, 117,
    114, 108, 24, 1, 32, 1, 40, 9, 82, 7, 116, 121, 112, 101, 85, 114, 108, 18, 20, 10, 5, 118, 97,
    108, 117, 101, 24, 2, 32, 1, 40, 12, 82, 5, 118, 97, 108, 117, 101, 66, 111, 10, 19, 99, 111,
    109, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 66, 8, 65,
    110, 121, 80, 114, 111, 116, 111, 80, 1, 90, 37, 103, 105, 116, 104, 117, 98, 46, 99, 111, 109,
    47, 103, 111, 108, 97, 110, 103, 47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 112, 116, 121,
    112, 101, 115, 47, 97, 110, 121, 162, 2, 3, 71, 80, 66, 170, 2, 30, 71, 111, 111, 103, 108,
    101, 46, 80, 114, 111, 116, 111, 98, 117, 102, 46, 87, 101, 108, 108, 75, 110, 111, 119, 110,
    84, 121, 112, 101, 115, 98, 6, 112, 114, 111, 116, 111, 51,
];
pub mod google_protobuf_any_proto {
    pub fn file() -> &'static crate::reflect::FileDescriptor<'static> {
        super::pool()
            .find_file_by_name("google/protobuf/any.proto")
            .unwrap()
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct Any {
        type_url: ::std::string::String,
        value: ::std::vec::Vec<u8>,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::Any {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => *self.type_url_mut() = input.read_string()?,
                    18 => *self.value_mut() = input.read_bytes()?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if **self.type_url() != *Self::TYPE_URL_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(self.type_url())?)?;
            }
            if **self.value() != *Self::VALUE_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bytes(self.value())?)?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if **self.type_url() != *Self::TYPE_URL_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(self.type_url())?;
            }
            if **self.value() != *Self::VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[18])?;
                output.write_bytes(self.value())?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl crate::LiteMessage for self::Any {
        fn merge(&mut self, other: &Self) {
            if other.type_url.len() != 0 {
                *self.type_url_mut() = ::std::clone::Clone::clone(other.type_url());
            }
            if other.value.len() != 0 {
                *self.value_mut() = ::std::clone::Clone::clone(other.value());
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::Any {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[0]
        }
    }
    impl self::Any {
        pub const TYPE_URL_FIELD_NUMBER: i32 = 1;
        pub const TYPE_URL_DEFAULT_VALUE: &'static str = "";
        pub fn type_url(&self) -> &::std::string::String {
            &self.type_url
        }
        pub fn type_url_mut(&mut self) -> &mut ::std::string::String {
            &mut self.type_url
        }
        pub const VALUE_FIELD_NUMBER: i32 = 2;
        pub const VALUE_DEFAULT_VALUE: &'static [u8] = &[];
        pub fn value(&self) -> &::std::vec::Vec<u8> {
            &self.value
        }
        pub fn value_mut(&mut self) -> &mut ::std::vec::Vec<u8> {
            &mut self.value
        }
    }
    pub(in super::super) mod any {
        pub(in super::super) static TYPE_URL_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<self::super::Any, ::std::string::String> =
            crate::reflect::access::SimpleFieldAccessor {
                get: self::super::Any::type_url,
                get_mut: self::super::Any::type_url_mut,
            };
        pub(in super::super) static VALUE_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Any,
            ::std::vec::Vec<u8>,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Any::value,
            get_mut: self::super::Any::value_mut,
        };
    }
}
static GOOGLE_PROTOBUF_API_PROTO_BINARY: &'static [u8] = &[
    10, 25, 103, 111, 111, 103, 108, 101, 47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 97, 112,
    105, 46, 112, 114, 111, 116, 111, 18, 15, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116,
    111, 98, 117, 102, 26, 36, 103, 111, 111, 103, 108, 101, 47, 112, 114, 111, 116, 111, 98, 117,
    102, 47, 115, 111, 117, 114, 99, 101, 95, 99, 111, 110, 116, 101, 120, 116, 46, 112, 114, 111,
    116, 111, 26, 26, 103, 111, 111, 103, 108, 101, 47, 112, 114, 111, 116, 111, 98, 117, 102, 47,
    116, 121, 112, 101, 46, 112, 114, 111, 116, 111, 34, 193, 2, 10, 3, 65, 112, 105, 18, 18, 10,
    4, 110, 97, 109, 101, 24, 1, 32, 1, 40, 9, 82, 4, 110, 97, 109, 101, 18, 49, 10, 7, 109, 101,
    116, 104, 111, 100, 115, 24, 2, 32, 3, 40, 11, 50, 23, 46, 103, 111, 111, 103, 108, 101, 46,
    112, 114, 111, 116, 111, 98, 117, 102, 46, 77, 101, 116, 104, 111, 100, 82, 7, 109, 101, 116,
    104, 111, 100, 115, 18, 49, 10, 7, 111, 112, 116, 105, 111, 110, 115, 24, 3, 32, 3, 40, 11, 50,
    23, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 79, 112,
    116, 105, 111, 110, 82, 7, 111, 112, 116, 105, 111, 110, 115, 18, 24, 10, 7, 118, 101, 114,
    115, 105, 111, 110, 24, 4, 32, 1, 40, 9, 82, 7, 118, 101, 114, 115, 105, 111, 110, 18, 69, 10,
    14, 115, 111, 117, 114, 99, 101, 95, 99, 111, 110, 116, 101, 120, 116, 24, 5, 32, 1, 40, 11,
    50, 30, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 83,
    111, 117, 114, 99, 101, 67, 111, 110, 116, 101, 120, 116, 82, 13, 115, 111, 117, 114, 99, 101,
    67, 111, 110, 116, 101, 120, 116, 18, 46, 10, 6, 109, 105, 120, 105, 110, 115, 24, 6, 32, 3,
    40, 11, 50, 22, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102,
    46, 77, 105, 120, 105, 110, 82, 6, 109, 105, 120, 105, 110, 115, 18, 47, 10, 6, 115, 121, 110,
    116, 97, 120, 24, 7, 32, 1, 40, 14, 50, 23, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114,
    111, 116, 111, 98, 117, 102, 46, 83, 121, 110, 116, 97, 120, 82, 6, 115, 121, 110, 116, 97,
    120, 34, 178, 2, 10, 6, 77, 101, 116, 104, 111, 100, 18, 18, 10, 4, 110, 97, 109, 101, 24, 1,
    32, 1, 40, 9, 82, 4, 110, 97, 109, 101, 18, 40, 10, 16, 114, 101, 113, 117, 101, 115, 116, 95,
    116, 121, 112, 101, 95, 117, 114, 108, 24, 2, 32, 1, 40, 9, 82, 14, 114, 101, 113, 117, 101,
    115, 116, 84, 121, 112, 101, 85, 114, 108, 18, 43, 10, 17, 114, 101, 113, 117, 101, 115, 116,
    95, 115, 116, 114, 101, 97, 109, 105, 110, 103, 24, 3, 32, 1, 40, 8, 82, 16, 114, 101, 113,
    117, 101, 115, 116, 83, 116, 114, 101, 97, 109, 105, 110, 103, 18, 42, 10, 17, 114, 101, 115,
    112, 111, 110, 115, 101, 95, 116, 121, 112, 101, 95, 117, 114, 108, 24, 4, 32, 1, 40, 9, 82,
    15, 114, 101, 115, 112, 111, 110, 115, 101, 84, 121, 112, 101, 85, 114, 108, 18, 45, 10, 18,
    114, 101, 115, 112, 111, 110, 115, 101, 95, 115, 116, 114, 101, 97, 109, 105, 110, 103, 24, 5,
    32, 1, 40, 8, 82, 17, 114, 101, 115, 112, 111, 110, 115, 101, 83, 116, 114, 101, 97, 109, 105,
    110, 103, 18, 49, 10, 7, 111, 112, 116, 105, 111, 110, 115, 24, 6, 32, 3, 40, 11, 50, 23, 46,
    103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 79, 112, 116, 105,
    111, 110, 82, 7, 111, 112, 116, 105, 111, 110, 115, 18, 47, 10, 6, 115, 121, 110, 116, 97, 120,
    24, 7, 32, 1, 40, 14, 50, 23, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111,
    98, 117, 102, 46, 83, 121, 110, 116, 97, 120, 82, 6, 115, 121, 110, 116, 97, 120, 34, 47, 10,
    5, 77, 105, 120, 105, 110, 18, 18, 10, 4, 110, 97, 109, 101, 24, 1, 32, 1, 40, 9, 82, 4, 110,
    97, 109, 101, 18, 18, 10, 4, 114, 111, 111, 116, 24, 2, 32, 1, 40, 9, 82, 4, 114, 111, 111,
    116, 66, 117, 10, 19, 99, 111, 109, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116,
    111, 98, 117, 102, 66, 8, 65, 112, 105, 80, 114, 111, 116, 111, 80, 1, 90, 43, 103, 111, 111,
    103, 108, 101, 46, 103, 111, 108, 97, 110, 103, 46, 111, 114, 103, 47, 103, 101, 110, 112, 114,
    111, 116, 111, 47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 97, 112, 105, 59, 97, 112, 105,
    162, 2, 3, 71, 80, 66, 170, 2, 30, 71, 111, 111, 103, 108, 101, 46, 80, 114, 111, 116, 111, 98,
    117, 102, 46, 87, 101, 108, 108, 75, 110, 111, 119, 110, 84, 121, 112, 101, 115, 98, 6, 112,
    114, 111, 116, 111, 51,
];
pub mod google_protobuf_api_proto {
    pub fn file() -> &'static crate::reflect::FileDescriptor<'static> {
        super::pool()
            .find_file_by_name("google/protobuf/api.proto")
            .unwrap()
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct Api {
        name: ::std::string::String,
        methods: crate::collections::RepeatedField<self::Method>,
        options: crate::collections::RepeatedField<self::super::google_protobuf_type_proto::Option>,
        version: ::std::string::String,
        source_context: ::std::option::Option<
            ::std::boxed::Box<self::super::google_protobuf_source_context_proto::SourceContext>,
        >,
        mixins: crate::collections::RepeatedField<self::Mixin>,
        syntax: crate::EnumValue<self::super::google_protobuf_type_proto::Syntax>,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::Api {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => *self.name_mut() = input.read_string()?,
                    18 => self.methods.add_entries(input, &self::api::METHODS_CODEC)?,
                    26 => self.options.add_entries(input, &self::api::OPTIONS_CODEC)?,
                    34 => *self.version_mut() = input.read_string()?,
                    42 => input.read_message(self.source_context_mut())?,
                    50 => self.mixins.add_entries(input, &self::api::MIXINS_CODEC)?,
                    56 | 58 => *self.syntax_mut() = input.read_enum_value()?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if **self.name() != *Self::NAME_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(self.name())?)?;
            }
            size = size.checked_add(self.methods().calculate_size(&self::api::METHODS_CODEC)?)?;
            size = size.checked_add(self.options().calculate_size(&self::api::OPTIONS_CODEC)?)?;
            if **self.version() != *Self::VERSION_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(self.version())?)?;
            }
            if let ::std::option::Option::Some(source_context) = self.source_context() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::message(source_context)?)?;
            }
            size = size.checked_add(self.mixins().calculate_size(&self::api::MIXINS_CODEC)?)?;
            if *self.syntax() != Self::SYNTAX_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::enum_value(*self.syntax()))?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if **self.name() != *Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(self.name())?;
            }
            self.methods().write_to(output, &self::api::METHODS_CODEC)?;
            self.options().write_to(output, &self::api::OPTIONS_CODEC)?;
            if **self.version() != *Self::VERSION_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[34])?;
                output.write_string(self.version())?;
            }
            if let ::std::option::Option::Some(source_context) = self.source_context() {
                output.write_raw_tag_bytes(&[42])?;
                output.write_message(source_context)?;
            }
            self.mixins().write_to(output, &self::api::MIXINS_CODEC)?;
            if *self.syntax() != Self::SYNTAX_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[56])?;
                output.write_enum_value(*self.syntax())?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.methods.is_initialized() {
                return false;
            }
            if !self.options.is_initialized() {
                return false;
            }
            if let ::std::option::Option::Some(source_context) = self.source_context() {
                if !crate::CodedMessage::is_initialized(source_context) {
                    return false;
                }
            }
            if !self.mixins.is_initialized() {
                return false;
            }
            true
        }
    }
    impl crate::LiteMessage for self::Api {
        fn merge(&mut self, other: &Self) {
            if other.name.len() != 0 {
                *self.name_mut() = ::std::clone::Clone::clone(other.name());
            }
            self.methods.merge(&other.methods);
            self.options.merge(&other.options);
            if other.version.len() != 0 {
                *self.version_mut() = ::std::clone::Clone::clone(other.version());
            }
            if let ::std::option::Option::Some(source_context) = &other.source_context() {
                crate::LiteMessage::merge(self.source_context_mut(), source_context);
            }
            self.mixins.merge(&other.mixins);
            if *other.syntax() != Self::SYNTAX_DEFAULT_VALUE {
                *self.syntax_mut() = *other.syntax();
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::Api {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[0]
        }
    }
    impl self::Api {
        pub const NAME_FIELD_NUMBER: i32 = 1;
        pub const NAME_DEFAULT_VALUE: &'static str = "";
        pub fn name(&self) -> &::std::string::String {
            &self.name
        }
        pub fn name_mut(&mut self) -> &mut ::std::string::String {
            &mut self.name
        }
        pub const METHODS_FIELD_NUMBER: i32 = 2;
        pub fn methods(&self) -> &crate::collections::RepeatedField<self::Method> {
            &self.methods
        }
        pub fn methods_mut(&mut self) -> &mut crate::collections::RepeatedField<self::Method> {
            &mut self.methods
        }
        pub const OPTIONS_FIELD_NUMBER: i32 = 3;
        pub fn options(
            &self,
        ) -> &crate::collections::RepeatedField<self::super::google_protobuf_type_proto::Option>
        {
            &self.options
        }
        pub fn options_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::super::google_protobuf_type_proto::Option>
        {
            &mut self.options
        }
        pub const VERSION_FIELD_NUMBER: i32 = 4;
        pub const VERSION_DEFAULT_VALUE: &'static str = "";
        pub fn version(&self) -> &::std::string::String {
            &self.version
        }
        pub fn version_mut(&mut self) -> &mut ::std::string::String {
            &mut self.version
        }
        pub const SOURCE_CONTEXT_FIELD_NUMBER: i32 = 5;
        pub fn source_context(
            &self,
        ) -> ::std::option::Option<&self::super::google_protobuf_source_context_proto::SourceContext>
        {
            self.source_context.as_ref().map(|v| &**v)
        }
        pub fn source_context_mut(
            &mut self,
        ) -> &mut self::super::google_protobuf_source_context_proto::SourceContext {
            self.source_context
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_source_context(&self) -> bool {
            self.source_context.is_some()
        }
        pub fn set_source_context(
            &mut self,
            value: self::super::google_protobuf_source_context_proto::SourceContext,
        ) {
            self.source_context = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_source_context(
            &mut self,
        ) -> ::std::option::Option<self::super::google_protobuf_source_context_proto::SourceContext>
        {
            self.source_context.take().map(|v| *v)
        }
        pub fn clear_source_context(&mut self) {
            self.source_context = ::std::option::Option::None;
        }
        pub const MIXINS_FIELD_NUMBER: i32 = 6;
        pub fn mixins(&self) -> &crate::collections::RepeatedField<self::Mixin> {
            &self.mixins
        }
        pub fn mixins_mut(&mut self) -> &mut crate::collections::RepeatedField<self::Mixin> {
            &mut self.mixins
        }
        pub const SYNTAX_FIELD_NUMBER: i32 = 7;
        pub const SYNTAX_DEFAULT_VALUE: crate::EnumValue<
            self::super::google_protobuf_type_proto::Syntax,
        > = crate::EnumValue::Defined(self::super::google_protobuf_type_proto::Syntax::Proto2);
        pub fn syntax(&self) -> &crate::EnumValue<self::super::google_protobuf_type_proto::Syntax> {
            &self.syntax
        }
        pub fn syntax_mut(
            &mut self,
        ) -> &mut crate::EnumValue<self::super::google_protobuf_type_proto::Syntax> {
            &mut self.syntax
        }
    }
    pub(in super::super) mod api {
        pub(super) static METHODS_CODEC: crate::Codec<self::super::Method> =
            crate::Codec::message(18);
        pub(super) static OPTIONS_CODEC: crate::Codec<
            self::super::super::google_protobuf_type_proto::Option,
        > = crate::Codec::message(26);
        pub(super) static MIXINS_CODEC: crate::Codec<self::super::Mixin> =
            crate::Codec::message(50);
        pub(in super::super) static NAME_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Api,
            ::std::string::String,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Api::name,
            get_mut: self::super::Api::name_mut,
        };
        pub(in super::super) static METHODS_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Api,
            crate::collections::RepeatedField<self::super::Method>,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Api::methods,
            get_mut: self::super::Api::methods_mut,
        };
        pub(in super::super) static OPTIONS_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Api,
            crate::collections::RepeatedField<
                self::super::super::google_protobuf_type_proto::Option,
            >,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Api::options,
            get_mut: self::super::Api::options_mut,
        };
        pub(in super::super) static VERSION_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Api,
            ::std::string::String,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Api::version,
            get_mut: self::super::Api::version_mut,
        };
        pub(in super::super) static SOURCE_CONTEXT_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::Api,
                self::super::super::google_protobuf_source_context_proto::SourceContext,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::Api::source_context,
            get_mut: self::super::Api::source_context_mut,
            set: self::super::Api::set_source_context,
            take: self::super::Api::take_source_context,
            clear: self::super::Api::clear_source_context,
        };
        pub(in super::super) static MIXINS_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Api,
            crate::collections::RepeatedField<self::super::Mixin>,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Api::mixins,
            get_mut: self::super::Api::mixins_mut,
        };
        pub(in super::super) static SYNTAX_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Api,
            crate::EnumValue<self::super::super::google_protobuf_type_proto::Syntax>,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Api::syntax,
            get_mut: self::super::Api::syntax_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct Method {
        name: ::std::string::String,
        request_type_url: ::std::string::String,
        request_streaming: bool,
        response_type_url: ::std::string::String,
        response_streaming: bool,
        options: crate::collections::RepeatedField<self::super::google_protobuf_type_proto::Option>,
        syntax: crate::EnumValue<self::super::google_protobuf_type_proto::Syntax>,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::Method {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => *self.name_mut() = input.read_string()?,
                    18 => *self.request_type_url_mut() = input.read_string()?,
                    24 | 26 => *self.request_streaming_mut() = input.read_bool()?,
                    34 => *self.response_type_url_mut() = input.read_string()?,
                    40 | 42 => *self.response_streaming_mut() = input.read_bool()?,
                    50 => self
                        .options
                        .add_entries(input, &self::method::OPTIONS_CODEC)?,
                    56 | 58 => *self.syntax_mut() = input.read_enum_value()?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if **self.name() != *Self::NAME_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(self.name())?)?;
            }
            if **self.request_type_url() != *Self::REQUEST_TYPE_URL_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(self.request_type_url())?)?;
            }
            if *self.request_streaming() != Self::REQUEST_STREAMING_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(*self.request_streaming()))?;
            }
            if **self.response_type_url() != *Self::RESPONSE_TYPE_URL_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(self.response_type_url())?)?;
            }
            if *self.response_streaming() != Self::RESPONSE_STREAMING_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(*self.response_streaming()))?;
            }
            size = size.checked_add(
                self.options()
                    .calculate_size(&self::method::OPTIONS_CODEC)?,
            )?;
            if *self.syntax() != Self::SYNTAX_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::enum_value(*self.syntax()))?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if **self.name() != *Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(self.name())?;
            }
            if **self.request_type_url() != *Self::REQUEST_TYPE_URL_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[18])?;
                output.write_string(self.request_type_url())?;
            }
            if *self.request_streaming() != Self::REQUEST_STREAMING_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[24])?;
                output.write_bool(*self.request_streaming())?;
            }
            if **self.response_type_url() != *Self::RESPONSE_TYPE_URL_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[34])?;
                output.write_string(self.response_type_url())?;
            }
            if *self.response_streaming() != Self::RESPONSE_STREAMING_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[40])?;
                output.write_bool(*self.response_streaming())?;
            }
            self.options()
                .write_to(output, &self::method::OPTIONS_CODEC)?;
            if *self.syntax() != Self::SYNTAX_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[56])?;
                output.write_enum_value(*self.syntax())?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.options.is_initialized() {
                return false;
            }
            true
        }
    }
    impl crate::LiteMessage for self::Method {
        fn merge(&mut self, other: &Self) {
            if other.name.len() != 0 {
                *self.name_mut() = ::std::clone::Clone::clone(other.name());
            }
            if other.request_type_url.len() != 0 {
                *self.request_type_url_mut() = ::std::clone::Clone::clone(other.request_type_url());
            }
            if *other.request_streaming() != Self::REQUEST_STREAMING_DEFAULT_VALUE {
                *self.request_streaming_mut() = *other.request_streaming();
            }
            if other.response_type_url.len() != 0 {
                *self.response_type_url_mut() =
                    ::std::clone::Clone::clone(other.response_type_url());
            }
            if *other.response_streaming() != Self::RESPONSE_STREAMING_DEFAULT_VALUE {
                *self.response_streaming_mut() = *other.response_streaming();
            }
            self.options.merge(&other.options);
            if *other.syntax() != Self::SYNTAX_DEFAULT_VALUE {
                *self.syntax_mut() = *other.syntax();
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::Method {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[1]
        }
    }
    impl self::Method {
        pub const NAME_FIELD_NUMBER: i32 = 1;
        pub const NAME_DEFAULT_VALUE: &'static str = "";
        pub fn name(&self) -> &::std::string::String {
            &self.name
        }
        pub fn name_mut(&mut self) -> &mut ::std::string::String {
            &mut self.name
        }
        pub const REQUEST_TYPE_URL_FIELD_NUMBER: i32 = 2;
        pub const REQUEST_TYPE_URL_DEFAULT_VALUE: &'static str = "";
        pub fn request_type_url(&self) -> &::std::string::String {
            &self.request_type_url
        }
        pub fn request_type_url_mut(&mut self) -> &mut ::std::string::String {
            &mut self.request_type_url
        }
        pub const REQUEST_STREAMING_FIELD_NUMBER: i32 = 3;
        pub const REQUEST_STREAMING_DEFAULT_VALUE: bool = false;
        pub fn request_streaming(&self) -> &bool {
            &self.request_streaming
        }
        pub fn request_streaming_mut(&mut self) -> &mut bool {
            &mut self.request_streaming
        }
        pub const RESPONSE_TYPE_URL_FIELD_NUMBER: i32 = 4;
        pub const RESPONSE_TYPE_URL_DEFAULT_VALUE: &'static str = "";
        pub fn response_type_url(&self) -> &::std::string::String {
            &self.response_type_url
        }
        pub fn response_type_url_mut(&mut self) -> &mut ::std::string::String {
            &mut self.response_type_url
        }
        pub const RESPONSE_STREAMING_FIELD_NUMBER: i32 = 5;
        pub const RESPONSE_STREAMING_DEFAULT_VALUE: bool = false;
        pub fn response_streaming(&self) -> &bool {
            &self.response_streaming
        }
        pub fn response_streaming_mut(&mut self) -> &mut bool {
            &mut self.response_streaming
        }
        pub const OPTIONS_FIELD_NUMBER: i32 = 6;
        pub fn options(
            &self,
        ) -> &crate::collections::RepeatedField<self::super::google_protobuf_type_proto::Option>
        {
            &self.options
        }
        pub fn options_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::super::google_protobuf_type_proto::Option>
        {
            &mut self.options
        }
        pub const SYNTAX_FIELD_NUMBER: i32 = 7;
        pub const SYNTAX_DEFAULT_VALUE: crate::EnumValue<
            self::super::google_protobuf_type_proto::Syntax,
        > = crate::EnumValue::Defined(self::super::google_protobuf_type_proto::Syntax::Proto2);
        pub fn syntax(&self) -> &crate::EnumValue<self::super::google_protobuf_type_proto::Syntax> {
            &self.syntax
        }
        pub fn syntax_mut(
            &mut self,
        ) -> &mut crate::EnumValue<self::super::google_protobuf_type_proto::Syntax> {
            &mut self.syntax
        }
    }
    pub(in super::super) mod method {
        pub(super) static OPTIONS_CODEC: crate::Codec<
            self::super::super::google_protobuf_type_proto::Option,
        > = crate::Codec::message(50);
        pub(in super::super) static NAME_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Method,
            ::std::string::String,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Method::name,
            get_mut: self::super::Method::name_mut,
        };
        pub(in super::super) static REQUEST_TYPE_URL_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<self::super::Method, ::std::string::String> =
            crate::reflect::access::SimpleFieldAccessor {
                get: self::super::Method::request_type_url,
                get_mut: self::super::Method::request_type_url_mut,
            };
        pub(in super::super) static REQUEST_STREAMING_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<self::super::Method, bool> =
            crate::reflect::access::SimpleFieldAccessor {
                get: self::super::Method::request_streaming,
                get_mut: self::super::Method::request_streaming_mut,
            };
        pub(in super::super) static RESPONSE_TYPE_URL_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<self::super::Method, ::std::string::String> =
            crate::reflect::access::SimpleFieldAccessor {
                get: self::super::Method::response_type_url,
                get_mut: self::super::Method::response_type_url_mut,
            };
        pub(in super::super) static RESPONSE_STREAMING_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<self::super::Method, bool> =
            crate::reflect::access::SimpleFieldAccessor {
                get: self::super::Method::response_streaming,
                get_mut: self::super::Method::response_streaming_mut,
            };
        pub(in super::super) static OPTIONS_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Method,
            crate::collections::RepeatedField<
                self::super::super::google_protobuf_type_proto::Option,
            >,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Method::options,
            get_mut: self::super::Method::options_mut,
        };
        pub(in super::super) static SYNTAX_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Method,
            crate::EnumValue<self::super::super::google_protobuf_type_proto::Syntax>,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Method::syntax,
            get_mut: self::super::Method::syntax_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct Mixin {
        name: ::std::string::String,
        root: ::std::string::String,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::Mixin {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => *self.name_mut() = input.read_string()?,
                    18 => *self.root_mut() = input.read_string()?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if **self.name() != *Self::NAME_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(self.name())?)?;
            }
            if **self.root() != *Self::ROOT_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(self.root())?)?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if **self.name() != *Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(self.name())?;
            }
            if **self.root() != *Self::ROOT_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[18])?;
                output.write_string(self.root())?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl crate::LiteMessage for self::Mixin {
        fn merge(&mut self, other: &Self) {
            if other.name.len() != 0 {
                *self.name_mut() = ::std::clone::Clone::clone(other.name());
            }
            if other.root.len() != 0 {
                *self.root_mut() = ::std::clone::Clone::clone(other.root());
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::Mixin {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[2]
        }
    }
    impl self::Mixin {
        pub const NAME_FIELD_NUMBER: i32 = 1;
        pub const NAME_DEFAULT_VALUE: &'static str = "";
        pub fn name(&self) -> &::std::string::String {
            &self.name
        }
        pub fn name_mut(&mut self) -> &mut ::std::string::String {
            &mut self.name
        }
        pub const ROOT_FIELD_NUMBER: i32 = 2;
        pub const ROOT_DEFAULT_VALUE: &'static str = "";
        pub fn root(&self) -> &::std::string::String {
            &self.root
        }
        pub fn root_mut(&mut self) -> &mut ::std::string::String {
            &mut self.root
        }
    }
    pub(in super::super) mod mixin {
        pub(in super::super) static NAME_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Mixin,
            ::std::string::String,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Mixin::name,
            get_mut: self::super::Mixin::name_mut,
        };
        pub(in super::super) static ROOT_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Mixin,
            ::std::string::String,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Mixin::root,
            get_mut: self::super::Mixin::root_mut,
        };
    }
}
static GOOGLE_PROTOBUF_DESCRIPTOR_PROTO_BINARY: &'static [u8] = &[
    10, 32, 103, 111, 111, 103, 108, 101, 47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 100, 101,
    115, 99, 114, 105, 112, 116, 111, 114, 46, 112, 114, 111, 116, 111, 18, 15, 103, 111, 111, 103,
    108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 34, 77, 10, 17, 70, 105, 108, 101, 68,
    101, 115, 99, 114, 105, 112, 116, 111, 114, 83, 101, 116, 18, 56, 10, 4, 102, 105, 108, 101,
    24, 1, 32, 3, 40, 11, 50, 36, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111,
    98, 117, 102, 46, 70, 105, 108, 101, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114,
    111, 116, 111, 82, 4, 102, 105, 108, 101, 34, 228, 4, 10, 19, 70, 105, 108, 101, 68, 101, 115,
    99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 18, 18, 10, 4, 110, 97, 109, 101, 24,
    1, 32, 1, 40, 9, 82, 4, 110, 97, 109, 101, 18, 24, 10, 7, 112, 97, 99, 107, 97, 103, 101, 24,
    2, 32, 1, 40, 9, 82, 7, 112, 97, 99, 107, 97, 103, 101, 18, 30, 10, 10, 100, 101, 112, 101,
    110, 100, 101, 110, 99, 121, 24, 3, 32, 3, 40, 9, 82, 10, 100, 101, 112, 101, 110, 100, 101,
    110, 99, 121, 18, 43, 10, 17, 112, 117, 98, 108, 105, 99, 95, 100, 101, 112, 101, 110, 100,
    101, 110, 99, 121, 24, 10, 32, 3, 40, 5, 82, 16, 112, 117, 98, 108, 105, 99, 68, 101, 112, 101,
    110, 100, 101, 110, 99, 121, 18, 39, 10, 15, 119, 101, 97, 107, 95, 100, 101, 112, 101, 110,
    100, 101, 110, 99, 121, 24, 11, 32, 3, 40, 5, 82, 14, 119, 101, 97, 107, 68, 101, 112, 101,
    110, 100, 101, 110, 99, 121, 18, 67, 10, 12, 109, 101, 115, 115, 97, 103, 101, 95, 116, 121,
    112, 101, 24, 4, 32, 3, 40, 11, 50, 32, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111,
    116, 111, 98, 117, 102, 46, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116,
    111, 82, 11, 109, 101, 115, 115, 97, 103, 101, 84, 121, 112, 101, 18, 65, 10, 9, 101, 110, 117,
    109, 95, 116, 121, 112, 101, 24, 5, 32, 3, 40, 11, 50, 36, 46, 103, 111, 111, 103, 108, 101,
    46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 69, 110, 117, 109, 68, 101, 115, 99, 114, 105,
    112, 116, 111, 114, 80, 114, 111, 116, 111, 82, 8, 101, 110, 117, 109, 84, 121, 112, 101, 18,
    65, 10, 7, 115, 101, 114, 118, 105, 99, 101, 24, 6, 32, 3, 40, 11, 50, 39, 46, 103, 111, 111,
    103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 83, 101, 114, 118, 105, 99, 101,
    68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 82, 7, 115, 101, 114,
    118, 105, 99, 101, 18, 67, 10, 9, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 7, 32, 3,
    40, 11, 50, 37, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102,
    46, 70, 105, 101, 108, 100, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116,
    111, 82, 9, 101, 120, 116, 101, 110, 115, 105, 111, 110, 18, 54, 10, 7, 111, 112, 116, 105,
    111, 110, 115, 24, 8, 32, 1, 40, 11, 50, 28, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114,
    111, 116, 111, 98, 117, 102, 46, 70, 105, 108, 101, 79, 112, 116, 105, 111, 110, 115, 82, 7,
    111, 112, 116, 105, 111, 110, 115, 18, 73, 10, 16, 115, 111, 117, 114, 99, 101, 95, 99, 111,
    100, 101, 95, 105, 110, 102, 111, 24, 9, 32, 1, 40, 11, 50, 31, 46, 103, 111, 111, 103, 108,
    101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 83, 111, 117, 114, 99, 101, 67, 111, 100,
    101, 73, 110, 102, 111, 82, 14, 115, 111, 117, 114, 99, 101, 67, 111, 100, 101, 73, 110, 102,
    111, 18, 22, 10, 6, 115, 121, 110, 116, 97, 120, 24, 12, 32, 1, 40, 9, 82, 6, 115, 121, 110,
    116, 97, 120, 34, 185, 6, 10, 15, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111,
    116, 111, 18, 18, 10, 4, 110, 97, 109, 101, 24, 1, 32, 1, 40, 9, 82, 4, 110, 97, 109, 101, 18,
    59, 10, 5, 102, 105, 101, 108, 100, 24, 2, 32, 3, 40, 11, 50, 37, 46, 103, 111, 111, 103, 108,
    101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 70, 105, 101, 108, 100, 68, 101, 115, 99,
    114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 82, 5, 102, 105, 101, 108, 100, 18, 67,
    10, 9, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 6, 32, 3, 40, 11, 50, 37, 46, 103, 111,
    111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 70, 105, 101, 108, 100, 68,
    101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 82, 9, 101, 120, 116, 101,
    110, 115, 105, 111, 110, 18, 65, 10, 11, 110, 101, 115, 116, 101, 100, 95, 116, 121, 112, 101,
    24, 3, 32, 3, 40, 11, 50, 32, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111,
    98, 117, 102, 46, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 82,
    10, 110, 101, 115, 116, 101, 100, 84, 121, 112, 101, 18, 65, 10, 9, 101, 110, 117, 109, 95,
    116, 121, 112, 101, 24, 4, 32, 3, 40, 11, 50, 36, 46, 103, 111, 111, 103, 108, 101, 46, 112,
    114, 111, 116, 111, 98, 117, 102, 46, 69, 110, 117, 109, 68, 101, 115, 99, 114, 105, 112, 116,
    111, 114, 80, 114, 111, 116, 111, 82, 8, 101, 110, 117, 109, 84, 121, 112, 101, 18, 88, 10, 15,
    101, 120, 116, 101, 110, 115, 105, 111, 110, 95, 114, 97, 110, 103, 101, 24, 5, 32, 3, 40, 11,
    50, 47, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 68,
    101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 46, 69, 120, 116, 101, 110,
    115, 105, 111, 110, 82, 97, 110, 103, 101, 82, 14, 101, 120, 116, 101, 110, 115, 105, 111, 110,
    82, 97, 110, 103, 101, 18, 68, 10, 10, 111, 110, 101, 111, 102, 95, 100, 101, 99, 108, 24, 8,
    32, 3, 40, 11, 50, 37, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117,
    102, 46, 79, 110, 101, 111, 102, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111,
    116, 111, 82, 9, 111, 110, 101, 111, 102, 68, 101, 99, 108, 18, 57, 10, 7, 111, 112, 116, 105,
    111, 110, 115, 24, 7, 32, 1, 40, 11, 50, 31, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114,
    111, 116, 111, 98, 117, 102, 46, 77, 101, 115, 115, 97, 103, 101, 79, 112, 116, 105, 111, 110,
    115, 82, 7, 111, 112, 116, 105, 111, 110, 115, 18, 85, 10, 14, 114, 101, 115, 101, 114, 118,
    101, 100, 95, 114, 97, 110, 103, 101, 24, 9, 32, 3, 40, 11, 50, 46, 46, 103, 111, 111, 103,
    108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 68, 101, 115, 99, 114, 105, 112, 116,
    111, 114, 80, 114, 111, 116, 111, 46, 82, 101, 115, 101, 114, 118, 101, 100, 82, 97, 110, 103,
    101, 82, 13, 114, 101, 115, 101, 114, 118, 101, 100, 82, 97, 110, 103, 101, 18, 35, 10, 13,
    114, 101, 115, 101, 114, 118, 101, 100, 95, 110, 97, 109, 101, 24, 10, 32, 3, 40, 9, 82, 12,
    114, 101, 115, 101, 114, 118, 101, 100, 78, 97, 109, 101, 26, 122, 10, 14, 69, 120, 116, 101,
    110, 115, 105, 111, 110, 82, 97, 110, 103, 101, 18, 20, 10, 5, 115, 116, 97, 114, 116, 24, 1,
    32, 1, 40, 5, 82, 5, 115, 116, 97, 114, 116, 18, 16, 10, 3, 101, 110, 100, 24, 2, 32, 1, 40, 5,
    82, 3, 101, 110, 100, 18, 64, 10, 7, 111, 112, 116, 105, 111, 110, 115, 24, 3, 32, 1, 40, 11,
    50, 38, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 69,
    120, 116, 101, 110, 115, 105, 111, 110, 82, 97, 110, 103, 101, 79, 112, 116, 105, 111, 110,
    115, 82, 7, 111, 112, 116, 105, 111, 110, 115, 26, 55, 10, 13, 82, 101, 115, 101, 114, 118,
    101, 100, 82, 97, 110, 103, 101, 18, 20, 10, 5, 115, 116, 97, 114, 116, 24, 1, 32, 1, 40, 5,
    82, 5, 115, 116, 97, 114, 116, 18, 16, 10, 3, 101, 110, 100, 24, 2, 32, 1, 40, 5, 82, 3, 101,
    110, 100, 34, 124, 10, 21, 69, 120, 116, 101, 110, 115, 105, 111, 110, 82, 97, 110, 103, 101,
    79, 112, 116, 105, 111, 110, 115, 18, 88, 10, 20, 117, 110, 105, 110, 116, 101, 114, 112, 114,
    101, 116, 101, 100, 95, 111, 112, 116, 105, 111, 110, 24, 231, 7, 32, 3, 40, 11, 50, 36, 46,
    103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 85, 110, 105, 110,
    116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 82, 19, 117, 110,
    105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 42, 9, 8,
    232, 7, 16, 128, 128, 128, 128, 2, 34, 152, 6, 10, 20, 70, 105, 101, 108, 100, 68, 101, 115,
    99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 18, 18, 10, 4, 110, 97, 109, 101, 24,
    1, 32, 1, 40, 9, 82, 4, 110, 97, 109, 101, 18, 22, 10, 6, 110, 117, 109, 98, 101, 114, 24, 3,
    32, 1, 40, 5, 82, 6, 110, 117, 109, 98, 101, 114, 18, 65, 10, 5, 108, 97, 98, 101, 108, 24, 4,
    32, 1, 40, 14, 50, 43, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117,
    102, 46, 70, 105, 101, 108, 100, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111,
    116, 111, 46, 76, 97, 98, 101, 108, 82, 5, 108, 97, 98, 101, 108, 18, 62, 10, 4, 116, 121, 112,
    101, 24, 5, 32, 1, 40, 14, 50, 42, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116,
    111, 98, 117, 102, 46, 70, 105, 101, 108, 100, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114,
    80, 114, 111, 116, 111, 46, 84, 121, 112, 101, 82, 4, 116, 121, 112, 101, 18, 27, 10, 9, 116,
    121, 112, 101, 95, 110, 97, 109, 101, 24, 6, 32, 1, 40, 9, 82, 8, 116, 121, 112, 101, 78, 97,
    109, 101, 18, 26, 10, 8, 101, 120, 116, 101, 110, 100, 101, 101, 24, 2, 32, 1, 40, 9, 82, 8,
    101, 120, 116, 101, 110, 100, 101, 101, 18, 35, 10, 13, 100, 101, 102, 97, 117, 108, 116, 95,
    118, 97, 108, 117, 101, 24, 7, 32, 1, 40, 9, 82, 12, 100, 101, 102, 97, 117, 108, 116, 86, 97,
    108, 117, 101, 18, 31, 10, 11, 111, 110, 101, 111, 102, 95, 105, 110, 100, 101, 120, 24, 9, 32,
    1, 40, 5, 82, 10, 111, 110, 101, 111, 102, 73, 110, 100, 101, 120, 18, 27, 10, 9, 106, 115,
    111, 110, 95, 110, 97, 109, 101, 24, 10, 32, 1, 40, 9, 82, 8, 106, 115, 111, 110, 78, 97, 109,
    101, 18, 55, 10, 7, 111, 112, 116, 105, 111, 110, 115, 24, 8, 32, 1, 40, 11, 50, 29, 46, 103,
    111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 70, 105, 101, 108, 100,
    79, 112, 116, 105, 111, 110, 115, 82, 7, 111, 112, 116, 105, 111, 110, 115, 34, 182, 2, 10, 4,
    84, 121, 112, 101, 18, 15, 10, 11, 84, 89, 80, 69, 95, 68, 79, 85, 66, 76, 69, 16, 1, 18, 14,
    10, 10, 84, 89, 80, 69, 95, 70, 76, 79, 65, 84, 16, 2, 18, 14, 10, 10, 84, 89, 80, 69, 95, 73,
    78, 84, 54, 52, 16, 3, 18, 15, 10, 11, 84, 89, 80, 69, 95, 85, 73, 78, 84, 54, 52, 16, 4, 18,
    14, 10, 10, 84, 89, 80, 69, 95, 73, 78, 84, 51, 50, 16, 5, 18, 16, 10, 12, 84, 89, 80, 69, 95,
    70, 73, 88, 69, 68, 54, 52, 16, 6, 18, 16, 10, 12, 84, 89, 80, 69, 95, 70, 73, 88, 69, 68, 51,
    50, 16, 7, 18, 13, 10, 9, 84, 89, 80, 69, 95, 66, 79, 79, 76, 16, 8, 18, 15, 10, 11, 84, 89,
    80, 69, 95, 83, 84, 82, 73, 78, 71, 16, 9, 18, 14, 10, 10, 84, 89, 80, 69, 95, 71, 82, 79, 85,
    80, 16, 10, 18, 16, 10, 12, 84, 89, 80, 69, 95, 77, 69, 83, 83, 65, 71, 69, 16, 11, 18, 14, 10,
    10, 84, 89, 80, 69, 95, 66, 89, 84, 69, 83, 16, 12, 18, 15, 10, 11, 84, 89, 80, 69, 95, 85, 73,
    78, 84, 51, 50, 16, 13, 18, 13, 10, 9, 84, 89, 80, 69, 95, 69, 78, 85, 77, 16, 14, 18, 17, 10,
    13, 84, 89, 80, 69, 95, 83, 70, 73, 88, 69, 68, 51, 50, 16, 15, 18, 17, 10, 13, 84, 89, 80, 69,
    95, 83, 70, 73, 88, 69, 68, 54, 52, 16, 16, 18, 15, 10, 11, 84, 89, 80, 69, 95, 83, 73, 78, 84,
    51, 50, 16, 17, 18, 15, 10, 11, 84, 89, 80, 69, 95, 83, 73, 78, 84, 54, 52, 16, 18, 34, 67, 10,
    5, 76, 97, 98, 101, 108, 18, 18, 10, 14, 76, 65, 66, 69, 76, 95, 79, 80, 84, 73, 79, 78, 65,
    76, 16, 1, 18, 18, 10, 14, 76, 65, 66, 69, 76, 95, 82, 69, 81, 85, 73, 82, 69, 68, 16, 2, 18,
    18, 10, 14, 76, 65, 66, 69, 76, 95, 82, 69, 80, 69, 65, 84, 69, 68, 16, 3, 34, 99, 10, 20, 79,
    110, 101, 111, 102, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 18,
    18, 10, 4, 110, 97, 109, 101, 24, 1, 32, 1, 40, 9, 82, 4, 110, 97, 109, 101, 18, 55, 10, 7,
    111, 112, 116, 105, 111, 110, 115, 24, 2, 32, 1, 40, 11, 50, 29, 46, 103, 111, 111, 103, 108,
    101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 79, 110, 101, 111, 102, 79, 112, 116, 105,
    111, 110, 115, 82, 7, 111, 112, 116, 105, 111, 110, 115, 34, 227, 2, 10, 19, 69, 110, 117, 109,
    68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 18, 18, 10, 4, 110, 97,
    109, 101, 24, 1, 32, 1, 40, 9, 82, 4, 110, 97, 109, 101, 18, 63, 10, 5, 118, 97, 108, 117, 101,
    24, 2, 32, 3, 40, 11, 50, 41, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111,
    98, 117, 102, 46, 69, 110, 117, 109, 86, 97, 108, 117, 101, 68, 101, 115, 99, 114, 105, 112,
    116, 111, 114, 80, 114, 111, 116, 111, 82, 5, 118, 97, 108, 117, 101, 18, 54, 10, 7, 111, 112,
    116, 105, 111, 110, 115, 24, 3, 32, 1, 40, 11, 50, 28, 46, 103, 111, 111, 103, 108, 101, 46,
    112, 114, 111, 116, 111, 98, 117, 102, 46, 69, 110, 117, 109, 79, 112, 116, 105, 111, 110, 115,
    82, 7, 111, 112, 116, 105, 111, 110, 115, 18, 93, 10, 14, 114, 101, 115, 101, 114, 118, 101,
    100, 95, 114, 97, 110, 103, 101, 24, 4, 32, 3, 40, 11, 50, 54, 46, 103, 111, 111, 103, 108,
    101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 69, 110, 117, 109, 68, 101, 115, 99, 114,
    105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 46, 69, 110, 117, 109, 82, 101, 115, 101, 114,
    118, 101, 100, 82, 97, 110, 103, 101, 82, 13, 114, 101, 115, 101, 114, 118, 101, 100, 82, 97,
    110, 103, 101, 18, 35, 10, 13, 114, 101, 115, 101, 114, 118, 101, 100, 95, 110, 97, 109, 101,
    24, 5, 32, 3, 40, 9, 82, 12, 114, 101, 115, 101, 114, 118, 101, 100, 78, 97, 109, 101, 26, 59,
    10, 17, 69, 110, 117, 109, 82, 101, 115, 101, 114, 118, 101, 100, 82, 97, 110, 103, 101, 18,
    20, 10, 5, 115, 116, 97, 114, 116, 24, 1, 32, 1, 40, 5, 82, 5, 115, 116, 97, 114, 116, 18, 16,
    10, 3, 101, 110, 100, 24, 2, 32, 1, 40, 5, 82, 3, 101, 110, 100, 34, 131, 1, 10, 24, 69, 110,
    117, 109, 86, 97, 108, 117, 101, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111,
    116, 111, 18, 18, 10, 4, 110, 97, 109, 101, 24, 1, 32, 1, 40, 9, 82, 4, 110, 97, 109, 101, 18,
    22, 10, 6, 110, 117, 109, 98, 101, 114, 24, 2, 32, 1, 40, 5, 82, 6, 110, 117, 109, 98, 101,
    114, 18, 59, 10, 7, 111, 112, 116, 105, 111, 110, 115, 24, 3, 32, 1, 40, 11, 50, 33, 46, 103,
    111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 69, 110, 117, 109, 86,
    97, 108, 117, 101, 79, 112, 116, 105, 111, 110, 115, 82, 7, 111, 112, 116, 105, 111, 110, 115,
    34, 167, 1, 10, 22, 83, 101, 114, 118, 105, 99, 101, 68, 101, 115, 99, 114, 105, 112, 116, 111,
    114, 80, 114, 111, 116, 111, 18, 18, 10, 4, 110, 97, 109, 101, 24, 1, 32, 1, 40, 9, 82, 4, 110,
    97, 109, 101, 18, 62, 10, 6, 109, 101, 116, 104, 111, 100, 24, 2, 32, 3, 40, 11, 50, 38, 46,
    103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 77, 101, 116, 104,
    111, 100, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111, 82, 6, 109,
    101, 116, 104, 111, 100, 18, 57, 10, 7, 111, 112, 116, 105, 111, 110, 115, 24, 3, 32, 1, 40,
    11, 50, 31, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46,
    83, 101, 114, 118, 105, 99, 101, 79, 112, 116, 105, 111, 110, 115, 82, 7, 111, 112, 116, 105,
    111, 110, 115, 34, 137, 2, 10, 21, 77, 101, 116, 104, 111, 100, 68, 101, 115, 99, 114, 105,
    112, 116, 111, 114, 80, 114, 111, 116, 111, 18, 18, 10, 4, 110, 97, 109, 101, 24, 1, 32, 1, 40,
    9, 82, 4, 110, 97, 109, 101, 18, 29, 10, 10, 105, 110, 112, 117, 116, 95, 116, 121, 112, 101,
    24, 2, 32, 1, 40, 9, 82, 9, 105, 110, 112, 117, 116, 84, 121, 112, 101, 18, 31, 10, 11, 111,
    117, 116, 112, 117, 116, 95, 116, 121, 112, 101, 24, 3, 32, 1, 40, 9, 82, 10, 111, 117, 116,
    112, 117, 116, 84, 121, 112, 101, 18, 56, 10, 7, 111, 112, 116, 105, 111, 110, 115, 24, 4, 32,
    1, 40, 11, 50, 30, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102,
    46, 77, 101, 116, 104, 111, 100, 79, 112, 116, 105, 111, 110, 115, 82, 7, 111, 112, 116, 105,
    111, 110, 115, 18, 48, 10, 16, 99, 108, 105, 101, 110, 116, 95, 115, 116, 114, 101, 97, 109,
    105, 110, 103, 24, 5, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 82, 15, 99, 108, 105, 101,
    110, 116, 83, 116, 114, 101, 97, 109, 105, 110, 103, 18, 48, 10, 16, 115, 101, 114, 118, 101,
    114, 95, 115, 116, 114, 101, 97, 109, 105, 110, 103, 24, 6, 32, 1, 40, 8, 58, 5, 102, 97, 108,
    115, 101, 82, 15, 115, 101, 114, 118, 101, 114, 83, 116, 114, 101, 97, 109, 105, 110, 103, 34,
    146, 9, 10, 11, 70, 105, 108, 101, 79, 112, 116, 105, 111, 110, 115, 18, 33, 10, 12, 106, 97,
    118, 97, 95, 112, 97, 99, 107, 97, 103, 101, 24, 1, 32, 1, 40, 9, 82, 11, 106, 97, 118, 97, 80,
    97, 99, 107, 97, 103, 101, 18, 48, 10, 20, 106, 97, 118, 97, 95, 111, 117, 116, 101, 114, 95,
    99, 108, 97, 115, 115, 110, 97, 109, 101, 24, 8, 32, 1, 40, 9, 82, 18, 106, 97, 118, 97, 79,
    117, 116, 101, 114, 67, 108, 97, 115, 115, 110, 97, 109, 101, 18, 53, 10, 19, 106, 97, 118, 97,
    95, 109, 117, 108, 116, 105, 112, 108, 101, 95, 102, 105, 108, 101, 115, 24, 10, 32, 1, 40, 8,
    58, 5, 102, 97, 108, 115, 101, 82, 17, 106, 97, 118, 97, 77, 117, 108, 116, 105, 112, 108, 101,
    70, 105, 108, 101, 115, 18, 68, 10, 29, 106, 97, 118, 97, 95, 103, 101, 110, 101, 114, 97, 116,
    101, 95, 101, 113, 117, 97, 108, 115, 95, 97, 110, 100, 95, 104, 97, 115, 104, 24, 20, 32, 1,
    40, 8, 82, 25, 106, 97, 118, 97, 71, 101, 110, 101, 114, 97, 116, 101, 69, 113, 117, 97, 108,
    115, 65, 110, 100, 72, 97, 115, 104, 66, 2, 24, 1, 18, 58, 10, 22, 106, 97, 118, 97, 95, 115,
    116, 114, 105, 110, 103, 95, 99, 104, 101, 99, 107, 95, 117, 116, 102, 56, 24, 27, 32, 1, 40,
    8, 58, 5, 102, 97, 108, 115, 101, 82, 19, 106, 97, 118, 97, 83, 116, 114, 105, 110, 103, 67,
    104, 101, 99, 107, 85, 116, 102, 56, 18, 83, 10, 12, 111, 112, 116, 105, 109, 105, 122, 101,
    95, 102, 111, 114, 24, 9, 32, 1, 40, 14, 50, 41, 46, 103, 111, 111, 103, 108, 101, 46, 112,
    114, 111, 116, 111, 98, 117, 102, 46, 70, 105, 108, 101, 79, 112, 116, 105, 111, 110, 115, 46,
    79, 112, 116, 105, 109, 105, 122, 101, 77, 111, 100, 101, 58, 5, 83, 80, 69, 69, 68, 82, 11,
    111, 112, 116, 105, 109, 105, 122, 101, 70, 111, 114, 18, 29, 10, 10, 103, 111, 95, 112, 97,
    99, 107, 97, 103, 101, 24, 11, 32, 1, 40, 9, 82, 9, 103, 111, 80, 97, 99, 107, 97, 103, 101,
    18, 53, 10, 19, 99, 99, 95, 103, 101, 110, 101, 114, 105, 99, 95, 115, 101, 114, 118, 105, 99,
    101, 115, 24, 16, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 82, 17, 99, 99, 71, 101, 110,
    101, 114, 105, 99, 83, 101, 114, 118, 105, 99, 101, 115, 18, 57, 10, 21, 106, 97, 118, 97, 95,
    103, 101, 110, 101, 114, 105, 99, 95, 115, 101, 114, 118, 105, 99, 101, 115, 24, 17, 32, 1, 40,
    8, 58, 5, 102, 97, 108, 115, 101, 82, 19, 106, 97, 118, 97, 71, 101, 110, 101, 114, 105, 99,
    83, 101, 114, 118, 105, 99, 101, 115, 18, 53, 10, 19, 112, 121, 95, 103, 101, 110, 101, 114,
    105, 99, 95, 115, 101, 114, 118, 105, 99, 101, 115, 24, 18, 32, 1, 40, 8, 58, 5, 102, 97, 108,
    115, 101, 82, 17, 112, 121, 71, 101, 110, 101, 114, 105, 99, 83, 101, 114, 118, 105, 99, 101,
    115, 18, 55, 10, 20, 112, 104, 112, 95, 103, 101, 110, 101, 114, 105, 99, 95, 115, 101, 114,
    118, 105, 99, 101, 115, 24, 42, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 82, 18, 112, 104,
    112, 71, 101, 110, 101, 114, 105, 99, 83, 101, 114, 118, 105, 99, 101, 115, 18, 37, 10, 10,
    100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 24, 23, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115,
    101, 82, 10, 100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 18, 47, 10, 16, 99, 99, 95, 101,
    110, 97, 98, 108, 101, 95, 97, 114, 101, 110, 97, 115, 24, 31, 32, 1, 40, 8, 58, 5, 102, 97,
    108, 115, 101, 82, 14, 99, 99, 69, 110, 97, 98, 108, 101, 65, 114, 101, 110, 97, 115, 18, 42,
    10, 17, 111, 98, 106, 99, 95, 99, 108, 97, 115, 115, 95, 112, 114, 101, 102, 105, 120, 24, 36,
    32, 1, 40, 9, 82, 15, 111, 98, 106, 99, 67, 108, 97, 115, 115, 80, 114, 101, 102, 105, 120, 18,
    41, 10, 16, 99, 115, 104, 97, 114, 112, 95, 110, 97, 109, 101, 115, 112, 97, 99, 101, 24, 37,
    32, 1, 40, 9, 82, 15, 99, 115, 104, 97, 114, 112, 78, 97, 109, 101, 115, 112, 97, 99, 101, 18,
    33, 10, 12, 115, 119, 105, 102, 116, 95, 112, 114, 101, 102, 105, 120, 24, 39, 32, 1, 40, 9,
    82, 11, 115, 119, 105, 102, 116, 80, 114, 101, 102, 105, 120, 18, 40, 10, 16, 112, 104, 112,
    95, 99, 108, 97, 115, 115, 95, 112, 114, 101, 102, 105, 120, 24, 40, 32, 1, 40, 9, 82, 14, 112,
    104, 112, 67, 108, 97, 115, 115, 80, 114, 101, 102, 105, 120, 18, 35, 10, 13, 112, 104, 112,
    95, 110, 97, 109, 101, 115, 112, 97, 99, 101, 24, 41, 32, 1, 40, 9, 82, 12, 112, 104, 112, 78,
    97, 109, 101, 115, 112, 97, 99, 101, 18, 52, 10, 22, 112, 104, 112, 95, 109, 101, 116, 97, 100,
    97, 116, 97, 95, 110, 97, 109, 101, 115, 112, 97, 99, 101, 24, 44, 32, 1, 40, 9, 82, 20, 112,
    104, 112, 77, 101, 116, 97, 100, 97, 116, 97, 78, 97, 109, 101, 115, 112, 97, 99, 101, 18, 33,
    10, 12, 114, 117, 98, 121, 95, 112, 97, 99, 107, 97, 103, 101, 24, 45, 32, 1, 40, 9, 82, 11,
    114, 117, 98, 121, 80, 97, 99, 107, 97, 103, 101, 18, 88, 10, 20, 117, 110, 105, 110, 116, 101,
    114, 112, 114, 101, 116, 101, 100, 95, 111, 112, 116, 105, 111, 110, 24, 231, 7, 32, 3, 40, 11,
    50, 36, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 85,
    110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 82,
    19, 117, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111,
    110, 34, 58, 10, 12, 79, 112, 116, 105, 109, 105, 122, 101, 77, 111, 100, 101, 18, 9, 10, 5,
    83, 80, 69, 69, 68, 16, 1, 18, 13, 10, 9, 67, 79, 68, 69, 95, 83, 73, 90, 69, 16, 2, 18, 16,
    10, 12, 76, 73, 84, 69, 95, 82, 85, 78, 84, 73, 77, 69, 16, 3, 42, 9, 8, 232, 7, 16, 128, 128,
    128, 128, 2, 74, 4, 8, 38, 16, 39, 34, 209, 2, 10, 14, 77, 101, 115, 115, 97, 103, 101, 79,
    112, 116, 105, 111, 110, 115, 18, 60, 10, 23, 109, 101, 115, 115, 97, 103, 101, 95, 115, 101,
    116, 95, 119, 105, 114, 101, 95, 102, 111, 114, 109, 97, 116, 24, 1, 32, 1, 40, 8, 58, 5, 102,
    97, 108, 115, 101, 82, 20, 109, 101, 115, 115, 97, 103, 101, 83, 101, 116, 87, 105, 114, 101,
    70, 111, 114, 109, 97, 116, 18, 76, 10, 31, 110, 111, 95, 115, 116, 97, 110, 100, 97, 114, 100,
    95, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 95, 97, 99, 99, 101, 115, 115, 111, 114,
    24, 2, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 82, 28, 110, 111, 83, 116, 97, 110, 100,
    97, 114, 100, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 65, 99, 99, 101, 115, 115, 111,
    114, 18, 37, 10, 10, 100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 24, 3, 32, 1, 40, 8, 58,
    5, 102, 97, 108, 115, 101, 82, 10, 100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 18, 27, 10,
    9, 109, 97, 112, 95, 101, 110, 116, 114, 121, 24, 7, 32, 1, 40, 8, 82, 8, 109, 97, 112, 69,
    110, 116, 114, 121, 18, 88, 10, 20, 117, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101,
    100, 95, 111, 112, 116, 105, 111, 110, 24, 231, 7, 32, 3, 40, 11, 50, 36, 46, 103, 111, 111,
    103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 85, 110, 105, 110, 116, 101, 114,
    112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 82, 19, 117, 110, 105, 110, 116,
    101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 42, 9, 8, 232, 7, 16, 128,
    128, 128, 128, 2, 74, 4, 8, 8, 16, 9, 74, 4, 8, 9, 16, 10, 34, 226, 3, 10, 12, 70, 105, 101,
    108, 100, 79, 112, 116, 105, 111, 110, 115, 18, 65, 10, 5, 99, 116, 121, 112, 101, 24, 1, 32,
    1, 40, 14, 50, 35, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102,
    46, 70, 105, 101, 108, 100, 79, 112, 116, 105, 111, 110, 115, 46, 67, 84, 121, 112, 101, 58, 6,
    83, 84, 82, 73, 78, 71, 82, 5, 99, 116, 121, 112, 101, 18, 22, 10, 6, 112, 97, 99, 107, 101,
    100, 24, 2, 32, 1, 40, 8, 82, 6, 112, 97, 99, 107, 101, 100, 18, 71, 10, 6, 106, 115, 116, 121,
    112, 101, 24, 6, 32, 1, 40, 14, 50, 36, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111,
    116, 111, 98, 117, 102, 46, 70, 105, 101, 108, 100, 79, 112, 116, 105, 111, 110, 115, 46, 74,
    83, 84, 121, 112, 101, 58, 9, 74, 83, 95, 78, 79, 82, 77, 65, 76, 82, 6, 106, 115, 116, 121,
    112, 101, 18, 25, 10, 4, 108, 97, 122, 121, 24, 5, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101,
    82, 4, 108, 97, 122, 121, 18, 37, 10, 10, 100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 24,
    3, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 82, 10, 100, 101, 112, 114, 101, 99, 97, 116,
    101, 100, 18, 25, 10, 4, 119, 101, 97, 107, 24, 10, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115,
    101, 82, 4, 119, 101, 97, 107, 18, 88, 10, 20, 117, 110, 105, 110, 116, 101, 114, 112, 114,
    101, 116, 101, 100, 95, 111, 112, 116, 105, 111, 110, 24, 231, 7, 32, 3, 40, 11, 50, 36, 46,
    103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 85, 110, 105, 110,
    116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 82, 19, 117, 110,
    105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 34, 47, 10,
    5, 67, 84, 121, 112, 101, 18, 10, 10, 6, 83, 84, 82, 73, 78, 71, 16, 0, 18, 8, 10, 4, 67, 79,
    82, 68, 16, 1, 18, 16, 10, 12, 83, 84, 82, 73, 78, 71, 95, 80, 73, 69, 67, 69, 16, 2, 34, 53,
    10, 6, 74, 83, 84, 121, 112, 101, 18, 13, 10, 9, 74, 83, 95, 78, 79, 82, 77, 65, 76, 16, 0, 18,
    13, 10, 9, 74, 83, 95, 83, 84, 82, 73, 78, 71, 16, 1, 18, 13, 10, 9, 74, 83, 95, 78, 85, 77,
    66, 69, 82, 16, 2, 42, 9, 8, 232, 7, 16, 128, 128, 128, 128, 2, 74, 4, 8, 4, 16, 5, 34, 115,
    10, 12, 79, 110, 101, 111, 102, 79, 112, 116, 105, 111, 110, 115, 18, 88, 10, 20, 117, 110,
    105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 95, 111, 112, 116, 105, 111, 110, 24,
    231, 7, 32, 3, 40, 11, 50, 36, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111,
    98, 117, 102, 46, 85, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116,
    105, 111, 110, 82, 19, 117, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79,
    112, 116, 105, 111, 110, 42, 9, 8, 232, 7, 16, 128, 128, 128, 128, 2, 34, 192, 1, 10, 11, 69,
    110, 117, 109, 79, 112, 116, 105, 111, 110, 115, 18, 31, 10, 11, 97, 108, 108, 111, 119, 95,
    97, 108, 105, 97, 115, 24, 2, 32, 1, 40, 8, 82, 10, 97, 108, 108, 111, 119, 65, 108, 105, 97,
    115, 18, 37, 10, 10, 100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 24, 3, 32, 1, 40, 8, 58,
    5, 102, 97, 108, 115, 101, 82, 10, 100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 18, 88, 10,
    20, 117, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 95, 111, 112, 116, 105,
    111, 110, 24, 231, 7, 32, 3, 40, 11, 50, 36, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114,
    111, 116, 111, 98, 117, 102, 46, 85, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101,
    100, 79, 112, 116, 105, 111, 110, 82, 19, 117, 110, 105, 110, 116, 101, 114, 112, 114, 101,
    116, 101, 100, 79, 112, 116, 105, 111, 110, 42, 9, 8, 232, 7, 16, 128, 128, 128, 128, 2, 74, 4,
    8, 5, 16, 6, 34, 158, 1, 10, 16, 69, 110, 117, 109, 86, 97, 108, 117, 101, 79, 112, 116, 105,
    111, 110, 115, 18, 37, 10, 10, 100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 24, 1, 32, 1,
    40, 8, 58, 5, 102, 97, 108, 115, 101, 82, 10, 100, 101, 112, 114, 101, 99, 97, 116, 101, 100,
    18, 88, 10, 20, 117, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 95, 111, 112,
    116, 105, 111, 110, 24, 231, 7, 32, 3, 40, 11, 50, 36, 46, 103, 111, 111, 103, 108, 101, 46,
    112, 114, 111, 116, 111, 98, 117, 102, 46, 85, 110, 105, 110, 116, 101, 114, 112, 114, 101,
    116, 101, 100, 79, 112, 116, 105, 111, 110, 82, 19, 117, 110, 105, 110, 116, 101, 114, 112,
    114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 42, 9, 8, 232, 7, 16, 128, 128, 128, 128,
    2, 34, 156, 1, 10, 14, 83, 101, 114, 118, 105, 99, 101, 79, 112, 116, 105, 111, 110, 115, 18,
    37, 10, 10, 100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 24, 33, 32, 1, 40, 8, 58, 5, 102,
    97, 108, 115, 101, 82, 10, 100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 18, 88, 10, 20, 117,
    110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 95, 111, 112, 116, 105, 111, 110,
    24, 231, 7, 32, 3, 40, 11, 50, 36, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116,
    111, 98, 117, 102, 46, 85, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112,
    116, 105, 111, 110, 82, 19, 117, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100,
    79, 112, 116, 105, 111, 110, 42, 9, 8, 232, 7, 16, 128, 128, 128, 128, 2, 34, 224, 2, 10, 13,
    77, 101, 116, 104, 111, 100, 79, 112, 116, 105, 111, 110, 115, 18, 37, 10, 10, 100, 101, 112,
    114, 101, 99, 97, 116, 101, 100, 24, 33, 32, 1, 40, 8, 58, 5, 102, 97, 108, 115, 101, 82, 10,
    100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 18, 113, 10, 17, 105, 100, 101, 109, 112, 111,
    116, 101, 110, 99, 121, 95, 108, 101, 118, 101, 108, 24, 34, 32, 1, 40, 14, 50, 47, 46, 103,
    111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 77, 101, 116, 104, 111,
    100, 79, 112, 116, 105, 111, 110, 115, 46, 73, 100, 101, 109, 112, 111, 116, 101, 110, 99, 121,
    76, 101, 118, 101, 108, 58, 19, 73, 68, 69, 77, 80, 79, 84, 69, 78, 67, 89, 95, 85, 78, 75, 78,
    79, 87, 78, 82, 16, 105, 100, 101, 109, 112, 111, 116, 101, 110, 99, 121, 76, 101, 118, 101,
    108, 18, 88, 10, 20, 117, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 95, 111,
    112, 116, 105, 111, 110, 24, 231, 7, 32, 3, 40, 11, 50, 36, 46, 103, 111, 111, 103, 108, 101,
    46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 85, 110, 105, 110, 116, 101, 114, 112, 114, 101,
    116, 101, 100, 79, 112, 116, 105, 111, 110, 82, 19, 117, 110, 105, 110, 116, 101, 114, 112,
    114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 34, 80, 10, 16, 73, 100, 101, 109, 112,
    111, 116, 101, 110, 99, 121, 76, 101, 118, 101, 108, 18, 23, 10, 19, 73, 68, 69, 77, 80, 79,
    84, 69, 78, 67, 89, 95, 85, 78, 75, 78, 79, 87, 78, 16, 0, 18, 19, 10, 15, 78, 79, 95, 83, 73,
    68, 69, 95, 69, 70, 70, 69, 67, 84, 83, 16, 1, 18, 14, 10, 10, 73, 68, 69, 77, 80, 79, 84, 69,
    78, 84, 16, 2, 42, 9, 8, 232, 7, 16, 128, 128, 128, 128, 2, 34, 154, 3, 10, 19, 85, 110, 105,
    110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 79, 112, 116, 105, 111, 110, 18, 65, 10, 4,
    110, 97, 109, 101, 24, 2, 32, 3, 40, 11, 50, 45, 46, 103, 111, 111, 103, 108, 101, 46, 112,
    114, 111, 116, 111, 98, 117, 102, 46, 85, 110, 105, 110, 116, 101, 114, 112, 114, 101, 116,
    101, 100, 79, 112, 116, 105, 111, 110, 46, 78, 97, 109, 101, 80, 97, 114, 116, 82, 4, 110, 97,
    109, 101, 18, 41, 10, 16, 105, 100, 101, 110, 116, 105, 102, 105, 101, 114, 95, 118, 97, 108,
    117, 101, 24, 3, 32, 1, 40, 9, 82, 15, 105, 100, 101, 110, 116, 105, 102, 105, 101, 114, 86,
    97, 108, 117, 101, 18, 44, 10, 18, 112, 111, 115, 105, 116, 105, 118, 101, 95, 105, 110, 116,
    95, 118, 97, 108, 117, 101, 24, 4, 32, 1, 40, 4, 82, 16, 112, 111, 115, 105, 116, 105, 118,
    101, 73, 110, 116, 86, 97, 108, 117, 101, 18, 44, 10, 18, 110, 101, 103, 97, 116, 105, 118,
    101, 95, 105, 110, 116, 95, 118, 97, 108, 117, 101, 24, 5, 32, 1, 40, 3, 82, 16, 110, 101, 103,
    97, 116, 105, 118, 101, 73, 110, 116, 86, 97, 108, 117, 101, 18, 33, 10, 12, 100, 111, 117, 98,
    108, 101, 95, 118, 97, 108, 117, 101, 24, 6, 32, 1, 40, 1, 82, 11, 100, 111, 117, 98, 108, 101,
    86, 97, 108, 117, 101, 18, 33, 10, 12, 115, 116, 114, 105, 110, 103, 95, 118, 97, 108, 117,
    101, 24, 7, 32, 1, 40, 12, 82, 11, 115, 116, 114, 105, 110, 103, 86, 97, 108, 117, 101, 18, 39,
    10, 15, 97, 103, 103, 114, 101, 103, 97, 116, 101, 95, 118, 97, 108, 117, 101, 24, 8, 32, 1,
    40, 9, 82, 14, 97, 103, 103, 114, 101, 103, 97, 116, 101, 86, 97, 108, 117, 101, 26, 74, 10, 8,
    78, 97, 109, 101, 80, 97, 114, 116, 18, 27, 10, 9, 110, 97, 109, 101, 95, 112, 97, 114, 116,
    24, 1, 32, 2, 40, 9, 82, 8, 110, 97, 109, 101, 80, 97, 114, 116, 18, 33, 10, 12, 105, 115, 95,
    101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 2, 32, 2, 40, 8, 82, 11, 105, 115, 69, 120,
    116, 101, 110, 115, 105, 111, 110, 34, 167, 2, 10, 14, 83, 111, 117, 114, 99, 101, 67, 111,
    100, 101, 73, 110, 102, 111, 18, 68, 10, 8, 108, 111, 99, 97, 116, 105, 111, 110, 24, 1, 32, 3,
    40, 11, 50, 40, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102,
    46, 83, 111, 117, 114, 99, 101, 67, 111, 100, 101, 73, 110, 102, 111, 46, 76, 111, 99, 97, 116,
    105, 111, 110, 82, 8, 108, 111, 99, 97, 116, 105, 111, 110, 26, 206, 1, 10, 8, 76, 111, 99, 97,
    116, 105, 111, 110, 18, 22, 10, 4, 112, 97, 116, 104, 24, 1, 32, 3, 40, 5, 82, 4, 112, 97, 116,
    104, 66, 2, 16, 1, 18, 22, 10, 4, 115, 112, 97, 110, 24, 2, 32, 3, 40, 5, 82, 4, 115, 112, 97,
    110, 66, 2, 16, 1, 18, 41, 10, 16, 108, 101, 97, 100, 105, 110, 103, 95, 99, 111, 109, 109,
    101, 110, 116, 115, 24, 3, 32, 1, 40, 9, 82, 15, 108, 101, 97, 100, 105, 110, 103, 67, 111,
    109, 109, 101, 110, 116, 115, 18, 43, 10, 17, 116, 114, 97, 105, 108, 105, 110, 103, 95, 99,
    111, 109, 109, 101, 110, 116, 115, 24, 4, 32, 1, 40, 9, 82, 16, 116, 114, 97, 105, 108, 105,
    110, 103, 67, 111, 109, 109, 101, 110, 116, 115, 18, 58, 10, 25, 108, 101, 97, 100, 105, 110,
    103, 95, 100, 101, 116, 97, 99, 104, 101, 100, 95, 99, 111, 109, 109, 101, 110, 116, 115, 24,
    6, 32, 3, 40, 9, 82, 23, 108, 101, 97, 100, 105, 110, 103, 68, 101, 116, 97, 99, 104, 101, 100,
    67, 111, 109, 109, 101, 110, 116, 115, 34, 209, 1, 10, 17, 71, 101, 110, 101, 114, 97, 116,
    101, 100, 67, 111, 100, 101, 73, 110, 102, 111, 18, 77, 10, 10, 97, 110, 110, 111, 116, 97,
    116, 105, 111, 110, 24, 1, 32, 3, 40, 11, 50, 45, 46, 103, 111, 111, 103, 108, 101, 46, 112,
    114, 111, 116, 111, 98, 117, 102, 46, 71, 101, 110, 101, 114, 97, 116, 101, 100, 67, 111, 100,
    101, 73, 110, 102, 111, 46, 65, 110, 110, 111, 116, 97, 116, 105, 111, 110, 82, 10, 97, 110,
    110, 111, 116, 97, 116, 105, 111, 110, 26, 109, 10, 10, 65, 110, 110, 111, 116, 97, 116, 105,
    111, 110, 18, 22, 10, 4, 112, 97, 116, 104, 24, 1, 32, 3, 40, 5, 82, 4, 112, 97, 116, 104, 66,
    2, 16, 1, 18, 31, 10, 11, 115, 111, 117, 114, 99, 101, 95, 102, 105, 108, 101, 24, 2, 32, 1,
    40, 9, 82, 10, 115, 111, 117, 114, 99, 101, 70, 105, 108, 101, 18, 20, 10, 5, 98, 101, 103,
    105, 110, 24, 3, 32, 1, 40, 5, 82, 5, 98, 101, 103, 105, 110, 18, 16, 10, 3, 101, 110, 100, 24,
    4, 32, 1, 40, 5, 82, 3, 101, 110, 100, 66, 143, 1, 10, 19, 99, 111, 109, 46, 103, 111, 111,
    103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 66, 16, 68, 101, 115, 99, 114, 105,
    112, 116, 111, 114, 80, 114, 111, 116, 111, 115, 72, 1, 90, 62, 103, 105, 116, 104, 117, 98,
    46, 99, 111, 109, 47, 103, 111, 108, 97, 110, 103, 47, 112, 114, 111, 116, 111, 98, 117, 102,
    47, 112, 114, 111, 116, 111, 99, 45, 103, 101, 110, 45, 103, 111, 47, 100, 101, 115, 99, 114,
    105, 112, 116, 111, 114, 59, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 248, 1, 1, 162,
    2, 3, 71, 80, 66, 170, 2, 26, 71, 111, 111, 103, 108, 101, 46, 80, 114, 111, 116, 111, 98, 117,
    102, 46, 82, 101, 102, 108, 101, 99, 116, 105, 111, 110,
];
pub mod google_protobuf_descriptor_proto {
    pub fn file() -> &'static crate::reflect::FileDescriptor<'static> {
        super::pool()
            .find_file_by_name("google/protobuf/descriptor.proto")
            .unwrap()
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct FileDescriptorSet {
        file: crate::collections::RepeatedField<self::FileDescriptorProto>,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::FileDescriptorSet {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => self
                        .file
                        .add_entries(input, &self::file_descriptor_set::FILE_CODEC)?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            size = size.checked_add(
                self.file()
                    .calculate_size(&self::file_descriptor_set::FILE_CODEC)?,
            )?;
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            self.file()
                .write_to(output, &self::file_descriptor_set::FILE_CODEC)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.file.is_initialized() {
                return false;
            }
            true
        }
    }
    impl crate::LiteMessage for self::FileDescriptorSet {
        fn merge(&mut self, other: &Self) {
            self.file.merge(&other.file);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::FileDescriptorSet {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[0]
        }
    }
    impl self::FileDescriptorSet {
        pub const FILE_FIELD_NUMBER: i32 = 1;
        pub fn file(&self) -> &crate::collections::RepeatedField<self::FileDescriptorProto> {
            &self.file
        }
        pub fn file_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::FileDescriptorProto> {
            &mut self.file
        }
    }
    pub(in super::super) mod file_descriptor_set {
        pub(super) static FILE_CODEC: crate::Codec<self::super::FileDescriptorProto> =
            crate::Codec::message(10);
        pub(in super::super) static FILE_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::FileDescriptorSet,
            crate::collections::RepeatedField<self::super::FileDescriptorProto>,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::FileDescriptorSet::file,
            get_mut: self::super::FileDescriptorSet::file_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct FileDescriptorProto {
        name: ::std::option::Option<::std::string::String>,
        package: ::std::option::Option<::std::string::String>,
        dependency: crate::collections::RepeatedField<::std::string::String>,
        public_dependency: crate::collections::RepeatedField<i32>,
        weak_dependency: crate::collections::RepeatedField<i32>,
        message_type: crate::collections::RepeatedField<self::DescriptorProto>,
        enum_type: crate::collections::RepeatedField<self::EnumDescriptorProto>,
        service: crate::collections::RepeatedField<self::ServiceDescriptorProto>,
        extension: crate::collections::RepeatedField<self::FieldDescriptorProto>,
        options: ::std::option::Option<::std::boxed::Box<self::FileOptions>>,
        source_code_info: ::std::option::Option<::std::boxed::Box<self::SourceCodeInfo>>,
        syntax: ::std::option::Option<::std::string::String>,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::FileDescriptorProto {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => self.set_name(input.read_string()?),
                    18 => self.set_package(input.read_string()?),
                    26 => self
                        .dependency
                        .add_entries(input, &self::file_descriptor_proto::DEPENDENCY_CODEC)?,
                    80 | 82 => self.public_dependency.add_entries(
                        input,
                        &self::file_descriptor_proto::PUBLIC_DEPENDENCY_CODEC,
                    )?,
                    88 | 90 => self
                        .weak_dependency
                        .add_entries(input, &self::file_descriptor_proto::WEAK_DEPENDENCY_CODEC)?,
                    34 => self
                        .message_type
                        .add_entries(input, &self::file_descriptor_proto::MESSAGE_TYPE_CODEC)?,
                    42 => self
                        .enum_type
                        .add_entries(input, &self::file_descriptor_proto::ENUM_TYPE_CODEC)?,
                    50 => self
                        .service
                        .add_entries(input, &self::file_descriptor_proto::SERVICE_CODEC)?,
                    58 => self
                        .extension
                        .add_entries(input, &self::file_descriptor_proto::EXTENSION_CODEC)?,
                    66 => input.read_extension_message(self.options_mut())?,
                    74 => input.read_message(self.source_code_info_mut())?,
                    98 => self.set_syntax(input.read_string()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if let ::std::option::Option::Some(name) = self.name_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(name)?)?;
            }
            if let ::std::option::Option::Some(package) = self.package_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(package)?)?;
            }
            size = size.checked_add(
                self.dependency()
                    .calculate_size(&self::file_descriptor_proto::DEPENDENCY_CODEC)?,
            )?;
            size = size.checked_add(
                self.public_dependency()
                    .calculate_size(&self::file_descriptor_proto::PUBLIC_DEPENDENCY_CODEC)?,
            )?;
            size = size.checked_add(
                self.weak_dependency()
                    .calculate_size(&self::file_descriptor_proto::WEAK_DEPENDENCY_CODEC)?,
            )?;
            size = size.checked_add(
                self.message_type()
                    .calculate_size(&self::file_descriptor_proto::MESSAGE_TYPE_CODEC)?,
            )?;
            size = size.checked_add(
                self.enum_type()
                    .calculate_size(&self::file_descriptor_proto::ENUM_TYPE_CODEC)?,
            )?;
            size = size.checked_add(
                self.service()
                    .calculate_size(&self::file_descriptor_proto::SERVICE_CODEC)?,
            )?;
            size = size.checked_add(
                self.extension()
                    .calculate_size(&self::file_descriptor_proto::EXTENSION_CODEC)?,
            )?;
            if let ::std::option::Option::Some(options) = self.options() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::extension_message(options)?)?;
            }
            if let ::std::option::Option::Some(source_code_info) = self.source_code_info() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::message(source_code_info)?)?;
            }
            if let ::std::option::Option::Some(syntax) = self.syntax_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(syntax)?)?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if let ::std::option::Option::Some(name) = self.name_option() {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
            if let ::std::option::Option::Some(package) = self.package_option() {
                output.write_raw_tag_bytes(&[18])?;
                output.write_string(package)?;
            }
            self.dependency()
                .write_to(output, &self::file_descriptor_proto::DEPENDENCY_CODEC)?;
            self.public_dependency().write_to(
                output,
                &self::file_descriptor_proto::PUBLIC_DEPENDENCY_CODEC,
            )?;
            self.weak_dependency()
                .write_to(output, &self::file_descriptor_proto::WEAK_DEPENDENCY_CODEC)?;
            self.message_type()
                .write_to(output, &self::file_descriptor_proto::MESSAGE_TYPE_CODEC)?;
            self.enum_type()
                .write_to(output, &self::file_descriptor_proto::ENUM_TYPE_CODEC)?;
            self.service()
                .write_to(output, &self::file_descriptor_proto::SERVICE_CODEC)?;
            self.extension()
                .write_to(output, &self::file_descriptor_proto::EXTENSION_CODEC)?;
            if let ::std::option::Option::Some(options) = self.options() {
                output.write_raw_tag_bytes(&[66])?;
                output.write_extension_message(options)?;
            }
            if let ::std::option::Option::Some(source_code_info) = self.source_code_info() {
                output.write_raw_tag_bytes(&[74])?;
                output.write_message(source_code_info)?;
            }
            if let ::std::option::Option::Some(syntax) = self.syntax_option() {
                output.write_raw_tag_bytes(&[98])?;
                output.write_string(syntax)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.message_type.is_initialized() {
                return false;
            }
            if !self.enum_type.is_initialized() {
                return false;
            }
            if !self.service.is_initialized() {
                return false;
            }
            if !self.extension.is_initialized() {
                return false;
            }
            if let ::std::option::Option::Some(options) = self.options() {
                if !crate::CodedMessage::is_initialized(options) {
                    return false;
                }
            }
            if let ::std::option::Option::Some(source_code_info) = self.source_code_info() {
                if !crate::CodedMessage::is_initialized(source_code_info) {
                    return false;
                }
            }
            true
        }
    }
    impl crate::LiteMessage for self::FileDescriptorProto {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(name) = other.name_option() {
                self.set_name(::std::clone::Clone::clone(name));
            }
            if let ::std::option::Option::Some(package) = other.package_option() {
                self.set_package(::std::clone::Clone::clone(package));
            }
            self.dependency.merge(&other.dependency);
            self.public_dependency.merge(&other.public_dependency);
            self.weak_dependency.merge(&other.weak_dependency);
            self.message_type.merge(&other.message_type);
            self.enum_type.merge(&other.enum_type);
            self.service.merge(&other.service);
            self.extension.merge(&other.extension);
            if let ::std::option::Option::Some(options) = &other.options() {
                crate::LiteMessage::merge(self.options_mut(), options);
            }
            if let ::std::option::Option::Some(source_code_info) = &other.source_code_info() {
                crate::LiteMessage::merge(self.source_code_info_mut(), source_code_info);
            }
            if let ::std::option::Option::Some(syntax) = other.syntax_option() {
                self.set_syntax(::std::clone::Clone::clone(syntax));
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::FileDescriptorProto {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[1]
        }
    }
    impl self::FileDescriptorProto {
        pub const NAME_FIELD_NUMBER: i32 = 1;
        pub const NAME_DEFAULT_VALUE: &'static str = "";
        pub fn name(&self) -> &str {
            self.name
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::NAME_DEFAULT_VALUE)
        }
        pub fn name_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.name.as_ref()
        }
        pub fn name_mut(&mut self) -> &mut ::std::string::String {
            self.name
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }
        pub fn set_name(&mut self, value: ::std::string::String) {
            self.name = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_name(&mut self) -> ::std::option::Option<::std::string::String> {
            self.name.take()
        }
        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }
        pub const PACKAGE_FIELD_NUMBER: i32 = 2;
        pub const PACKAGE_DEFAULT_VALUE: &'static str = "";
        pub fn package(&self) -> &str {
            self.package
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::PACKAGE_DEFAULT_VALUE)
        }
        pub fn package_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.package.as_ref()
        }
        pub fn package_mut(&mut self) -> &mut ::std::string::String {
            self.package
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_package(&self) -> bool {
            self.package.is_some()
        }
        pub fn set_package(&mut self, value: ::std::string::String) {
            self.package = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_package(&mut self) -> ::std::option::Option<::std::string::String> {
            self.package.take()
        }
        pub fn clear_package(&mut self) {
            self.package = ::std::option::Option::None;
        }
        pub const DEPENDENCY_FIELD_NUMBER: i32 = 3;
        pub fn dependency(&self) -> &crate::collections::RepeatedField<::std::string::String> {
            &self.dependency
        }
        pub fn dependency_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<::std::string::String> {
            &mut self.dependency
        }
        pub const PUBLIC_DEPENDENCY_FIELD_NUMBER: i32 = 10;
        pub fn public_dependency(&self) -> &crate::collections::RepeatedField<i32> {
            &self.public_dependency
        }
        pub fn public_dependency_mut(&mut self) -> &mut crate::collections::RepeatedField<i32> {
            &mut self.public_dependency
        }
        pub const WEAK_DEPENDENCY_FIELD_NUMBER: i32 = 11;
        pub fn weak_dependency(&self) -> &crate::collections::RepeatedField<i32> {
            &self.weak_dependency
        }
        pub fn weak_dependency_mut(&mut self) -> &mut crate::collections::RepeatedField<i32> {
            &mut self.weak_dependency
        }
        pub const MESSAGE_TYPE_FIELD_NUMBER: i32 = 4;
        pub fn message_type(&self) -> &crate::collections::RepeatedField<self::DescriptorProto> {
            &self.message_type
        }
        pub fn message_type_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::DescriptorProto> {
            &mut self.message_type
        }
        pub const ENUM_TYPE_FIELD_NUMBER: i32 = 5;
        pub fn enum_type(&self) -> &crate::collections::RepeatedField<self::EnumDescriptorProto> {
            &self.enum_type
        }
        pub fn enum_type_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::EnumDescriptorProto> {
            &mut self.enum_type
        }
        pub const SERVICE_FIELD_NUMBER: i32 = 6;
        pub fn service(&self) -> &crate::collections::RepeatedField<self::ServiceDescriptorProto> {
            &self.service
        }
        pub fn service_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::ServiceDescriptorProto> {
            &mut self.service
        }
        pub const EXTENSION_FIELD_NUMBER: i32 = 7;
        pub fn extension(&self) -> &crate::collections::RepeatedField<self::FieldDescriptorProto> {
            &self.extension
        }
        pub fn extension_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::FieldDescriptorProto> {
            &mut self.extension
        }
        pub const OPTIONS_FIELD_NUMBER: i32 = 8;
        pub fn options(&self) -> ::std::option::Option<&self::FileOptions> {
            self.options.as_ref().map(|v| &**v)
        }
        pub fn options_mut(&mut self) -> &mut self::FileOptions {
            self.options
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_options(&self) -> bool {
            self.options.is_some()
        }
        pub fn set_options(&mut self, value: self::FileOptions) {
            self.options = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_options(&mut self) -> ::std::option::Option<self::FileOptions> {
            self.options.take().map(|v| *v)
        }
        pub fn clear_options(&mut self) {
            self.options = ::std::option::Option::None;
        }
        pub const SOURCE_CODE_INFO_FIELD_NUMBER: i32 = 9;
        pub fn source_code_info(&self) -> ::std::option::Option<&self::SourceCodeInfo> {
            self.source_code_info.as_ref().map(|v| &**v)
        }
        pub fn source_code_info_mut(&mut self) -> &mut self::SourceCodeInfo {
            self.source_code_info
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_source_code_info(&self) -> bool {
            self.source_code_info.is_some()
        }
        pub fn set_source_code_info(&mut self, value: self::SourceCodeInfo) {
            self.source_code_info = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_source_code_info(&mut self) -> ::std::option::Option<self::SourceCodeInfo> {
            self.source_code_info.take().map(|v| *v)
        }
        pub fn clear_source_code_info(&mut self) {
            self.source_code_info = ::std::option::Option::None;
        }
        pub const SYNTAX_FIELD_NUMBER: i32 = 12;
        pub const SYNTAX_DEFAULT_VALUE: &'static str = "";
        pub fn syntax(&self) -> &str {
            self.syntax
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::SYNTAX_DEFAULT_VALUE)
        }
        pub fn syntax_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.syntax.as_ref()
        }
        pub fn syntax_mut(&mut self) -> &mut ::std::string::String {
            self.syntax
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_syntax(&self) -> bool {
            self.syntax.is_some()
        }
        pub fn set_syntax(&mut self, value: ::std::string::String) {
            self.syntax = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_syntax(&mut self) -> ::std::option::Option<::std::string::String> {
            self.syntax.take()
        }
        pub fn clear_syntax(&mut self) {
            self.syntax = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod file_descriptor_proto {
        pub(super) static DEPENDENCY_CODEC: crate::Codec<::std::string::String> =
            crate::Codec::string(26);
        pub(super) static PUBLIC_DEPENDENCY_CODEC: crate::Codec<i32> = crate::Codec::int32(80);
        pub(super) static WEAK_DEPENDENCY_CODEC: crate::Codec<i32> = crate::Codec::int32(88);
        pub(super) static MESSAGE_TYPE_CODEC: crate::Codec<self::super::DescriptorProto> =
            crate::Codec::message(34);
        pub(super) static ENUM_TYPE_CODEC: crate::Codec<self::super::EnumDescriptorProto> =
            crate::Codec::message(42);
        pub(super) static SERVICE_CODEC: crate::Codec<self::super::ServiceDescriptorProto> =
            crate::Codec::message(50);
        pub(super) static EXTENSION_CODEC: crate::Codec<self::super::FieldDescriptorProto> =
            crate::Codec::message(58);
        pub(in super::super) static NAME_REFLECTOR: crate::reflect::access::VerboseFieldAccessor<
            self::super::FileDescriptorProto,
            ::std::string::String,
        > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FileDescriptorProto::name_option,
            get_mut: self::super::FileDescriptorProto::name_mut,
            set: self::super::FileDescriptorProto::set_name,
            take: self::super::FileDescriptorProto::take_name,
            clear: self::super::FileDescriptorProto::clear_name,
        };
        pub(in super::super) static PACKAGE_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::FileDescriptorProto,
                ::std::string::String,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FileDescriptorProto::package_option,
            get_mut: self::super::FileDescriptorProto::package_mut,
            set: self::super::FileDescriptorProto::set_package,
            take: self::super::FileDescriptorProto::take_package,
            clear: self::super::FileDescriptorProto::clear_package,
        };
        pub(in super::super) static DEPENDENCY_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::FileDescriptorProto,
                crate::collections::RepeatedField<::std::string::String>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::FileDescriptorProto::dependency,
            get_mut: self::super::FileDescriptorProto::dependency_mut,
        };
        pub(in super::super) static PUBLIC_DEPENDENCY_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::FileDescriptorProto,
                crate::collections::RepeatedField<i32>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::FileDescriptorProto::public_dependency,
            get_mut: self::super::FileDescriptorProto::public_dependency_mut,
        };
        pub(in super::super) static WEAK_DEPENDENCY_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::FileDescriptorProto,
                crate::collections::RepeatedField<i32>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::FileDescriptorProto::weak_dependency,
            get_mut: self::super::FileDescriptorProto::weak_dependency_mut,
        };
        pub(in super::super) static MESSAGE_TYPE_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::FileDescriptorProto,
                crate::collections::RepeatedField<self::super::DescriptorProto>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::FileDescriptorProto::message_type,
            get_mut: self::super::FileDescriptorProto::message_type_mut,
        };
        pub(in super::super) static ENUM_TYPE_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::FileDescriptorProto,
                crate::collections::RepeatedField<self::super::EnumDescriptorProto>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::FileDescriptorProto::enum_type,
            get_mut: self::super::FileDescriptorProto::enum_type_mut,
        };
        pub(in super::super) static SERVICE_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::FileDescriptorProto,
            crate::collections::RepeatedField<self::super::ServiceDescriptorProto>,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::FileDescriptorProto::service,
            get_mut: self::super::FileDescriptorProto::service_mut,
        };
        pub(in super::super) static EXTENSION_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::FileDescriptorProto,
                crate::collections::RepeatedField<self::super::FieldDescriptorProto>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::FileDescriptorProto::extension,
            get_mut: self::super::FileDescriptorProto::extension_mut,
        };
        pub(in super::super) static OPTIONS_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::FileDescriptorProto,
                self::super::FileOptions,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FileDescriptorProto::options,
            get_mut: self::super::FileDescriptorProto::options_mut,
            set: self::super::FileDescriptorProto::set_options,
            take: self::super::FileDescriptorProto::take_options,
            clear: self::super::FileDescriptorProto::clear_options,
        };
        pub(in super::super) static SOURCE_CODE_INFO_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::FileDescriptorProto,
                self::super::SourceCodeInfo,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FileDescriptorProto::source_code_info,
            get_mut: self::super::FileDescriptorProto::source_code_info_mut,
            set: self::super::FileDescriptorProto::set_source_code_info,
            take: self::super::FileDescriptorProto::take_source_code_info,
            clear: self::super::FileDescriptorProto::clear_source_code_info,
        };
        pub(in super::super) static SYNTAX_REFLECTOR: crate::reflect::access::VerboseFieldAccessor<
            self::super::FileDescriptorProto,
            ::std::string::String,
        > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FileDescriptorProto::syntax_option,
            get_mut: self::super::FileDescriptorProto::syntax_mut,
            set: self::super::FileDescriptorProto::set_syntax,
            take: self::super::FileDescriptorProto::take_syntax,
            clear: self::super::FileDescriptorProto::clear_syntax,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct DescriptorProto {
        name: ::std::option::Option<::std::string::String>,
        field: crate::collections::RepeatedField<self::FieldDescriptorProto>,
        extension: crate::collections::RepeatedField<self::FieldDescriptorProto>,
        nested_type: crate::collections::RepeatedField<self::DescriptorProto>,
        enum_type: crate::collections::RepeatedField<self::EnumDescriptorProto>,
        extension_range: crate::collections::RepeatedField<self::descriptor_proto::ExtensionRange>,
        oneof_decl: crate::collections::RepeatedField<self::OneofDescriptorProto>,
        options: ::std::option::Option<::std::boxed::Box<self::MessageOptions>>,
        reserved_range: crate::collections::RepeatedField<self::descriptor_proto::ReservedRange>,
        reserved_name: crate::collections::RepeatedField<::std::string::String>,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::DescriptorProto {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => self.set_name(input.read_string()?),
                    18 => self
                        .field
                        .add_entries(input, &self::descriptor_proto::FIELD_CODEC)?,
                    50 => self
                        .extension
                        .add_entries(input, &self::descriptor_proto::EXTENSION_CODEC)?,
                    26 => self
                        .nested_type
                        .add_entries(input, &self::descriptor_proto::NESTED_TYPE_CODEC)?,
                    34 => self
                        .enum_type
                        .add_entries(input, &self::descriptor_proto::ENUM_TYPE_CODEC)?,
                    42 => self
                        .extension_range
                        .add_entries(input, &self::descriptor_proto::EXTENSION_RANGE_CODEC)?,
                    66 => self
                        .oneof_decl
                        .add_entries(input, &self::descriptor_proto::ONEOF_DECL_CODEC)?,
                    58 => input.read_extension_message(self.options_mut())?,
                    74 => self
                        .reserved_range
                        .add_entries(input, &self::descriptor_proto::RESERVED_RANGE_CODEC)?,
                    82 => self
                        .reserved_name
                        .add_entries(input, &self::descriptor_proto::RESERVED_NAME_CODEC)?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if let ::std::option::Option::Some(name) = self.name_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(name)?)?;
            }
            size = size.checked_add(
                self.field()
                    .calculate_size(&self::descriptor_proto::FIELD_CODEC)?,
            )?;
            size = size.checked_add(
                self.extension()
                    .calculate_size(&self::descriptor_proto::EXTENSION_CODEC)?,
            )?;
            size = size.checked_add(
                self.nested_type()
                    .calculate_size(&self::descriptor_proto::NESTED_TYPE_CODEC)?,
            )?;
            size = size.checked_add(
                self.enum_type()
                    .calculate_size(&self::descriptor_proto::ENUM_TYPE_CODEC)?,
            )?;
            size = size.checked_add(
                self.extension_range()
                    .calculate_size(&self::descriptor_proto::EXTENSION_RANGE_CODEC)?,
            )?;
            size = size.checked_add(
                self.oneof_decl()
                    .calculate_size(&self::descriptor_proto::ONEOF_DECL_CODEC)?,
            )?;
            if let ::std::option::Option::Some(options) = self.options() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::extension_message(options)?)?;
            }
            size = size.checked_add(
                self.reserved_range()
                    .calculate_size(&self::descriptor_proto::RESERVED_RANGE_CODEC)?,
            )?;
            size = size.checked_add(
                self.reserved_name()
                    .calculate_size(&self::descriptor_proto::RESERVED_NAME_CODEC)?,
            )?;
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if let ::std::option::Option::Some(name) = self.name_option() {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
            self.field()
                .write_to(output, &self::descriptor_proto::FIELD_CODEC)?;
            self.extension()
                .write_to(output, &self::descriptor_proto::EXTENSION_CODEC)?;
            self.nested_type()
                .write_to(output, &self::descriptor_proto::NESTED_TYPE_CODEC)?;
            self.enum_type()
                .write_to(output, &self::descriptor_proto::ENUM_TYPE_CODEC)?;
            self.extension_range()
                .write_to(output, &self::descriptor_proto::EXTENSION_RANGE_CODEC)?;
            self.oneof_decl()
                .write_to(output, &self::descriptor_proto::ONEOF_DECL_CODEC)?;
            if let ::std::option::Option::Some(options) = self.options() {
                output.write_raw_tag_bytes(&[58])?;
                output.write_extension_message(options)?;
            }
            self.reserved_range()
                .write_to(output, &self::descriptor_proto::RESERVED_RANGE_CODEC)?;
            self.reserved_name()
                .write_to(output, &self::descriptor_proto::RESERVED_NAME_CODEC)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.field.is_initialized() {
                return false;
            }
            if !self.extension.is_initialized() {
                return false;
            }
            if !self.nested_type.is_initialized() {
                return false;
            }
            if !self.enum_type.is_initialized() {
                return false;
            }
            if !self.extension_range.is_initialized() {
                return false;
            }
            if !self.oneof_decl.is_initialized() {
                return false;
            }
            if let ::std::option::Option::Some(options) = self.options() {
                if !crate::CodedMessage::is_initialized(options) {
                    return false;
                }
            }
            if !self.reserved_range.is_initialized() {
                return false;
            }
            true
        }
    }
    impl crate::LiteMessage for self::DescriptorProto {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(name) = other.name_option() {
                self.set_name(::std::clone::Clone::clone(name));
            }
            self.field.merge(&other.field);
            self.extension.merge(&other.extension);
            self.nested_type.merge(&other.nested_type);
            self.enum_type.merge(&other.enum_type);
            self.extension_range.merge(&other.extension_range);
            self.oneof_decl.merge(&other.oneof_decl);
            if let ::std::option::Option::Some(options) = &other.options() {
                crate::LiteMessage::merge(self.options_mut(), options);
            }
            self.reserved_range.merge(&other.reserved_range);
            self.reserved_name.merge(&other.reserved_name);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::DescriptorProto {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[2]
        }
    }
    impl self::DescriptorProto {
        pub const NAME_FIELD_NUMBER: i32 = 1;
        pub const NAME_DEFAULT_VALUE: &'static str = "";
        pub fn name(&self) -> &str {
            self.name
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::NAME_DEFAULT_VALUE)
        }
        pub fn name_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.name.as_ref()
        }
        pub fn name_mut(&mut self) -> &mut ::std::string::String {
            self.name
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }
        pub fn set_name(&mut self, value: ::std::string::String) {
            self.name = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_name(&mut self) -> ::std::option::Option<::std::string::String> {
            self.name.take()
        }
        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }
        pub const FIELD_FIELD_NUMBER: i32 = 2;
        pub fn field(&self) -> &crate::collections::RepeatedField<self::FieldDescriptorProto> {
            &self.field
        }
        pub fn field_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::FieldDescriptorProto> {
            &mut self.field
        }
        pub const EXTENSION_FIELD_NUMBER: i32 = 6;
        pub fn extension(&self) -> &crate::collections::RepeatedField<self::FieldDescriptorProto> {
            &self.extension
        }
        pub fn extension_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::FieldDescriptorProto> {
            &mut self.extension
        }
        pub const NESTED_TYPE_FIELD_NUMBER: i32 = 3;
        pub fn nested_type(&self) -> &crate::collections::RepeatedField<self::DescriptorProto> {
            &self.nested_type
        }
        pub fn nested_type_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::DescriptorProto> {
            &mut self.nested_type
        }
        pub const ENUM_TYPE_FIELD_NUMBER: i32 = 4;
        pub fn enum_type(&self) -> &crate::collections::RepeatedField<self::EnumDescriptorProto> {
            &self.enum_type
        }
        pub fn enum_type_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::EnumDescriptorProto> {
            &mut self.enum_type
        }
        pub const EXTENSION_RANGE_FIELD_NUMBER: i32 = 5;
        pub fn extension_range(
            &self,
        ) -> &crate::collections::RepeatedField<self::descriptor_proto::ExtensionRange> {
            &self.extension_range
        }
        pub fn extension_range_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::descriptor_proto::ExtensionRange>
        {
            &mut self.extension_range
        }
        pub const ONEOF_DECL_FIELD_NUMBER: i32 = 8;
        pub fn oneof_decl(&self) -> &crate::collections::RepeatedField<self::OneofDescriptorProto> {
            &self.oneof_decl
        }
        pub fn oneof_decl_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::OneofDescriptorProto> {
            &mut self.oneof_decl
        }
        pub const OPTIONS_FIELD_NUMBER: i32 = 7;
        pub fn options(&self) -> ::std::option::Option<&self::MessageOptions> {
            self.options.as_ref().map(|v| &**v)
        }
        pub fn options_mut(&mut self) -> &mut self::MessageOptions {
            self.options
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_options(&self) -> bool {
            self.options.is_some()
        }
        pub fn set_options(&mut self, value: self::MessageOptions) {
            self.options = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_options(&mut self) -> ::std::option::Option<self::MessageOptions> {
            self.options.take().map(|v| *v)
        }
        pub fn clear_options(&mut self) {
            self.options = ::std::option::Option::None;
        }
        pub const RESERVED_RANGE_FIELD_NUMBER: i32 = 9;
        pub fn reserved_range(
            &self,
        ) -> &crate::collections::RepeatedField<self::descriptor_proto::ReservedRange> {
            &self.reserved_range
        }
        pub fn reserved_range_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::descriptor_proto::ReservedRange> {
            &mut self.reserved_range
        }
        pub const RESERVED_NAME_FIELD_NUMBER: i32 = 10;
        pub fn reserved_name(&self) -> &crate::collections::RepeatedField<::std::string::String> {
            &self.reserved_name
        }
        pub fn reserved_name_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<::std::string::String> {
            &mut self.reserved_name
        }
    }
    pub mod descriptor_proto {
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct ExtensionRange {
            start: ::std::option::Option<i32>,
            end: ::std::option::Option<i32>,
            options: ::std::option::Option<::std::boxed::Box<self::super::ExtensionRangeOptions>>,
            unknown_fields: crate::UnknownFieldSet,
        }
        impl crate::CodedMessage for self::ExtensionRange {
            fn merge_from(
                &mut self,
                input: &mut crate::io::CodedInput,
            ) -> crate::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        8 | 10 => self.set_start(input.read_int32()?),
                        16 | 18 => self.set_end(input.read_int32()?),
                        26 => input.read_extension_message(self.options_mut())?,
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> ::std::option::Option<i32> {
                let mut size = 0i32;
                if let ::std::option::Option::Some(start) = self.start_option() {
                    size = size.checked_add(1)?;
                    size = size.checked_add(crate::io::sizes::int32(*start))?;
                }
                if let ::std::option::Option::Some(end) = self.end_option() {
                    size = size.checked_add(1)?;
                    size = size.checked_add(crate::io::sizes::int32(*end))?;
                }
                if let ::std::option::Option::Some(options) = self.options() {
                    size = size.checked_add(1)?;
                    size = size.checked_add(crate::io::sizes::extension_message(options)?)?;
                }
                size = size.checked_add(self.unknown_fields.calculate_size()?)?;
                ::std::option::Option::Some(size)
            }
            fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
                if let ::std::option::Option::Some(start) = self.start_option() {
                    output.write_raw_tag_bytes(&[8])?;
                    output.write_int32(*start)?;
                }
                if let ::std::option::Option::Some(end) = self.end_option() {
                    output.write_raw_tag_bytes(&[16])?;
                    output.write_int32(*end)?;
                }
                if let ::std::option::Option::Some(options) = self.options() {
                    output.write_raw_tag_bytes(&[26])?;
                    output.write_extension_message(options)?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                if let ::std::option::Option::Some(options) = self.options() {
                    if !crate::CodedMessage::is_initialized(options) {
                        return false;
                    }
                }
                true
            }
        }
        impl crate::LiteMessage for self::ExtensionRange {
            fn merge(&mut self, other: &Self) {
                if let ::std::option::Option::Some(start) = other.start_option() {
                    self.set_start(*start);
                }
                if let ::std::option::Option::Some(end) = other.end_option() {
                    self.set_end(*end);
                }
                if let ::std::option::Option::Some(options) = &other.options() {
                    crate::LiteMessage::merge(self.options_mut(), options);
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl crate::Message for self::ExtensionRange {
            fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
                &<self::super::DescriptorProto as crate::Message>::descriptor().messages()[0]
            }
        }
        impl self::ExtensionRange {
            pub const START_FIELD_NUMBER: i32 = 1;
            pub const START_DEFAULT_VALUE: i32 = 0;
            pub fn start(&self) -> i32 {
                self.start.unwrap_or(Self::START_DEFAULT_VALUE)
            }
            pub fn start_option(&self) -> ::std::option::Option<&i32> {
                self.start.as_ref()
            }
            pub fn start_mut(&mut self) -> &mut i32 {
                self.start
                    .get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_start(&self) -> bool {
                self.start.is_some()
            }
            pub fn set_start(&mut self, value: i32) {
                self.start = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_start(&mut self) -> ::std::option::Option<i32> {
                self.start.take()
            }
            pub fn clear_start(&mut self) {
                self.start = ::std::option::Option::None;
            }
            pub const END_FIELD_NUMBER: i32 = 2;
            pub const END_DEFAULT_VALUE: i32 = 0;
            pub fn end(&self) -> i32 {
                self.end.unwrap_or(Self::END_DEFAULT_VALUE)
            }
            pub fn end_option(&self) -> ::std::option::Option<&i32> {
                self.end.as_ref()
            }
            pub fn end_mut(&mut self) -> &mut i32 {
                self.end
                    .get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_end(&self) -> bool {
                self.end.is_some()
            }
            pub fn set_end(&mut self, value: i32) {
                self.end = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_end(&mut self) -> ::std::option::Option<i32> {
                self.end.take()
            }
            pub fn clear_end(&mut self) {
                self.end = ::std::option::Option::None;
            }
            pub const OPTIONS_FIELD_NUMBER: i32 = 3;
            pub fn options(&self) -> ::std::option::Option<&self::super::ExtensionRangeOptions> {
                self.options.as_ref().map(|v| &**v)
            }
            pub fn options_mut(&mut self) -> &mut self::super::ExtensionRangeOptions {
                self.options
                    .get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_options(&self) -> bool {
                self.options.is_some()
            }
            pub fn set_options(&mut self, value: self::super::ExtensionRangeOptions) {
                self.options = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_options(
                &mut self,
            ) -> ::std::option::Option<self::super::ExtensionRangeOptions> {
                self.options.take().map(|v| *v)
            }
            pub fn clear_options(&mut self) {
                self.options = ::std::option::Option::None;
            }
        }
        pub(in super::super::super) mod extension_range {
            pub(in super::super::super) static START_REFLECTOR:
                crate::reflect::access::VerboseFieldAccessor<self::super::ExtensionRange, i32> =
                crate::reflect::access::VerboseFieldAccessor {
                    get_option: self::super::ExtensionRange::start_option,
                    get_mut: self::super::ExtensionRange::start_mut,
                    set: self::super::ExtensionRange::set_start,
                    take: self::super::ExtensionRange::take_start,
                    clear: self::super::ExtensionRange::clear_start,
                };
            pub(in super::super::super) static END_REFLECTOR:
                crate::reflect::access::VerboseFieldAccessor<self::super::ExtensionRange, i32> =
                crate::reflect::access::VerboseFieldAccessor {
                    get_option: self::super::ExtensionRange::end_option,
                    get_mut: self::super::ExtensionRange::end_mut,
                    set: self::super::ExtensionRange::set_end,
                    take: self::super::ExtensionRange::take_end,
                    clear: self::super::ExtensionRange::clear_end,
                };
            pub(in super::super::super) static OPTIONS_REFLECTOR:
                crate::reflect::access::VerboseFieldAccessor<
                    self::super::ExtensionRange,
                    self::super::super::ExtensionRangeOptions,
                > = crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::ExtensionRange::options,
                get_mut: self::super::ExtensionRange::options_mut,
                set: self::super::ExtensionRange::set_options,
                take: self::super::ExtensionRange::take_options,
                clear: self::super::ExtensionRange::clear_options,
            };
        }
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct ReservedRange {
            start: ::std::option::Option<i32>,
            end: ::std::option::Option<i32>,
            unknown_fields: crate::UnknownFieldSet,
        }
        impl crate::CodedMessage for self::ReservedRange {
            fn merge_from(
                &mut self,
                input: &mut crate::io::CodedInput,
            ) -> crate::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        8 | 10 => self.set_start(input.read_int32()?),
                        16 | 18 => self.set_end(input.read_int32()?),
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> ::std::option::Option<i32> {
                let mut size = 0i32;
                if let ::std::option::Option::Some(start) = self.start_option() {
                    size = size.checked_add(1)?;
                    size = size.checked_add(crate::io::sizes::int32(*start))?;
                }
                if let ::std::option::Option::Some(end) = self.end_option() {
                    size = size.checked_add(1)?;
                    size = size.checked_add(crate::io::sizes::int32(*end))?;
                }
                size = size.checked_add(self.unknown_fields.calculate_size()?)?;
                ::std::option::Option::Some(size)
            }
            fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
                if let ::std::option::Option::Some(start) = self.start_option() {
                    output.write_raw_tag_bytes(&[8])?;
                    output.write_int32(*start)?;
                }
                if let ::std::option::Option::Some(end) = self.end_option() {
                    output.write_raw_tag_bytes(&[16])?;
                    output.write_int32(*end)?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                true
            }
        }
        impl crate::LiteMessage for self::ReservedRange {
            fn merge(&mut self, other: &Self) {
                if let ::std::option::Option::Some(start) = other.start_option() {
                    self.set_start(*start);
                }
                if let ::std::option::Option::Some(end) = other.end_option() {
                    self.set_end(*end);
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl crate::Message for self::ReservedRange {
            fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
                &<self::super::DescriptorProto as crate::Message>::descriptor().messages()[1]
            }
        }
        impl self::ReservedRange {
            pub const START_FIELD_NUMBER: i32 = 1;
            pub const START_DEFAULT_VALUE: i32 = 0;
            pub fn start(&self) -> i32 {
                self.start.unwrap_or(Self::START_DEFAULT_VALUE)
            }
            pub fn start_option(&self) -> ::std::option::Option<&i32> {
                self.start.as_ref()
            }
            pub fn start_mut(&mut self) -> &mut i32 {
                self.start
                    .get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_start(&self) -> bool {
                self.start.is_some()
            }
            pub fn set_start(&mut self, value: i32) {
                self.start = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_start(&mut self) -> ::std::option::Option<i32> {
                self.start.take()
            }
            pub fn clear_start(&mut self) {
                self.start = ::std::option::Option::None;
            }
            pub const END_FIELD_NUMBER: i32 = 2;
            pub const END_DEFAULT_VALUE: i32 = 0;
            pub fn end(&self) -> i32 {
                self.end.unwrap_or(Self::END_DEFAULT_VALUE)
            }
            pub fn end_option(&self) -> ::std::option::Option<&i32> {
                self.end.as_ref()
            }
            pub fn end_mut(&mut self) -> &mut i32 {
                self.end
                    .get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_end(&self) -> bool {
                self.end.is_some()
            }
            pub fn set_end(&mut self, value: i32) {
                self.end = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_end(&mut self) -> ::std::option::Option<i32> {
                self.end.take()
            }
            pub fn clear_end(&mut self) {
                self.end = ::std::option::Option::None;
            }
        }
        pub(in super::super::super) mod reserved_range {
            pub(in super::super::super) static START_REFLECTOR:
                crate::reflect::access::VerboseFieldAccessor<self::super::ReservedRange, i32> =
                crate::reflect::access::VerboseFieldAccessor {
                    get_option: self::super::ReservedRange::start_option,
                    get_mut: self::super::ReservedRange::start_mut,
                    set: self::super::ReservedRange::set_start,
                    take: self::super::ReservedRange::take_start,
                    clear: self::super::ReservedRange::clear_start,
                };
            pub(in super::super::super) static END_REFLECTOR:
                crate::reflect::access::VerboseFieldAccessor<self::super::ReservedRange, i32> =
                crate::reflect::access::VerboseFieldAccessor {
                    get_option: self::super::ReservedRange::end_option,
                    get_mut: self::super::ReservedRange::end_mut,
                    set: self::super::ReservedRange::set_end,
                    take: self::super::ReservedRange::take_end,
                    clear: self::super::ReservedRange::clear_end,
                };
        }
        pub(super) static FIELD_CODEC: crate::Codec<self::super::FieldDescriptorProto> =
            crate::Codec::message(18);
        pub(super) static EXTENSION_CODEC: crate::Codec<self::super::FieldDescriptorProto> =
            crate::Codec::message(50);
        pub(super) static NESTED_TYPE_CODEC: crate::Codec<self::super::DescriptorProto> =
            crate::Codec::message(26);
        pub(super) static ENUM_TYPE_CODEC: crate::Codec<self::super::EnumDescriptorProto> =
            crate::Codec::message(34);
        pub(super) static EXTENSION_RANGE_CODEC: crate::Codec<self::ExtensionRange> =
            crate::Codec::message(42);
        pub(super) static ONEOF_DECL_CODEC: crate::Codec<self::super::OneofDescriptorProto> =
            crate::Codec::message(66);
        pub(super) static RESERVED_RANGE_CODEC: crate::Codec<self::ReservedRange> =
            crate::Codec::message(74);
        pub(super) static RESERVED_NAME_CODEC: crate::Codec<::std::string::String> =
            crate::Codec::string(82);
        pub(in super::super) static NAME_REFLECTOR: crate::reflect::access::VerboseFieldAccessor<
            self::super::DescriptorProto,
            ::std::string::String,
        > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::DescriptorProto::name_option,
            get_mut: self::super::DescriptorProto::name_mut,
            set: self::super::DescriptorProto::set_name,
            take: self::super::DescriptorProto::take_name,
            clear: self::super::DescriptorProto::clear_name,
        };
        pub(in super::super) static FIELD_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::DescriptorProto,
            crate::collections::RepeatedField<self::super::FieldDescriptorProto>,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::DescriptorProto::field,
            get_mut: self::super::DescriptorProto::field_mut,
        };
        pub(in super::super) static EXTENSION_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::DescriptorProto,
                crate::collections::RepeatedField<self::super::FieldDescriptorProto>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::DescriptorProto::extension,
            get_mut: self::super::DescriptorProto::extension_mut,
        };
        pub(in super::super) static NESTED_TYPE_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::DescriptorProto,
                crate::collections::RepeatedField<self::super::DescriptorProto>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::DescriptorProto::nested_type,
            get_mut: self::super::DescriptorProto::nested_type_mut,
        };
        pub(in super::super) static ENUM_TYPE_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::DescriptorProto,
                crate::collections::RepeatedField<self::super::EnumDescriptorProto>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::DescriptorProto::enum_type,
            get_mut: self::super::DescriptorProto::enum_type_mut,
        };
        pub(in super::super) static EXTENSION_RANGE_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::DescriptorProto,
                crate::collections::RepeatedField<self::ExtensionRange>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::DescriptorProto::extension_range,
            get_mut: self::super::DescriptorProto::extension_range_mut,
        };
        pub(in super::super) static ONEOF_DECL_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::DescriptorProto,
                crate::collections::RepeatedField<self::super::OneofDescriptorProto>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::DescriptorProto::oneof_decl,
            get_mut: self::super::DescriptorProto::oneof_decl_mut,
        };
        pub(in super::super) static OPTIONS_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::DescriptorProto,
                self::super::MessageOptions,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::DescriptorProto::options,
            get_mut: self::super::DescriptorProto::options_mut,
            set: self::super::DescriptorProto::set_options,
            take: self::super::DescriptorProto::take_options,
            clear: self::super::DescriptorProto::clear_options,
        };
        pub(in super::super) static RESERVED_RANGE_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::DescriptorProto,
                crate::collections::RepeatedField<self::ReservedRange>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::DescriptorProto::reserved_range,
            get_mut: self::super::DescriptorProto::reserved_range_mut,
        };
        pub(in super::super) static RESERVED_NAME_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::DescriptorProto,
                crate::collections::RepeatedField<::std::string::String>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::DescriptorProto::reserved_name,
            get_mut: self::super::DescriptorProto::reserved_name_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct ExtensionRangeOptions {
        uninterpreted_option: crate::collections::RepeatedField<self::UninterpretedOption>,
        unknown_fields: crate::UnknownFieldSet,
        extensions: crate::ExtensionSet<Self>,
    }
    impl crate::CodedMessage for self::ExtensionRangeOptions {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    7994 => self.uninterpreted_option.add_entries(
                        input,
                        &self::extension_range_options::UNINTERPRETED_OPTION_CODEC,
                    )?,
                    _ => {
                        if !self.extensions.merge_from(input)? {
                            self.unknown_fields.merge_from(tag, input)?
                        }
                    }
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            size = size
                .checked_add(self.uninterpreted_option().calculate_size(
                    &self::extension_range_options::UNINTERPRETED_OPTION_CODEC,
                )?)?;
            size = size.checked_add(self.extensions.calculate_size()?)?;
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            self.uninterpreted_option().write_to(
                output,
                &self::extension_range_options::UNINTERPRETED_OPTION_CODEC,
            )?;
            self.extensions.write_to(output)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.uninterpreted_option.is_initialized() {
                return false;
            }
            true
        }
    }
    impl crate::LiteMessage for self::ExtensionRangeOptions {
        fn merge(&mut self, other: &Self) {
            self.uninterpreted_option.merge(&other.uninterpreted_option);
            self.extensions.merge(&other.extensions);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::ExtendableMessage for self::ExtensionRangeOptions {
        fn registry(&self) -> ::std::option::Option<&'static crate::ExtensionRegistry> {
            self.extensions.registry()
        }
        fn replace_registry(
            &mut self,
            extensions: ::std::option::Option<&'static crate::ExtensionRegistry>,
        ) -> ::std::option::Option<&'static crate::ExtensionRegistry> {
            self.extensions.replace_registry(extensions)
        }
        fn has_extension<T: crate::ExtensionIdentifier>(&self, extension: &'static T) -> bool {
            self.extensions.has_extension(extension)
        }
        fn has_extension_unchecked<T: crate::ExtensionIdentifier>(
            &self,
            extension: &'static T,
        ) -> bool {
            self.extensions.has_extension_unchecked(extension)
        }
        fn get_value<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &self,
            extension: &'static crate::Extension<Self, V, D>,
        ) -> Option<&V> {
            self.extensions.get_value(extension)
        }
        fn get_value_or_default<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync
                + ::std::ops::Deref<Target = L>,
            D: ::std::marker::Sync + ::std::ops::Deref<Target = L>,
            L,
        >(
            &self,
            extension: &'static crate::Extension<Self, V, D>,
        ) -> Option<&L> {
            self.extensions.get_value_or_default(extension)
        }
        fn get_repeated_value<
            V: ::std::cmp::PartialEq
                + ::std::clone::Clone
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &self,
            extension: &'static crate::RepeatedExtension<Self, V>,
        ) -> Option<&crate::collections::RepeatedField<V>> {
            self.extensions.get_repeated_value(extension)
        }
        fn field<
            V: ::std::default::Default
                + ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static crate::Extension<Self, V, D>,
        ) -> ::std::option::Option<crate::ExtensionField<Self, V, D>> {
            self.extensions.field(extension)
        }
        fn repeated_field<
            V: ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static crate::RepeatedExtension<Self, V>,
        ) -> ::std::option::Option<crate::RepeatedExtensionField<Self, V>> {
            self.extensions.repeated_field(extension)
        }
    }
    impl crate::Message for self::ExtensionRangeOptions {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[3]
        }
    }
    impl self::ExtensionRangeOptions {
        pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
        pub fn uninterpreted_option(
            &self,
        ) -> &crate::collections::RepeatedField<self::UninterpretedOption> {
            &self.uninterpreted_option
        }
        pub fn uninterpreted_option_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::UninterpretedOption> {
            &mut self.uninterpreted_option
        }
    }
    pub(in super::super) mod extension_range_options {
        pub(super) static UNINTERPRETED_OPTION_CODEC: crate::Codec<
            self::super::UninterpretedOption,
        > = crate::Codec::message(7994);
        pub(in super::super) static UNINTERPRETED_OPTION_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::ExtensionRangeOptions,
                crate::collections::RepeatedField<self::super::UninterpretedOption>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::ExtensionRangeOptions::uninterpreted_option,
            get_mut: self::super::ExtensionRangeOptions::uninterpreted_option_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct FieldDescriptorProto {
        name: ::std::option::Option<::std::string::String>,
        number: ::std::option::Option<i32>,
        label: ::std::option::Option<crate::EnumValue<self::field_descriptor_proto::Label>>,
        r#type: ::std::option::Option<crate::EnumValue<self::field_descriptor_proto::Type>>,
        type_name: ::std::option::Option<::std::string::String>,
        extendee: ::std::option::Option<::std::string::String>,
        default_value: ::std::option::Option<::std::string::String>,
        oneof_index: ::std::option::Option<i32>,
        json_name: ::std::option::Option<::std::string::String>,
        options: ::std::option::Option<::std::boxed::Box<self::FieldOptions>>,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::FieldDescriptorProto {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => self.set_name(input.read_string()?),
                    24 | 26 => self.set_number(input.read_int32()?),
                    32 | 34 => self.set_label(input.read_enum_value()?),
                    40 | 42 => self.set_type(input.read_enum_value()?),
                    50 => self.set_type_name(input.read_string()?),
                    18 => self.set_extendee(input.read_string()?),
                    58 => self.set_default_value(input.read_string()?),
                    72 | 74 => self.set_oneof_index(input.read_int32()?),
                    82 => self.set_json_name(input.read_string()?),
                    66 => input.read_extension_message(self.options_mut())?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if let ::std::option::Option::Some(name) = self.name_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(name)?)?;
            }
            if let ::std::option::Option::Some(number) = self.number_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::int32(*number))?;
            }
            if let ::std::option::Option::Some(label) = self.label_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::enum_value(*label))?;
            }
            if let ::std::option::Option::Some(r#type) = self.type_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::enum_value(*r#type))?;
            }
            if let ::std::option::Option::Some(type_name) = self.type_name_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(type_name)?)?;
            }
            if let ::std::option::Option::Some(extendee) = self.extendee_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(extendee)?)?;
            }
            if let ::std::option::Option::Some(default_value) = self.default_value_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(default_value)?)?;
            }
            if let ::std::option::Option::Some(oneof_index) = self.oneof_index_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::int32(*oneof_index))?;
            }
            if let ::std::option::Option::Some(json_name) = self.json_name_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(json_name)?)?;
            }
            if let ::std::option::Option::Some(options) = self.options() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::extension_message(options)?)?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if let ::std::option::Option::Some(name) = self.name_option() {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
            if let ::std::option::Option::Some(number) = self.number_option() {
                output.write_raw_tag_bytes(&[24])?;
                output.write_int32(*number)?;
            }
            if let ::std::option::Option::Some(label) = self.label_option() {
                output.write_raw_tag_bytes(&[32])?;
                output.write_enum_value(*label)?;
            }
            if let ::std::option::Option::Some(r#type) = self.type_option() {
                output.write_raw_tag_bytes(&[40])?;
                output.write_enum_value(*r#type)?;
            }
            if let ::std::option::Option::Some(type_name) = self.type_name_option() {
                output.write_raw_tag_bytes(&[50])?;
                output.write_string(type_name)?;
            }
            if let ::std::option::Option::Some(extendee) = self.extendee_option() {
                output.write_raw_tag_bytes(&[18])?;
                output.write_string(extendee)?;
            }
            if let ::std::option::Option::Some(default_value) = self.default_value_option() {
                output.write_raw_tag_bytes(&[58])?;
                output.write_string(default_value)?;
            }
            if let ::std::option::Option::Some(oneof_index) = self.oneof_index_option() {
                output.write_raw_tag_bytes(&[72])?;
                output.write_int32(*oneof_index)?;
            }
            if let ::std::option::Option::Some(json_name) = self.json_name_option() {
                output.write_raw_tag_bytes(&[82])?;
                output.write_string(json_name)?;
            }
            if let ::std::option::Option::Some(options) = self.options() {
                output.write_raw_tag_bytes(&[66])?;
                output.write_extension_message(options)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(options) = self.options() {
                if !crate::CodedMessage::is_initialized(options) {
                    return false;
                }
            }
            true
        }
    }
    impl crate::LiteMessage for self::FieldDescriptorProto {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(name) = other.name_option() {
                self.set_name(::std::clone::Clone::clone(name));
            }
            if let ::std::option::Option::Some(number) = other.number_option() {
                self.set_number(*number);
            }
            if let ::std::option::Option::Some(label) = other.label_option() {
                self.set_label(*label);
            }
            if let ::std::option::Option::Some(r#type) = other.type_option() {
                self.set_type(*r#type);
            }
            if let ::std::option::Option::Some(type_name) = other.type_name_option() {
                self.set_type_name(::std::clone::Clone::clone(type_name));
            }
            if let ::std::option::Option::Some(extendee) = other.extendee_option() {
                self.set_extendee(::std::clone::Clone::clone(extendee));
            }
            if let ::std::option::Option::Some(default_value) = other.default_value_option() {
                self.set_default_value(::std::clone::Clone::clone(default_value));
            }
            if let ::std::option::Option::Some(oneof_index) = other.oneof_index_option() {
                self.set_oneof_index(*oneof_index);
            }
            if let ::std::option::Option::Some(json_name) = other.json_name_option() {
                self.set_json_name(::std::clone::Clone::clone(json_name));
            }
            if let ::std::option::Option::Some(options) = &other.options() {
                crate::LiteMessage::merge(self.options_mut(), options);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::FieldDescriptorProto {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[4]
        }
    }
    impl self::FieldDescriptorProto {
        pub const NAME_FIELD_NUMBER: i32 = 1;
        pub const NAME_DEFAULT_VALUE: &'static str = "";
        pub fn name(&self) -> &str {
            self.name
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::NAME_DEFAULT_VALUE)
        }
        pub fn name_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.name.as_ref()
        }
        pub fn name_mut(&mut self) -> &mut ::std::string::String {
            self.name
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }
        pub fn set_name(&mut self, value: ::std::string::String) {
            self.name = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_name(&mut self) -> ::std::option::Option<::std::string::String> {
            self.name.take()
        }
        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }
        pub const NUMBER_FIELD_NUMBER: i32 = 3;
        pub const NUMBER_DEFAULT_VALUE: i32 = 0;
        pub fn number(&self) -> i32 {
            self.number.unwrap_or(Self::NUMBER_DEFAULT_VALUE)
        }
        pub fn number_option(&self) -> ::std::option::Option<&i32> {
            self.number.as_ref()
        }
        pub fn number_mut(&mut self) -> &mut i32 {
            self.number
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_number(&self) -> bool {
            self.number.is_some()
        }
        pub fn set_number(&mut self, value: i32) {
            self.number = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_number(&mut self) -> ::std::option::Option<i32> {
            self.number.take()
        }
        pub fn clear_number(&mut self) {
            self.number = ::std::option::Option::None;
        }
        pub const LABEL_FIELD_NUMBER: i32 = 4;
        pub const LABEL_DEFAULT_VALUE: crate::EnumValue<self::field_descriptor_proto::Label> =
            crate::EnumValue::Undefined(0);
        pub fn label(&self) -> crate::EnumValue<self::field_descriptor_proto::Label> {
            self.label.unwrap_or(Self::LABEL_DEFAULT_VALUE)
        }
        pub fn label_option(
            &self,
        ) -> ::std::option::Option<&crate::EnumValue<self::field_descriptor_proto::Label>> {
            self.label.as_ref()
        }
        pub fn label_mut(&mut self) -> &mut crate::EnumValue<self::field_descriptor_proto::Label> {
            self.label
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_label(&self) -> bool {
            self.label.is_some()
        }
        pub fn set_label(&mut self, value: crate::EnumValue<self::field_descriptor_proto::Label>) {
            self.label = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_label(
            &mut self,
        ) -> ::std::option::Option<crate::EnumValue<self::field_descriptor_proto::Label>> {
            self.label.take()
        }
        pub fn clear_label(&mut self) {
            self.label = ::std::option::Option::None;
        }
        pub const TYPE_FIELD_NUMBER: i32 = 5;
        pub const TYPE_DEFAULT_VALUE: crate::EnumValue<self::field_descriptor_proto::Type> =
            crate::EnumValue::Undefined(0);
        pub fn r#type(&self) -> crate::EnumValue<self::field_descriptor_proto::Type> {
            self.r#type.unwrap_or(Self::TYPE_DEFAULT_VALUE)
        }
        pub fn type_option(
            &self,
        ) -> ::std::option::Option<&crate::EnumValue<self::field_descriptor_proto::Type>> {
            self.r#type.as_ref()
        }
        pub fn type_mut(&mut self) -> &mut crate::EnumValue<self::field_descriptor_proto::Type> {
            self.r#type
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_type(&self) -> bool {
            self.r#type.is_some()
        }
        pub fn set_type(&mut self, value: crate::EnumValue<self::field_descriptor_proto::Type>) {
            self.r#type = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_type(
            &mut self,
        ) -> ::std::option::Option<crate::EnumValue<self::field_descriptor_proto::Type>> {
            self.r#type.take()
        }
        pub fn clear_type(&mut self) {
            self.r#type = ::std::option::Option::None;
        }
        pub const TYPE_NAME_FIELD_NUMBER: i32 = 6;
        pub const TYPE_NAME_DEFAULT_VALUE: &'static str = "";
        pub fn type_name(&self) -> &str {
            self.type_name
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::TYPE_NAME_DEFAULT_VALUE)
        }
        pub fn type_name_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.type_name.as_ref()
        }
        pub fn type_name_mut(&mut self) -> &mut ::std::string::String {
            self.type_name
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_type_name(&self) -> bool {
            self.type_name.is_some()
        }
        pub fn set_type_name(&mut self, value: ::std::string::String) {
            self.type_name = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_type_name(&mut self) -> ::std::option::Option<::std::string::String> {
            self.type_name.take()
        }
        pub fn clear_type_name(&mut self) {
            self.type_name = ::std::option::Option::None;
        }
        pub const EXTENDEE_FIELD_NUMBER: i32 = 2;
        pub const EXTENDEE_DEFAULT_VALUE: &'static str = "";
        pub fn extendee(&self) -> &str {
            self.extendee
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::EXTENDEE_DEFAULT_VALUE)
        }
        pub fn extendee_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.extendee.as_ref()
        }
        pub fn extendee_mut(&mut self) -> &mut ::std::string::String {
            self.extendee
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_extendee(&self) -> bool {
            self.extendee.is_some()
        }
        pub fn set_extendee(&mut self, value: ::std::string::String) {
            self.extendee = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_extendee(&mut self) -> ::std::option::Option<::std::string::String> {
            self.extendee.take()
        }
        pub fn clear_extendee(&mut self) {
            self.extendee = ::std::option::Option::None;
        }
        pub const DEFAULT_VALUE_FIELD_NUMBER: i32 = 7;
        pub const DEFAULT_VALUE_DEFAULT_VALUE: &'static str = "";
        pub fn default_value(&self) -> &str {
            self.default_value
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::DEFAULT_VALUE_DEFAULT_VALUE)
        }
        pub fn default_value_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.default_value.as_ref()
        }
        pub fn default_value_mut(&mut self) -> &mut ::std::string::String {
            self.default_value
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_default_value(&self) -> bool {
            self.default_value.is_some()
        }
        pub fn set_default_value(&mut self, value: ::std::string::String) {
            self.default_value = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_default_value(&mut self) -> ::std::option::Option<::std::string::String> {
            self.default_value.take()
        }
        pub fn clear_default_value(&mut self) {
            self.default_value = ::std::option::Option::None;
        }
        pub const ONEOF_INDEX_FIELD_NUMBER: i32 = 9;
        pub const ONEOF_INDEX_DEFAULT_VALUE: i32 = 0;
        pub fn oneof_index(&self) -> i32 {
            self.oneof_index.unwrap_or(Self::ONEOF_INDEX_DEFAULT_VALUE)
        }
        pub fn oneof_index_option(&self) -> ::std::option::Option<&i32> {
            self.oneof_index.as_ref()
        }
        pub fn oneof_index_mut(&mut self) -> &mut i32 {
            self.oneof_index
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_oneof_index(&self) -> bool {
            self.oneof_index.is_some()
        }
        pub fn set_oneof_index(&mut self, value: i32) {
            self.oneof_index = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_oneof_index(&mut self) -> ::std::option::Option<i32> {
            self.oneof_index.take()
        }
        pub fn clear_oneof_index(&mut self) {
            self.oneof_index = ::std::option::Option::None;
        }
        pub const JSON_NAME_FIELD_NUMBER: i32 = 10;
        pub const JSON_NAME_DEFAULT_VALUE: &'static str = "";
        pub fn json_name(&self) -> &str {
            self.json_name
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::JSON_NAME_DEFAULT_VALUE)
        }
        pub fn json_name_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.json_name.as_ref()
        }
        pub fn json_name_mut(&mut self) -> &mut ::std::string::String {
            self.json_name
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_json_name(&self) -> bool {
            self.json_name.is_some()
        }
        pub fn set_json_name(&mut self, value: ::std::string::String) {
            self.json_name = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_json_name(&mut self) -> ::std::option::Option<::std::string::String> {
            self.json_name.take()
        }
        pub fn clear_json_name(&mut self) {
            self.json_name = ::std::option::Option::None;
        }
        pub const OPTIONS_FIELD_NUMBER: i32 = 8;
        pub fn options(&self) -> ::std::option::Option<&self::FieldOptions> {
            self.options.as_ref().map(|v| &**v)
        }
        pub fn options_mut(&mut self) -> &mut self::FieldOptions {
            self.options
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_options(&self) -> bool {
            self.options.is_some()
        }
        pub fn set_options(&mut self, value: self::FieldOptions) {
            self.options = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_options(&mut self) -> ::std::option::Option<self::FieldOptions> {
            self.options.take().map(|v| *v)
        }
        pub fn clear_options(&mut self) {
            self.options = ::std::option::Option::None;
        }
    }
    pub mod field_descriptor_proto {
        #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
        pub enum Type {
            Double,
            Float,
            Int64,
            Uint64,
            Int32,
            Fixed64,
            Fixed32,
            Bool,
            String,
            Group,
            Message,
            Bytes,
            Uint32,
            Enum,
            Sfixed32,
            Sfixed64,
            Sint32,
            Sint64,
        }
        impl crate::Enum for self::Type {
            fn descriptor() -> &'static crate::reflect::EnumDescriptor<'static> {
                &<self::super::FieldDescriptorProto as crate::Message>::descriptor().enums()[0]
            }
        }
        impl ::std::convert::TryFrom<i32> for self::Type {
            type Error = crate::VariantUndefinedError;
            fn try_from(value: i32) -> ::std::result::Result<Self, crate::VariantUndefinedError> {
                #[allow(unreachable_patterns)]
                match value {
                    1 => ::std::result::Result::Ok(self::Type::Double),
                    2 => ::std::result::Result::Ok(self::Type::Float),
                    3 => ::std::result::Result::Ok(self::Type::Int64),
                    4 => ::std::result::Result::Ok(self::Type::Uint64),
                    5 => ::std::result::Result::Ok(self::Type::Int32),
                    6 => ::std::result::Result::Ok(self::Type::Fixed64),
                    7 => ::std::result::Result::Ok(self::Type::Fixed32),
                    8 => ::std::result::Result::Ok(self::Type::Bool),
                    9 => ::std::result::Result::Ok(self::Type::String),
                    10 => ::std::result::Result::Ok(self::Type::Group),
                    11 => ::std::result::Result::Ok(self::Type::Message),
                    12 => ::std::result::Result::Ok(self::Type::Bytes),
                    13 => ::std::result::Result::Ok(self::Type::Uint32),
                    14 => ::std::result::Result::Ok(self::Type::Enum),
                    15 => ::std::result::Result::Ok(self::Type::Sfixed32),
                    16 => ::std::result::Result::Ok(self::Type::Sfixed64),
                    17 => ::std::result::Result::Ok(self::Type::Sint32),
                    18 => ::std::result::Result::Ok(self::Type::Sint64),
                    _ => ::std::result::Result::Err(crate::VariantUndefinedError),
                }
            }
        }
        impl ::std::convert::From<self::Type> for i32 {
            fn from(value: self::Type) -> i32 {
                match value {
                    self::Type::Double => 1,
                    self::Type::Float => 2,
                    self::Type::Int64 => 3,
                    self::Type::Uint64 => 4,
                    self::Type::Int32 => 5,
                    self::Type::Fixed64 => 6,
                    self::Type::Fixed32 => 7,
                    self::Type::Bool => 8,
                    self::Type::String => 9,
                    self::Type::Group => 10,
                    self::Type::Message => 11,
                    self::Type::Bytes => 12,
                    self::Type::Uint32 => 13,
                    self::Type::Enum => 14,
                    self::Type::Sfixed32 => 15,
                    self::Type::Sfixed64 => 16,
                    self::Type::Sint32 => 17,
                    self::Type::Sint64 => 18,
                }
            }
        }
        #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
        pub enum Label {
            Optional,
            Required,
            Repeated,
        }
        impl crate::Enum for self::Label {
            fn descriptor() -> &'static crate::reflect::EnumDescriptor<'static> {
                &<self::super::FieldDescriptorProto as crate::Message>::descriptor().enums()[1]
            }
        }
        impl ::std::convert::TryFrom<i32> for self::Label {
            type Error = crate::VariantUndefinedError;
            fn try_from(value: i32) -> ::std::result::Result<Self, crate::VariantUndefinedError> {
                #[allow(unreachable_patterns)]
                match value {
                    1 => ::std::result::Result::Ok(self::Label::Optional),
                    2 => ::std::result::Result::Ok(self::Label::Required),
                    3 => ::std::result::Result::Ok(self::Label::Repeated),
                    _ => ::std::result::Result::Err(crate::VariantUndefinedError),
                }
            }
        }
        impl ::std::convert::From<self::Label> for i32 {
            fn from(value: self::Label) -> i32 {
                match value {
                    self::Label::Optional => 1,
                    self::Label::Required => 2,
                    self::Label::Repeated => 3,
                }
            }
        }
        pub(in super::super) static NAME_REFLECTOR: crate::reflect::access::VerboseFieldAccessor<
            self::super::FieldDescriptorProto,
            ::std::string::String,
        > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FieldDescriptorProto::name_option,
            get_mut: self::super::FieldDescriptorProto::name_mut,
            set: self::super::FieldDescriptorProto::set_name,
            take: self::super::FieldDescriptorProto::take_name,
            clear: self::super::FieldDescriptorProto::clear_name,
        };
        pub(in super::super) static NUMBER_REFLECTOR: crate::reflect::access::VerboseFieldAccessor<
            self::super::FieldDescriptorProto,
            i32,
        > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FieldDescriptorProto::number_option,
            get_mut: self::super::FieldDescriptorProto::number_mut,
            set: self::super::FieldDescriptorProto::set_number,
            take: self::super::FieldDescriptorProto::take_number,
            clear: self::super::FieldDescriptorProto::clear_number,
        };
        pub(in super::super) static LABEL_REFLECTOR: crate::reflect::access::VerboseFieldAccessor<
            self::super::FieldDescriptorProto,
            crate::EnumValue<self::Label>,
        > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FieldDescriptorProto::label_option,
            get_mut: self::super::FieldDescriptorProto::label_mut,
            set: self::super::FieldDescriptorProto::set_label,
            take: self::super::FieldDescriptorProto::take_label,
            clear: self::super::FieldDescriptorProto::clear_label,
        };
        pub(in super::super) static TYPE_REFLECTOR: crate::reflect::access::VerboseFieldAccessor<
            self::super::FieldDescriptorProto,
            crate::EnumValue<self::Type>,
        > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FieldDescriptorProto::type_option,
            get_mut: self::super::FieldDescriptorProto::type_mut,
            set: self::super::FieldDescriptorProto::set_type,
            take: self::super::FieldDescriptorProto::take_type,
            clear: self::super::FieldDescriptorProto::clear_type,
        };
        pub(in super::super) static TYPE_NAME_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::FieldDescriptorProto,
                ::std::string::String,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FieldDescriptorProto::type_name_option,
            get_mut: self::super::FieldDescriptorProto::type_name_mut,
            set: self::super::FieldDescriptorProto::set_type_name,
            take: self::super::FieldDescriptorProto::take_type_name,
            clear: self::super::FieldDescriptorProto::clear_type_name,
        };
        pub(in super::super) static EXTENDEE_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::FieldDescriptorProto,
                ::std::string::String,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FieldDescriptorProto::extendee_option,
            get_mut: self::super::FieldDescriptorProto::extendee_mut,
            set: self::super::FieldDescriptorProto::set_extendee,
            take: self::super::FieldDescriptorProto::take_extendee,
            clear: self::super::FieldDescriptorProto::clear_extendee,
        };
        pub(in super::super) static DEFAULT_VALUE_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::FieldDescriptorProto,
                ::std::string::String,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FieldDescriptorProto::default_value_option,
            get_mut: self::super::FieldDescriptorProto::default_value_mut,
            set: self::super::FieldDescriptorProto::set_default_value,
            take: self::super::FieldDescriptorProto::take_default_value,
            clear: self::super::FieldDescriptorProto::clear_default_value,
        };
        pub(in super::super) static ONEOF_INDEX_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::FieldDescriptorProto, i32> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::FieldDescriptorProto::oneof_index_option,
                get_mut: self::super::FieldDescriptorProto::oneof_index_mut,
                set: self::super::FieldDescriptorProto::set_oneof_index,
                take: self::super::FieldDescriptorProto::take_oneof_index,
                clear: self::super::FieldDescriptorProto::clear_oneof_index,
            };
        pub(in super::super) static JSON_NAME_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::FieldDescriptorProto,
                ::std::string::String,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FieldDescriptorProto::json_name_option,
            get_mut: self::super::FieldDescriptorProto::json_name_mut,
            set: self::super::FieldDescriptorProto::set_json_name,
            take: self::super::FieldDescriptorProto::take_json_name,
            clear: self::super::FieldDescriptorProto::clear_json_name,
        };
        pub(in super::super) static OPTIONS_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::FieldDescriptorProto,
                self::super::FieldOptions,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FieldDescriptorProto::options,
            get_mut: self::super::FieldDescriptorProto::options_mut,
            set: self::super::FieldDescriptorProto::set_options,
            take: self::super::FieldDescriptorProto::take_options,
            clear: self::super::FieldDescriptorProto::clear_options,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct OneofDescriptorProto {
        name: ::std::option::Option<::std::string::String>,
        options: ::std::option::Option<::std::boxed::Box<self::OneofOptions>>,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::OneofDescriptorProto {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => self.set_name(input.read_string()?),
                    18 => input.read_extension_message(self.options_mut())?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if let ::std::option::Option::Some(name) = self.name_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(name)?)?;
            }
            if let ::std::option::Option::Some(options) = self.options() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::extension_message(options)?)?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if let ::std::option::Option::Some(name) = self.name_option() {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
            if let ::std::option::Option::Some(options) = self.options() {
                output.write_raw_tag_bytes(&[18])?;
                output.write_extension_message(options)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(options) = self.options() {
                if !crate::CodedMessage::is_initialized(options) {
                    return false;
                }
            }
            true
        }
    }
    impl crate::LiteMessage for self::OneofDescriptorProto {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(name) = other.name_option() {
                self.set_name(::std::clone::Clone::clone(name));
            }
            if let ::std::option::Option::Some(options) = &other.options() {
                crate::LiteMessage::merge(self.options_mut(), options);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::OneofDescriptorProto {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[5]
        }
    }
    impl self::OneofDescriptorProto {
        pub const NAME_FIELD_NUMBER: i32 = 1;
        pub const NAME_DEFAULT_VALUE: &'static str = "";
        pub fn name(&self) -> &str {
            self.name
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::NAME_DEFAULT_VALUE)
        }
        pub fn name_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.name.as_ref()
        }
        pub fn name_mut(&mut self) -> &mut ::std::string::String {
            self.name
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }
        pub fn set_name(&mut self, value: ::std::string::String) {
            self.name = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_name(&mut self) -> ::std::option::Option<::std::string::String> {
            self.name.take()
        }
        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }
        pub const OPTIONS_FIELD_NUMBER: i32 = 2;
        pub fn options(&self) -> ::std::option::Option<&self::OneofOptions> {
            self.options.as_ref().map(|v| &**v)
        }
        pub fn options_mut(&mut self) -> &mut self::OneofOptions {
            self.options
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_options(&self) -> bool {
            self.options.is_some()
        }
        pub fn set_options(&mut self, value: self::OneofOptions) {
            self.options = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_options(&mut self) -> ::std::option::Option<self::OneofOptions> {
            self.options.take().map(|v| *v)
        }
        pub fn clear_options(&mut self) {
            self.options = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod oneof_descriptor_proto {
        pub(in super::super) static NAME_REFLECTOR: crate::reflect::access::VerboseFieldAccessor<
            self::super::OneofDescriptorProto,
            ::std::string::String,
        > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::OneofDescriptorProto::name_option,
            get_mut: self::super::OneofDescriptorProto::name_mut,
            set: self::super::OneofDescriptorProto::set_name,
            take: self::super::OneofDescriptorProto::take_name,
            clear: self::super::OneofDescriptorProto::clear_name,
        };
        pub(in super::super) static OPTIONS_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::OneofDescriptorProto,
                self::super::OneofOptions,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::OneofDescriptorProto::options,
            get_mut: self::super::OneofDescriptorProto::options_mut,
            set: self::super::OneofDescriptorProto::set_options,
            take: self::super::OneofDescriptorProto::take_options,
            clear: self::super::OneofDescriptorProto::clear_options,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct EnumDescriptorProto {
        name: ::std::option::Option<::std::string::String>,
        value: crate::collections::RepeatedField<self::EnumValueDescriptorProto>,
        options: ::std::option::Option<::std::boxed::Box<self::EnumOptions>>,
        reserved_range:
            crate::collections::RepeatedField<self::enum_descriptor_proto::EnumReservedRange>,
        reserved_name: crate::collections::RepeatedField<::std::string::String>,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::EnumDescriptorProto {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => self.set_name(input.read_string()?),
                    18 => self
                        .value
                        .add_entries(input, &self::enum_descriptor_proto::VALUE_CODEC)?,
                    26 => input.read_extension_message(self.options_mut())?,
                    34 => self
                        .reserved_range
                        .add_entries(input, &self::enum_descriptor_proto::RESERVED_RANGE_CODEC)?,
                    42 => self
                        .reserved_name
                        .add_entries(input, &self::enum_descriptor_proto::RESERVED_NAME_CODEC)?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if let ::std::option::Option::Some(name) = self.name_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(name)?)?;
            }
            size = size.checked_add(
                self.value()
                    .calculate_size(&self::enum_descriptor_proto::VALUE_CODEC)?,
            )?;
            if let ::std::option::Option::Some(options) = self.options() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::extension_message(options)?)?;
            }
            size = size.checked_add(
                self.reserved_range()
                    .calculate_size(&self::enum_descriptor_proto::RESERVED_RANGE_CODEC)?,
            )?;
            size = size.checked_add(
                self.reserved_name()
                    .calculate_size(&self::enum_descriptor_proto::RESERVED_NAME_CODEC)?,
            )?;
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if let ::std::option::Option::Some(name) = self.name_option() {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
            self.value()
                .write_to(output, &self::enum_descriptor_proto::VALUE_CODEC)?;
            if let ::std::option::Option::Some(options) = self.options() {
                output.write_raw_tag_bytes(&[26])?;
                output.write_extension_message(options)?;
            }
            self.reserved_range()
                .write_to(output, &self::enum_descriptor_proto::RESERVED_RANGE_CODEC)?;
            self.reserved_name()
                .write_to(output, &self::enum_descriptor_proto::RESERVED_NAME_CODEC)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.value.is_initialized() {
                return false;
            }
            if let ::std::option::Option::Some(options) = self.options() {
                if !crate::CodedMessage::is_initialized(options) {
                    return false;
                }
            }
            if !self.reserved_range.is_initialized() {
                return false;
            }
            true
        }
    }
    impl crate::LiteMessage for self::EnumDescriptorProto {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(name) = other.name_option() {
                self.set_name(::std::clone::Clone::clone(name));
            }
            self.value.merge(&other.value);
            if let ::std::option::Option::Some(options) = &other.options() {
                crate::LiteMessage::merge(self.options_mut(), options);
            }
            self.reserved_range.merge(&other.reserved_range);
            self.reserved_name.merge(&other.reserved_name);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::EnumDescriptorProto {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[6]
        }
    }
    impl self::EnumDescriptorProto {
        pub const NAME_FIELD_NUMBER: i32 = 1;
        pub const NAME_DEFAULT_VALUE: &'static str = "";
        pub fn name(&self) -> &str {
            self.name
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::NAME_DEFAULT_VALUE)
        }
        pub fn name_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.name.as_ref()
        }
        pub fn name_mut(&mut self) -> &mut ::std::string::String {
            self.name
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }
        pub fn set_name(&mut self, value: ::std::string::String) {
            self.name = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_name(&mut self) -> ::std::option::Option<::std::string::String> {
            self.name.take()
        }
        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }
        pub const VALUE_FIELD_NUMBER: i32 = 2;
        pub fn value(&self) -> &crate::collections::RepeatedField<self::EnumValueDescriptorProto> {
            &self.value
        }
        pub fn value_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::EnumValueDescriptorProto> {
            &mut self.value
        }
        pub const OPTIONS_FIELD_NUMBER: i32 = 3;
        pub fn options(&self) -> ::std::option::Option<&self::EnumOptions> {
            self.options.as_ref().map(|v| &**v)
        }
        pub fn options_mut(&mut self) -> &mut self::EnumOptions {
            self.options
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_options(&self) -> bool {
            self.options.is_some()
        }
        pub fn set_options(&mut self, value: self::EnumOptions) {
            self.options = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_options(&mut self) -> ::std::option::Option<self::EnumOptions> {
            self.options.take().map(|v| *v)
        }
        pub fn clear_options(&mut self) {
            self.options = ::std::option::Option::None;
        }
        pub const RESERVED_RANGE_FIELD_NUMBER: i32 = 4;
        pub fn reserved_range(
            &self,
        ) -> &crate::collections::RepeatedField<self::enum_descriptor_proto::EnumReservedRange>
        {
            &self.reserved_range
        }
        pub fn reserved_range_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::enum_descriptor_proto::EnumReservedRange>
        {
            &mut self.reserved_range
        }
        pub const RESERVED_NAME_FIELD_NUMBER: i32 = 5;
        pub fn reserved_name(&self) -> &crate::collections::RepeatedField<::std::string::String> {
            &self.reserved_name
        }
        pub fn reserved_name_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<::std::string::String> {
            &mut self.reserved_name
        }
    }
    pub mod enum_descriptor_proto {
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct EnumReservedRange {
            start: ::std::option::Option<i32>,
            end: ::std::option::Option<i32>,
            unknown_fields: crate::UnknownFieldSet,
        }
        impl crate::CodedMessage for self::EnumReservedRange {
            fn merge_from(
                &mut self,
                input: &mut crate::io::CodedInput,
            ) -> crate::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        8 | 10 => self.set_start(input.read_int32()?),
                        16 | 18 => self.set_end(input.read_int32()?),
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> ::std::option::Option<i32> {
                let mut size = 0i32;
                if let ::std::option::Option::Some(start) = self.start_option() {
                    size = size.checked_add(1)?;
                    size = size.checked_add(crate::io::sizes::int32(*start))?;
                }
                if let ::std::option::Option::Some(end) = self.end_option() {
                    size = size.checked_add(1)?;
                    size = size.checked_add(crate::io::sizes::int32(*end))?;
                }
                size = size.checked_add(self.unknown_fields.calculate_size()?)?;
                ::std::option::Option::Some(size)
            }
            fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
                if let ::std::option::Option::Some(start) = self.start_option() {
                    output.write_raw_tag_bytes(&[8])?;
                    output.write_int32(*start)?;
                }
                if let ::std::option::Option::Some(end) = self.end_option() {
                    output.write_raw_tag_bytes(&[16])?;
                    output.write_int32(*end)?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                true
            }
        }
        impl crate::LiteMessage for self::EnumReservedRange {
            fn merge(&mut self, other: &Self) {
                if let ::std::option::Option::Some(start) = other.start_option() {
                    self.set_start(*start);
                }
                if let ::std::option::Option::Some(end) = other.end_option() {
                    self.set_end(*end);
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl crate::Message for self::EnumReservedRange {
            fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
                &<self::super::EnumDescriptorProto as crate::Message>::descriptor().messages()[0]
            }
        }
        impl self::EnumReservedRange {
            pub const START_FIELD_NUMBER: i32 = 1;
            pub const START_DEFAULT_VALUE: i32 = 0;
            pub fn start(&self) -> i32 {
                self.start.unwrap_or(Self::START_DEFAULT_VALUE)
            }
            pub fn start_option(&self) -> ::std::option::Option<&i32> {
                self.start.as_ref()
            }
            pub fn start_mut(&mut self) -> &mut i32 {
                self.start
                    .get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_start(&self) -> bool {
                self.start.is_some()
            }
            pub fn set_start(&mut self, value: i32) {
                self.start = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_start(&mut self) -> ::std::option::Option<i32> {
                self.start.take()
            }
            pub fn clear_start(&mut self) {
                self.start = ::std::option::Option::None;
            }
            pub const END_FIELD_NUMBER: i32 = 2;
            pub const END_DEFAULT_VALUE: i32 = 0;
            pub fn end(&self) -> i32 {
                self.end.unwrap_or(Self::END_DEFAULT_VALUE)
            }
            pub fn end_option(&self) -> ::std::option::Option<&i32> {
                self.end.as_ref()
            }
            pub fn end_mut(&mut self) -> &mut i32 {
                self.end
                    .get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_end(&self) -> bool {
                self.end.is_some()
            }
            pub fn set_end(&mut self, value: i32) {
                self.end = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_end(&mut self) -> ::std::option::Option<i32> {
                self.end.take()
            }
            pub fn clear_end(&mut self) {
                self.end = ::std::option::Option::None;
            }
        }
        pub(in super::super::super) mod enum_reserved_range {
            pub(in super::super::super) static START_REFLECTOR:
                crate::reflect::access::VerboseFieldAccessor<self::super::EnumReservedRange, i32> =
                crate::reflect::access::VerboseFieldAccessor {
                    get_option: self::super::EnumReservedRange::start_option,
                    get_mut: self::super::EnumReservedRange::start_mut,
                    set: self::super::EnumReservedRange::set_start,
                    take: self::super::EnumReservedRange::take_start,
                    clear: self::super::EnumReservedRange::clear_start,
                };
            pub(in super::super::super) static END_REFLECTOR:
                crate::reflect::access::VerboseFieldAccessor<self::super::EnumReservedRange, i32> =
                crate::reflect::access::VerboseFieldAccessor {
                    get_option: self::super::EnumReservedRange::end_option,
                    get_mut: self::super::EnumReservedRange::end_mut,
                    set: self::super::EnumReservedRange::set_end,
                    take: self::super::EnumReservedRange::take_end,
                    clear: self::super::EnumReservedRange::clear_end,
                };
        }
        pub(super) static VALUE_CODEC: crate::Codec<self::super::EnumValueDescriptorProto> =
            crate::Codec::message(18);
        pub(super) static RESERVED_RANGE_CODEC: crate::Codec<self::EnumReservedRange> =
            crate::Codec::message(34);
        pub(super) static RESERVED_NAME_CODEC: crate::Codec<::std::string::String> =
            crate::Codec::string(42);
        pub(in super::super) static NAME_REFLECTOR: crate::reflect::access::VerboseFieldAccessor<
            self::super::EnumDescriptorProto,
            ::std::string::String,
        > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::EnumDescriptorProto::name_option,
            get_mut: self::super::EnumDescriptorProto::name_mut,
            set: self::super::EnumDescriptorProto::set_name,
            take: self::super::EnumDescriptorProto::take_name,
            clear: self::super::EnumDescriptorProto::clear_name,
        };
        pub(in super::super) static VALUE_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::EnumDescriptorProto,
            crate::collections::RepeatedField<self::super::EnumValueDescriptorProto>,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::EnumDescriptorProto::value,
            get_mut: self::super::EnumDescriptorProto::value_mut,
        };
        pub(in super::super) static OPTIONS_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::EnumDescriptorProto,
                self::super::EnumOptions,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::EnumDescriptorProto::options,
            get_mut: self::super::EnumDescriptorProto::options_mut,
            set: self::super::EnumDescriptorProto::set_options,
            take: self::super::EnumDescriptorProto::take_options,
            clear: self::super::EnumDescriptorProto::clear_options,
        };
        pub(in super::super) static RESERVED_RANGE_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::EnumDescriptorProto,
                crate::collections::RepeatedField<self::EnumReservedRange>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::EnumDescriptorProto::reserved_range,
            get_mut: self::super::EnumDescriptorProto::reserved_range_mut,
        };
        pub(in super::super) static RESERVED_NAME_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::EnumDescriptorProto,
                crate::collections::RepeatedField<::std::string::String>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::EnumDescriptorProto::reserved_name,
            get_mut: self::super::EnumDescriptorProto::reserved_name_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct EnumValueDescriptorProto {
        name: ::std::option::Option<::std::string::String>,
        number: ::std::option::Option<i32>,
        options: ::std::option::Option<::std::boxed::Box<self::EnumValueOptions>>,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::EnumValueDescriptorProto {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => self.set_name(input.read_string()?),
                    16 | 18 => self.set_number(input.read_int32()?),
                    26 => input.read_extension_message(self.options_mut())?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if let ::std::option::Option::Some(name) = self.name_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(name)?)?;
            }
            if let ::std::option::Option::Some(number) = self.number_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::int32(*number))?;
            }
            if let ::std::option::Option::Some(options) = self.options() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::extension_message(options)?)?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if let ::std::option::Option::Some(name) = self.name_option() {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
            if let ::std::option::Option::Some(number) = self.number_option() {
                output.write_raw_tag_bytes(&[16])?;
                output.write_int32(*number)?;
            }
            if let ::std::option::Option::Some(options) = self.options() {
                output.write_raw_tag_bytes(&[26])?;
                output.write_extension_message(options)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(options) = self.options() {
                if !crate::CodedMessage::is_initialized(options) {
                    return false;
                }
            }
            true
        }
    }
    impl crate::LiteMessage for self::EnumValueDescriptorProto {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(name) = other.name_option() {
                self.set_name(::std::clone::Clone::clone(name));
            }
            if let ::std::option::Option::Some(number) = other.number_option() {
                self.set_number(*number);
            }
            if let ::std::option::Option::Some(options) = &other.options() {
                crate::LiteMessage::merge(self.options_mut(), options);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::EnumValueDescriptorProto {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[7]
        }
    }
    impl self::EnumValueDescriptorProto {
        pub const NAME_FIELD_NUMBER: i32 = 1;
        pub const NAME_DEFAULT_VALUE: &'static str = "";
        pub fn name(&self) -> &str {
            self.name
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::NAME_DEFAULT_VALUE)
        }
        pub fn name_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.name.as_ref()
        }
        pub fn name_mut(&mut self) -> &mut ::std::string::String {
            self.name
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }
        pub fn set_name(&mut self, value: ::std::string::String) {
            self.name = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_name(&mut self) -> ::std::option::Option<::std::string::String> {
            self.name.take()
        }
        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }
        pub const NUMBER_FIELD_NUMBER: i32 = 2;
        pub const NUMBER_DEFAULT_VALUE: i32 = 0;
        pub fn number(&self) -> i32 {
            self.number.unwrap_or(Self::NUMBER_DEFAULT_VALUE)
        }
        pub fn number_option(&self) -> ::std::option::Option<&i32> {
            self.number.as_ref()
        }
        pub fn number_mut(&mut self) -> &mut i32 {
            self.number
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_number(&self) -> bool {
            self.number.is_some()
        }
        pub fn set_number(&mut self, value: i32) {
            self.number = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_number(&mut self) -> ::std::option::Option<i32> {
            self.number.take()
        }
        pub fn clear_number(&mut self) {
            self.number = ::std::option::Option::None;
        }
        pub const OPTIONS_FIELD_NUMBER: i32 = 3;
        pub fn options(&self) -> ::std::option::Option<&self::EnumValueOptions> {
            self.options.as_ref().map(|v| &**v)
        }
        pub fn options_mut(&mut self) -> &mut self::EnumValueOptions {
            self.options
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_options(&self) -> bool {
            self.options.is_some()
        }
        pub fn set_options(&mut self, value: self::EnumValueOptions) {
            self.options = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_options(&mut self) -> ::std::option::Option<self::EnumValueOptions> {
            self.options.take().map(|v| *v)
        }
        pub fn clear_options(&mut self) {
            self.options = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod enum_value_descriptor_proto {
        pub(in super::super) static NAME_REFLECTOR: crate::reflect::access::VerboseFieldAccessor<
            self::super::EnumValueDescriptorProto,
            ::std::string::String,
        > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::EnumValueDescriptorProto::name_option,
            get_mut: self::super::EnumValueDescriptorProto::name_mut,
            set: self::super::EnumValueDescriptorProto::set_name,
            take: self::super::EnumValueDescriptorProto::take_name,
            clear: self::super::EnumValueDescriptorProto::clear_name,
        };
        pub(in super::super) static NUMBER_REFLECTOR: crate::reflect::access::VerboseFieldAccessor<
            self::super::EnumValueDescriptorProto,
            i32,
        > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::EnumValueDescriptorProto::number_option,
            get_mut: self::super::EnumValueDescriptorProto::number_mut,
            set: self::super::EnumValueDescriptorProto::set_number,
            take: self::super::EnumValueDescriptorProto::take_number,
            clear: self::super::EnumValueDescriptorProto::clear_number,
        };
        pub(in super::super) static OPTIONS_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::EnumValueDescriptorProto,
                self::super::EnumValueOptions,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::EnumValueDescriptorProto::options,
            get_mut: self::super::EnumValueDescriptorProto::options_mut,
            set: self::super::EnumValueDescriptorProto::set_options,
            take: self::super::EnumValueDescriptorProto::take_options,
            clear: self::super::EnumValueDescriptorProto::clear_options,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct ServiceDescriptorProto {
        name: ::std::option::Option<::std::string::String>,
        method: crate::collections::RepeatedField<self::MethodDescriptorProto>,
        options: ::std::option::Option<::std::boxed::Box<self::ServiceOptions>>,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::ServiceDescriptorProto {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => self.set_name(input.read_string()?),
                    18 => self
                        .method
                        .add_entries(input, &self::service_descriptor_proto::METHOD_CODEC)?,
                    26 => input.read_extension_message(self.options_mut())?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if let ::std::option::Option::Some(name) = self.name_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(name)?)?;
            }
            size = size.checked_add(
                self.method()
                    .calculate_size(&self::service_descriptor_proto::METHOD_CODEC)?,
            )?;
            if let ::std::option::Option::Some(options) = self.options() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::extension_message(options)?)?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if let ::std::option::Option::Some(name) = self.name_option() {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
            self.method()
                .write_to(output, &self::service_descriptor_proto::METHOD_CODEC)?;
            if let ::std::option::Option::Some(options) = self.options() {
                output.write_raw_tag_bytes(&[26])?;
                output.write_extension_message(options)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.method.is_initialized() {
                return false;
            }
            if let ::std::option::Option::Some(options) = self.options() {
                if !crate::CodedMessage::is_initialized(options) {
                    return false;
                }
            }
            true
        }
    }
    impl crate::LiteMessage for self::ServiceDescriptorProto {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(name) = other.name_option() {
                self.set_name(::std::clone::Clone::clone(name));
            }
            self.method.merge(&other.method);
            if let ::std::option::Option::Some(options) = &other.options() {
                crate::LiteMessage::merge(self.options_mut(), options);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::ServiceDescriptorProto {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[8]
        }
    }
    impl self::ServiceDescriptorProto {
        pub const NAME_FIELD_NUMBER: i32 = 1;
        pub const NAME_DEFAULT_VALUE: &'static str = "";
        pub fn name(&self) -> &str {
            self.name
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::NAME_DEFAULT_VALUE)
        }
        pub fn name_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.name.as_ref()
        }
        pub fn name_mut(&mut self) -> &mut ::std::string::String {
            self.name
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }
        pub fn set_name(&mut self, value: ::std::string::String) {
            self.name = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_name(&mut self) -> ::std::option::Option<::std::string::String> {
            self.name.take()
        }
        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }
        pub const METHOD_FIELD_NUMBER: i32 = 2;
        pub fn method(&self) -> &crate::collections::RepeatedField<self::MethodDescriptorProto> {
            &self.method
        }
        pub fn method_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::MethodDescriptorProto> {
            &mut self.method
        }
        pub const OPTIONS_FIELD_NUMBER: i32 = 3;
        pub fn options(&self) -> ::std::option::Option<&self::ServiceOptions> {
            self.options.as_ref().map(|v| &**v)
        }
        pub fn options_mut(&mut self) -> &mut self::ServiceOptions {
            self.options
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_options(&self) -> bool {
            self.options.is_some()
        }
        pub fn set_options(&mut self, value: self::ServiceOptions) {
            self.options = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_options(&mut self) -> ::std::option::Option<self::ServiceOptions> {
            self.options.take().map(|v| *v)
        }
        pub fn clear_options(&mut self) {
            self.options = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod service_descriptor_proto {
        pub(super) static METHOD_CODEC: crate::Codec<self::super::MethodDescriptorProto> =
            crate::Codec::message(18);
        pub(in super::super) static NAME_REFLECTOR: crate::reflect::access::VerboseFieldAccessor<
            self::super::ServiceDescriptorProto,
            ::std::string::String,
        > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::ServiceDescriptorProto::name_option,
            get_mut: self::super::ServiceDescriptorProto::name_mut,
            set: self::super::ServiceDescriptorProto::set_name,
            take: self::super::ServiceDescriptorProto::take_name,
            clear: self::super::ServiceDescriptorProto::clear_name,
        };
        pub(in super::super) static METHOD_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::ServiceDescriptorProto,
            crate::collections::RepeatedField<self::super::MethodDescriptorProto>,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::ServiceDescriptorProto::method,
            get_mut: self::super::ServiceDescriptorProto::method_mut,
        };
        pub(in super::super) static OPTIONS_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::ServiceDescriptorProto,
                self::super::ServiceOptions,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::ServiceDescriptorProto::options,
            get_mut: self::super::ServiceDescriptorProto::options_mut,
            set: self::super::ServiceDescriptorProto::set_options,
            take: self::super::ServiceDescriptorProto::take_options,
            clear: self::super::ServiceDescriptorProto::clear_options,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct MethodDescriptorProto {
        name: ::std::option::Option<::std::string::String>,
        input_type: ::std::option::Option<::std::string::String>,
        output_type: ::std::option::Option<::std::string::String>,
        options: ::std::option::Option<::std::boxed::Box<self::MethodOptions>>,
        client_streaming: ::std::option::Option<bool>,
        server_streaming: ::std::option::Option<bool>,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::MethodDescriptorProto {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => self.set_name(input.read_string()?),
                    18 => self.set_input_type(input.read_string()?),
                    26 => self.set_output_type(input.read_string()?),
                    34 => input.read_extension_message(self.options_mut())?,
                    40 | 42 => self.set_client_streaming(input.read_bool()?),
                    48 | 50 => self.set_server_streaming(input.read_bool()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if let ::std::option::Option::Some(name) = self.name_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(name)?)?;
            }
            if let ::std::option::Option::Some(input_type) = self.input_type_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(input_type)?)?;
            }
            if let ::std::option::Option::Some(output_type) = self.output_type_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(output_type)?)?;
            }
            if let ::std::option::Option::Some(options) = self.options() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::extension_message(options)?)?;
            }
            if let ::std::option::Option::Some(client_streaming) = self.client_streaming_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(*client_streaming))?;
            }
            if let ::std::option::Option::Some(server_streaming) = self.server_streaming_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(*server_streaming))?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if let ::std::option::Option::Some(name) = self.name_option() {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(name)?;
            }
            if let ::std::option::Option::Some(input_type) = self.input_type_option() {
                output.write_raw_tag_bytes(&[18])?;
                output.write_string(input_type)?;
            }
            if let ::std::option::Option::Some(output_type) = self.output_type_option() {
                output.write_raw_tag_bytes(&[26])?;
                output.write_string(output_type)?;
            }
            if let ::std::option::Option::Some(options) = self.options() {
                output.write_raw_tag_bytes(&[34])?;
                output.write_extension_message(options)?;
            }
            if let ::std::option::Option::Some(client_streaming) = self.client_streaming_option() {
                output.write_raw_tag_bytes(&[40])?;
                output.write_bool(*client_streaming)?;
            }
            if let ::std::option::Option::Some(server_streaming) = self.server_streaming_option() {
                output.write_raw_tag_bytes(&[48])?;
                output.write_bool(*server_streaming)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(options) = self.options() {
                if !crate::CodedMessage::is_initialized(options) {
                    return false;
                }
            }
            true
        }
    }
    impl crate::LiteMessage for self::MethodDescriptorProto {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(name) = other.name_option() {
                self.set_name(::std::clone::Clone::clone(name));
            }
            if let ::std::option::Option::Some(input_type) = other.input_type_option() {
                self.set_input_type(::std::clone::Clone::clone(input_type));
            }
            if let ::std::option::Option::Some(output_type) = other.output_type_option() {
                self.set_output_type(::std::clone::Clone::clone(output_type));
            }
            if let ::std::option::Option::Some(options) = &other.options() {
                crate::LiteMessage::merge(self.options_mut(), options);
            }
            if let ::std::option::Option::Some(client_streaming) = other.client_streaming_option() {
                self.set_client_streaming(*client_streaming);
            }
            if let ::std::option::Option::Some(server_streaming) = other.server_streaming_option() {
                self.set_server_streaming(*server_streaming);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::MethodDescriptorProto {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[9]
        }
    }
    impl self::MethodDescriptorProto {
        pub const NAME_FIELD_NUMBER: i32 = 1;
        pub const NAME_DEFAULT_VALUE: &'static str = "";
        pub fn name(&self) -> &str {
            self.name
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::NAME_DEFAULT_VALUE)
        }
        pub fn name_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.name.as_ref()
        }
        pub fn name_mut(&mut self) -> &mut ::std::string::String {
            self.name
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }
        pub fn set_name(&mut self, value: ::std::string::String) {
            self.name = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_name(&mut self) -> ::std::option::Option<::std::string::String> {
            self.name.take()
        }
        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }
        pub const INPUT_TYPE_FIELD_NUMBER: i32 = 2;
        pub const INPUT_TYPE_DEFAULT_VALUE: &'static str = "";
        pub fn input_type(&self) -> &str {
            self.input_type
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::INPUT_TYPE_DEFAULT_VALUE)
        }
        pub fn input_type_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.input_type.as_ref()
        }
        pub fn input_type_mut(&mut self) -> &mut ::std::string::String {
            self.input_type
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_input_type(&self) -> bool {
            self.input_type.is_some()
        }
        pub fn set_input_type(&mut self, value: ::std::string::String) {
            self.input_type = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_input_type(&mut self) -> ::std::option::Option<::std::string::String> {
            self.input_type.take()
        }
        pub fn clear_input_type(&mut self) {
            self.input_type = ::std::option::Option::None;
        }
        pub const OUTPUT_TYPE_FIELD_NUMBER: i32 = 3;
        pub const OUTPUT_TYPE_DEFAULT_VALUE: &'static str = "";
        pub fn output_type(&self) -> &str {
            self.output_type
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::OUTPUT_TYPE_DEFAULT_VALUE)
        }
        pub fn output_type_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.output_type.as_ref()
        }
        pub fn output_type_mut(&mut self) -> &mut ::std::string::String {
            self.output_type
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_output_type(&self) -> bool {
            self.output_type.is_some()
        }
        pub fn set_output_type(&mut self, value: ::std::string::String) {
            self.output_type = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_output_type(&mut self) -> ::std::option::Option<::std::string::String> {
            self.output_type.take()
        }
        pub fn clear_output_type(&mut self) {
            self.output_type = ::std::option::Option::None;
        }
        pub const OPTIONS_FIELD_NUMBER: i32 = 4;
        pub fn options(&self) -> ::std::option::Option<&self::MethodOptions> {
            self.options.as_ref().map(|v| &**v)
        }
        pub fn options_mut(&mut self) -> &mut self::MethodOptions {
            self.options
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_options(&self) -> bool {
            self.options.is_some()
        }
        pub fn set_options(&mut self, value: self::MethodOptions) {
            self.options = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_options(&mut self) -> ::std::option::Option<self::MethodOptions> {
            self.options.take().map(|v| *v)
        }
        pub fn clear_options(&mut self) {
            self.options = ::std::option::Option::None;
        }
        pub const CLIENT_STREAMING_FIELD_NUMBER: i32 = 5;
        pub const CLIENT_STREAMING_DEFAULT_VALUE: bool = false;
        pub fn client_streaming(&self) -> bool {
            self.client_streaming
                .unwrap_or(Self::CLIENT_STREAMING_DEFAULT_VALUE)
        }
        pub fn client_streaming_option(&self) -> ::std::option::Option<&bool> {
            self.client_streaming.as_ref()
        }
        pub fn client_streaming_mut(&mut self) -> &mut bool {
            self.client_streaming
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_client_streaming(&self) -> bool {
            self.client_streaming.is_some()
        }
        pub fn set_client_streaming(&mut self, value: bool) {
            self.client_streaming = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_client_streaming(&mut self) -> ::std::option::Option<bool> {
            self.client_streaming.take()
        }
        pub fn clear_client_streaming(&mut self) {
            self.client_streaming = ::std::option::Option::None;
        }
        pub const SERVER_STREAMING_FIELD_NUMBER: i32 = 6;
        pub const SERVER_STREAMING_DEFAULT_VALUE: bool = false;
        pub fn server_streaming(&self) -> bool {
            self.server_streaming
                .unwrap_or(Self::SERVER_STREAMING_DEFAULT_VALUE)
        }
        pub fn server_streaming_option(&self) -> ::std::option::Option<&bool> {
            self.server_streaming.as_ref()
        }
        pub fn server_streaming_mut(&mut self) -> &mut bool {
            self.server_streaming
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_server_streaming(&self) -> bool {
            self.server_streaming.is_some()
        }
        pub fn set_server_streaming(&mut self, value: bool) {
            self.server_streaming = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_server_streaming(&mut self) -> ::std::option::Option<bool> {
            self.server_streaming.take()
        }
        pub fn clear_server_streaming(&mut self) {
            self.server_streaming = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod method_descriptor_proto {
        pub(in super::super) static NAME_REFLECTOR: crate::reflect::access::VerboseFieldAccessor<
            self::super::MethodDescriptorProto,
            ::std::string::String,
        > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::MethodDescriptorProto::name_option,
            get_mut: self::super::MethodDescriptorProto::name_mut,
            set: self::super::MethodDescriptorProto::set_name,
            take: self::super::MethodDescriptorProto::take_name,
            clear: self::super::MethodDescriptorProto::clear_name,
        };
        pub(in super::super) static INPUT_TYPE_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::MethodDescriptorProto,
                ::std::string::String,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::MethodDescriptorProto::input_type_option,
            get_mut: self::super::MethodDescriptorProto::input_type_mut,
            set: self::super::MethodDescriptorProto::set_input_type,
            take: self::super::MethodDescriptorProto::take_input_type,
            clear: self::super::MethodDescriptorProto::clear_input_type,
        };
        pub(in super::super) static OUTPUT_TYPE_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::MethodDescriptorProto,
                ::std::string::String,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::MethodDescriptorProto::output_type_option,
            get_mut: self::super::MethodDescriptorProto::output_type_mut,
            set: self::super::MethodDescriptorProto::set_output_type,
            take: self::super::MethodDescriptorProto::take_output_type,
            clear: self::super::MethodDescriptorProto::clear_output_type,
        };
        pub(in super::super) static OPTIONS_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::MethodDescriptorProto,
                self::super::MethodOptions,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::MethodDescriptorProto::options,
            get_mut: self::super::MethodDescriptorProto::options_mut,
            set: self::super::MethodDescriptorProto::set_options,
            take: self::super::MethodDescriptorProto::take_options,
            clear: self::super::MethodDescriptorProto::clear_options,
        };
        pub(in super::super) static CLIENT_STREAMING_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::MethodDescriptorProto, bool> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::MethodDescriptorProto::client_streaming_option,
                get_mut: self::super::MethodDescriptorProto::client_streaming_mut,
                set: self::super::MethodDescriptorProto::set_client_streaming,
                take: self::super::MethodDescriptorProto::take_client_streaming,
                clear: self::super::MethodDescriptorProto::clear_client_streaming,
            };
        pub(in super::super) static SERVER_STREAMING_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::MethodDescriptorProto, bool> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::MethodDescriptorProto::server_streaming_option,
                get_mut: self::super::MethodDescriptorProto::server_streaming_mut,
                set: self::super::MethodDescriptorProto::set_server_streaming,
                take: self::super::MethodDescriptorProto::take_server_streaming,
                clear: self::super::MethodDescriptorProto::clear_server_streaming,
            };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct FileOptions {
        java_package: ::std::option::Option<::std::string::String>,
        java_outer_classname: ::std::option::Option<::std::string::String>,
        java_multiple_files: ::std::option::Option<bool>,
        java_generate_equals_and_hash: ::std::option::Option<bool>,
        java_string_check_utf8: ::std::option::Option<bool>,
        optimize_for: ::std::option::Option<crate::EnumValue<self::file_options::OptimizeMode>>,
        go_package: ::std::option::Option<::std::string::String>,
        cc_generic_services: ::std::option::Option<bool>,
        java_generic_services: ::std::option::Option<bool>,
        py_generic_services: ::std::option::Option<bool>,
        php_generic_services: ::std::option::Option<bool>,
        deprecated: ::std::option::Option<bool>,
        cc_enable_arenas: ::std::option::Option<bool>,
        objc_class_prefix: ::std::option::Option<::std::string::String>,
        csharp_namespace: ::std::option::Option<::std::string::String>,
        swift_prefix: ::std::option::Option<::std::string::String>,
        php_class_prefix: ::std::option::Option<::std::string::String>,
        php_namespace: ::std::option::Option<::std::string::String>,
        php_metadata_namespace: ::std::option::Option<::std::string::String>,
        ruby_package: ::std::option::Option<::std::string::String>,
        uninterpreted_option: crate::collections::RepeatedField<self::UninterpretedOption>,
        unknown_fields: crate::UnknownFieldSet,
        extensions: crate::ExtensionSet<Self>,
    }
    impl crate::CodedMessage for self::FileOptions {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => self.set_java_package(input.read_string()?),
                    66 => self.set_java_outer_classname(input.read_string()?),
                    80 | 82 => self.set_java_multiple_files(input.read_bool()?),
                    160 | 162 => self.set_java_generate_equals_and_hash(input.read_bool()?),
                    216 | 218 => self.set_java_string_check_utf8(input.read_bool()?),
                    72 | 74 => self.set_optimize_for(input.read_enum_value()?),
                    90 => self.set_go_package(input.read_string()?),
                    128 | 130 => self.set_cc_generic_services(input.read_bool()?),
                    136 | 138 => self.set_java_generic_services(input.read_bool()?),
                    144 | 146 => self.set_py_generic_services(input.read_bool()?),
                    336 | 338 => self.set_php_generic_services(input.read_bool()?),
                    184 | 186 => self.set_deprecated(input.read_bool()?),
                    248 | 250 => self.set_cc_enable_arenas(input.read_bool()?),
                    290 => self.set_objc_class_prefix(input.read_string()?),
                    298 => self.set_csharp_namespace(input.read_string()?),
                    314 => self.set_swift_prefix(input.read_string()?),
                    322 => self.set_php_class_prefix(input.read_string()?),
                    330 => self.set_php_namespace(input.read_string()?),
                    354 => self.set_php_metadata_namespace(input.read_string()?),
                    362 => self.set_ruby_package(input.read_string()?),
                    7994 => self
                        .uninterpreted_option
                        .add_entries(input, &self::file_options::UNINTERPRETED_OPTION_CODEC)?,
                    _ => {
                        if !self.extensions.merge_from(input)? {
                            self.unknown_fields.merge_from(tag, input)?
                        }
                    }
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if let ::std::option::Option::Some(java_package) = self.java_package_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(java_package)?)?;
            }
            if let ::std::option::Option::Some(java_outer_classname) =
                self.java_outer_classname_option()
            {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(java_outer_classname)?)?;
            }
            if let ::std::option::Option::Some(java_multiple_files) =
                self.java_multiple_files_option()
            {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(*java_multiple_files))?;
            }
            if let ::std::option::Option::Some(java_generate_equals_and_hash) =
                self.java_generate_equals_and_hash_option()
            {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::bool(*java_generate_equals_and_hash))?;
            }
            if let ::std::option::Option::Some(java_string_check_utf8) =
                self.java_string_check_utf8_option()
            {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::bool(*java_string_check_utf8))?;
            }
            if let ::std::option::Option::Some(optimize_for) = self.optimize_for_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::enum_value(*optimize_for))?;
            }
            if let ::std::option::Option::Some(go_package) = self.go_package_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(go_package)?)?;
            }
            if let ::std::option::Option::Some(cc_generic_services) =
                self.cc_generic_services_option()
            {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::bool(*cc_generic_services))?;
            }
            if let ::std::option::Option::Some(java_generic_services) =
                self.java_generic_services_option()
            {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::bool(*java_generic_services))?;
            }
            if let ::std::option::Option::Some(py_generic_services) =
                self.py_generic_services_option()
            {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::bool(*py_generic_services))?;
            }
            if let ::std::option::Option::Some(php_generic_services) =
                self.php_generic_services_option()
            {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::bool(*php_generic_services))?;
            }
            if let ::std::option::Option::Some(deprecated) = self.deprecated_option() {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::bool(*deprecated))?;
            }
            if let ::std::option::Option::Some(cc_enable_arenas) = self.cc_enable_arenas_option() {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::bool(*cc_enable_arenas))?;
            }
            if let ::std::option::Option::Some(objc_class_prefix) = self.objc_class_prefix_option()
            {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::string(objc_class_prefix)?)?;
            }
            if let ::std::option::Option::Some(csharp_namespace) = self.csharp_namespace_option() {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::string(csharp_namespace)?)?;
            }
            if let ::std::option::Option::Some(swift_prefix) = self.swift_prefix_option() {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::string(swift_prefix)?)?;
            }
            if let ::std::option::Option::Some(php_class_prefix) = self.php_class_prefix_option() {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::string(php_class_prefix)?)?;
            }
            if let ::std::option::Option::Some(php_namespace) = self.php_namespace_option() {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::string(php_namespace)?)?;
            }
            if let ::std::option::Option::Some(php_metadata_namespace) =
                self.php_metadata_namespace_option()
            {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::string(php_metadata_namespace)?)?;
            }
            if let ::std::option::Option::Some(ruby_package) = self.ruby_package_option() {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::string(ruby_package)?)?;
            }
            size = size.checked_add(
                self.uninterpreted_option()
                    .calculate_size(&self::file_options::UNINTERPRETED_OPTION_CODEC)?,
            )?;
            size = size.checked_add(self.extensions.calculate_size()?)?;
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if let ::std::option::Option::Some(java_package) = self.java_package_option() {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(java_package)?;
            }
            if let ::std::option::Option::Some(java_outer_classname) =
                self.java_outer_classname_option()
            {
                output.write_raw_tag_bytes(&[66])?;
                output.write_string(java_outer_classname)?;
            }
            if let ::std::option::Option::Some(java_multiple_files) =
                self.java_multiple_files_option()
            {
                output.write_raw_tag_bytes(&[80])?;
                output.write_bool(*java_multiple_files)?;
            }
            if let ::std::option::Option::Some(java_generate_equals_and_hash) =
                self.java_generate_equals_and_hash_option()
            {
                output.write_raw_tag_bytes(&[160, 1])?;
                output.write_bool(*java_generate_equals_and_hash)?;
            }
            if let ::std::option::Option::Some(java_string_check_utf8) =
                self.java_string_check_utf8_option()
            {
                output.write_raw_tag_bytes(&[216, 1])?;
                output.write_bool(*java_string_check_utf8)?;
            }
            if let ::std::option::Option::Some(optimize_for) = self.optimize_for_option() {
                output.write_raw_tag_bytes(&[72])?;
                output.write_enum_value(*optimize_for)?;
            }
            if let ::std::option::Option::Some(go_package) = self.go_package_option() {
                output.write_raw_tag_bytes(&[90])?;
                output.write_string(go_package)?;
            }
            if let ::std::option::Option::Some(cc_generic_services) =
                self.cc_generic_services_option()
            {
                output.write_raw_tag_bytes(&[128, 1])?;
                output.write_bool(*cc_generic_services)?;
            }
            if let ::std::option::Option::Some(java_generic_services) =
                self.java_generic_services_option()
            {
                output.write_raw_tag_bytes(&[136, 1])?;
                output.write_bool(*java_generic_services)?;
            }
            if let ::std::option::Option::Some(py_generic_services) =
                self.py_generic_services_option()
            {
                output.write_raw_tag_bytes(&[144, 1])?;
                output.write_bool(*py_generic_services)?;
            }
            if let ::std::option::Option::Some(php_generic_services) =
                self.php_generic_services_option()
            {
                output.write_raw_tag_bytes(&[208, 2])?;
                output.write_bool(*php_generic_services)?;
            }
            if let ::std::option::Option::Some(deprecated) = self.deprecated_option() {
                output.write_raw_tag_bytes(&[184, 1])?;
                output.write_bool(*deprecated)?;
            }
            if let ::std::option::Option::Some(cc_enable_arenas) = self.cc_enable_arenas_option() {
                output.write_raw_tag_bytes(&[248, 1])?;
                output.write_bool(*cc_enable_arenas)?;
            }
            if let ::std::option::Option::Some(objc_class_prefix) = self.objc_class_prefix_option()
            {
                output.write_raw_tag_bytes(&[162, 2])?;
                output.write_string(objc_class_prefix)?;
            }
            if let ::std::option::Option::Some(csharp_namespace) = self.csharp_namespace_option() {
                output.write_raw_tag_bytes(&[170, 2])?;
                output.write_string(csharp_namespace)?;
            }
            if let ::std::option::Option::Some(swift_prefix) = self.swift_prefix_option() {
                output.write_raw_tag_bytes(&[186, 2])?;
                output.write_string(swift_prefix)?;
            }
            if let ::std::option::Option::Some(php_class_prefix) = self.php_class_prefix_option() {
                output.write_raw_tag_bytes(&[194, 2])?;
                output.write_string(php_class_prefix)?;
            }
            if let ::std::option::Option::Some(php_namespace) = self.php_namespace_option() {
                output.write_raw_tag_bytes(&[202, 2])?;
                output.write_string(php_namespace)?;
            }
            if let ::std::option::Option::Some(php_metadata_namespace) =
                self.php_metadata_namespace_option()
            {
                output.write_raw_tag_bytes(&[226, 2])?;
                output.write_string(php_metadata_namespace)?;
            }
            if let ::std::option::Option::Some(ruby_package) = self.ruby_package_option() {
                output.write_raw_tag_bytes(&[234, 2])?;
                output.write_string(ruby_package)?;
            }
            self.uninterpreted_option()
                .write_to(output, &self::file_options::UNINTERPRETED_OPTION_CODEC)?;
            self.extensions.write_to(output)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.uninterpreted_option.is_initialized() {
                return false;
            }
            true
        }
    }
    impl crate::LiteMessage for self::FileOptions {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(java_package) = other.java_package_option() {
                self.set_java_package(::std::clone::Clone::clone(java_package));
            }
            if let ::std::option::Option::Some(java_outer_classname) =
                other.java_outer_classname_option()
            {
                self.set_java_outer_classname(::std::clone::Clone::clone(java_outer_classname));
            }
            if let ::std::option::Option::Some(java_multiple_files) =
                other.java_multiple_files_option()
            {
                self.set_java_multiple_files(*java_multiple_files);
            }
            if let ::std::option::Option::Some(java_generate_equals_and_hash) =
                other.java_generate_equals_and_hash_option()
            {
                self.set_java_generate_equals_and_hash(*java_generate_equals_and_hash);
            }
            if let ::std::option::Option::Some(java_string_check_utf8) =
                other.java_string_check_utf8_option()
            {
                self.set_java_string_check_utf8(*java_string_check_utf8);
            }
            if let ::std::option::Option::Some(optimize_for) = other.optimize_for_option() {
                self.set_optimize_for(*optimize_for);
            }
            if let ::std::option::Option::Some(go_package) = other.go_package_option() {
                self.set_go_package(::std::clone::Clone::clone(go_package));
            }
            if let ::std::option::Option::Some(cc_generic_services) =
                other.cc_generic_services_option()
            {
                self.set_cc_generic_services(*cc_generic_services);
            }
            if let ::std::option::Option::Some(java_generic_services) =
                other.java_generic_services_option()
            {
                self.set_java_generic_services(*java_generic_services);
            }
            if let ::std::option::Option::Some(py_generic_services) =
                other.py_generic_services_option()
            {
                self.set_py_generic_services(*py_generic_services);
            }
            if let ::std::option::Option::Some(php_generic_services) =
                other.php_generic_services_option()
            {
                self.set_php_generic_services(*php_generic_services);
            }
            if let ::std::option::Option::Some(deprecated) = other.deprecated_option() {
                self.set_deprecated(*deprecated);
            }
            if let ::std::option::Option::Some(cc_enable_arenas) = other.cc_enable_arenas_option() {
                self.set_cc_enable_arenas(*cc_enable_arenas);
            }
            if let ::std::option::Option::Some(objc_class_prefix) = other.objc_class_prefix_option()
            {
                self.set_objc_class_prefix(::std::clone::Clone::clone(objc_class_prefix));
            }
            if let ::std::option::Option::Some(csharp_namespace) = other.csharp_namespace_option() {
                self.set_csharp_namespace(::std::clone::Clone::clone(csharp_namespace));
            }
            if let ::std::option::Option::Some(swift_prefix) = other.swift_prefix_option() {
                self.set_swift_prefix(::std::clone::Clone::clone(swift_prefix));
            }
            if let ::std::option::Option::Some(php_class_prefix) = other.php_class_prefix_option() {
                self.set_php_class_prefix(::std::clone::Clone::clone(php_class_prefix));
            }
            if let ::std::option::Option::Some(php_namespace) = other.php_namespace_option() {
                self.set_php_namespace(::std::clone::Clone::clone(php_namespace));
            }
            if let ::std::option::Option::Some(php_metadata_namespace) =
                other.php_metadata_namespace_option()
            {
                self.set_php_metadata_namespace(::std::clone::Clone::clone(php_metadata_namespace));
            }
            if let ::std::option::Option::Some(ruby_package) = other.ruby_package_option() {
                self.set_ruby_package(::std::clone::Clone::clone(ruby_package));
            }
            self.uninterpreted_option.merge(&other.uninterpreted_option);
            self.extensions.merge(&other.extensions);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::ExtendableMessage for self::FileOptions {
        fn registry(&self) -> ::std::option::Option<&'static crate::ExtensionRegistry> {
            self.extensions.registry()
        }
        fn replace_registry(
            &mut self,
            extensions: ::std::option::Option<&'static crate::ExtensionRegistry>,
        ) -> ::std::option::Option<&'static crate::ExtensionRegistry> {
            self.extensions.replace_registry(extensions)
        }
        fn has_extension<T: crate::ExtensionIdentifier>(&self, extension: &'static T) -> bool {
            self.extensions.has_extension(extension)
        }
        fn has_extension_unchecked<T: crate::ExtensionIdentifier>(
            &self,
            extension: &'static T,
        ) -> bool {
            self.extensions.has_extension_unchecked(extension)
        }
        fn get_value<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &self,
            extension: &'static crate::Extension<Self, V, D>,
        ) -> Option<&V> {
            self.extensions.get_value(extension)
        }
        fn get_value_or_default<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync
                + ::std::ops::Deref<Target = L>,
            D: ::std::marker::Sync + ::std::ops::Deref<Target = L>,
            L,
        >(
            &self,
            extension: &'static crate::Extension<Self, V, D>,
        ) -> Option<&L> {
            self.extensions.get_value_or_default(extension)
        }
        fn get_repeated_value<
            V: ::std::cmp::PartialEq
                + ::std::clone::Clone
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &self,
            extension: &'static crate::RepeatedExtension<Self, V>,
        ) -> Option<&crate::collections::RepeatedField<V>> {
            self.extensions.get_repeated_value(extension)
        }
        fn field<
            V: ::std::default::Default
                + ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static crate::Extension<Self, V, D>,
        ) -> ::std::option::Option<crate::ExtensionField<Self, V, D>> {
            self.extensions.field(extension)
        }
        fn repeated_field<
            V: ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static crate::RepeatedExtension<Self, V>,
        ) -> ::std::option::Option<crate::RepeatedExtensionField<Self, V>> {
            self.extensions.repeated_field(extension)
        }
    }
    impl crate::Message for self::FileOptions {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[10]
        }
    }
    impl self::FileOptions {
        pub const JAVA_PACKAGE_FIELD_NUMBER: i32 = 1;
        pub const JAVA_PACKAGE_DEFAULT_VALUE: &'static str = "";
        pub fn java_package(&self) -> &str {
            self.java_package
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::JAVA_PACKAGE_DEFAULT_VALUE)
        }
        pub fn java_package_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.java_package.as_ref()
        }
        pub fn java_package_mut(&mut self) -> &mut ::std::string::String {
            self.java_package
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_java_package(&self) -> bool {
            self.java_package.is_some()
        }
        pub fn set_java_package(&mut self, value: ::std::string::String) {
            self.java_package = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_java_package(&mut self) -> ::std::option::Option<::std::string::String> {
            self.java_package.take()
        }
        pub fn clear_java_package(&mut self) {
            self.java_package = ::std::option::Option::None;
        }
        pub const JAVA_OUTER_CLASSNAME_FIELD_NUMBER: i32 = 8;
        pub const JAVA_OUTER_CLASSNAME_DEFAULT_VALUE: &'static str = "";
        pub fn java_outer_classname(&self) -> &str {
            self.java_outer_classname
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::JAVA_OUTER_CLASSNAME_DEFAULT_VALUE)
        }
        pub fn java_outer_classname_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.java_outer_classname.as_ref()
        }
        pub fn java_outer_classname_mut(&mut self) -> &mut ::std::string::String {
            self.java_outer_classname
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_java_outer_classname(&self) -> bool {
            self.java_outer_classname.is_some()
        }
        pub fn set_java_outer_classname(&mut self, value: ::std::string::String) {
            self.java_outer_classname =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_java_outer_classname(
            &mut self,
        ) -> ::std::option::Option<::std::string::String> {
            self.java_outer_classname.take()
        }
        pub fn clear_java_outer_classname(&mut self) {
            self.java_outer_classname = ::std::option::Option::None;
        }
        pub const JAVA_MULTIPLE_FILES_FIELD_NUMBER: i32 = 10;
        pub const JAVA_MULTIPLE_FILES_DEFAULT_VALUE: bool = false;
        pub fn java_multiple_files(&self) -> bool {
            self.java_multiple_files
                .unwrap_or(Self::JAVA_MULTIPLE_FILES_DEFAULT_VALUE)
        }
        pub fn java_multiple_files_option(&self) -> ::std::option::Option<&bool> {
            self.java_multiple_files.as_ref()
        }
        pub fn java_multiple_files_mut(&mut self) -> &mut bool {
            self.java_multiple_files
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_java_multiple_files(&self) -> bool {
            self.java_multiple_files.is_some()
        }
        pub fn set_java_multiple_files(&mut self, value: bool) {
            self.java_multiple_files =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_java_multiple_files(&mut self) -> ::std::option::Option<bool> {
            self.java_multiple_files.take()
        }
        pub fn clear_java_multiple_files(&mut self) {
            self.java_multiple_files = ::std::option::Option::None;
        }
        pub const JAVA_GENERATE_EQUALS_AND_HASH_FIELD_NUMBER: i32 = 20;
        pub const JAVA_GENERATE_EQUALS_AND_HASH_DEFAULT_VALUE: bool = false;
        pub fn java_generate_equals_and_hash(&self) -> bool {
            self.java_generate_equals_and_hash
                .unwrap_or(Self::JAVA_GENERATE_EQUALS_AND_HASH_DEFAULT_VALUE)
        }
        pub fn java_generate_equals_and_hash_option(&self) -> ::std::option::Option<&bool> {
            self.java_generate_equals_and_hash.as_ref()
        }
        pub fn java_generate_equals_and_hash_mut(&mut self) -> &mut bool {
            self.java_generate_equals_and_hash
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_java_generate_equals_and_hash(&self) -> bool {
            self.java_generate_equals_and_hash.is_some()
        }
        pub fn set_java_generate_equals_and_hash(&mut self, value: bool) {
            self.java_generate_equals_and_hash =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_java_generate_equals_and_hash(&mut self) -> ::std::option::Option<bool> {
            self.java_generate_equals_and_hash.take()
        }
        pub fn clear_java_generate_equals_and_hash(&mut self) {
            self.java_generate_equals_and_hash = ::std::option::Option::None;
        }
        pub const JAVA_STRING_CHECK_UTF8_FIELD_NUMBER: i32 = 27;
        pub const JAVA_STRING_CHECK_UTF8_DEFAULT_VALUE: bool = false;
        pub fn java_string_check_utf8(&self) -> bool {
            self.java_string_check_utf8
                .unwrap_or(Self::JAVA_STRING_CHECK_UTF8_DEFAULT_VALUE)
        }
        pub fn java_string_check_utf8_option(&self) -> ::std::option::Option<&bool> {
            self.java_string_check_utf8.as_ref()
        }
        pub fn java_string_check_utf8_mut(&mut self) -> &mut bool {
            self.java_string_check_utf8
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_java_string_check_utf8(&self) -> bool {
            self.java_string_check_utf8.is_some()
        }
        pub fn set_java_string_check_utf8(&mut self, value: bool) {
            self.java_string_check_utf8 =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_java_string_check_utf8(&mut self) -> ::std::option::Option<bool> {
            self.java_string_check_utf8.take()
        }
        pub fn clear_java_string_check_utf8(&mut self) {
            self.java_string_check_utf8 = ::std::option::Option::None;
        }
        pub const OPTIMIZE_FOR_FIELD_NUMBER: i32 = 9;
        pub const OPTIMIZE_FOR_DEFAULT_VALUE: crate::EnumValue<self::file_options::OptimizeMode> =
            crate::EnumValue::Defined(self::file_options::OptimizeMode::Speed);
        pub fn optimize_for(&self) -> crate::EnumValue<self::file_options::OptimizeMode> {
            self.optimize_for
                .unwrap_or(Self::OPTIMIZE_FOR_DEFAULT_VALUE)
        }
        pub fn optimize_for_option(
            &self,
        ) -> ::std::option::Option<&crate::EnumValue<self::file_options::OptimizeMode>> {
            self.optimize_for.as_ref()
        }
        pub fn optimize_for_mut(
            &mut self,
        ) -> &mut crate::EnumValue<self::file_options::OptimizeMode> {
            self.optimize_for
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optimize_for(&self) -> bool {
            self.optimize_for.is_some()
        }
        pub fn set_optimize_for(
            &mut self,
            value: crate::EnumValue<self::file_options::OptimizeMode>,
        ) {
            self.optimize_for = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optimize_for(
            &mut self,
        ) -> ::std::option::Option<crate::EnumValue<self::file_options::OptimizeMode>> {
            self.optimize_for.take()
        }
        pub fn clear_optimize_for(&mut self) {
            self.optimize_for = ::std::option::Option::None;
        }
        pub const GO_PACKAGE_FIELD_NUMBER: i32 = 11;
        pub const GO_PACKAGE_DEFAULT_VALUE: &'static str = "";
        pub fn go_package(&self) -> &str {
            self.go_package
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::GO_PACKAGE_DEFAULT_VALUE)
        }
        pub fn go_package_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.go_package.as_ref()
        }
        pub fn go_package_mut(&mut self) -> &mut ::std::string::String {
            self.go_package
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_go_package(&self) -> bool {
            self.go_package.is_some()
        }
        pub fn set_go_package(&mut self, value: ::std::string::String) {
            self.go_package = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_go_package(&mut self) -> ::std::option::Option<::std::string::String> {
            self.go_package.take()
        }
        pub fn clear_go_package(&mut self) {
            self.go_package = ::std::option::Option::None;
        }
        pub const CC_GENERIC_SERVICES_FIELD_NUMBER: i32 = 16;
        pub const CC_GENERIC_SERVICES_DEFAULT_VALUE: bool = false;
        pub fn cc_generic_services(&self) -> bool {
            self.cc_generic_services
                .unwrap_or(Self::CC_GENERIC_SERVICES_DEFAULT_VALUE)
        }
        pub fn cc_generic_services_option(&self) -> ::std::option::Option<&bool> {
            self.cc_generic_services.as_ref()
        }
        pub fn cc_generic_services_mut(&mut self) -> &mut bool {
            self.cc_generic_services
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_cc_generic_services(&self) -> bool {
            self.cc_generic_services.is_some()
        }
        pub fn set_cc_generic_services(&mut self, value: bool) {
            self.cc_generic_services =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_cc_generic_services(&mut self) -> ::std::option::Option<bool> {
            self.cc_generic_services.take()
        }
        pub fn clear_cc_generic_services(&mut self) {
            self.cc_generic_services = ::std::option::Option::None;
        }
        pub const JAVA_GENERIC_SERVICES_FIELD_NUMBER: i32 = 17;
        pub const JAVA_GENERIC_SERVICES_DEFAULT_VALUE: bool = false;
        pub fn java_generic_services(&self) -> bool {
            self.java_generic_services
                .unwrap_or(Self::JAVA_GENERIC_SERVICES_DEFAULT_VALUE)
        }
        pub fn java_generic_services_option(&self) -> ::std::option::Option<&bool> {
            self.java_generic_services.as_ref()
        }
        pub fn java_generic_services_mut(&mut self) -> &mut bool {
            self.java_generic_services
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_java_generic_services(&self) -> bool {
            self.java_generic_services.is_some()
        }
        pub fn set_java_generic_services(&mut self, value: bool) {
            self.java_generic_services =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_java_generic_services(&mut self) -> ::std::option::Option<bool> {
            self.java_generic_services.take()
        }
        pub fn clear_java_generic_services(&mut self) {
            self.java_generic_services = ::std::option::Option::None;
        }
        pub const PY_GENERIC_SERVICES_FIELD_NUMBER: i32 = 18;
        pub const PY_GENERIC_SERVICES_DEFAULT_VALUE: bool = false;
        pub fn py_generic_services(&self) -> bool {
            self.py_generic_services
                .unwrap_or(Self::PY_GENERIC_SERVICES_DEFAULT_VALUE)
        }
        pub fn py_generic_services_option(&self) -> ::std::option::Option<&bool> {
            self.py_generic_services.as_ref()
        }
        pub fn py_generic_services_mut(&mut self) -> &mut bool {
            self.py_generic_services
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_py_generic_services(&self) -> bool {
            self.py_generic_services.is_some()
        }
        pub fn set_py_generic_services(&mut self, value: bool) {
            self.py_generic_services =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_py_generic_services(&mut self) -> ::std::option::Option<bool> {
            self.py_generic_services.take()
        }
        pub fn clear_py_generic_services(&mut self) {
            self.py_generic_services = ::std::option::Option::None;
        }
        pub const PHP_GENERIC_SERVICES_FIELD_NUMBER: i32 = 42;
        pub const PHP_GENERIC_SERVICES_DEFAULT_VALUE: bool = false;
        pub fn php_generic_services(&self) -> bool {
            self.php_generic_services
                .unwrap_or(Self::PHP_GENERIC_SERVICES_DEFAULT_VALUE)
        }
        pub fn php_generic_services_option(&self) -> ::std::option::Option<&bool> {
            self.php_generic_services.as_ref()
        }
        pub fn php_generic_services_mut(&mut self) -> &mut bool {
            self.php_generic_services
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_php_generic_services(&self) -> bool {
            self.php_generic_services.is_some()
        }
        pub fn set_php_generic_services(&mut self, value: bool) {
            self.php_generic_services =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_php_generic_services(&mut self) -> ::std::option::Option<bool> {
            self.php_generic_services.take()
        }
        pub fn clear_php_generic_services(&mut self) {
            self.php_generic_services = ::std::option::Option::None;
        }
        pub const DEPRECATED_FIELD_NUMBER: i32 = 23;
        pub const DEPRECATED_DEFAULT_VALUE: bool = false;
        pub fn deprecated(&self) -> bool {
            self.deprecated.unwrap_or(Self::DEPRECATED_DEFAULT_VALUE)
        }
        pub fn deprecated_option(&self) -> ::std::option::Option<&bool> {
            self.deprecated.as_ref()
        }
        pub fn deprecated_mut(&mut self) -> &mut bool {
            self.deprecated
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_deprecated(&self) -> bool {
            self.deprecated.is_some()
        }
        pub fn set_deprecated(&mut self, value: bool) {
            self.deprecated = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_deprecated(&mut self) -> ::std::option::Option<bool> {
            self.deprecated.take()
        }
        pub fn clear_deprecated(&mut self) {
            self.deprecated = ::std::option::Option::None;
        }
        pub const CC_ENABLE_ARENAS_FIELD_NUMBER: i32 = 31;
        pub const CC_ENABLE_ARENAS_DEFAULT_VALUE: bool = false;
        pub fn cc_enable_arenas(&self) -> bool {
            self.cc_enable_arenas
                .unwrap_or(Self::CC_ENABLE_ARENAS_DEFAULT_VALUE)
        }
        pub fn cc_enable_arenas_option(&self) -> ::std::option::Option<&bool> {
            self.cc_enable_arenas.as_ref()
        }
        pub fn cc_enable_arenas_mut(&mut self) -> &mut bool {
            self.cc_enable_arenas
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_cc_enable_arenas(&self) -> bool {
            self.cc_enable_arenas.is_some()
        }
        pub fn set_cc_enable_arenas(&mut self, value: bool) {
            self.cc_enable_arenas = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_cc_enable_arenas(&mut self) -> ::std::option::Option<bool> {
            self.cc_enable_arenas.take()
        }
        pub fn clear_cc_enable_arenas(&mut self) {
            self.cc_enable_arenas = ::std::option::Option::None;
        }
        pub const OBJC_CLASS_PREFIX_FIELD_NUMBER: i32 = 36;
        pub const OBJC_CLASS_PREFIX_DEFAULT_VALUE: &'static str = "";
        pub fn objc_class_prefix(&self) -> &str {
            self.objc_class_prefix
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::OBJC_CLASS_PREFIX_DEFAULT_VALUE)
        }
        pub fn objc_class_prefix_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.objc_class_prefix.as_ref()
        }
        pub fn objc_class_prefix_mut(&mut self) -> &mut ::std::string::String {
            self.objc_class_prefix
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_objc_class_prefix(&self) -> bool {
            self.objc_class_prefix.is_some()
        }
        pub fn set_objc_class_prefix(&mut self, value: ::std::string::String) {
            self.objc_class_prefix = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_objc_class_prefix(&mut self) -> ::std::option::Option<::std::string::String> {
            self.objc_class_prefix.take()
        }
        pub fn clear_objc_class_prefix(&mut self) {
            self.objc_class_prefix = ::std::option::Option::None;
        }
        pub const CSHARP_NAMESPACE_FIELD_NUMBER: i32 = 37;
        pub const CSHARP_NAMESPACE_DEFAULT_VALUE: &'static str = "";
        pub fn csharp_namespace(&self) -> &str {
            self.csharp_namespace
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::CSHARP_NAMESPACE_DEFAULT_VALUE)
        }
        pub fn csharp_namespace_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.csharp_namespace.as_ref()
        }
        pub fn csharp_namespace_mut(&mut self) -> &mut ::std::string::String {
            self.csharp_namespace
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_csharp_namespace(&self) -> bool {
            self.csharp_namespace.is_some()
        }
        pub fn set_csharp_namespace(&mut self, value: ::std::string::String) {
            self.csharp_namespace = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_csharp_namespace(&mut self) -> ::std::option::Option<::std::string::String> {
            self.csharp_namespace.take()
        }
        pub fn clear_csharp_namespace(&mut self) {
            self.csharp_namespace = ::std::option::Option::None;
        }
        pub const SWIFT_PREFIX_FIELD_NUMBER: i32 = 39;
        pub const SWIFT_PREFIX_DEFAULT_VALUE: &'static str = "";
        pub fn swift_prefix(&self) -> &str {
            self.swift_prefix
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::SWIFT_PREFIX_DEFAULT_VALUE)
        }
        pub fn swift_prefix_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.swift_prefix.as_ref()
        }
        pub fn swift_prefix_mut(&mut self) -> &mut ::std::string::String {
            self.swift_prefix
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_swift_prefix(&self) -> bool {
            self.swift_prefix.is_some()
        }
        pub fn set_swift_prefix(&mut self, value: ::std::string::String) {
            self.swift_prefix = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_swift_prefix(&mut self) -> ::std::option::Option<::std::string::String> {
            self.swift_prefix.take()
        }
        pub fn clear_swift_prefix(&mut self) {
            self.swift_prefix = ::std::option::Option::None;
        }
        pub const PHP_CLASS_PREFIX_FIELD_NUMBER: i32 = 40;
        pub const PHP_CLASS_PREFIX_DEFAULT_VALUE: &'static str = "";
        pub fn php_class_prefix(&self) -> &str {
            self.php_class_prefix
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::PHP_CLASS_PREFIX_DEFAULT_VALUE)
        }
        pub fn php_class_prefix_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.php_class_prefix.as_ref()
        }
        pub fn php_class_prefix_mut(&mut self) -> &mut ::std::string::String {
            self.php_class_prefix
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_php_class_prefix(&self) -> bool {
            self.php_class_prefix.is_some()
        }
        pub fn set_php_class_prefix(&mut self, value: ::std::string::String) {
            self.php_class_prefix = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_php_class_prefix(&mut self) -> ::std::option::Option<::std::string::String> {
            self.php_class_prefix.take()
        }
        pub fn clear_php_class_prefix(&mut self) {
            self.php_class_prefix = ::std::option::Option::None;
        }
        pub const PHP_NAMESPACE_FIELD_NUMBER: i32 = 41;
        pub const PHP_NAMESPACE_DEFAULT_VALUE: &'static str = "";
        pub fn php_namespace(&self) -> &str {
            self.php_namespace
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::PHP_NAMESPACE_DEFAULT_VALUE)
        }
        pub fn php_namespace_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.php_namespace.as_ref()
        }
        pub fn php_namespace_mut(&mut self) -> &mut ::std::string::String {
            self.php_namespace
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_php_namespace(&self) -> bool {
            self.php_namespace.is_some()
        }
        pub fn set_php_namespace(&mut self, value: ::std::string::String) {
            self.php_namespace = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_php_namespace(&mut self) -> ::std::option::Option<::std::string::String> {
            self.php_namespace.take()
        }
        pub fn clear_php_namespace(&mut self) {
            self.php_namespace = ::std::option::Option::None;
        }
        pub const PHP_METADATA_NAMESPACE_FIELD_NUMBER: i32 = 44;
        pub const PHP_METADATA_NAMESPACE_DEFAULT_VALUE: &'static str = "";
        pub fn php_metadata_namespace(&self) -> &str {
            self.php_metadata_namespace
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::PHP_METADATA_NAMESPACE_DEFAULT_VALUE)
        }
        pub fn php_metadata_namespace_option(
            &self,
        ) -> ::std::option::Option<&::std::string::String> {
            self.php_metadata_namespace.as_ref()
        }
        pub fn php_metadata_namespace_mut(&mut self) -> &mut ::std::string::String {
            self.php_metadata_namespace
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_php_metadata_namespace(&self) -> bool {
            self.php_metadata_namespace.is_some()
        }
        pub fn set_php_metadata_namespace(&mut self, value: ::std::string::String) {
            self.php_metadata_namespace =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_php_metadata_namespace(
            &mut self,
        ) -> ::std::option::Option<::std::string::String> {
            self.php_metadata_namespace.take()
        }
        pub fn clear_php_metadata_namespace(&mut self) {
            self.php_metadata_namespace = ::std::option::Option::None;
        }
        pub const RUBY_PACKAGE_FIELD_NUMBER: i32 = 45;
        pub const RUBY_PACKAGE_DEFAULT_VALUE: &'static str = "";
        pub fn ruby_package(&self) -> &str {
            self.ruby_package
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::RUBY_PACKAGE_DEFAULT_VALUE)
        }
        pub fn ruby_package_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.ruby_package.as_ref()
        }
        pub fn ruby_package_mut(&mut self) -> &mut ::std::string::String {
            self.ruby_package
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_ruby_package(&self) -> bool {
            self.ruby_package.is_some()
        }
        pub fn set_ruby_package(&mut self, value: ::std::string::String) {
            self.ruby_package = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_ruby_package(&mut self) -> ::std::option::Option<::std::string::String> {
            self.ruby_package.take()
        }
        pub fn clear_ruby_package(&mut self) {
            self.ruby_package = ::std::option::Option::None;
        }
        pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
        pub fn uninterpreted_option(
            &self,
        ) -> &crate::collections::RepeatedField<self::UninterpretedOption> {
            &self.uninterpreted_option
        }
        pub fn uninterpreted_option_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::UninterpretedOption> {
            &mut self.uninterpreted_option
        }
    }
    pub mod file_options {
        #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
        pub enum OptimizeMode {
            Speed,
            CodeSize,
            LiteRuntime,
        }
        impl crate::Enum for self::OptimizeMode {
            fn descriptor() -> &'static crate::reflect::EnumDescriptor<'static> {
                &<self::super::FileOptions as crate::Message>::descriptor().enums()[0]
            }
        }
        impl ::std::convert::TryFrom<i32> for self::OptimizeMode {
            type Error = crate::VariantUndefinedError;
            fn try_from(value: i32) -> ::std::result::Result<Self, crate::VariantUndefinedError> {
                #[allow(unreachable_patterns)]
                match value {
                    1 => ::std::result::Result::Ok(self::OptimizeMode::Speed),
                    2 => ::std::result::Result::Ok(self::OptimizeMode::CodeSize),
                    3 => ::std::result::Result::Ok(self::OptimizeMode::LiteRuntime),
                    _ => ::std::result::Result::Err(crate::VariantUndefinedError),
                }
            }
        }
        impl ::std::convert::From<self::OptimizeMode> for i32 {
            fn from(value: self::OptimizeMode) -> i32 {
                match value {
                    self::OptimizeMode::Speed => 1,
                    self::OptimizeMode::CodeSize => 2,
                    self::OptimizeMode::LiteRuntime => 3,
                }
            }
        }
        pub(super) static UNINTERPRETED_OPTION_CODEC: crate::Codec<
            self::super::UninterpretedOption,
        > = crate::Codec::message(7994);
        pub(in super::super) static JAVA_PACKAGE_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::FileOptions,
                ::std::string::String,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FileOptions::java_package_option,
            get_mut: self::super::FileOptions::java_package_mut,
            set: self::super::FileOptions::set_java_package,
            take: self::super::FileOptions::take_java_package,
            clear: self::super::FileOptions::clear_java_package,
        };
        pub(in super::super) static JAVA_OUTER_CLASSNAME_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::FileOptions,
                ::std::string::String,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FileOptions::java_outer_classname_option,
            get_mut: self::super::FileOptions::java_outer_classname_mut,
            set: self::super::FileOptions::set_java_outer_classname,
            take: self::super::FileOptions::take_java_outer_classname,
            clear: self::super::FileOptions::clear_java_outer_classname,
        };
        pub(in super::super) static JAVA_MULTIPLE_FILES_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::FileOptions, bool> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::FileOptions::java_multiple_files_option,
                get_mut: self::super::FileOptions::java_multiple_files_mut,
                set: self::super::FileOptions::set_java_multiple_files,
                take: self::super::FileOptions::take_java_multiple_files,
                clear: self::super::FileOptions::clear_java_multiple_files,
            };
        pub(in super::super) static JAVA_GENERATE_EQUALS_AND_HASH_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::FileOptions, bool> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::FileOptions::java_generate_equals_and_hash_option,
                get_mut: self::super::FileOptions::java_generate_equals_and_hash_mut,
                set: self::super::FileOptions::set_java_generate_equals_and_hash,
                take: self::super::FileOptions::take_java_generate_equals_and_hash,
                clear: self::super::FileOptions::clear_java_generate_equals_and_hash,
            };
        pub(in super::super) static JAVA_STRING_CHECK_UTF8_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::FileOptions, bool> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::FileOptions::java_string_check_utf8_option,
                get_mut: self::super::FileOptions::java_string_check_utf8_mut,
                set: self::super::FileOptions::set_java_string_check_utf8,
                take: self::super::FileOptions::take_java_string_check_utf8,
                clear: self::super::FileOptions::clear_java_string_check_utf8,
            };
        pub(in super::super) static OPTIMIZE_FOR_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::FileOptions,
                crate::EnumValue<self::OptimizeMode>,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FileOptions::optimize_for_option,
            get_mut: self::super::FileOptions::optimize_for_mut,
            set: self::super::FileOptions::set_optimize_for,
            take: self::super::FileOptions::take_optimize_for,
            clear: self::super::FileOptions::clear_optimize_for,
        };
        pub(in super::super) static GO_PACKAGE_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::FileOptions,
                ::std::string::String,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FileOptions::go_package_option,
            get_mut: self::super::FileOptions::go_package_mut,
            set: self::super::FileOptions::set_go_package,
            take: self::super::FileOptions::take_go_package,
            clear: self::super::FileOptions::clear_go_package,
        };
        pub(in super::super) static CC_GENERIC_SERVICES_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::FileOptions, bool> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::FileOptions::cc_generic_services_option,
                get_mut: self::super::FileOptions::cc_generic_services_mut,
                set: self::super::FileOptions::set_cc_generic_services,
                take: self::super::FileOptions::take_cc_generic_services,
                clear: self::super::FileOptions::clear_cc_generic_services,
            };
        pub(in super::super) static JAVA_GENERIC_SERVICES_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::FileOptions, bool> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::FileOptions::java_generic_services_option,
                get_mut: self::super::FileOptions::java_generic_services_mut,
                set: self::super::FileOptions::set_java_generic_services,
                take: self::super::FileOptions::take_java_generic_services,
                clear: self::super::FileOptions::clear_java_generic_services,
            };
        pub(in super::super) static PY_GENERIC_SERVICES_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::FileOptions, bool> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::FileOptions::py_generic_services_option,
                get_mut: self::super::FileOptions::py_generic_services_mut,
                set: self::super::FileOptions::set_py_generic_services,
                take: self::super::FileOptions::take_py_generic_services,
                clear: self::super::FileOptions::clear_py_generic_services,
            };
        pub(in super::super) static PHP_GENERIC_SERVICES_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::FileOptions, bool> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::FileOptions::php_generic_services_option,
                get_mut: self::super::FileOptions::php_generic_services_mut,
                set: self::super::FileOptions::set_php_generic_services,
                take: self::super::FileOptions::take_php_generic_services,
                clear: self::super::FileOptions::clear_php_generic_services,
            };
        pub(in super::super) static DEPRECATED_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::FileOptions, bool> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::FileOptions::deprecated_option,
                get_mut: self::super::FileOptions::deprecated_mut,
                set: self::super::FileOptions::set_deprecated,
                take: self::super::FileOptions::take_deprecated,
                clear: self::super::FileOptions::clear_deprecated,
            };
        pub(in super::super) static CC_ENABLE_ARENAS_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::FileOptions, bool> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::FileOptions::cc_enable_arenas_option,
                get_mut: self::super::FileOptions::cc_enable_arenas_mut,
                set: self::super::FileOptions::set_cc_enable_arenas,
                take: self::super::FileOptions::take_cc_enable_arenas,
                clear: self::super::FileOptions::clear_cc_enable_arenas,
            };
        pub(in super::super) static OBJC_CLASS_PREFIX_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::FileOptions,
                ::std::string::String,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FileOptions::objc_class_prefix_option,
            get_mut: self::super::FileOptions::objc_class_prefix_mut,
            set: self::super::FileOptions::set_objc_class_prefix,
            take: self::super::FileOptions::take_objc_class_prefix,
            clear: self::super::FileOptions::clear_objc_class_prefix,
        };
        pub(in super::super) static CSHARP_NAMESPACE_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::FileOptions,
                ::std::string::String,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FileOptions::csharp_namespace_option,
            get_mut: self::super::FileOptions::csharp_namespace_mut,
            set: self::super::FileOptions::set_csharp_namespace,
            take: self::super::FileOptions::take_csharp_namespace,
            clear: self::super::FileOptions::clear_csharp_namespace,
        };
        pub(in super::super) static SWIFT_PREFIX_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::FileOptions,
                ::std::string::String,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FileOptions::swift_prefix_option,
            get_mut: self::super::FileOptions::swift_prefix_mut,
            set: self::super::FileOptions::set_swift_prefix,
            take: self::super::FileOptions::take_swift_prefix,
            clear: self::super::FileOptions::clear_swift_prefix,
        };
        pub(in super::super) static PHP_CLASS_PREFIX_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::FileOptions,
                ::std::string::String,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FileOptions::php_class_prefix_option,
            get_mut: self::super::FileOptions::php_class_prefix_mut,
            set: self::super::FileOptions::set_php_class_prefix,
            take: self::super::FileOptions::take_php_class_prefix,
            clear: self::super::FileOptions::clear_php_class_prefix,
        };
        pub(in super::super) static PHP_NAMESPACE_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::FileOptions,
                ::std::string::String,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FileOptions::php_namespace_option,
            get_mut: self::super::FileOptions::php_namespace_mut,
            set: self::super::FileOptions::set_php_namespace,
            take: self::super::FileOptions::take_php_namespace,
            clear: self::super::FileOptions::clear_php_namespace,
        };
        pub(in super::super) static PHP_METADATA_NAMESPACE_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::FileOptions,
                ::std::string::String,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FileOptions::php_metadata_namespace_option,
            get_mut: self::super::FileOptions::php_metadata_namespace_mut,
            set: self::super::FileOptions::set_php_metadata_namespace,
            take: self::super::FileOptions::take_php_metadata_namespace,
            clear: self::super::FileOptions::clear_php_metadata_namespace,
        };
        pub(in super::super) static RUBY_PACKAGE_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::FileOptions,
                ::std::string::String,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FileOptions::ruby_package_option,
            get_mut: self::super::FileOptions::ruby_package_mut,
            set: self::super::FileOptions::set_ruby_package,
            take: self::super::FileOptions::take_ruby_package,
            clear: self::super::FileOptions::clear_ruby_package,
        };
        pub(in super::super) static UNINTERPRETED_OPTION_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::FileOptions,
                crate::collections::RepeatedField<self::super::UninterpretedOption>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::FileOptions::uninterpreted_option,
            get_mut: self::super::FileOptions::uninterpreted_option_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct MessageOptions {
        message_set_wire_format: ::std::option::Option<bool>,
        no_standard_descriptor_accessor: ::std::option::Option<bool>,
        deprecated: ::std::option::Option<bool>,
        map_entry: ::std::option::Option<bool>,
        uninterpreted_option: crate::collections::RepeatedField<self::UninterpretedOption>,
        unknown_fields: crate::UnknownFieldSet,
        extensions: crate::ExtensionSet<Self>,
    }
    impl crate::CodedMessage for self::MessageOptions {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.set_message_set_wire_format(input.read_bool()?),
                    16 | 18 => self.set_no_standard_descriptor_accessor(input.read_bool()?),
                    24 | 26 => self.set_deprecated(input.read_bool()?),
                    56 | 58 => self.set_map_entry(input.read_bool()?),
                    7994 => self
                        .uninterpreted_option
                        .add_entries(input, &self::message_options::UNINTERPRETED_OPTION_CODEC)?,
                    _ => {
                        if !self.extensions.merge_from(input)? {
                            self.unknown_fields.merge_from(tag, input)?
                        }
                    }
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if let ::std::option::Option::Some(message_set_wire_format) =
                self.message_set_wire_format_option()
            {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(*message_set_wire_format))?;
            }
            if let ::std::option::Option::Some(no_standard_descriptor_accessor) =
                self.no_standard_descriptor_accessor_option()
            {
                size = size.checked_add(1)?;
                size =
                    size.checked_add(crate::io::sizes::bool(*no_standard_descriptor_accessor))?;
            }
            if let ::std::option::Option::Some(deprecated) = self.deprecated_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(*deprecated))?;
            }
            if let ::std::option::Option::Some(map_entry) = self.map_entry_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(*map_entry))?;
            }
            size = size.checked_add(
                self.uninterpreted_option()
                    .calculate_size(&self::message_options::UNINTERPRETED_OPTION_CODEC)?,
            )?;
            size = size.checked_add(self.extensions.calculate_size()?)?;
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if let ::std::option::Option::Some(message_set_wire_format) =
                self.message_set_wire_format_option()
            {
                output.write_raw_tag_bytes(&[8])?;
                output.write_bool(*message_set_wire_format)?;
            }
            if let ::std::option::Option::Some(no_standard_descriptor_accessor) =
                self.no_standard_descriptor_accessor_option()
            {
                output.write_raw_tag_bytes(&[16])?;
                output.write_bool(*no_standard_descriptor_accessor)?;
            }
            if let ::std::option::Option::Some(deprecated) = self.deprecated_option() {
                output.write_raw_tag_bytes(&[24])?;
                output.write_bool(*deprecated)?;
            }
            if let ::std::option::Option::Some(map_entry) = self.map_entry_option() {
                output.write_raw_tag_bytes(&[56])?;
                output.write_bool(*map_entry)?;
            }
            self.uninterpreted_option()
                .write_to(output, &self::message_options::UNINTERPRETED_OPTION_CODEC)?;
            self.extensions.write_to(output)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.uninterpreted_option.is_initialized() {
                return false;
            }
            true
        }
    }
    impl crate::LiteMessage for self::MessageOptions {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(message_set_wire_format) =
                other.message_set_wire_format_option()
            {
                self.set_message_set_wire_format(*message_set_wire_format);
            }
            if let ::std::option::Option::Some(no_standard_descriptor_accessor) =
                other.no_standard_descriptor_accessor_option()
            {
                self.set_no_standard_descriptor_accessor(*no_standard_descriptor_accessor);
            }
            if let ::std::option::Option::Some(deprecated) = other.deprecated_option() {
                self.set_deprecated(*deprecated);
            }
            if let ::std::option::Option::Some(map_entry) = other.map_entry_option() {
                self.set_map_entry(*map_entry);
            }
            self.uninterpreted_option.merge(&other.uninterpreted_option);
            self.extensions.merge(&other.extensions);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::ExtendableMessage for self::MessageOptions {
        fn registry(&self) -> ::std::option::Option<&'static crate::ExtensionRegistry> {
            self.extensions.registry()
        }
        fn replace_registry(
            &mut self,
            extensions: ::std::option::Option<&'static crate::ExtensionRegistry>,
        ) -> ::std::option::Option<&'static crate::ExtensionRegistry> {
            self.extensions.replace_registry(extensions)
        }
        fn has_extension<T: crate::ExtensionIdentifier>(&self, extension: &'static T) -> bool {
            self.extensions.has_extension(extension)
        }
        fn has_extension_unchecked<T: crate::ExtensionIdentifier>(
            &self,
            extension: &'static T,
        ) -> bool {
            self.extensions.has_extension_unchecked(extension)
        }
        fn get_value<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &self,
            extension: &'static crate::Extension<Self, V, D>,
        ) -> Option<&V> {
            self.extensions.get_value(extension)
        }
        fn get_value_or_default<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync
                + ::std::ops::Deref<Target = L>,
            D: ::std::marker::Sync + ::std::ops::Deref<Target = L>,
            L,
        >(
            &self,
            extension: &'static crate::Extension<Self, V, D>,
        ) -> Option<&L> {
            self.extensions.get_value_or_default(extension)
        }
        fn get_repeated_value<
            V: ::std::cmp::PartialEq
                + ::std::clone::Clone
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &self,
            extension: &'static crate::RepeatedExtension<Self, V>,
        ) -> Option<&crate::collections::RepeatedField<V>> {
            self.extensions.get_repeated_value(extension)
        }
        fn field<
            V: ::std::default::Default
                + ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static crate::Extension<Self, V, D>,
        ) -> ::std::option::Option<crate::ExtensionField<Self, V, D>> {
            self.extensions.field(extension)
        }
        fn repeated_field<
            V: ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static crate::RepeatedExtension<Self, V>,
        ) -> ::std::option::Option<crate::RepeatedExtensionField<Self, V>> {
            self.extensions.repeated_field(extension)
        }
    }
    impl crate::Message for self::MessageOptions {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[11]
        }
    }
    impl self::MessageOptions {
        pub const MESSAGE_SET_WIRE_FORMAT_FIELD_NUMBER: i32 = 1;
        pub const MESSAGE_SET_WIRE_FORMAT_DEFAULT_VALUE: bool = false;
        pub fn message_set_wire_format(&self) -> bool {
            self.message_set_wire_format
                .unwrap_or(Self::MESSAGE_SET_WIRE_FORMAT_DEFAULT_VALUE)
        }
        pub fn message_set_wire_format_option(&self) -> ::std::option::Option<&bool> {
            self.message_set_wire_format.as_ref()
        }
        pub fn message_set_wire_format_mut(&mut self) -> &mut bool {
            self.message_set_wire_format
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_message_set_wire_format(&self) -> bool {
            self.message_set_wire_format.is_some()
        }
        pub fn set_message_set_wire_format(&mut self, value: bool) {
            self.message_set_wire_format =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_message_set_wire_format(&mut self) -> ::std::option::Option<bool> {
            self.message_set_wire_format.take()
        }
        pub fn clear_message_set_wire_format(&mut self) {
            self.message_set_wire_format = ::std::option::Option::None;
        }
        pub const NO_STANDARD_DESCRIPTOR_ACCESSOR_FIELD_NUMBER: i32 = 2;
        pub const NO_STANDARD_DESCRIPTOR_ACCESSOR_DEFAULT_VALUE: bool = false;
        pub fn no_standard_descriptor_accessor(&self) -> bool {
            self.no_standard_descriptor_accessor
                .unwrap_or(Self::NO_STANDARD_DESCRIPTOR_ACCESSOR_DEFAULT_VALUE)
        }
        pub fn no_standard_descriptor_accessor_option(&self) -> ::std::option::Option<&bool> {
            self.no_standard_descriptor_accessor.as_ref()
        }
        pub fn no_standard_descriptor_accessor_mut(&mut self) -> &mut bool {
            self.no_standard_descriptor_accessor
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_no_standard_descriptor_accessor(&self) -> bool {
            self.no_standard_descriptor_accessor.is_some()
        }
        pub fn set_no_standard_descriptor_accessor(&mut self, value: bool) {
            self.no_standard_descriptor_accessor =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_no_standard_descriptor_accessor(&mut self) -> ::std::option::Option<bool> {
            self.no_standard_descriptor_accessor.take()
        }
        pub fn clear_no_standard_descriptor_accessor(&mut self) {
            self.no_standard_descriptor_accessor = ::std::option::Option::None;
        }
        pub const DEPRECATED_FIELD_NUMBER: i32 = 3;
        pub const DEPRECATED_DEFAULT_VALUE: bool = false;
        pub fn deprecated(&self) -> bool {
            self.deprecated.unwrap_or(Self::DEPRECATED_DEFAULT_VALUE)
        }
        pub fn deprecated_option(&self) -> ::std::option::Option<&bool> {
            self.deprecated.as_ref()
        }
        pub fn deprecated_mut(&mut self) -> &mut bool {
            self.deprecated
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_deprecated(&self) -> bool {
            self.deprecated.is_some()
        }
        pub fn set_deprecated(&mut self, value: bool) {
            self.deprecated = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_deprecated(&mut self) -> ::std::option::Option<bool> {
            self.deprecated.take()
        }
        pub fn clear_deprecated(&mut self) {
            self.deprecated = ::std::option::Option::None;
        }
        pub const MAP_ENTRY_FIELD_NUMBER: i32 = 7;
        pub const MAP_ENTRY_DEFAULT_VALUE: bool = false;
        pub fn map_entry(&self) -> bool {
            self.map_entry.unwrap_or(Self::MAP_ENTRY_DEFAULT_VALUE)
        }
        pub fn map_entry_option(&self) -> ::std::option::Option<&bool> {
            self.map_entry.as_ref()
        }
        pub fn map_entry_mut(&mut self) -> &mut bool {
            self.map_entry
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_map_entry(&self) -> bool {
            self.map_entry.is_some()
        }
        pub fn set_map_entry(&mut self, value: bool) {
            self.map_entry = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_map_entry(&mut self) -> ::std::option::Option<bool> {
            self.map_entry.take()
        }
        pub fn clear_map_entry(&mut self) {
            self.map_entry = ::std::option::Option::None;
        }
        pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
        pub fn uninterpreted_option(
            &self,
        ) -> &crate::collections::RepeatedField<self::UninterpretedOption> {
            &self.uninterpreted_option
        }
        pub fn uninterpreted_option_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::UninterpretedOption> {
            &mut self.uninterpreted_option
        }
    }
    pub(in super::super) mod message_options {
        pub(super) static UNINTERPRETED_OPTION_CODEC: crate::Codec<
            self::super::UninterpretedOption,
        > = crate::Codec::message(7994);
        pub(in super::super) static MESSAGE_SET_WIRE_FORMAT_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::MessageOptions, bool> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::MessageOptions::message_set_wire_format_option,
                get_mut: self::super::MessageOptions::message_set_wire_format_mut,
                set: self::super::MessageOptions::set_message_set_wire_format,
                take: self::super::MessageOptions::take_message_set_wire_format,
                clear: self::super::MessageOptions::clear_message_set_wire_format,
            };
        pub(in super::super) static NO_STANDARD_DESCRIPTOR_ACCESSOR_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::MessageOptions, bool> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::MessageOptions::no_standard_descriptor_accessor_option,
                get_mut: self::super::MessageOptions::no_standard_descriptor_accessor_mut,
                set: self::super::MessageOptions::set_no_standard_descriptor_accessor,
                take: self::super::MessageOptions::take_no_standard_descriptor_accessor,
                clear: self::super::MessageOptions::clear_no_standard_descriptor_accessor,
            };
        pub(in super::super) static DEPRECATED_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::MessageOptions, bool> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::MessageOptions::deprecated_option,
                get_mut: self::super::MessageOptions::deprecated_mut,
                set: self::super::MessageOptions::set_deprecated,
                take: self::super::MessageOptions::take_deprecated,
                clear: self::super::MessageOptions::clear_deprecated,
            };
        pub(in super::super) static MAP_ENTRY_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::MessageOptions, bool> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::MessageOptions::map_entry_option,
                get_mut: self::super::MessageOptions::map_entry_mut,
                set: self::super::MessageOptions::set_map_entry,
                take: self::super::MessageOptions::take_map_entry,
                clear: self::super::MessageOptions::clear_map_entry,
            };
        pub(in super::super) static UNINTERPRETED_OPTION_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::MessageOptions,
                crate::collections::RepeatedField<self::super::UninterpretedOption>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::MessageOptions::uninterpreted_option,
            get_mut: self::super::MessageOptions::uninterpreted_option_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct FieldOptions {
        ctype: ::std::option::Option<crate::EnumValue<self::field_options::CType>>,
        packed: ::std::option::Option<bool>,
        jstype: ::std::option::Option<crate::EnumValue<self::field_options::JSType>>,
        lazy: ::std::option::Option<bool>,
        deprecated: ::std::option::Option<bool>,
        weak: ::std::option::Option<bool>,
        uninterpreted_option: crate::collections::RepeatedField<self::UninterpretedOption>,
        unknown_fields: crate::UnknownFieldSet,
        extensions: crate::ExtensionSet<Self>,
    }
    impl crate::CodedMessage for self::FieldOptions {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.set_ctype(input.read_enum_value()?),
                    16 | 18 => self.set_packed(input.read_bool()?),
                    48 | 50 => self.set_jstype(input.read_enum_value()?),
                    40 | 42 => self.set_lazy(input.read_bool()?),
                    24 | 26 => self.set_deprecated(input.read_bool()?),
                    80 | 82 => self.set_weak(input.read_bool()?),
                    7994 => self
                        .uninterpreted_option
                        .add_entries(input, &self::field_options::UNINTERPRETED_OPTION_CODEC)?,
                    _ => {
                        if !self.extensions.merge_from(input)? {
                            self.unknown_fields.merge_from(tag, input)?
                        }
                    }
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if let ::std::option::Option::Some(ctype) = self.ctype_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::enum_value(*ctype))?;
            }
            if let ::std::option::Option::Some(packed) = self.packed_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(*packed))?;
            }
            if let ::std::option::Option::Some(jstype) = self.jstype_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::enum_value(*jstype))?;
            }
            if let ::std::option::Option::Some(lazy) = self.lazy_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(*lazy))?;
            }
            if let ::std::option::Option::Some(deprecated) = self.deprecated_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(*deprecated))?;
            }
            if let ::std::option::Option::Some(weak) = self.weak_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(*weak))?;
            }
            size = size.checked_add(
                self.uninterpreted_option()
                    .calculate_size(&self::field_options::UNINTERPRETED_OPTION_CODEC)?,
            )?;
            size = size.checked_add(self.extensions.calculate_size()?)?;
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if let ::std::option::Option::Some(ctype) = self.ctype_option() {
                output.write_raw_tag_bytes(&[8])?;
                output.write_enum_value(*ctype)?;
            }
            if let ::std::option::Option::Some(packed) = self.packed_option() {
                output.write_raw_tag_bytes(&[16])?;
                output.write_bool(*packed)?;
            }
            if let ::std::option::Option::Some(jstype) = self.jstype_option() {
                output.write_raw_tag_bytes(&[48])?;
                output.write_enum_value(*jstype)?;
            }
            if let ::std::option::Option::Some(lazy) = self.lazy_option() {
                output.write_raw_tag_bytes(&[40])?;
                output.write_bool(*lazy)?;
            }
            if let ::std::option::Option::Some(deprecated) = self.deprecated_option() {
                output.write_raw_tag_bytes(&[24])?;
                output.write_bool(*deprecated)?;
            }
            if let ::std::option::Option::Some(weak) = self.weak_option() {
                output.write_raw_tag_bytes(&[80])?;
                output.write_bool(*weak)?;
            }
            self.uninterpreted_option()
                .write_to(output, &self::field_options::UNINTERPRETED_OPTION_CODEC)?;
            self.extensions.write_to(output)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.uninterpreted_option.is_initialized() {
                return false;
            }
            true
        }
    }
    impl crate::LiteMessage for self::FieldOptions {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(ctype) = other.ctype_option() {
                self.set_ctype(*ctype);
            }
            if let ::std::option::Option::Some(packed) = other.packed_option() {
                self.set_packed(*packed);
            }
            if let ::std::option::Option::Some(jstype) = other.jstype_option() {
                self.set_jstype(*jstype);
            }
            if let ::std::option::Option::Some(lazy) = other.lazy_option() {
                self.set_lazy(*lazy);
            }
            if let ::std::option::Option::Some(deprecated) = other.deprecated_option() {
                self.set_deprecated(*deprecated);
            }
            if let ::std::option::Option::Some(weak) = other.weak_option() {
                self.set_weak(*weak);
            }
            self.uninterpreted_option.merge(&other.uninterpreted_option);
            self.extensions.merge(&other.extensions);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::ExtendableMessage for self::FieldOptions {
        fn registry(&self) -> ::std::option::Option<&'static crate::ExtensionRegistry> {
            self.extensions.registry()
        }
        fn replace_registry(
            &mut self,
            extensions: ::std::option::Option<&'static crate::ExtensionRegistry>,
        ) -> ::std::option::Option<&'static crate::ExtensionRegistry> {
            self.extensions.replace_registry(extensions)
        }
        fn has_extension<T: crate::ExtensionIdentifier>(&self, extension: &'static T) -> bool {
            self.extensions.has_extension(extension)
        }
        fn has_extension_unchecked<T: crate::ExtensionIdentifier>(
            &self,
            extension: &'static T,
        ) -> bool {
            self.extensions.has_extension_unchecked(extension)
        }
        fn get_value<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &self,
            extension: &'static crate::Extension<Self, V, D>,
        ) -> Option<&V> {
            self.extensions.get_value(extension)
        }
        fn get_value_or_default<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync
                + ::std::ops::Deref<Target = L>,
            D: ::std::marker::Sync + ::std::ops::Deref<Target = L>,
            L,
        >(
            &self,
            extension: &'static crate::Extension<Self, V, D>,
        ) -> Option<&L> {
            self.extensions.get_value_or_default(extension)
        }
        fn get_repeated_value<
            V: ::std::cmp::PartialEq
                + ::std::clone::Clone
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &self,
            extension: &'static crate::RepeatedExtension<Self, V>,
        ) -> Option<&crate::collections::RepeatedField<V>> {
            self.extensions.get_repeated_value(extension)
        }
        fn field<
            V: ::std::default::Default
                + ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static crate::Extension<Self, V, D>,
        ) -> ::std::option::Option<crate::ExtensionField<Self, V, D>> {
            self.extensions.field(extension)
        }
        fn repeated_field<
            V: ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static crate::RepeatedExtension<Self, V>,
        ) -> ::std::option::Option<crate::RepeatedExtensionField<Self, V>> {
            self.extensions.repeated_field(extension)
        }
    }
    impl crate::Message for self::FieldOptions {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[12]
        }
    }
    impl self::FieldOptions {
        pub const CTYPE_FIELD_NUMBER: i32 = 1;
        pub const CTYPE_DEFAULT_VALUE: crate::EnumValue<self::field_options::CType> =
            crate::EnumValue::Defined(self::field_options::CType::String);
        pub fn ctype(&self) -> crate::EnumValue<self::field_options::CType> {
            self.ctype.unwrap_or(Self::CTYPE_DEFAULT_VALUE)
        }
        pub fn ctype_option(
            &self,
        ) -> ::std::option::Option<&crate::EnumValue<self::field_options::CType>> {
            self.ctype.as_ref()
        }
        pub fn ctype_mut(&mut self) -> &mut crate::EnumValue<self::field_options::CType> {
            self.ctype
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_ctype(&self) -> bool {
            self.ctype.is_some()
        }
        pub fn set_ctype(&mut self, value: crate::EnumValue<self::field_options::CType>) {
            self.ctype = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_ctype(
            &mut self,
        ) -> ::std::option::Option<crate::EnumValue<self::field_options::CType>> {
            self.ctype.take()
        }
        pub fn clear_ctype(&mut self) {
            self.ctype = ::std::option::Option::None;
        }
        pub const PACKED_FIELD_NUMBER: i32 = 2;
        pub const PACKED_DEFAULT_VALUE: bool = false;
        pub fn packed(&self) -> bool {
            self.packed.unwrap_or(Self::PACKED_DEFAULT_VALUE)
        }
        pub fn packed_option(&self) -> ::std::option::Option<&bool> {
            self.packed.as_ref()
        }
        pub fn packed_mut(&mut self) -> &mut bool {
            self.packed
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_packed(&self) -> bool {
            self.packed.is_some()
        }
        pub fn set_packed(&mut self, value: bool) {
            self.packed = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_packed(&mut self) -> ::std::option::Option<bool> {
            self.packed.take()
        }
        pub fn clear_packed(&mut self) {
            self.packed = ::std::option::Option::None;
        }
        pub const JSTYPE_FIELD_NUMBER: i32 = 6;
        pub const JSTYPE_DEFAULT_VALUE: crate::EnumValue<self::field_options::JSType> =
            crate::EnumValue::Defined(self::field_options::JSType::JsNormal);
        pub fn jstype(&self) -> crate::EnumValue<self::field_options::JSType> {
            self.jstype.unwrap_or(Self::JSTYPE_DEFAULT_VALUE)
        }
        pub fn jstype_option(
            &self,
        ) -> ::std::option::Option<&crate::EnumValue<self::field_options::JSType>> {
            self.jstype.as_ref()
        }
        pub fn jstype_mut(&mut self) -> &mut crate::EnumValue<self::field_options::JSType> {
            self.jstype
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_jstype(&self) -> bool {
            self.jstype.is_some()
        }
        pub fn set_jstype(&mut self, value: crate::EnumValue<self::field_options::JSType>) {
            self.jstype = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_jstype(
            &mut self,
        ) -> ::std::option::Option<crate::EnumValue<self::field_options::JSType>> {
            self.jstype.take()
        }
        pub fn clear_jstype(&mut self) {
            self.jstype = ::std::option::Option::None;
        }
        pub const LAZY_FIELD_NUMBER: i32 = 5;
        pub const LAZY_DEFAULT_VALUE: bool = false;
        pub fn lazy(&self) -> bool {
            self.lazy.unwrap_or(Self::LAZY_DEFAULT_VALUE)
        }
        pub fn lazy_option(&self) -> ::std::option::Option<&bool> {
            self.lazy.as_ref()
        }
        pub fn lazy_mut(&mut self) -> &mut bool {
            self.lazy
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_lazy(&self) -> bool {
            self.lazy.is_some()
        }
        pub fn set_lazy(&mut self, value: bool) {
            self.lazy = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_lazy(&mut self) -> ::std::option::Option<bool> {
            self.lazy.take()
        }
        pub fn clear_lazy(&mut self) {
            self.lazy = ::std::option::Option::None;
        }
        pub const DEPRECATED_FIELD_NUMBER: i32 = 3;
        pub const DEPRECATED_DEFAULT_VALUE: bool = false;
        pub fn deprecated(&self) -> bool {
            self.deprecated.unwrap_or(Self::DEPRECATED_DEFAULT_VALUE)
        }
        pub fn deprecated_option(&self) -> ::std::option::Option<&bool> {
            self.deprecated.as_ref()
        }
        pub fn deprecated_mut(&mut self) -> &mut bool {
            self.deprecated
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_deprecated(&self) -> bool {
            self.deprecated.is_some()
        }
        pub fn set_deprecated(&mut self, value: bool) {
            self.deprecated = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_deprecated(&mut self) -> ::std::option::Option<bool> {
            self.deprecated.take()
        }
        pub fn clear_deprecated(&mut self) {
            self.deprecated = ::std::option::Option::None;
        }
        pub const WEAK_FIELD_NUMBER: i32 = 10;
        pub const WEAK_DEFAULT_VALUE: bool = false;
        pub fn weak(&self) -> bool {
            self.weak.unwrap_or(Self::WEAK_DEFAULT_VALUE)
        }
        pub fn weak_option(&self) -> ::std::option::Option<&bool> {
            self.weak.as_ref()
        }
        pub fn weak_mut(&mut self) -> &mut bool {
            self.weak
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_weak(&self) -> bool {
            self.weak.is_some()
        }
        pub fn set_weak(&mut self, value: bool) {
            self.weak = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_weak(&mut self) -> ::std::option::Option<bool> {
            self.weak.take()
        }
        pub fn clear_weak(&mut self) {
            self.weak = ::std::option::Option::None;
        }
        pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
        pub fn uninterpreted_option(
            &self,
        ) -> &crate::collections::RepeatedField<self::UninterpretedOption> {
            &self.uninterpreted_option
        }
        pub fn uninterpreted_option_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::UninterpretedOption> {
            &mut self.uninterpreted_option
        }
    }
    pub mod field_options {
        #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
        pub enum CType {
            String,
            Cord,
            StringPiece,
        }
        impl crate::Enum for self::CType {
            fn descriptor() -> &'static crate::reflect::EnumDescriptor<'static> {
                &<self::super::FieldOptions as crate::Message>::descriptor().enums()[0]
            }
        }
        impl ::std::convert::TryFrom<i32> for self::CType {
            type Error = crate::VariantUndefinedError;
            fn try_from(value: i32) -> ::std::result::Result<Self, crate::VariantUndefinedError> {
                #[allow(unreachable_patterns)]
                match value {
                    0 => ::std::result::Result::Ok(self::CType::String),
                    1 => ::std::result::Result::Ok(self::CType::Cord),
                    2 => ::std::result::Result::Ok(self::CType::StringPiece),
                    _ => ::std::result::Result::Err(crate::VariantUndefinedError),
                }
            }
        }
        impl ::std::convert::From<self::CType> for i32 {
            fn from(value: self::CType) -> i32 {
                match value {
                    self::CType::String => 0,
                    self::CType::Cord => 1,
                    self::CType::StringPiece => 2,
                }
            }
        }
        #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
        pub enum JSType {
            JsNormal,
            JsString,
            JsNumber,
        }
        impl crate::Enum for self::JSType {
            fn descriptor() -> &'static crate::reflect::EnumDescriptor<'static> {
                &<self::super::FieldOptions as crate::Message>::descriptor().enums()[1]
            }
        }
        impl ::std::convert::TryFrom<i32> for self::JSType {
            type Error = crate::VariantUndefinedError;
            fn try_from(value: i32) -> ::std::result::Result<Self, crate::VariantUndefinedError> {
                #[allow(unreachable_patterns)]
                match value {
                    0 => ::std::result::Result::Ok(self::JSType::JsNormal),
                    1 => ::std::result::Result::Ok(self::JSType::JsString),
                    2 => ::std::result::Result::Ok(self::JSType::JsNumber),
                    _ => ::std::result::Result::Err(crate::VariantUndefinedError),
                }
            }
        }
        impl ::std::convert::From<self::JSType> for i32 {
            fn from(value: self::JSType) -> i32 {
                match value {
                    self::JSType::JsNormal => 0,
                    self::JSType::JsString => 1,
                    self::JSType::JsNumber => 2,
                }
            }
        }
        pub(super) static UNINTERPRETED_OPTION_CODEC: crate::Codec<
            self::super::UninterpretedOption,
        > = crate::Codec::message(7994);
        pub(in super::super) static CTYPE_REFLECTOR: crate::reflect::access::VerboseFieldAccessor<
            self::super::FieldOptions,
            crate::EnumValue<self::CType>,
        > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FieldOptions::ctype_option,
            get_mut: self::super::FieldOptions::ctype_mut,
            set: self::super::FieldOptions::set_ctype,
            take: self::super::FieldOptions::take_ctype,
            clear: self::super::FieldOptions::clear_ctype,
        };
        pub(in super::super) static PACKED_REFLECTOR: crate::reflect::access::VerboseFieldAccessor<
            self::super::FieldOptions,
            bool,
        > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FieldOptions::packed_option,
            get_mut: self::super::FieldOptions::packed_mut,
            set: self::super::FieldOptions::set_packed,
            take: self::super::FieldOptions::take_packed,
            clear: self::super::FieldOptions::clear_packed,
        };
        pub(in super::super) static JSTYPE_REFLECTOR: crate::reflect::access::VerboseFieldAccessor<
            self::super::FieldOptions,
            crate::EnumValue<self::JSType>,
        > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FieldOptions::jstype_option,
            get_mut: self::super::FieldOptions::jstype_mut,
            set: self::super::FieldOptions::set_jstype,
            take: self::super::FieldOptions::take_jstype,
            clear: self::super::FieldOptions::clear_jstype,
        };
        pub(in super::super) static LAZY_REFLECTOR: crate::reflect::access::VerboseFieldAccessor<
            self::super::FieldOptions,
            bool,
        > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FieldOptions::lazy_option,
            get_mut: self::super::FieldOptions::lazy_mut,
            set: self::super::FieldOptions::set_lazy,
            take: self::super::FieldOptions::take_lazy,
            clear: self::super::FieldOptions::clear_lazy,
        };
        pub(in super::super) static DEPRECATED_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::FieldOptions, bool> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::FieldOptions::deprecated_option,
                get_mut: self::super::FieldOptions::deprecated_mut,
                set: self::super::FieldOptions::set_deprecated,
                take: self::super::FieldOptions::take_deprecated,
                clear: self::super::FieldOptions::clear_deprecated,
            };
        pub(in super::super) static WEAK_REFLECTOR: crate::reflect::access::VerboseFieldAccessor<
            self::super::FieldOptions,
            bool,
        > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::FieldOptions::weak_option,
            get_mut: self::super::FieldOptions::weak_mut,
            set: self::super::FieldOptions::set_weak,
            take: self::super::FieldOptions::take_weak,
            clear: self::super::FieldOptions::clear_weak,
        };
        pub(in super::super) static UNINTERPRETED_OPTION_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::FieldOptions,
                crate::collections::RepeatedField<self::super::UninterpretedOption>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::FieldOptions::uninterpreted_option,
            get_mut: self::super::FieldOptions::uninterpreted_option_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct OneofOptions {
        uninterpreted_option: crate::collections::RepeatedField<self::UninterpretedOption>,
        unknown_fields: crate::UnknownFieldSet,
        extensions: crate::ExtensionSet<Self>,
    }
    impl crate::CodedMessage for self::OneofOptions {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    7994 => self
                        .uninterpreted_option
                        .add_entries(input, &self::oneof_options::UNINTERPRETED_OPTION_CODEC)?,
                    _ => {
                        if !self.extensions.merge_from(input)? {
                            self.unknown_fields.merge_from(tag, input)?
                        }
                    }
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            size = size.checked_add(
                self.uninterpreted_option()
                    .calculate_size(&self::oneof_options::UNINTERPRETED_OPTION_CODEC)?,
            )?;
            size = size.checked_add(self.extensions.calculate_size()?)?;
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            self.uninterpreted_option()
                .write_to(output, &self::oneof_options::UNINTERPRETED_OPTION_CODEC)?;
            self.extensions.write_to(output)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.uninterpreted_option.is_initialized() {
                return false;
            }
            true
        }
    }
    impl crate::LiteMessage for self::OneofOptions {
        fn merge(&mut self, other: &Self) {
            self.uninterpreted_option.merge(&other.uninterpreted_option);
            self.extensions.merge(&other.extensions);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::ExtendableMessage for self::OneofOptions {
        fn registry(&self) -> ::std::option::Option<&'static crate::ExtensionRegistry> {
            self.extensions.registry()
        }
        fn replace_registry(
            &mut self,
            extensions: ::std::option::Option<&'static crate::ExtensionRegistry>,
        ) -> ::std::option::Option<&'static crate::ExtensionRegistry> {
            self.extensions.replace_registry(extensions)
        }
        fn has_extension<T: crate::ExtensionIdentifier>(&self, extension: &'static T) -> bool {
            self.extensions.has_extension(extension)
        }
        fn has_extension_unchecked<T: crate::ExtensionIdentifier>(
            &self,
            extension: &'static T,
        ) -> bool {
            self.extensions.has_extension_unchecked(extension)
        }
        fn get_value<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &self,
            extension: &'static crate::Extension<Self, V, D>,
        ) -> Option<&V> {
            self.extensions.get_value(extension)
        }
        fn get_value_or_default<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync
                + ::std::ops::Deref<Target = L>,
            D: ::std::marker::Sync + ::std::ops::Deref<Target = L>,
            L,
        >(
            &self,
            extension: &'static crate::Extension<Self, V, D>,
        ) -> Option<&L> {
            self.extensions.get_value_or_default(extension)
        }
        fn get_repeated_value<
            V: ::std::cmp::PartialEq
                + ::std::clone::Clone
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &self,
            extension: &'static crate::RepeatedExtension<Self, V>,
        ) -> Option<&crate::collections::RepeatedField<V>> {
            self.extensions.get_repeated_value(extension)
        }
        fn field<
            V: ::std::default::Default
                + ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static crate::Extension<Self, V, D>,
        ) -> ::std::option::Option<crate::ExtensionField<Self, V, D>> {
            self.extensions.field(extension)
        }
        fn repeated_field<
            V: ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static crate::RepeatedExtension<Self, V>,
        ) -> ::std::option::Option<crate::RepeatedExtensionField<Self, V>> {
            self.extensions.repeated_field(extension)
        }
    }
    impl crate::Message for self::OneofOptions {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[13]
        }
    }
    impl self::OneofOptions {
        pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
        pub fn uninterpreted_option(
            &self,
        ) -> &crate::collections::RepeatedField<self::UninterpretedOption> {
            &self.uninterpreted_option
        }
        pub fn uninterpreted_option_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::UninterpretedOption> {
            &mut self.uninterpreted_option
        }
    }
    pub(in super::super) mod oneof_options {
        pub(super) static UNINTERPRETED_OPTION_CODEC: crate::Codec<
            self::super::UninterpretedOption,
        > = crate::Codec::message(7994);
        pub(in super::super) static UNINTERPRETED_OPTION_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::OneofOptions,
                crate::collections::RepeatedField<self::super::UninterpretedOption>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::OneofOptions::uninterpreted_option,
            get_mut: self::super::OneofOptions::uninterpreted_option_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct EnumOptions {
        allow_alias: ::std::option::Option<bool>,
        deprecated: ::std::option::Option<bool>,
        uninterpreted_option: crate::collections::RepeatedField<self::UninterpretedOption>,
        unknown_fields: crate::UnknownFieldSet,
        extensions: crate::ExtensionSet<Self>,
    }
    impl crate::CodedMessage for self::EnumOptions {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    16 | 18 => self.set_allow_alias(input.read_bool()?),
                    24 | 26 => self.set_deprecated(input.read_bool()?),
                    7994 => self
                        .uninterpreted_option
                        .add_entries(input, &self::enum_options::UNINTERPRETED_OPTION_CODEC)?,
                    _ => {
                        if !self.extensions.merge_from(input)? {
                            self.unknown_fields.merge_from(tag, input)?
                        }
                    }
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if let ::std::option::Option::Some(allow_alias) = self.allow_alias_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(*allow_alias))?;
            }
            if let ::std::option::Option::Some(deprecated) = self.deprecated_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(*deprecated))?;
            }
            size = size.checked_add(
                self.uninterpreted_option()
                    .calculate_size(&self::enum_options::UNINTERPRETED_OPTION_CODEC)?,
            )?;
            size = size.checked_add(self.extensions.calculate_size()?)?;
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if let ::std::option::Option::Some(allow_alias) = self.allow_alias_option() {
                output.write_raw_tag_bytes(&[16])?;
                output.write_bool(*allow_alias)?;
            }
            if let ::std::option::Option::Some(deprecated) = self.deprecated_option() {
                output.write_raw_tag_bytes(&[24])?;
                output.write_bool(*deprecated)?;
            }
            self.uninterpreted_option()
                .write_to(output, &self::enum_options::UNINTERPRETED_OPTION_CODEC)?;
            self.extensions.write_to(output)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.uninterpreted_option.is_initialized() {
                return false;
            }
            true
        }
    }
    impl crate::LiteMessage for self::EnumOptions {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(allow_alias) = other.allow_alias_option() {
                self.set_allow_alias(*allow_alias);
            }
            if let ::std::option::Option::Some(deprecated) = other.deprecated_option() {
                self.set_deprecated(*deprecated);
            }
            self.uninterpreted_option.merge(&other.uninterpreted_option);
            self.extensions.merge(&other.extensions);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::ExtendableMessage for self::EnumOptions {
        fn registry(&self) -> ::std::option::Option<&'static crate::ExtensionRegistry> {
            self.extensions.registry()
        }
        fn replace_registry(
            &mut self,
            extensions: ::std::option::Option<&'static crate::ExtensionRegistry>,
        ) -> ::std::option::Option<&'static crate::ExtensionRegistry> {
            self.extensions.replace_registry(extensions)
        }
        fn has_extension<T: crate::ExtensionIdentifier>(&self, extension: &'static T) -> bool {
            self.extensions.has_extension(extension)
        }
        fn has_extension_unchecked<T: crate::ExtensionIdentifier>(
            &self,
            extension: &'static T,
        ) -> bool {
            self.extensions.has_extension_unchecked(extension)
        }
        fn get_value<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &self,
            extension: &'static crate::Extension<Self, V, D>,
        ) -> Option<&V> {
            self.extensions.get_value(extension)
        }
        fn get_value_or_default<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync
                + ::std::ops::Deref<Target = L>,
            D: ::std::marker::Sync + ::std::ops::Deref<Target = L>,
            L,
        >(
            &self,
            extension: &'static crate::Extension<Self, V, D>,
        ) -> Option<&L> {
            self.extensions.get_value_or_default(extension)
        }
        fn get_repeated_value<
            V: ::std::cmp::PartialEq
                + ::std::clone::Clone
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &self,
            extension: &'static crate::RepeatedExtension<Self, V>,
        ) -> Option<&crate::collections::RepeatedField<V>> {
            self.extensions.get_repeated_value(extension)
        }
        fn field<
            V: ::std::default::Default
                + ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static crate::Extension<Self, V, D>,
        ) -> ::std::option::Option<crate::ExtensionField<Self, V, D>> {
            self.extensions.field(extension)
        }
        fn repeated_field<
            V: ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static crate::RepeatedExtension<Self, V>,
        ) -> ::std::option::Option<crate::RepeatedExtensionField<Self, V>> {
            self.extensions.repeated_field(extension)
        }
    }
    impl crate::Message for self::EnumOptions {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[14]
        }
    }
    impl self::EnumOptions {
        pub const ALLOW_ALIAS_FIELD_NUMBER: i32 = 2;
        pub const ALLOW_ALIAS_DEFAULT_VALUE: bool = false;
        pub fn allow_alias(&self) -> bool {
            self.allow_alias.unwrap_or(Self::ALLOW_ALIAS_DEFAULT_VALUE)
        }
        pub fn allow_alias_option(&self) -> ::std::option::Option<&bool> {
            self.allow_alias.as_ref()
        }
        pub fn allow_alias_mut(&mut self) -> &mut bool {
            self.allow_alias
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_allow_alias(&self) -> bool {
            self.allow_alias.is_some()
        }
        pub fn set_allow_alias(&mut self, value: bool) {
            self.allow_alias = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_allow_alias(&mut self) -> ::std::option::Option<bool> {
            self.allow_alias.take()
        }
        pub fn clear_allow_alias(&mut self) {
            self.allow_alias = ::std::option::Option::None;
        }
        pub const DEPRECATED_FIELD_NUMBER: i32 = 3;
        pub const DEPRECATED_DEFAULT_VALUE: bool = false;
        pub fn deprecated(&self) -> bool {
            self.deprecated.unwrap_or(Self::DEPRECATED_DEFAULT_VALUE)
        }
        pub fn deprecated_option(&self) -> ::std::option::Option<&bool> {
            self.deprecated.as_ref()
        }
        pub fn deprecated_mut(&mut self) -> &mut bool {
            self.deprecated
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_deprecated(&self) -> bool {
            self.deprecated.is_some()
        }
        pub fn set_deprecated(&mut self, value: bool) {
            self.deprecated = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_deprecated(&mut self) -> ::std::option::Option<bool> {
            self.deprecated.take()
        }
        pub fn clear_deprecated(&mut self) {
            self.deprecated = ::std::option::Option::None;
        }
        pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
        pub fn uninterpreted_option(
            &self,
        ) -> &crate::collections::RepeatedField<self::UninterpretedOption> {
            &self.uninterpreted_option
        }
        pub fn uninterpreted_option_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::UninterpretedOption> {
            &mut self.uninterpreted_option
        }
    }
    pub(in super::super) mod enum_options {
        pub(super) static UNINTERPRETED_OPTION_CODEC: crate::Codec<
            self::super::UninterpretedOption,
        > = crate::Codec::message(7994);
        pub(in super::super) static ALLOW_ALIAS_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::EnumOptions, bool> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::EnumOptions::allow_alias_option,
                get_mut: self::super::EnumOptions::allow_alias_mut,
                set: self::super::EnumOptions::set_allow_alias,
                take: self::super::EnumOptions::take_allow_alias,
                clear: self::super::EnumOptions::clear_allow_alias,
            };
        pub(in super::super) static DEPRECATED_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::EnumOptions, bool> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::EnumOptions::deprecated_option,
                get_mut: self::super::EnumOptions::deprecated_mut,
                set: self::super::EnumOptions::set_deprecated,
                take: self::super::EnumOptions::take_deprecated,
                clear: self::super::EnumOptions::clear_deprecated,
            };
        pub(in super::super) static UNINTERPRETED_OPTION_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::EnumOptions,
                crate::collections::RepeatedField<self::super::UninterpretedOption>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::EnumOptions::uninterpreted_option,
            get_mut: self::super::EnumOptions::uninterpreted_option_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct EnumValueOptions {
        deprecated: ::std::option::Option<bool>,
        uninterpreted_option: crate::collections::RepeatedField<self::UninterpretedOption>,
        unknown_fields: crate::UnknownFieldSet,
        extensions: crate::ExtensionSet<Self>,
    }
    impl crate::CodedMessage for self::EnumValueOptions {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.set_deprecated(input.read_bool()?),
                    7994 => self.uninterpreted_option.add_entries(
                        input,
                        &self::enum_value_options::UNINTERPRETED_OPTION_CODEC,
                    )?,
                    _ => {
                        if !self.extensions.merge_from(input)? {
                            self.unknown_fields.merge_from(tag, input)?
                        }
                    }
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if let ::std::option::Option::Some(deprecated) = self.deprecated_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(*deprecated))?;
            }
            size = size.checked_add(
                self.uninterpreted_option()
                    .calculate_size(&self::enum_value_options::UNINTERPRETED_OPTION_CODEC)?,
            )?;
            size = size.checked_add(self.extensions.calculate_size()?)?;
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if let ::std::option::Option::Some(deprecated) = self.deprecated_option() {
                output.write_raw_tag_bytes(&[8])?;
                output.write_bool(*deprecated)?;
            }
            self.uninterpreted_option().write_to(
                output,
                &self::enum_value_options::UNINTERPRETED_OPTION_CODEC,
            )?;
            self.extensions.write_to(output)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.uninterpreted_option.is_initialized() {
                return false;
            }
            true
        }
    }
    impl crate::LiteMessage for self::EnumValueOptions {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(deprecated) = other.deprecated_option() {
                self.set_deprecated(*deprecated);
            }
            self.uninterpreted_option.merge(&other.uninterpreted_option);
            self.extensions.merge(&other.extensions);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::ExtendableMessage for self::EnumValueOptions {
        fn registry(&self) -> ::std::option::Option<&'static crate::ExtensionRegistry> {
            self.extensions.registry()
        }
        fn replace_registry(
            &mut self,
            extensions: ::std::option::Option<&'static crate::ExtensionRegistry>,
        ) -> ::std::option::Option<&'static crate::ExtensionRegistry> {
            self.extensions.replace_registry(extensions)
        }
        fn has_extension<T: crate::ExtensionIdentifier>(&self, extension: &'static T) -> bool {
            self.extensions.has_extension(extension)
        }
        fn has_extension_unchecked<T: crate::ExtensionIdentifier>(
            &self,
            extension: &'static T,
        ) -> bool {
            self.extensions.has_extension_unchecked(extension)
        }
        fn get_value<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &self,
            extension: &'static crate::Extension<Self, V, D>,
        ) -> Option<&V> {
            self.extensions.get_value(extension)
        }
        fn get_value_or_default<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync
                + ::std::ops::Deref<Target = L>,
            D: ::std::marker::Sync + ::std::ops::Deref<Target = L>,
            L,
        >(
            &self,
            extension: &'static crate::Extension<Self, V, D>,
        ) -> Option<&L> {
            self.extensions.get_value_or_default(extension)
        }
        fn get_repeated_value<
            V: ::std::cmp::PartialEq
                + ::std::clone::Clone
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &self,
            extension: &'static crate::RepeatedExtension<Self, V>,
        ) -> Option<&crate::collections::RepeatedField<V>> {
            self.extensions.get_repeated_value(extension)
        }
        fn field<
            V: ::std::default::Default
                + ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static crate::Extension<Self, V, D>,
        ) -> ::std::option::Option<crate::ExtensionField<Self, V, D>> {
            self.extensions.field(extension)
        }
        fn repeated_field<
            V: ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static crate::RepeatedExtension<Self, V>,
        ) -> ::std::option::Option<crate::RepeatedExtensionField<Self, V>> {
            self.extensions.repeated_field(extension)
        }
    }
    impl crate::Message for self::EnumValueOptions {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[15]
        }
    }
    impl self::EnumValueOptions {
        pub const DEPRECATED_FIELD_NUMBER: i32 = 1;
        pub const DEPRECATED_DEFAULT_VALUE: bool = false;
        pub fn deprecated(&self) -> bool {
            self.deprecated.unwrap_or(Self::DEPRECATED_DEFAULT_VALUE)
        }
        pub fn deprecated_option(&self) -> ::std::option::Option<&bool> {
            self.deprecated.as_ref()
        }
        pub fn deprecated_mut(&mut self) -> &mut bool {
            self.deprecated
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_deprecated(&self) -> bool {
            self.deprecated.is_some()
        }
        pub fn set_deprecated(&mut self, value: bool) {
            self.deprecated = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_deprecated(&mut self) -> ::std::option::Option<bool> {
            self.deprecated.take()
        }
        pub fn clear_deprecated(&mut self) {
            self.deprecated = ::std::option::Option::None;
        }
        pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
        pub fn uninterpreted_option(
            &self,
        ) -> &crate::collections::RepeatedField<self::UninterpretedOption> {
            &self.uninterpreted_option
        }
        pub fn uninterpreted_option_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::UninterpretedOption> {
            &mut self.uninterpreted_option
        }
    }
    pub(in super::super) mod enum_value_options {
        pub(super) static UNINTERPRETED_OPTION_CODEC: crate::Codec<
            self::super::UninterpretedOption,
        > = crate::Codec::message(7994);
        pub(in super::super) static DEPRECATED_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::EnumValueOptions, bool> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::EnumValueOptions::deprecated_option,
                get_mut: self::super::EnumValueOptions::deprecated_mut,
                set: self::super::EnumValueOptions::set_deprecated,
                take: self::super::EnumValueOptions::take_deprecated,
                clear: self::super::EnumValueOptions::clear_deprecated,
            };
        pub(in super::super) static UNINTERPRETED_OPTION_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::EnumValueOptions,
                crate::collections::RepeatedField<self::super::UninterpretedOption>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::EnumValueOptions::uninterpreted_option,
            get_mut: self::super::EnumValueOptions::uninterpreted_option_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct ServiceOptions {
        deprecated: ::std::option::Option<bool>,
        uninterpreted_option: crate::collections::RepeatedField<self::UninterpretedOption>,
        unknown_fields: crate::UnknownFieldSet,
        extensions: crate::ExtensionSet<Self>,
    }
    impl crate::CodedMessage for self::ServiceOptions {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    264 | 266 => self.set_deprecated(input.read_bool()?),
                    7994 => self
                        .uninterpreted_option
                        .add_entries(input, &self::service_options::UNINTERPRETED_OPTION_CODEC)?,
                    _ => {
                        if !self.extensions.merge_from(input)? {
                            self.unknown_fields.merge_from(tag, input)?
                        }
                    }
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if let ::std::option::Option::Some(deprecated) = self.deprecated_option() {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::bool(*deprecated))?;
            }
            size = size.checked_add(
                self.uninterpreted_option()
                    .calculate_size(&self::service_options::UNINTERPRETED_OPTION_CODEC)?,
            )?;
            size = size.checked_add(self.extensions.calculate_size()?)?;
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if let ::std::option::Option::Some(deprecated) = self.deprecated_option() {
                output.write_raw_tag_bytes(&[136, 2])?;
                output.write_bool(*deprecated)?;
            }
            self.uninterpreted_option()
                .write_to(output, &self::service_options::UNINTERPRETED_OPTION_CODEC)?;
            self.extensions.write_to(output)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.uninterpreted_option.is_initialized() {
                return false;
            }
            true
        }
    }
    impl crate::LiteMessage for self::ServiceOptions {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(deprecated) = other.deprecated_option() {
                self.set_deprecated(*deprecated);
            }
            self.uninterpreted_option.merge(&other.uninterpreted_option);
            self.extensions.merge(&other.extensions);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::ExtendableMessage for self::ServiceOptions {
        fn registry(&self) -> ::std::option::Option<&'static crate::ExtensionRegistry> {
            self.extensions.registry()
        }
        fn replace_registry(
            &mut self,
            extensions: ::std::option::Option<&'static crate::ExtensionRegistry>,
        ) -> ::std::option::Option<&'static crate::ExtensionRegistry> {
            self.extensions.replace_registry(extensions)
        }
        fn has_extension<T: crate::ExtensionIdentifier>(&self, extension: &'static T) -> bool {
            self.extensions.has_extension(extension)
        }
        fn has_extension_unchecked<T: crate::ExtensionIdentifier>(
            &self,
            extension: &'static T,
        ) -> bool {
            self.extensions.has_extension_unchecked(extension)
        }
        fn get_value<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &self,
            extension: &'static crate::Extension<Self, V, D>,
        ) -> Option<&V> {
            self.extensions.get_value(extension)
        }
        fn get_value_or_default<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync
                + ::std::ops::Deref<Target = L>,
            D: ::std::marker::Sync + ::std::ops::Deref<Target = L>,
            L,
        >(
            &self,
            extension: &'static crate::Extension<Self, V, D>,
        ) -> Option<&L> {
            self.extensions.get_value_or_default(extension)
        }
        fn get_repeated_value<
            V: ::std::cmp::PartialEq
                + ::std::clone::Clone
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &self,
            extension: &'static crate::RepeatedExtension<Self, V>,
        ) -> Option<&crate::collections::RepeatedField<V>> {
            self.extensions.get_repeated_value(extension)
        }
        fn field<
            V: ::std::default::Default
                + ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static crate::Extension<Self, V, D>,
        ) -> ::std::option::Option<crate::ExtensionField<Self, V, D>> {
            self.extensions.field(extension)
        }
        fn repeated_field<
            V: ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static crate::RepeatedExtension<Self, V>,
        ) -> ::std::option::Option<crate::RepeatedExtensionField<Self, V>> {
            self.extensions.repeated_field(extension)
        }
    }
    impl crate::Message for self::ServiceOptions {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[16]
        }
    }
    impl self::ServiceOptions {
        pub const DEPRECATED_FIELD_NUMBER: i32 = 33;
        pub const DEPRECATED_DEFAULT_VALUE: bool = false;
        pub fn deprecated(&self) -> bool {
            self.deprecated.unwrap_or(Self::DEPRECATED_DEFAULT_VALUE)
        }
        pub fn deprecated_option(&self) -> ::std::option::Option<&bool> {
            self.deprecated.as_ref()
        }
        pub fn deprecated_mut(&mut self) -> &mut bool {
            self.deprecated
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_deprecated(&self) -> bool {
            self.deprecated.is_some()
        }
        pub fn set_deprecated(&mut self, value: bool) {
            self.deprecated = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_deprecated(&mut self) -> ::std::option::Option<bool> {
            self.deprecated.take()
        }
        pub fn clear_deprecated(&mut self) {
            self.deprecated = ::std::option::Option::None;
        }
        pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
        pub fn uninterpreted_option(
            &self,
        ) -> &crate::collections::RepeatedField<self::UninterpretedOption> {
            &self.uninterpreted_option
        }
        pub fn uninterpreted_option_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::UninterpretedOption> {
            &mut self.uninterpreted_option
        }
    }
    pub(in super::super) mod service_options {
        pub(super) static UNINTERPRETED_OPTION_CODEC: crate::Codec<
            self::super::UninterpretedOption,
        > = crate::Codec::message(7994);
        pub(in super::super) static DEPRECATED_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::ServiceOptions, bool> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::ServiceOptions::deprecated_option,
                get_mut: self::super::ServiceOptions::deprecated_mut,
                set: self::super::ServiceOptions::set_deprecated,
                take: self::super::ServiceOptions::take_deprecated,
                clear: self::super::ServiceOptions::clear_deprecated,
            };
        pub(in super::super) static UNINTERPRETED_OPTION_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::ServiceOptions,
                crate::collections::RepeatedField<self::super::UninterpretedOption>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::ServiceOptions::uninterpreted_option,
            get_mut: self::super::ServiceOptions::uninterpreted_option_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct MethodOptions {
        deprecated: ::std::option::Option<bool>,
        idempotency_level:
            ::std::option::Option<crate::EnumValue<self::method_options::IdempotencyLevel>>,
        uninterpreted_option: crate::collections::RepeatedField<self::UninterpretedOption>,
        unknown_fields: crate::UnknownFieldSet,
        extensions: crate::ExtensionSet<Self>,
    }
    impl crate::CodedMessage for self::MethodOptions {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    264 | 266 => self.set_deprecated(input.read_bool()?),
                    272 | 274 => self.set_idempotency_level(input.read_enum_value()?),
                    7994 => self
                        .uninterpreted_option
                        .add_entries(input, &self::method_options::UNINTERPRETED_OPTION_CODEC)?,
                    _ => {
                        if !self.extensions.merge_from(input)? {
                            self.unknown_fields.merge_from(tag, input)?
                        }
                    }
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if let ::std::option::Option::Some(deprecated) = self.deprecated_option() {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::bool(*deprecated))?;
            }
            if let ::std::option::Option::Some(idempotency_level) = self.idempotency_level_option()
            {
                size = size.checked_add(2)?;
                size = size.checked_add(crate::io::sizes::enum_value(*idempotency_level))?;
            }
            size = size.checked_add(
                self.uninterpreted_option()
                    .calculate_size(&self::method_options::UNINTERPRETED_OPTION_CODEC)?,
            )?;
            size = size.checked_add(self.extensions.calculate_size()?)?;
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if let ::std::option::Option::Some(deprecated) = self.deprecated_option() {
                output.write_raw_tag_bytes(&[136, 2])?;
                output.write_bool(*deprecated)?;
            }
            if let ::std::option::Option::Some(idempotency_level) = self.idempotency_level_option()
            {
                output.write_raw_tag_bytes(&[144, 2])?;
                output.write_enum_value(*idempotency_level)?;
            }
            self.uninterpreted_option()
                .write_to(output, &self::method_options::UNINTERPRETED_OPTION_CODEC)?;
            self.extensions.write_to(output)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.uninterpreted_option.is_initialized() {
                return false;
            }
            true
        }
    }
    impl crate::LiteMessage for self::MethodOptions {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(deprecated) = other.deprecated_option() {
                self.set_deprecated(*deprecated);
            }
            if let ::std::option::Option::Some(idempotency_level) = other.idempotency_level_option()
            {
                self.set_idempotency_level(*idempotency_level);
            }
            self.uninterpreted_option.merge(&other.uninterpreted_option);
            self.extensions.merge(&other.extensions);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::ExtendableMessage for self::MethodOptions {
        fn registry(&self) -> ::std::option::Option<&'static crate::ExtensionRegistry> {
            self.extensions.registry()
        }
        fn replace_registry(
            &mut self,
            extensions: ::std::option::Option<&'static crate::ExtensionRegistry>,
        ) -> ::std::option::Option<&'static crate::ExtensionRegistry> {
            self.extensions.replace_registry(extensions)
        }
        fn has_extension<T: crate::ExtensionIdentifier>(&self, extension: &'static T) -> bool {
            self.extensions.has_extension(extension)
        }
        fn has_extension_unchecked<T: crate::ExtensionIdentifier>(
            &self,
            extension: &'static T,
        ) -> bool {
            self.extensions.has_extension_unchecked(extension)
        }
        fn get_value<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &self,
            extension: &'static crate::Extension<Self, V, D>,
        ) -> Option<&V> {
            self.extensions.get_value(extension)
        }
        fn get_value_or_default<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync
                + ::std::ops::Deref<Target = L>,
            D: ::std::marker::Sync + ::std::ops::Deref<Target = L>,
            L,
        >(
            &self,
            extension: &'static crate::Extension<Self, V, D>,
        ) -> Option<&L> {
            self.extensions.get_value_or_default(extension)
        }
        fn get_repeated_value<
            V: ::std::cmp::PartialEq
                + ::std::clone::Clone
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &self,
            extension: &'static crate::RepeatedExtension<Self, V>,
        ) -> Option<&crate::collections::RepeatedField<V>> {
            self.extensions.get_repeated_value(extension)
        }
        fn field<
            V: ::std::default::Default
                + ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static crate::Extension<Self, V, D>,
        ) -> ::std::option::Option<crate::ExtensionField<Self, V, D>> {
            self.extensions.field(extension)
        }
        fn repeated_field<
            V: ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static crate::RepeatedExtension<Self, V>,
        ) -> ::std::option::Option<crate::RepeatedExtensionField<Self, V>> {
            self.extensions.repeated_field(extension)
        }
    }
    impl crate::Message for self::MethodOptions {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[17]
        }
    }
    impl self::MethodOptions {
        pub const DEPRECATED_FIELD_NUMBER: i32 = 33;
        pub const DEPRECATED_DEFAULT_VALUE: bool = false;
        pub fn deprecated(&self) -> bool {
            self.deprecated.unwrap_or(Self::DEPRECATED_DEFAULT_VALUE)
        }
        pub fn deprecated_option(&self) -> ::std::option::Option<&bool> {
            self.deprecated.as_ref()
        }
        pub fn deprecated_mut(&mut self) -> &mut bool {
            self.deprecated
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_deprecated(&self) -> bool {
            self.deprecated.is_some()
        }
        pub fn set_deprecated(&mut self, value: bool) {
            self.deprecated = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_deprecated(&mut self) -> ::std::option::Option<bool> {
            self.deprecated.take()
        }
        pub fn clear_deprecated(&mut self) {
            self.deprecated = ::std::option::Option::None;
        }
        pub const IDEMPOTENCY_LEVEL_FIELD_NUMBER: i32 = 34;
        pub const IDEMPOTENCY_LEVEL_DEFAULT_VALUE: crate::EnumValue<
            self::method_options::IdempotencyLevel,
        > = crate::EnumValue::Defined(self::method_options::IdempotencyLevel::IdempotencyUnknown);
        pub fn idempotency_level(
            &self,
        ) -> crate::EnumValue<self::method_options::IdempotencyLevel> {
            self.idempotency_level
                .unwrap_or(Self::IDEMPOTENCY_LEVEL_DEFAULT_VALUE)
        }
        pub fn idempotency_level_option(
            &self,
        ) -> ::std::option::Option<&crate::EnumValue<self::method_options::IdempotencyLevel>>
        {
            self.idempotency_level.as_ref()
        }
        pub fn idempotency_level_mut(
            &mut self,
        ) -> &mut crate::EnumValue<self::method_options::IdempotencyLevel> {
            self.idempotency_level
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_idempotency_level(&self) -> bool {
            self.idempotency_level.is_some()
        }
        pub fn set_idempotency_level(
            &mut self,
            value: crate::EnumValue<self::method_options::IdempotencyLevel>,
        ) {
            self.idempotency_level = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_idempotency_level(
            &mut self,
        ) -> ::std::option::Option<crate::EnumValue<self::method_options::IdempotencyLevel>>
        {
            self.idempotency_level.take()
        }
        pub fn clear_idempotency_level(&mut self) {
            self.idempotency_level = ::std::option::Option::None;
        }
        pub const UNINTERPRETED_OPTION_FIELD_NUMBER: i32 = 999;
        pub fn uninterpreted_option(
            &self,
        ) -> &crate::collections::RepeatedField<self::UninterpretedOption> {
            &self.uninterpreted_option
        }
        pub fn uninterpreted_option_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::UninterpretedOption> {
            &mut self.uninterpreted_option
        }
    }
    pub mod method_options {
        #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
        pub enum IdempotencyLevel {
            IdempotencyUnknown,
            NoSideEffects,
            Idempotent,
        }
        impl crate::Enum for self::IdempotencyLevel {
            fn descriptor() -> &'static crate::reflect::EnumDescriptor<'static> {
                &<self::super::MethodOptions as crate::Message>::descriptor().enums()[0]
            }
        }
        impl ::std::convert::TryFrom<i32> for self::IdempotencyLevel {
            type Error = crate::VariantUndefinedError;
            fn try_from(value: i32) -> ::std::result::Result<Self, crate::VariantUndefinedError> {
                #[allow(unreachable_patterns)]
                match value {
                    0 => ::std::result::Result::Ok(self::IdempotencyLevel::IdempotencyUnknown),
                    1 => ::std::result::Result::Ok(self::IdempotencyLevel::NoSideEffects),
                    2 => ::std::result::Result::Ok(self::IdempotencyLevel::Idempotent),
                    _ => ::std::result::Result::Err(crate::VariantUndefinedError),
                }
            }
        }
        impl ::std::convert::From<self::IdempotencyLevel> for i32 {
            fn from(value: self::IdempotencyLevel) -> i32 {
                match value {
                    self::IdempotencyLevel::IdempotencyUnknown => 0,
                    self::IdempotencyLevel::NoSideEffects => 1,
                    self::IdempotencyLevel::Idempotent => 2,
                }
            }
        }
        pub(super) static UNINTERPRETED_OPTION_CODEC: crate::Codec<
            self::super::UninterpretedOption,
        > = crate::Codec::message(7994);
        pub(in super::super) static DEPRECATED_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::MethodOptions, bool> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::MethodOptions::deprecated_option,
                get_mut: self::super::MethodOptions::deprecated_mut,
                set: self::super::MethodOptions::set_deprecated,
                take: self::super::MethodOptions::take_deprecated,
                clear: self::super::MethodOptions::clear_deprecated,
            };
        pub(in super::super) static IDEMPOTENCY_LEVEL_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::MethodOptions,
                crate::EnumValue<self::IdempotencyLevel>,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::MethodOptions::idempotency_level_option,
            get_mut: self::super::MethodOptions::idempotency_level_mut,
            set: self::super::MethodOptions::set_idempotency_level,
            take: self::super::MethodOptions::take_idempotency_level,
            clear: self::super::MethodOptions::clear_idempotency_level,
        };
        pub(in super::super) static UNINTERPRETED_OPTION_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::MethodOptions,
                crate::collections::RepeatedField<self::super::UninterpretedOption>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::MethodOptions::uninterpreted_option,
            get_mut: self::super::MethodOptions::uninterpreted_option_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct UninterpretedOption {
        name: crate::collections::RepeatedField<self::uninterpreted_option::NamePart>,
        identifier_value: ::std::option::Option<::std::string::String>,
        positive_int_value: ::std::option::Option<u64>,
        negative_int_value: ::std::option::Option<i64>,
        double_value: ::std::option::Option<f64>,
        string_value: ::std::option::Option<::std::vec::Vec<u8>>,
        aggregate_value: ::std::option::Option<::std::string::String>,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::UninterpretedOption {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    18 => self
                        .name
                        .add_entries(input, &self::uninterpreted_option::NAME_CODEC)?,
                    26 => self.set_identifier_value(input.read_string()?),
                    32 | 34 => self.set_positive_int_value(input.read_uint64()?),
                    40 | 42 => self.set_negative_int_value(input.read_int64()?),
                    49 | 50 => self.set_double_value(input.read_double()?),
                    58 => self.set_string_value(input.read_bytes()?),
                    66 => self.set_aggregate_value(input.read_string()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            size = size.checked_add(
                self.name()
                    .calculate_size(&self::uninterpreted_option::NAME_CODEC)?,
            )?;
            if let ::std::option::Option::Some(identifier_value) = self.identifier_value_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(identifier_value)?)?;
            }
            if let ::std::option::Option::Some(positive_int_value) =
                self.positive_int_value_option()
            {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::uint64(*positive_int_value))?;
            }
            if let ::std::option::Option::Some(negative_int_value) =
                self.negative_int_value_option()
            {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::int64(*negative_int_value))?;
            }
            if let ::std::option::Option::Some(double_value) = self.double_value_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::double(*double_value))?;
            }
            if let ::std::option::Option::Some(string_value) = self.string_value_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bytes(string_value)?)?;
            }
            if let ::std::option::Option::Some(aggregate_value) = self.aggregate_value_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(aggregate_value)?)?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            self.name()
                .write_to(output, &self::uninterpreted_option::NAME_CODEC)?;
            if let ::std::option::Option::Some(identifier_value) = self.identifier_value_option() {
                output.write_raw_tag_bytes(&[26])?;
                output.write_string(identifier_value)?;
            }
            if let ::std::option::Option::Some(positive_int_value) =
                self.positive_int_value_option()
            {
                output.write_raw_tag_bytes(&[32])?;
                output.write_uint64(*positive_int_value)?;
            }
            if let ::std::option::Option::Some(negative_int_value) =
                self.negative_int_value_option()
            {
                output.write_raw_tag_bytes(&[40])?;
                output.write_int64(*negative_int_value)?;
            }
            if let ::std::option::Option::Some(double_value) = self.double_value_option() {
                output.write_raw_tag_bytes(&[49])?;
                output.write_double(*double_value)?;
            }
            if let ::std::option::Option::Some(string_value) = self.string_value_option() {
                output.write_raw_tag_bytes(&[58])?;
                output.write_bytes(string_value)?;
            }
            if let ::std::option::Option::Some(aggregate_value) = self.aggregate_value_option() {
                output.write_raw_tag_bytes(&[66])?;
                output.write_string(aggregate_value)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.name.is_initialized() {
                return false;
            }
            true
        }
    }
    impl crate::LiteMessage for self::UninterpretedOption {
        fn merge(&mut self, other: &Self) {
            self.name.merge(&other.name);
            if let ::std::option::Option::Some(identifier_value) = other.identifier_value_option() {
                self.set_identifier_value(::std::clone::Clone::clone(identifier_value));
            }
            if let ::std::option::Option::Some(positive_int_value) =
                other.positive_int_value_option()
            {
                self.set_positive_int_value(*positive_int_value);
            }
            if let ::std::option::Option::Some(negative_int_value) =
                other.negative_int_value_option()
            {
                self.set_negative_int_value(*negative_int_value);
            }
            if let ::std::option::Option::Some(double_value) = other.double_value_option() {
                self.set_double_value(*double_value);
            }
            if let ::std::option::Option::Some(string_value) = other.string_value_option() {
                self.set_string_value(::std::clone::Clone::clone(string_value));
            }
            if let ::std::option::Option::Some(aggregate_value) = other.aggregate_value_option() {
                self.set_aggregate_value(::std::clone::Clone::clone(aggregate_value));
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::UninterpretedOption {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[18]
        }
    }
    impl self::UninterpretedOption {
        pub const NAME_FIELD_NUMBER: i32 = 2;
        pub fn name(
            &self,
        ) -> &crate::collections::RepeatedField<self::uninterpreted_option::NamePart> {
            &self.name
        }
        pub fn name_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::uninterpreted_option::NamePart> {
            &mut self.name
        }
        pub const IDENTIFIER_VALUE_FIELD_NUMBER: i32 = 3;
        pub const IDENTIFIER_VALUE_DEFAULT_VALUE: &'static str = "";
        pub fn identifier_value(&self) -> &str {
            self.identifier_value
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::IDENTIFIER_VALUE_DEFAULT_VALUE)
        }
        pub fn identifier_value_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.identifier_value.as_ref()
        }
        pub fn identifier_value_mut(&mut self) -> &mut ::std::string::String {
            self.identifier_value
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_identifier_value(&self) -> bool {
            self.identifier_value.is_some()
        }
        pub fn set_identifier_value(&mut self, value: ::std::string::String) {
            self.identifier_value = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_identifier_value(&mut self) -> ::std::option::Option<::std::string::String> {
            self.identifier_value.take()
        }
        pub fn clear_identifier_value(&mut self) {
            self.identifier_value = ::std::option::Option::None;
        }
        pub const POSITIVE_INT_VALUE_FIELD_NUMBER: i32 = 4;
        pub const POSITIVE_INT_VALUE_DEFAULT_VALUE: u64 = 0;
        pub fn positive_int_value(&self) -> u64 {
            self.positive_int_value
                .unwrap_or(Self::POSITIVE_INT_VALUE_DEFAULT_VALUE)
        }
        pub fn positive_int_value_option(&self) -> ::std::option::Option<&u64> {
            self.positive_int_value.as_ref()
        }
        pub fn positive_int_value_mut(&mut self) -> &mut u64 {
            self.positive_int_value
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_positive_int_value(&self) -> bool {
            self.positive_int_value.is_some()
        }
        pub fn set_positive_int_value(&mut self, value: u64) {
            self.positive_int_value = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_positive_int_value(&mut self) -> ::std::option::Option<u64> {
            self.positive_int_value.take()
        }
        pub fn clear_positive_int_value(&mut self) {
            self.positive_int_value = ::std::option::Option::None;
        }
        pub const NEGATIVE_INT_VALUE_FIELD_NUMBER: i32 = 5;
        pub const NEGATIVE_INT_VALUE_DEFAULT_VALUE: i64 = 0;
        pub fn negative_int_value(&self) -> i64 {
            self.negative_int_value
                .unwrap_or(Self::NEGATIVE_INT_VALUE_DEFAULT_VALUE)
        }
        pub fn negative_int_value_option(&self) -> ::std::option::Option<&i64> {
            self.negative_int_value.as_ref()
        }
        pub fn negative_int_value_mut(&mut self) -> &mut i64 {
            self.negative_int_value
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_negative_int_value(&self) -> bool {
            self.negative_int_value.is_some()
        }
        pub fn set_negative_int_value(&mut self, value: i64) {
            self.negative_int_value = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_negative_int_value(&mut self) -> ::std::option::Option<i64> {
            self.negative_int_value.take()
        }
        pub fn clear_negative_int_value(&mut self) {
            self.negative_int_value = ::std::option::Option::None;
        }
        pub const DOUBLE_VALUE_FIELD_NUMBER: i32 = 6;
        pub const DOUBLE_VALUE_DEFAULT_VALUE: f64 = 0.0;
        pub fn double_value(&self) -> f64 {
            self.double_value
                .unwrap_or(Self::DOUBLE_VALUE_DEFAULT_VALUE)
        }
        pub fn double_value_option(&self) -> ::std::option::Option<&f64> {
            self.double_value.as_ref()
        }
        pub fn double_value_mut(&mut self) -> &mut f64 {
            self.double_value
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_double_value(&self) -> bool {
            self.double_value.is_some()
        }
        pub fn set_double_value(&mut self, value: f64) {
            self.double_value = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_double_value(&mut self) -> ::std::option::Option<f64> {
            self.double_value.take()
        }
        pub fn clear_double_value(&mut self) {
            self.double_value = ::std::option::Option::None;
        }
        pub const STRING_VALUE_FIELD_NUMBER: i32 = 7;
        pub const STRING_VALUE_DEFAULT_VALUE: &'static [u8] = &[];
        pub fn string_value(&self) -> &[u8] {
            self.string_value
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::STRING_VALUE_DEFAULT_VALUE)
        }
        pub fn string_value_option(&self) -> ::std::option::Option<&::std::vec::Vec<u8>> {
            self.string_value.as_ref()
        }
        pub fn string_value_mut(&mut self) -> &mut ::std::vec::Vec<u8> {
            self.string_value
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_string_value(&self) -> bool {
            self.string_value.is_some()
        }
        pub fn set_string_value(&mut self, value: ::std::vec::Vec<u8>) {
            self.string_value = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_string_value(&mut self) -> ::std::option::Option<::std::vec::Vec<u8>> {
            self.string_value.take()
        }
        pub fn clear_string_value(&mut self) {
            self.string_value = ::std::option::Option::None;
        }
        pub const AGGREGATE_VALUE_FIELD_NUMBER: i32 = 8;
        pub const AGGREGATE_VALUE_DEFAULT_VALUE: &'static str = "";
        pub fn aggregate_value(&self) -> &str {
            self.aggregate_value
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::AGGREGATE_VALUE_DEFAULT_VALUE)
        }
        pub fn aggregate_value_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.aggregate_value.as_ref()
        }
        pub fn aggregate_value_mut(&mut self) -> &mut ::std::string::String {
            self.aggregate_value
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_aggregate_value(&self) -> bool {
            self.aggregate_value.is_some()
        }
        pub fn set_aggregate_value(&mut self, value: ::std::string::String) {
            self.aggregate_value = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_aggregate_value(&mut self) -> ::std::option::Option<::std::string::String> {
            self.aggregate_value.take()
        }
        pub fn clear_aggregate_value(&mut self) {
            self.aggregate_value = ::std::option::Option::None;
        }
    }
    pub mod uninterpreted_option {
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct NamePart {
            name_part: ::std::option::Option<::std::string::String>,
            is_extension: ::std::option::Option<bool>,
            unknown_fields: crate::UnknownFieldSet,
        }
        impl crate::CodedMessage for self::NamePart {
            fn merge_from(
                &mut self,
                input: &mut crate::io::CodedInput,
            ) -> crate::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        10 => self.set_name_part(input.read_string()?),
                        16 | 18 => self.set_is_extension(input.read_bool()?),
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> ::std::option::Option<i32> {
                let mut size = 0i32;
                if let ::std::option::Option::Some(name_part) = self.name_part_option() {
                    size = size.checked_add(1)?;
                    size = size.checked_add(crate::io::sizes::string(name_part)?)?;
                }
                if let ::std::option::Option::Some(is_extension) = self.is_extension_option() {
                    size = size.checked_add(1)?;
                    size = size.checked_add(crate::io::sizes::bool(*is_extension))?;
                }
                size = size.checked_add(self.unknown_fields.calculate_size()?)?;
                ::std::option::Option::Some(size)
            }
            fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
                if let ::std::option::Option::Some(name_part) = self.name_part_option() {
                    output.write_raw_tag_bytes(&[10])?;
                    output.write_string(name_part)?;
                }
                if let ::std::option::Option::Some(is_extension) = self.is_extension_option() {
                    output.write_raw_tag_bytes(&[16])?;
                    output.write_bool(*is_extension)?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                if !self.has_name_part() {
                    return false;
                }
                if !self.has_is_extension() {
                    return false;
                }
                true
            }
        }
        impl crate::LiteMessage for self::NamePart {
            fn merge(&mut self, other: &Self) {
                if let ::std::option::Option::Some(name_part) = other.name_part_option() {
                    self.set_name_part(::std::clone::Clone::clone(name_part));
                }
                if let ::std::option::Option::Some(is_extension) = other.is_extension_option() {
                    self.set_is_extension(*is_extension);
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl crate::Message for self::NamePart {
            fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
                &<self::super::UninterpretedOption as crate::Message>::descriptor().messages()[0]
            }
        }
        impl self::NamePart {
            pub const NAME_PART_FIELD_NUMBER: i32 = 1;
            pub const NAME_PART_DEFAULT_VALUE: &'static str = "";
            pub fn name_part(&self) -> &str {
                self.name_part
                    .as_ref()
                    .map(|v| &**v)
                    .unwrap_or(Self::NAME_PART_DEFAULT_VALUE)
            }
            pub fn name_part_option(&self) -> ::std::option::Option<&::std::string::String> {
                self.name_part.as_ref()
            }
            pub fn name_part_mut(&mut self) -> &mut ::std::string::String {
                self.name_part
                    .get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_name_part(&self) -> bool {
                self.name_part.is_some()
            }
            pub fn set_name_part(&mut self, value: ::std::string::String) {
                self.name_part = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_name_part(&mut self) -> ::std::option::Option<::std::string::String> {
                self.name_part.take()
            }
            pub fn clear_name_part(&mut self) {
                self.name_part = ::std::option::Option::None;
            }
            pub const IS_EXTENSION_FIELD_NUMBER: i32 = 2;
            pub const IS_EXTENSION_DEFAULT_VALUE: bool = false;
            pub fn is_extension(&self) -> bool {
                self.is_extension
                    .unwrap_or(Self::IS_EXTENSION_DEFAULT_VALUE)
            }
            pub fn is_extension_option(&self) -> ::std::option::Option<&bool> {
                self.is_extension.as_ref()
            }
            pub fn is_extension_mut(&mut self) -> &mut bool {
                self.is_extension
                    .get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_is_extension(&self) -> bool {
                self.is_extension.is_some()
            }
            pub fn set_is_extension(&mut self, value: bool) {
                self.is_extension = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_is_extension(&mut self) -> ::std::option::Option<bool> {
                self.is_extension.take()
            }
            pub fn clear_is_extension(&mut self) {
                self.is_extension = ::std::option::Option::None;
            }
        }
        pub(in super::super::super) mod name_part {
            pub(in super::super::super) static NAME_PART_REFLECTOR:
                crate::reflect::access::VerboseFieldAccessor<
                    self::super::NamePart,
                    ::std::string::String,
                > = crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::NamePart::name_part_option,
                get_mut: self::super::NamePart::name_part_mut,
                set: self::super::NamePart::set_name_part,
                take: self::super::NamePart::take_name_part,
                clear: self::super::NamePart::clear_name_part,
            };
            pub(in super::super::super) static IS_EXTENSION_REFLECTOR:
                crate::reflect::access::VerboseFieldAccessor<self::super::NamePart, bool> =
                crate::reflect::access::VerboseFieldAccessor {
                    get_option: self::super::NamePart::is_extension_option,
                    get_mut: self::super::NamePart::is_extension_mut,
                    set: self::super::NamePart::set_is_extension,
                    take: self::super::NamePart::take_is_extension,
                    clear: self::super::NamePart::clear_is_extension,
                };
        }
        pub(super) static NAME_CODEC: crate::Codec<self::NamePart> = crate::Codec::message(18);
        pub(in super::super) static NAME_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::UninterpretedOption,
            crate::collections::RepeatedField<self::NamePart>,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::UninterpretedOption::name,
            get_mut: self::super::UninterpretedOption::name_mut,
        };
        pub(in super::super) static IDENTIFIER_VALUE_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::UninterpretedOption,
                ::std::string::String,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::UninterpretedOption::identifier_value_option,
            get_mut: self::super::UninterpretedOption::identifier_value_mut,
            set: self::super::UninterpretedOption::set_identifier_value,
            take: self::super::UninterpretedOption::take_identifier_value,
            clear: self::super::UninterpretedOption::clear_identifier_value,
        };
        pub(in super::super) static POSITIVE_INT_VALUE_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::UninterpretedOption, u64> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::UninterpretedOption::positive_int_value_option,
                get_mut: self::super::UninterpretedOption::positive_int_value_mut,
                set: self::super::UninterpretedOption::set_positive_int_value,
                take: self::super::UninterpretedOption::take_positive_int_value,
                clear: self::super::UninterpretedOption::clear_positive_int_value,
            };
        pub(in super::super) static NEGATIVE_INT_VALUE_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::UninterpretedOption, i64> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::UninterpretedOption::negative_int_value_option,
                get_mut: self::super::UninterpretedOption::negative_int_value_mut,
                set: self::super::UninterpretedOption::set_negative_int_value,
                take: self::super::UninterpretedOption::take_negative_int_value,
                clear: self::super::UninterpretedOption::clear_negative_int_value,
            };
        pub(in super::super) static DOUBLE_VALUE_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::UninterpretedOption, f64> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::UninterpretedOption::double_value_option,
                get_mut: self::super::UninterpretedOption::double_value_mut,
                set: self::super::UninterpretedOption::set_double_value,
                take: self::super::UninterpretedOption::take_double_value,
                clear: self::super::UninterpretedOption::clear_double_value,
            };
        pub(in super::super) static STRING_VALUE_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::UninterpretedOption,
                ::std::vec::Vec<u8>,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::UninterpretedOption::string_value_option,
            get_mut: self::super::UninterpretedOption::string_value_mut,
            set: self::super::UninterpretedOption::set_string_value,
            take: self::super::UninterpretedOption::take_string_value,
            clear: self::super::UninterpretedOption::clear_string_value,
        };
        pub(in super::super) static AGGREGATE_VALUE_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::UninterpretedOption,
                ::std::string::String,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::UninterpretedOption::aggregate_value_option,
            get_mut: self::super::UninterpretedOption::aggregate_value_mut,
            set: self::super::UninterpretedOption::set_aggregate_value,
            take: self::super::UninterpretedOption::take_aggregate_value,
            clear: self::super::UninterpretedOption::clear_aggregate_value,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct SourceCodeInfo {
        location: crate::collections::RepeatedField<self::source_code_info::Location>,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::SourceCodeInfo {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => self
                        .location
                        .add_entries(input, &self::source_code_info::LOCATION_CODEC)?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            size = size.checked_add(
                self.location()
                    .calculate_size(&self::source_code_info::LOCATION_CODEC)?,
            )?;
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            self.location()
                .write_to(output, &self::source_code_info::LOCATION_CODEC)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.location.is_initialized() {
                return false;
            }
            true
        }
    }
    impl crate::LiteMessage for self::SourceCodeInfo {
        fn merge(&mut self, other: &Self) {
            self.location.merge(&other.location);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::SourceCodeInfo {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[19]
        }
    }
    impl self::SourceCodeInfo {
        pub const LOCATION_FIELD_NUMBER: i32 = 1;
        pub fn location(
            &self,
        ) -> &crate::collections::RepeatedField<self::source_code_info::Location> {
            &self.location
        }
        pub fn location_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::source_code_info::Location> {
            &mut self.location
        }
    }
    pub mod source_code_info {
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct Location {
            path: crate::collections::RepeatedField<i32>,
            span: crate::collections::RepeatedField<i32>,
            leading_comments: ::std::option::Option<::std::string::String>,
            trailing_comments: ::std::option::Option<::std::string::String>,
            leading_detached_comments: crate::collections::RepeatedField<::std::string::String>,
            unknown_fields: crate::UnknownFieldSet,
        }
        impl crate::CodedMessage for self::Location {
            fn merge_from(
                &mut self,
                input: &mut crate::io::CodedInput,
            ) -> crate::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        10 => self.path.add_entries(input, &self::location::PATH_CODEC)?,
                        18 => self.span.add_entries(input, &self::location::SPAN_CODEC)?,
                        26 => self.set_leading_comments(input.read_string()?),
                        34 => self.set_trailing_comments(input.read_string()?),
                        50 => self
                            .leading_detached_comments
                            .add_entries(input, &self::location::LEADING_DETACHED_COMMENTS_CODEC)?,
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> ::std::option::Option<i32> {
                let mut size = 0i32;
                size =
                    size.checked_add(self.path().calculate_size(&self::location::PATH_CODEC)?)?;
                size =
                    size.checked_add(self.span().calculate_size(&self::location::SPAN_CODEC)?)?;
                if let ::std::option::Option::Some(leading_comments) =
                    self.leading_comments_option()
                {
                    size = size.checked_add(1)?;
                    size = size.checked_add(crate::io::sizes::string(leading_comments)?)?;
                }
                if let ::std::option::Option::Some(trailing_comments) =
                    self.trailing_comments_option()
                {
                    size = size.checked_add(1)?;
                    size = size.checked_add(crate::io::sizes::string(trailing_comments)?)?;
                }
                size = size.checked_add(
                    self.leading_detached_comments()
                        .calculate_size(&self::location::LEADING_DETACHED_COMMENTS_CODEC)?,
                )?;
                size = size.checked_add(self.unknown_fields.calculate_size()?)?;
                ::std::option::Option::Some(size)
            }
            fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
                self.path().write_to(output, &self::location::PATH_CODEC)?;
                self.span().write_to(output, &self::location::SPAN_CODEC)?;
                if let ::std::option::Option::Some(leading_comments) =
                    self.leading_comments_option()
                {
                    output.write_raw_tag_bytes(&[26])?;
                    output.write_string(leading_comments)?;
                }
                if let ::std::option::Option::Some(trailing_comments) =
                    self.trailing_comments_option()
                {
                    output.write_raw_tag_bytes(&[34])?;
                    output.write_string(trailing_comments)?;
                }
                self.leading_detached_comments()
                    .write_to(output, &self::location::LEADING_DETACHED_COMMENTS_CODEC)?;
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                true
            }
        }
        impl crate::LiteMessage for self::Location {
            fn merge(&mut self, other: &Self) {
                self.path.merge(&other.path);
                self.span.merge(&other.span);
                if let ::std::option::Option::Some(leading_comments) =
                    other.leading_comments_option()
                {
                    self.set_leading_comments(::std::clone::Clone::clone(leading_comments));
                }
                if let ::std::option::Option::Some(trailing_comments) =
                    other.trailing_comments_option()
                {
                    self.set_trailing_comments(::std::clone::Clone::clone(trailing_comments));
                }
                self.leading_detached_comments
                    .merge(&other.leading_detached_comments);
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl crate::Message for self::Location {
            fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
                &<self::super::SourceCodeInfo as crate::Message>::descriptor().messages()[0]
            }
        }
        impl self::Location {
            pub const PATH_FIELD_NUMBER: i32 = 1;
            pub fn path(&self) -> &crate::collections::RepeatedField<i32> {
                &self.path
            }
            pub fn path_mut(&mut self) -> &mut crate::collections::RepeatedField<i32> {
                &mut self.path
            }
            pub const SPAN_FIELD_NUMBER: i32 = 2;
            pub fn span(&self) -> &crate::collections::RepeatedField<i32> {
                &self.span
            }
            pub fn span_mut(&mut self) -> &mut crate::collections::RepeatedField<i32> {
                &mut self.span
            }
            pub const LEADING_COMMENTS_FIELD_NUMBER: i32 = 3;
            pub const LEADING_COMMENTS_DEFAULT_VALUE: &'static str = "";
            pub fn leading_comments(&self) -> &str {
                self.leading_comments
                    .as_ref()
                    .map(|v| &**v)
                    .unwrap_or(Self::LEADING_COMMENTS_DEFAULT_VALUE)
            }
            pub fn leading_comments_option(&self) -> ::std::option::Option<&::std::string::String> {
                self.leading_comments.as_ref()
            }
            pub fn leading_comments_mut(&mut self) -> &mut ::std::string::String {
                self.leading_comments
                    .get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_leading_comments(&self) -> bool {
                self.leading_comments.is_some()
            }
            pub fn set_leading_comments(&mut self, value: ::std::string::String) {
                self.leading_comments =
                    ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_leading_comments(
                &mut self,
            ) -> ::std::option::Option<::std::string::String> {
                self.leading_comments.take()
            }
            pub fn clear_leading_comments(&mut self) {
                self.leading_comments = ::std::option::Option::None;
            }
            pub const TRAILING_COMMENTS_FIELD_NUMBER: i32 = 4;
            pub const TRAILING_COMMENTS_DEFAULT_VALUE: &'static str = "";
            pub fn trailing_comments(&self) -> &str {
                self.trailing_comments
                    .as_ref()
                    .map(|v| &**v)
                    .unwrap_or(Self::TRAILING_COMMENTS_DEFAULT_VALUE)
            }
            pub fn trailing_comments_option(
                &self,
            ) -> ::std::option::Option<&::std::string::String> {
                self.trailing_comments.as_ref()
            }
            pub fn trailing_comments_mut(&mut self) -> &mut ::std::string::String {
                self.trailing_comments
                    .get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_trailing_comments(&self) -> bool {
                self.trailing_comments.is_some()
            }
            pub fn set_trailing_comments(&mut self, value: ::std::string::String) {
                self.trailing_comments =
                    ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_trailing_comments(
                &mut self,
            ) -> ::std::option::Option<::std::string::String> {
                self.trailing_comments.take()
            }
            pub fn clear_trailing_comments(&mut self) {
                self.trailing_comments = ::std::option::Option::None;
            }
            pub const LEADING_DETACHED_COMMENTS_FIELD_NUMBER: i32 = 6;
            pub fn leading_detached_comments(
                &self,
            ) -> &crate::collections::RepeatedField<::std::string::String> {
                &self.leading_detached_comments
            }
            pub fn leading_detached_comments_mut(
                &mut self,
            ) -> &mut crate::collections::RepeatedField<::std::string::String> {
                &mut self.leading_detached_comments
            }
        }
        pub(in super::super::super) mod location {
            pub(super) static PATH_CODEC: crate::Codec<i32> = crate::Codec::int32(10);
            pub(super) static SPAN_CODEC: crate::Codec<i32> = crate::Codec::int32(18);
            pub(super) static LEADING_DETACHED_COMMENTS_CODEC: crate::Codec<::std::string::String> =
                crate::Codec::string(50);
            pub(in super::super::super) static PATH_REFLECTOR:
                crate::reflect::access::SimpleFieldAccessor<
                    self::super::Location,
                    crate::collections::RepeatedField<i32>,
                > = crate::reflect::access::SimpleFieldAccessor {
                get: self::super::Location::path,
                get_mut: self::super::Location::path_mut,
            };
            pub(in super::super::super) static SPAN_REFLECTOR:
                crate::reflect::access::SimpleFieldAccessor<
                    self::super::Location,
                    crate::collections::RepeatedField<i32>,
                > = crate::reflect::access::SimpleFieldAccessor {
                get: self::super::Location::span,
                get_mut: self::super::Location::span_mut,
            };
            pub(in super::super::super) static LEADING_COMMENTS_REFLECTOR:
                crate::reflect::access::VerboseFieldAccessor<
                    self::super::Location,
                    ::std::string::String,
                > = crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::Location::leading_comments_option,
                get_mut: self::super::Location::leading_comments_mut,
                set: self::super::Location::set_leading_comments,
                take: self::super::Location::take_leading_comments,
                clear: self::super::Location::clear_leading_comments,
            };
            pub(in super::super::super) static TRAILING_COMMENTS_REFLECTOR:
                crate::reflect::access::VerboseFieldAccessor<
                    self::super::Location,
                    ::std::string::String,
                > = crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::Location::trailing_comments_option,
                get_mut: self::super::Location::trailing_comments_mut,
                set: self::super::Location::set_trailing_comments,
                take: self::super::Location::take_trailing_comments,
                clear: self::super::Location::clear_trailing_comments,
            };
            pub(in super::super::super) static LEADING_DETACHED_COMMENTS_REFLECTOR:
                crate::reflect::access::SimpleFieldAccessor<
                    self::super::Location,
                    crate::collections::RepeatedField<::std::string::String>,
                > = crate::reflect::access::SimpleFieldAccessor {
                get: self::super::Location::leading_detached_comments,
                get_mut: self::super::Location::leading_detached_comments_mut,
            };
        }
        pub(super) static LOCATION_CODEC: crate::Codec<self::Location> = crate::Codec::message(10);
        pub(in super::super) static LOCATION_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::SourceCodeInfo,
                crate::collections::RepeatedField<self::Location>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::SourceCodeInfo::location,
            get_mut: self::super::SourceCodeInfo::location_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct GeneratedCodeInfo {
        annotation: crate::collections::RepeatedField<self::generated_code_info::Annotation>,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::GeneratedCodeInfo {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => self
                        .annotation
                        .add_entries(input, &self::generated_code_info::ANNOTATION_CODEC)?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            size = size.checked_add(
                self.annotation()
                    .calculate_size(&self::generated_code_info::ANNOTATION_CODEC)?,
            )?;
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            self.annotation()
                .write_to(output, &self::generated_code_info::ANNOTATION_CODEC)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.annotation.is_initialized() {
                return false;
            }
            true
        }
    }
    impl crate::LiteMessage for self::GeneratedCodeInfo {
        fn merge(&mut self, other: &Self) {
            self.annotation.merge(&other.annotation);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::GeneratedCodeInfo {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[20]
        }
    }
    impl self::GeneratedCodeInfo {
        pub const ANNOTATION_FIELD_NUMBER: i32 = 1;
        pub fn annotation(
            &self,
        ) -> &crate::collections::RepeatedField<self::generated_code_info::Annotation> {
            &self.annotation
        }
        pub fn annotation_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::generated_code_info::Annotation> {
            &mut self.annotation
        }
    }
    pub mod generated_code_info {
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct Annotation {
            path: crate::collections::RepeatedField<i32>,
            source_file: ::std::option::Option<::std::string::String>,
            begin: ::std::option::Option<i32>,
            end: ::std::option::Option<i32>,
            unknown_fields: crate::UnknownFieldSet,
        }
        impl crate::CodedMessage for self::Annotation {
            fn merge_from(
                &mut self,
                input: &mut crate::io::CodedInput,
            ) -> crate::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        10 => self
                            .path
                            .add_entries(input, &self::annotation::PATH_CODEC)?,
                        18 => self.set_source_file(input.read_string()?),
                        24 | 26 => self.set_begin(input.read_int32()?),
                        32 | 34 => self.set_end(input.read_int32()?),
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> ::std::option::Option<i32> {
                let mut size = 0i32;
                size =
                    size.checked_add(self.path().calculate_size(&self::annotation::PATH_CODEC)?)?;
                if let ::std::option::Option::Some(source_file) = self.source_file_option() {
                    size = size.checked_add(1)?;
                    size = size.checked_add(crate::io::sizes::string(source_file)?)?;
                }
                if let ::std::option::Option::Some(begin) = self.begin_option() {
                    size = size.checked_add(1)?;
                    size = size.checked_add(crate::io::sizes::int32(*begin))?;
                }
                if let ::std::option::Option::Some(end) = self.end_option() {
                    size = size.checked_add(1)?;
                    size = size.checked_add(crate::io::sizes::int32(*end))?;
                }
                size = size.checked_add(self.unknown_fields.calculate_size()?)?;
                ::std::option::Option::Some(size)
            }
            fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
                self.path()
                    .write_to(output, &self::annotation::PATH_CODEC)?;
                if let ::std::option::Option::Some(source_file) = self.source_file_option() {
                    output.write_raw_tag_bytes(&[18])?;
                    output.write_string(source_file)?;
                }
                if let ::std::option::Option::Some(begin) = self.begin_option() {
                    output.write_raw_tag_bytes(&[24])?;
                    output.write_int32(*begin)?;
                }
                if let ::std::option::Option::Some(end) = self.end_option() {
                    output.write_raw_tag_bytes(&[32])?;
                    output.write_int32(*end)?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                true
            }
        }
        impl crate::LiteMessage for self::Annotation {
            fn merge(&mut self, other: &Self) {
                self.path.merge(&other.path);
                if let ::std::option::Option::Some(source_file) = other.source_file_option() {
                    self.set_source_file(::std::clone::Clone::clone(source_file));
                }
                if let ::std::option::Option::Some(begin) = other.begin_option() {
                    self.set_begin(*begin);
                }
                if let ::std::option::Option::Some(end) = other.end_option() {
                    self.set_end(*end);
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl crate::Message for self::Annotation {
            fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
                &<self::super::GeneratedCodeInfo as crate::Message>::descriptor().messages()[0]
            }
        }
        impl self::Annotation {
            pub const PATH_FIELD_NUMBER: i32 = 1;
            pub fn path(&self) -> &crate::collections::RepeatedField<i32> {
                &self.path
            }
            pub fn path_mut(&mut self) -> &mut crate::collections::RepeatedField<i32> {
                &mut self.path
            }
            pub const SOURCE_FILE_FIELD_NUMBER: i32 = 2;
            pub const SOURCE_FILE_DEFAULT_VALUE: &'static str = "";
            pub fn source_file(&self) -> &str {
                self.source_file
                    .as_ref()
                    .map(|v| &**v)
                    .unwrap_or(Self::SOURCE_FILE_DEFAULT_VALUE)
            }
            pub fn source_file_option(&self) -> ::std::option::Option<&::std::string::String> {
                self.source_file.as_ref()
            }
            pub fn source_file_mut(&mut self) -> &mut ::std::string::String {
                self.source_file
                    .get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_source_file(&self) -> bool {
                self.source_file.is_some()
            }
            pub fn set_source_file(&mut self, value: ::std::string::String) {
                self.source_file = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_source_file(&mut self) -> ::std::option::Option<::std::string::String> {
                self.source_file.take()
            }
            pub fn clear_source_file(&mut self) {
                self.source_file = ::std::option::Option::None;
            }
            pub const BEGIN_FIELD_NUMBER: i32 = 3;
            pub const BEGIN_DEFAULT_VALUE: i32 = 0;
            pub fn begin(&self) -> i32 {
                self.begin.unwrap_or(Self::BEGIN_DEFAULT_VALUE)
            }
            pub fn begin_option(&self) -> ::std::option::Option<&i32> {
                self.begin.as_ref()
            }
            pub fn begin_mut(&mut self) -> &mut i32 {
                self.begin
                    .get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_begin(&self) -> bool {
                self.begin.is_some()
            }
            pub fn set_begin(&mut self, value: i32) {
                self.begin = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_begin(&mut self) -> ::std::option::Option<i32> {
                self.begin.take()
            }
            pub fn clear_begin(&mut self) {
                self.begin = ::std::option::Option::None;
            }
            pub const END_FIELD_NUMBER: i32 = 4;
            pub const END_DEFAULT_VALUE: i32 = 0;
            pub fn end(&self) -> i32 {
                self.end.unwrap_or(Self::END_DEFAULT_VALUE)
            }
            pub fn end_option(&self) -> ::std::option::Option<&i32> {
                self.end.as_ref()
            }
            pub fn end_mut(&mut self) -> &mut i32 {
                self.end
                    .get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_end(&self) -> bool {
                self.end.is_some()
            }
            pub fn set_end(&mut self, value: i32) {
                self.end = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_end(&mut self) -> ::std::option::Option<i32> {
                self.end.take()
            }
            pub fn clear_end(&mut self) {
                self.end = ::std::option::Option::None;
            }
        }
        pub(in super::super::super) mod annotation {
            pub(super) static PATH_CODEC: crate::Codec<i32> = crate::Codec::int32(10);
            pub(in super::super::super) static PATH_REFLECTOR:
                crate::reflect::access::SimpleFieldAccessor<
                    self::super::Annotation,
                    crate::collections::RepeatedField<i32>,
                > = crate::reflect::access::SimpleFieldAccessor {
                get: self::super::Annotation::path,
                get_mut: self::super::Annotation::path_mut,
            };
            pub(in super::super::super) static SOURCE_FILE_REFLECTOR:
                crate::reflect::access::VerboseFieldAccessor<
                    self::super::Annotation,
                    ::std::string::String,
                > = crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::Annotation::source_file_option,
                get_mut: self::super::Annotation::source_file_mut,
                set: self::super::Annotation::set_source_file,
                take: self::super::Annotation::take_source_file,
                clear: self::super::Annotation::clear_source_file,
            };
            pub(in super::super::super) static BEGIN_REFLECTOR:
                crate::reflect::access::VerboseFieldAccessor<self::super::Annotation, i32> =
                crate::reflect::access::VerboseFieldAccessor {
                    get_option: self::super::Annotation::begin_option,
                    get_mut: self::super::Annotation::begin_mut,
                    set: self::super::Annotation::set_begin,
                    take: self::super::Annotation::take_begin,
                    clear: self::super::Annotation::clear_begin,
                };
            pub(in super::super::super) static END_REFLECTOR:
                crate::reflect::access::VerboseFieldAccessor<self::super::Annotation, i32> =
                crate::reflect::access::VerboseFieldAccessor {
                    get_option: self::super::Annotation::end_option,
                    get_mut: self::super::Annotation::end_mut,
                    set: self::super::Annotation::set_end,
                    take: self::super::Annotation::take_end,
                    clear: self::super::Annotation::clear_end,
                };
        }
        pub(super) static ANNOTATION_CODEC: crate::Codec<self::Annotation> =
            crate::Codec::message(10);
        pub(in super::super) static ANNOTATION_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::GeneratedCodeInfo,
                crate::collections::RepeatedField<self::Annotation>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::GeneratedCodeInfo::annotation,
            get_mut: self::super::GeneratedCodeInfo::annotation_mut,
        };
    }
}
static GOOGLE_PROTOBUF_DURATION_PROTO_BINARY: &'static [u8] = &[
    10, 30, 103, 111, 111, 103, 108, 101, 47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 100, 117,
    114, 97, 116, 105, 111, 110, 46, 112, 114, 111, 116, 111, 18, 15, 103, 111, 111, 103, 108, 101,
    46, 112, 114, 111, 116, 111, 98, 117, 102, 34, 58, 10, 8, 68, 117, 114, 97, 116, 105, 111, 110,
    18, 24, 10, 7, 115, 101, 99, 111, 110, 100, 115, 24, 1, 32, 1, 40, 3, 82, 7, 115, 101, 99, 111,
    110, 100, 115, 18, 20, 10, 5, 110, 97, 110, 111, 115, 24, 2, 32, 1, 40, 5, 82, 5, 110, 97, 110,
    111, 115, 66, 124, 10, 19, 99, 111, 109, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111,
    116, 111, 98, 117, 102, 66, 13, 68, 117, 114, 97, 116, 105, 111, 110, 80, 114, 111, 116, 111,
    80, 1, 90, 42, 103, 105, 116, 104, 117, 98, 46, 99, 111, 109, 47, 103, 111, 108, 97, 110, 103,
    47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 112, 116, 121, 112, 101, 115, 47, 100, 117, 114,
    97, 116, 105, 111, 110, 248, 1, 1, 162, 2, 3, 71, 80, 66, 170, 2, 30, 71, 111, 111, 103, 108,
    101, 46, 80, 114, 111, 116, 111, 98, 117, 102, 46, 87, 101, 108, 108, 75, 110, 111, 119, 110,
    84, 121, 112, 101, 115, 98, 6, 112, 114, 111, 116, 111, 51,
];
pub mod google_protobuf_duration_proto {
    pub fn file() -> &'static crate::reflect::FileDescriptor<'static> {
        super::pool()
            .find_file_by_name("google/protobuf/duration.proto")
            .unwrap()
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct Duration {
        seconds: i64,
        nanos: i32,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::Duration {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => *self.seconds_mut() = input.read_int64()?,
                    16 | 18 => *self.nanos_mut() = input.read_int32()?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if *self.seconds() != Self::SECONDS_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::int64(*self.seconds()))?;
            }
            if *self.nanos() != Self::NANOS_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::int32(*self.nanos()))?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if *self.seconds() != Self::SECONDS_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int64(*self.seconds())?;
            }
            if *self.nanos() != Self::NANOS_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_int32(*self.nanos())?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl crate::LiteMessage for self::Duration {
        fn merge(&mut self, other: &Self) {
            if *other.seconds() != Self::SECONDS_DEFAULT_VALUE {
                *self.seconds_mut() = *other.seconds();
            }
            if *other.nanos() != Self::NANOS_DEFAULT_VALUE {
                *self.nanos_mut() = *other.nanos();
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::Duration {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[0]
        }
    }
    impl self::Duration {
        pub const SECONDS_FIELD_NUMBER: i32 = 1;
        pub const SECONDS_DEFAULT_VALUE: i64 = 0;
        pub fn seconds(&self) -> &i64 {
            &self.seconds
        }
        pub fn seconds_mut(&mut self) -> &mut i64 {
            &mut self.seconds
        }
        pub const NANOS_FIELD_NUMBER: i32 = 2;
        pub const NANOS_DEFAULT_VALUE: i32 = 0;
        pub fn nanos(&self) -> &i32 {
            &self.nanos
        }
        pub fn nanos_mut(&mut self) -> &mut i32 {
            &mut self.nanos
        }
    }
    pub(in super::super) mod duration {
        pub(in super::super) static SECONDS_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Duration,
            i64,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Duration::seconds,
            get_mut: self::super::Duration::seconds_mut,
        };
        pub(in super::super) static NANOS_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Duration,
            i32,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Duration::nanos,
            get_mut: self::super::Duration::nanos_mut,
        };
    }
}
static GOOGLE_PROTOBUF_EMPTY_PROTO_BINARY: &'static [u8] = &[
    10, 27, 103, 111, 111, 103, 108, 101, 47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 101, 109,
    112, 116, 121, 46, 112, 114, 111, 116, 111, 18, 15, 103, 111, 111, 103, 108, 101, 46, 112, 114,
    111, 116, 111, 98, 117, 102, 34, 7, 10, 5, 69, 109, 112, 116, 121, 66, 118, 10, 19, 99, 111,
    109, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 66, 10, 69,
    109, 112, 116, 121, 80, 114, 111, 116, 111, 80, 1, 90, 39, 103, 105, 116, 104, 117, 98, 46, 99,
    111, 109, 47, 103, 111, 108, 97, 110, 103, 47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 112,
    116, 121, 112, 101, 115, 47, 101, 109, 112, 116, 121, 248, 1, 1, 162, 2, 3, 71, 80, 66, 170, 2,
    30, 71, 111, 111, 103, 108, 101, 46, 80, 114, 111, 116, 111, 98, 117, 102, 46, 87, 101, 108,
    108, 75, 110, 111, 119, 110, 84, 121, 112, 101, 115, 98, 6, 112, 114, 111, 116, 111, 51,
];
pub mod google_protobuf_empty_proto {
    pub fn file() -> &'static crate::reflect::FileDescriptor<'static> {
        super::pool()
            .find_file_by_name("google/protobuf/empty.proto")
            .unwrap()
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct Empty {
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::Empty {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl crate::LiteMessage for self::Empty {
        fn merge(&mut self, other: &Self) {
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::Empty {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[0]
        }
    }
    impl self::Empty {}
}
static GOOGLE_PROTOBUF_FIELD_MASK_PROTO_BINARY: &'static [u8] = &[
    10, 32, 103, 111, 111, 103, 108, 101, 47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 102, 105,
    101, 108, 100, 95, 109, 97, 115, 107, 46, 112, 114, 111, 116, 111, 18, 15, 103, 111, 111, 103,
    108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 34, 33, 10, 9, 70, 105, 101, 108, 100, 77,
    97, 115, 107, 18, 20, 10, 5, 112, 97, 116, 104, 115, 24, 1, 32, 3, 40, 9, 82, 5, 112, 97, 116,
    104, 115, 66, 137, 1, 10, 19, 99, 111, 109, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114,
    111, 116, 111, 98, 117, 102, 66, 14, 70, 105, 101, 108, 100, 77, 97, 115, 107, 80, 114, 111,
    116, 111, 80, 1, 90, 57, 103, 111, 111, 103, 108, 101, 46, 103, 111, 108, 97, 110, 103, 46,
    111, 114, 103, 47, 103, 101, 110, 112, 114, 111, 116, 111, 47, 112, 114, 111, 116, 111, 98,
    117, 102, 47, 102, 105, 101, 108, 100, 95, 109, 97, 115, 107, 59, 102, 105, 101, 108, 100, 95,
    109, 97, 115, 107, 162, 2, 3, 71, 80, 66, 170, 2, 30, 71, 111, 111, 103, 108, 101, 46, 80, 114,
    111, 116, 111, 98, 117, 102, 46, 87, 101, 108, 108, 75, 110, 111, 119, 110, 84, 121, 112, 101,
    115, 98, 6, 112, 114, 111, 116, 111, 51,
];
pub mod google_protobuf_field_mask_proto {
    pub fn file() -> &'static crate::reflect::FileDescriptor<'static> {
        super::pool()
            .find_file_by_name("google/protobuf/field_mask.proto")
            .unwrap()
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct FieldMask {
        paths: crate::collections::RepeatedField<::std::string::String>,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::FieldMask {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => self
                        .paths
                        .add_entries(input, &self::field_mask::PATHS_CODEC)?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            size = size.checked_add(
                self.paths()
                    .calculate_size(&self::field_mask::PATHS_CODEC)?,
            )?;
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            self.paths()
                .write_to(output, &self::field_mask::PATHS_CODEC)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl crate::LiteMessage for self::FieldMask {
        fn merge(&mut self, other: &Self) {
            self.paths.merge(&other.paths);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::FieldMask {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[0]
        }
    }
    impl self::FieldMask {
        pub const PATHS_FIELD_NUMBER: i32 = 1;
        pub fn paths(&self) -> &crate::collections::RepeatedField<::std::string::String> {
            &self.paths
        }
        pub fn paths_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<::std::string::String> {
            &mut self.paths
        }
    }
    pub(in super::super) mod field_mask {
        pub(super) static PATHS_CODEC: crate::Codec<::std::string::String> =
            crate::Codec::string(10);
        pub(in super::super) static PATHS_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::FieldMask,
            crate::collections::RepeatedField<::std::string::String>,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::FieldMask::paths,
            get_mut: self::super::FieldMask::paths_mut,
        };
    }
}
static GOOGLE_PROTOBUF_SOURCE_CONTEXT_PROTO_BINARY: &'static [u8] = &[
    10, 36, 103, 111, 111, 103, 108, 101, 47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 115, 111,
    117, 114, 99, 101, 95, 99, 111, 110, 116, 101, 120, 116, 46, 112, 114, 111, 116, 111, 18, 15,
    103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 34, 44, 10, 13, 83,
    111, 117, 114, 99, 101, 67, 111, 110, 116, 101, 120, 116, 18, 27, 10, 9, 102, 105, 108, 101,
    95, 110, 97, 109, 101, 24, 1, 32, 1, 40, 9, 82, 8, 102, 105, 108, 101, 78, 97, 109, 101, 66,
    149, 1, 10, 19, 99, 111, 109, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111,
    98, 117, 102, 66, 18, 83, 111, 117, 114, 99, 101, 67, 111, 110, 116, 101, 120, 116, 80, 114,
    111, 116, 111, 80, 1, 90, 65, 103, 111, 111, 103, 108, 101, 46, 103, 111, 108, 97, 110, 103,
    46, 111, 114, 103, 47, 103, 101, 110, 112, 114, 111, 116, 111, 47, 112, 114, 111, 116, 111, 98,
    117, 102, 47, 115, 111, 117, 114, 99, 101, 95, 99, 111, 110, 116, 101, 120, 116, 59, 115, 111,
    117, 114, 99, 101, 95, 99, 111, 110, 116, 101, 120, 116, 162, 2, 3, 71, 80, 66, 170, 2, 30, 71,
    111, 111, 103, 108, 101, 46, 80, 114, 111, 116, 111, 98, 117, 102, 46, 87, 101, 108, 108, 75,
    110, 111, 119, 110, 84, 121, 112, 101, 115, 98, 6, 112, 114, 111, 116, 111, 51,
];
pub mod google_protobuf_source_context_proto {
    pub fn file() -> &'static crate::reflect::FileDescriptor<'static> {
        super::pool()
            .find_file_by_name("google/protobuf/source_context.proto")
            .unwrap()
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct SourceContext {
        file_name: ::std::string::String,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::SourceContext {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => *self.file_name_mut() = input.read_string()?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if **self.file_name() != *Self::FILE_NAME_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(self.file_name())?)?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if **self.file_name() != *Self::FILE_NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(self.file_name())?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl crate::LiteMessage for self::SourceContext {
        fn merge(&mut self, other: &Self) {
            if other.file_name.len() != 0 {
                *self.file_name_mut() = ::std::clone::Clone::clone(other.file_name());
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::SourceContext {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[0]
        }
    }
    impl self::SourceContext {
        pub const FILE_NAME_FIELD_NUMBER: i32 = 1;
        pub const FILE_NAME_DEFAULT_VALUE: &'static str = "";
        pub fn file_name(&self) -> &::std::string::String {
            &self.file_name
        }
        pub fn file_name_mut(&mut self) -> &mut ::std::string::String {
            &mut self.file_name
        }
    }
    pub(in super::super) mod source_context {
        pub(in super::super) static FILE_NAME_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::SourceContext,
                ::std::string::String,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::SourceContext::file_name,
            get_mut: self::super::SourceContext::file_name_mut,
        };
    }
}
static GOOGLE_PROTOBUF_STRUCT_PROTO_BINARY: &'static [u8] = &[
    10, 28, 103, 111, 111, 103, 108, 101, 47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 115, 116,
    114, 117, 99, 116, 46, 112, 114, 111, 116, 111, 18, 15, 103, 111, 111, 103, 108, 101, 46, 112,
    114, 111, 116, 111, 98, 117, 102, 34, 152, 1, 10, 6, 83, 116, 114, 117, 99, 116, 18, 59, 10, 6,
    102, 105, 101, 108, 100, 115, 24, 1, 32, 3, 40, 11, 50, 35, 46, 103, 111, 111, 103, 108, 101,
    46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 83, 116, 114, 117, 99, 116, 46, 70, 105, 101,
    108, 100, 115, 69, 110, 116, 114, 121, 82, 6, 102, 105, 101, 108, 100, 115, 26, 81, 10, 11, 70,
    105, 101, 108, 100, 115, 69, 110, 116, 114, 121, 18, 16, 10, 3, 107, 101, 121, 24, 1, 32, 1,
    40, 9, 82, 3, 107, 101, 121, 18, 44, 10, 5, 118, 97, 108, 117, 101, 24, 2, 32, 1, 40, 11, 50,
    22, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 86, 97,
    108, 117, 101, 82, 5, 118, 97, 108, 117, 101, 58, 2, 56, 1, 34, 178, 2, 10, 5, 86, 97, 108,
    117, 101, 18, 59, 10, 10, 110, 117, 108, 108, 95, 118, 97, 108, 117, 101, 24, 1, 32, 1, 40, 14,
    50, 26, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 78,
    117, 108, 108, 86, 97, 108, 117, 101, 72, 0, 82, 9, 110, 117, 108, 108, 86, 97, 108, 117, 101,
    18, 35, 10, 12, 110, 117, 109, 98, 101, 114, 95, 118, 97, 108, 117, 101, 24, 2, 32, 1, 40, 1,
    72, 0, 82, 11, 110, 117, 109, 98, 101, 114, 86, 97, 108, 117, 101, 18, 35, 10, 12, 115, 116,
    114, 105, 110, 103, 95, 118, 97, 108, 117, 101, 24, 3, 32, 1, 40, 9, 72, 0, 82, 11, 115, 116,
    114, 105, 110, 103, 86, 97, 108, 117, 101, 18, 31, 10, 10, 98, 111, 111, 108, 95, 118, 97, 108,
    117, 101, 24, 4, 32, 1, 40, 8, 72, 0, 82, 9, 98, 111, 111, 108, 86, 97, 108, 117, 101, 18, 60,
    10, 12, 115, 116, 114, 117, 99, 116, 95, 118, 97, 108, 117, 101, 24, 5, 32, 1, 40, 11, 50, 23,
    46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 83, 116, 114,
    117, 99, 116, 72, 0, 82, 11, 115, 116, 114, 117, 99, 116, 86, 97, 108, 117, 101, 18, 59, 10,
    10, 108, 105, 115, 116, 95, 118, 97, 108, 117, 101, 24, 6, 32, 1, 40, 11, 50, 26, 46, 103, 111,
    111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 76, 105, 115, 116, 86, 97,
    108, 117, 101, 72, 0, 82, 9, 108, 105, 115, 116, 86, 97, 108, 117, 101, 66, 6, 10, 4, 107, 105,
    110, 100, 34, 59, 10, 9, 76, 105, 115, 116, 86, 97, 108, 117, 101, 18, 46, 10, 6, 118, 97, 108,
    117, 101, 115, 24, 1, 32, 3, 40, 11, 50, 22, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114,
    111, 116, 111, 98, 117, 102, 46, 86, 97, 108, 117, 101, 82, 6, 118, 97, 108, 117, 101, 115, 42,
    27, 10, 9, 78, 117, 108, 108, 86, 97, 108, 117, 101, 18, 14, 10, 10, 78, 85, 76, 76, 95, 86,
    65, 76, 85, 69, 16, 0, 66, 129, 1, 10, 19, 99, 111, 109, 46, 103, 111, 111, 103, 108, 101, 46,
    112, 114, 111, 116, 111, 98, 117, 102, 66, 11, 83, 116, 114, 117, 99, 116, 80, 114, 111, 116,
    111, 80, 1, 90, 49, 103, 105, 116, 104, 117, 98, 46, 99, 111, 109, 47, 103, 111, 108, 97, 110,
    103, 47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 112, 116, 121, 112, 101, 115, 47, 115, 116,
    114, 117, 99, 116, 59, 115, 116, 114, 117, 99, 116, 112, 98, 248, 1, 1, 162, 2, 3, 71, 80, 66,
    170, 2, 30, 71, 111, 111, 103, 108, 101, 46, 80, 114, 111, 116, 111, 98, 117, 102, 46, 87, 101,
    108, 108, 75, 110, 111, 119, 110, 84, 121, 112, 101, 115, 98, 6, 112, 114, 111, 116, 111, 51,
];
pub mod google_protobuf_struct_proto {
    pub fn file() -> &'static crate::reflect::FileDescriptor<'static> {
        super::pool()
            .find_file_by_name("google/protobuf/struct.proto")
            .unwrap()
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct Struct {
        fields: crate::collections::MapField<::std::string::String, self::Value>,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::Struct {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => self
                        .fields
                        .add_entries(input, &self::r#struct::FIELDS_CODEC)?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            size = size.checked_add(
                self.fields()
                    .calculate_size(&self::r#struct::FIELDS_CODEC)?,
            )?;
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            self.fields()
                .write_to(output, &self::r#struct::FIELDS_CODEC)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.fields.is_initialized() {
                return false;
            }
            true
        }
    }
    impl crate::LiteMessage for self::Struct {
        fn merge(&mut self, other: &Self) {
            self.fields.merge(&other.fields);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::Struct {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[0]
        }
    }
    impl self::Struct {
        pub const FIELDS_FIELD_NUMBER: i32 = 1;
        pub fn fields(&self) -> &crate::collections::MapField<::std::string::String, self::Value> {
            &self.fields
        }
        pub fn fields_mut(
            &mut self,
        ) -> &mut crate::collections::MapField<::std::string::String, self::Value> {
            &mut self.fields
        }
    }
    pub(in super::super) mod r#struct {
        pub(super) static FIELDS_CODEC: crate::collections::MapCodec<
            ::std::string::String,
            self::super::Value,
        > = crate::collections::MapCodec::new(
            crate::Codec::string(10),
            crate::Codec::message(18),
            10,
        );
        pub(in super::super) static FIELDS_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Struct,
            crate::collections::MapField<::std::string::String, self::super::Value>,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Struct::fields,
            get_mut: self::super::Struct::fields_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct Value {
        kind: self::value::Kind,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::Value {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => *self.null_value_mut() = input.read_enum_value()?,
                    17 | 18 => *self.number_value_mut() = input.read_double()?,
                    26 => *self.string_value_mut() = input.read_string()?,
                    32 | 34 => *self.bool_value_mut() = input.read_bool()?,
                    42 => input.read_message(self.struct_value_mut())?,
                    50 => input.read_message(self.list_value_mut())?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if let ::std::option::Option::Some(null_value) = self.null_value() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::enum_value(*null_value))?;
            }
            if let ::std::option::Option::Some(number_value) = self.number_value() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::double(*number_value))?;
            }
            if let ::std::option::Option::Some(string_value) = self.string_value() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(string_value)?)?;
            }
            if let ::std::option::Option::Some(bool_value) = self.bool_value() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(*bool_value))?;
            }
            if let ::std::option::Option::Some(struct_value) = self.struct_value() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::message(struct_value)?)?;
            }
            if let ::std::option::Option::Some(list_value) = self.list_value() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::message(list_value)?)?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if let ::std::option::Option::Some(null_value) = self.null_value() {
                output.write_raw_tag_bytes(&[8])?;
                output.write_enum_value(*null_value)?;
            }
            if let ::std::option::Option::Some(number_value) = self.number_value() {
                output.write_raw_tag_bytes(&[17])?;
                output.write_double(*number_value)?;
            }
            if let ::std::option::Option::Some(string_value) = self.string_value() {
                output.write_raw_tag_bytes(&[26])?;
                output.write_string(string_value)?;
            }
            if let ::std::option::Option::Some(bool_value) = self.bool_value() {
                output.write_raw_tag_bytes(&[32])?;
                output.write_bool(*bool_value)?;
            }
            if let ::std::option::Option::Some(struct_value) = self.struct_value() {
                output.write_raw_tag_bytes(&[42])?;
                output.write_message(struct_value)?;
            }
            if let ::std::option::Option::Some(list_value) = self.list_value() {
                output.write_raw_tag_bytes(&[50])?;
                output.write_message(list_value)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(struct_value) = self.struct_value() {
                if !crate::CodedMessage::is_initialized(struct_value) {
                    return false;
                }
            }
            if let ::std::option::Option::Some(list_value) = self.list_value() {
                if !crate::CodedMessage::is_initialized(list_value) {
                    return false;
                }
            }
            true
        }
    }
    impl crate::LiteMessage for self::Value {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(null_value) = other.null_value() {
                self.set_null_value(*null_value);
            }
            if let ::std::option::Option::Some(number_value) = other.number_value() {
                self.set_number_value(*number_value);
            }
            if let ::std::option::Option::Some(string_value) = other.string_value() {
                self.set_string_value(::std::clone::Clone::clone(string_value));
            }
            if let ::std::option::Option::Some(bool_value) = other.bool_value() {
                self.set_bool_value(*bool_value);
            }
            if let ::std::option::Option::Some(struct_value) = &other.struct_value() {
                crate::LiteMessage::merge(self.struct_value_mut(), struct_value);
            }
            if let ::std::option::Option::Some(list_value) = &other.list_value() {
                crate::LiteMessage::merge(self.list_value_mut(), list_value);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::Value {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[1]
        }
    }
    impl self::Value {
        pub const NULL_VALUE_FIELD_NUMBER: i32 = 1;
        pub const NULL_VALUE_DEFAULT_VALUE: crate::EnumValue<self::NullValue> =
            crate::EnumValue::Defined(self::NullValue::NullValue);
        pub fn null_value(&self) -> ::std::option::Option<&crate::EnumValue<self::NullValue>> {
            match &self.kind {
                self::value::Kind::NullValue(kind) => ::std::option::Option::Some(kind),
                _ => ::std::option::Option::None,
            }
        }
        pub fn null_value_mut(&mut self) -> &mut crate::EnumValue<self::NullValue> {
            match self.kind {
                self::value::Kind::NullValue(_) => (),
                _ => self.kind = self::value::Kind::NullValue(::std::default::Default::default()),
            }
            match self.kind {
                self::value::Kind::NullValue(ref mut kind) => kind,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_null_value(&self) -> bool {
            match self.kind {
                self::value::Kind::NullValue(_) => true,
                _ => false,
            }
        }
        pub fn set_null_value(&mut self, value: crate::EnumValue<self::NullValue>) {
            self.kind = self::value::Kind::NullValue(::std::convert::From::from(value))
        }
        pub fn take_null_value(
            &mut self,
        ) -> ::std::option::Option<crate::EnumValue<self::NullValue>> {
            let kind = ::std::mem::replace(&mut self.kind, self::value::Kind::None);
            match kind {
                self::value::Kind::NullValue(kind) => ::std::option::Option::Some(kind),
                mut kind => {
                    ::std::mem::swap(&mut self.kind, &mut kind);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_null_value(&mut self) {
            let kind = ::std::mem::replace(&mut self.kind, self::value::Kind::None);
            match kind {
                self::value::Kind::NullValue(_) => {}
                mut kind => ::std::mem::swap(&mut self.kind, &mut kind),
            }
        }
        pub const NUMBER_VALUE_FIELD_NUMBER: i32 = 2;
        pub const NUMBER_VALUE_DEFAULT_VALUE: f64 = 0.0;
        pub fn number_value(&self) -> ::std::option::Option<&f64> {
            match &self.kind {
                self::value::Kind::NumberValue(kind) => ::std::option::Option::Some(kind),
                _ => ::std::option::Option::None,
            }
        }
        pub fn number_value_mut(&mut self) -> &mut f64 {
            match self.kind {
                self::value::Kind::NumberValue(_) => (),
                _ => self.kind = self::value::Kind::NumberValue(::std::default::Default::default()),
            }
            match self.kind {
                self::value::Kind::NumberValue(ref mut kind) => kind,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_number_value(&self) -> bool {
            match self.kind {
                self::value::Kind::NumberValue(_) => true,
                _ => false,
            }
        }
        pub fn set_number_value(&mut self, value: f64) {
            self.kind = self::value::Kind::NumberValue(::std::convert::From::from(value))
        }
        pub fn take_number_value(&mut self) -> ::std::option::Option<f64> {
            let kind = ::std::mem::replace(&mut self.kind, self::value::Kind::None);
            match kind {
                self::value::Kind::NumberValue(kind) => ::std::option::Option::Some(kind),
                mut kind => {
                    ::std::mem::swap(&mut self.kind, &mut kind);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_number_value(&mut self) {
            let kind = ::std::mem::replace(&mut self.kind, self::value::Kind::None);
            match kind {
                self::value::Kind::NumberValue(_) => {}
                mut kind => ::std::mem::swap(&mut self.kind, &mut kind),
            }
        }
        pub const STRING_VALUE_FIELD_NUMBER: i32 = 3;
        pub const STRING_VALUE_DEFAULT_VALUE: &'static str = "";
        pub fn string_value(&self) -> ::std::option::Option<&::std::string::String> {
            match &self.kind {
                self::value::Kind::StringValue(kind) => ::std::option::Option::Some(kind),
                _ => ::std::option::Option::None,
            }
        }
        pub fn string_value_mut(&mut self) -> &mut ::std::string::String {
            match self.kind {
                self::value::Kind::StringValue(_) => (),
                _ => self.kind = self::value::Kind::StringValue(::std::default::Default::default()),
            }
            match self.kind {
                self::value::Kind::StringValue(ref mut kind) => kind,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_string_value(&self) -> bool {
            match self.kind {
                self::value::Kind::StringValue(_) => true,
                _ => false,
            }
        }
        pub fn set_string_value(&mut self, value: ::std::string::String) {
            self.kind = self::value::Kind::StringValue(::std::convert::From::from(value))
        }
        pub fn take_string_value(&mut self) -> ::std::option::Option<::std::string::String> {
            let kind = ::std::mem::replace(&mut self.kind, self::value::Kind::None);
            match kind {
                self::value::Kind::StringValue(kind) => ::std::option::Option::Some(kind),
                mut kind => {
                    ::std::mem::swap(&mut self.kind, &mut kind);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_string_value(&mut self) {
            let kind = ::std::mem::replace(&mut self.kind, self::value::Kind::None);
            match kind {
                self::value::Kind::StringValue(_) => {}
                mut kind => ::std::mem::swap(&mut self.kind, &mut kind),
            }
        }
        pub const BOOL_VALUE_FIELD_NUMBER: i32 = 4;
        pub const BOOL_VALUE_DEFAULT_VALUE: bool = false;
        pub fn bool_value(&self) -> ::std::option::Option<&bool> {
            match &self.kind {
                self::value::Kind::BoolValue(kind) => ::std::option::Option::Some(kind),
                _ => ::std::option::Option::None,
            }
        }
        pub fn bool_value_mut(&mut self) -> &mut bool {
            match self.kind {
                self::value::Kind::BoolValue(_) => (),
                _ => self.kind = self::value::Kind::BoolValue(::std::default::Default::default()),
            }
            match self.kind {
                self::value::Kind::BoolValue(ref mut kind) => kind,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_bool_value(&self) -> bool {
            match self.kind {
                self::value::Kind::BoolValue(_) => true,
                _ => false,
            }
        }
        pub fn set_bool_value(&mut self, value: bool) {
            self.kind = self::value::Kind::BoolValue(::std::convert::From::from(value))
        }
        pub fn take_bool_value(&mut self) -> ::std::option::Option<bool> {
            let kind = ::std::mem::replace(&mut self.kind, self::value::Kind::None);
            match kind {
                self::value::Kind::BoolValue(kind) => ::std::option::Option::Some(kind),
                mut kind => {
                    ::std::mem::swap(&mut self.kind, &mut kind);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_bool_value(&mut self) {
            let kind = ::std::mem::replace(&mut self.kind, self::value::Kind::None);
            match kind {
                self::value::Kind::BoolValue(_) => {}
                mut kind => ::std::mem::swap(&mut self.kind, &mut kind),
            }
        }
        pub const STRUCT_VALUE_FIELD_NUMBER: i32 = 5;
        pub fn struct_value(&self) -> ::std::option::Option<&self::Struct> {
            match &self.kind {
                self::value::Kind::StructValue(kind) => ::std::option::Option::Some(&**kind),
                _ => ::std::option::Option::None,
            }
        }
        pub fn struct_value_mut(&mut self) -> &mut self::Struct {
            match self.kind {
                self::value::Kind::StructValue(_) => (),
                _ => self.kind = self::value::Kind::StructValue(::std::default::Default::default()),
            }
            match self.kind {
                self::value::Kind::StructValue(ref mut kind) => &mut **kind,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_struct_value(&self) -> bool {
            match self.kind {
                self::value::Kind::StructValue(_) => true,
                _ => false,
            }
        }
        pub fn set_struct_value(&mut self, value: self::Struct) {
            self.kind = self::value::Kind::StructValue(::std::convert::From::from(value))
        }
        pub fn take_struct_value(&mut self) -> ::std::option::Option<self::Struct> {
            let kind = ::std::mem::replace(&mut self.kind, self::value::Kind::None);
            match kind {
                self::value::Kind::StructValue(kind) => ::std::option::Option::Some(*kind),
                mut kind => {
                    ::std::mem::swap(&mut self.kind, &mut kind);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_struct_value(&mut self) {
            let kind = ::std::mem::replace(&mut self.kind, self::value::Kind::None);
            match kind {
                self::value::Kind::StructValue(_) => {}
                mut kind => ::std::mem::swap(&mut self.kind, &mut kind),
            }
        }
        pub const LIST_VALUE_FIELD_NUMBER: i32 = 6;
        pub fn list_value(&self) -> ::std::option::Option<&self::ListValue> {
            match &self.kind {
                self::value::Kind::ListValue(kind) => ::std::option::Option::Some(&**kind),
                _ => ::std::option::Option::None,
            }
        }
        pub fn list_value_mut(&mut self) -> &mut self::ListValue {
            match self.kind {
                self::value::Kind::ListValue(_) => (),
                _ => self.kind = self::value::Kind::ListValue(::std::default::Default::default()),
            }
            match self.kind {
                self::value::Kind::ListValue(ref mut kind) => &mut **kind,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_list_value(&self) -> bool {
            match self.kind {
                self::value::Kind::ListValue(_) => true,
                _ => false,
            }
        }
        pub fn set_list_value(&mut self, value: self::ListValue) {
            self.kind = self::value::Kind::ListValue(::std::convert::From::from(value))
        }
        pub fn take_list_value(&mut self) -> ::std::option::Option<self::ListValue> {
            let kind = ::std::mem::replace(&mut self.kind, self::value::Kind::None);
            match kind {
                self::value::Kind::ListValue(kind) => ::std::option::Option::Some(*kind),
                mut kind => {
                    ::std::mem::swap(&mut self.kind, &mut kind);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_list_value(&mut self) {
            let kind = ::std::mem::replace(&mut self.kind, self::value::Kind::None);
            match kind {
                self::value::Kind::ListValue(_) => {}
                mut kind => ::std::mem::swap(&mut self.kind, &mut kind),
            }
        }
        pub fn kind(&self) -> &self::value::Kind {
            &self.kind
        }
        pub fn kind_mut(&mut self) -> &mut self::value::Kind {
            &mut self.kind
        }
    }
    pub mod value {
        #[derive(Clone, Debug, PartialEq)]
        pub enum Kind {
            None,
            NullValue(crate::EnumValue<self::super::NullValue>),
            NumberValue(f64),
            StringValue(::std::string::String),
            BoolValue(bool),
            StructValue(::std::boxed::Box<self::super::Struct>),
            ListValue(::std::boxed::Box<self::super::ListValue>),
        }
        impl ::std::default::Default for self::Kind {
            fn default() -> Self {
                self::Kind::None
            }
        }
        pub(in super::super) static NULL_VALUE_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::Value,
                crate::EnumValue<self::super::NullValue>,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::Value::null_value,
            get_mut: self::super::Value::null_value_mut,
            set: self::super::Value::set_null_value,
            take: self::super::Value::take_null_value,
            clear: self::super::Value::clear_null_value,
        };
        pub(in super::super) static NUMBER_VALUE_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::Value, f64> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::Value::number_value,
                get_mut: self::super::Value::number_value_mut,
                set: self::super::Value::set_number_value,
                take: self::super::Value::take_number_value,
                clear: self::super::Value::clear_number_value,
            };
        pub(in super::super) static STRING_VALUE_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::Value, ::std::string::String> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::Value::string_value,
                get_mut: self::super::Value::string_value_mut,
                set: self::super::Value::set_string_value,
                take: self::super::Value::take_string_value,
                clear: self::super::Value::clear_string_value,
            };
        pub(in super::super) static BOOL_VALUE_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::Value, bool> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::Value::bool_value,
                get_mut: self::super::Value::bool_value_mut,
                set: self::super::Value::set_bool_value,
                take: self::super::Value::take_bool_value,
                clear: self::super::Value::clear_bool_value,
            };
        pub(in super::super) static STRUCT_VALUE_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::Value, self::super::Struct> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::Value::struct_value,
                get_mut: self::super::Value::struct_value_mut,
                set: self::super::Value::set_struct_value,
                take: self::super::Value::take_struct_value,
                clear: self::super::Value::clear_struct_value,
            };
        pub(in super::super) static LIST_VALUE_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<self::super::Value, self::super::ListValue> =
            crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::Value::list_value,
                get_mut: self::super::Value::list_value_mut,
                set: self::super::Value::set_list_value,
                take: self::super::Value::take_list_value,
                clear: self::super::Value::clear_list_value,
            };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct ListValue {
        values: crate::collections::RepeatedField<self::Value>,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::ListValue {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => self
                        .values
                        .add_entries(input, &self::list_value::VALUES_CODEC)?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            size = size.checked_add(
                self.values()
                    .calculate_size(&self::list_value::VALUES_CODEC)?,
            )?;
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            self.values()
                .write_to(output, &self::list_value::VALUES_CODEC)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.values.is_initialized() {
                return false;
            }
            true
        }
    }
    impl crate::LiteMessage for self::ListValue {
        fn merge(&mut self, other: &Self) {
            self.values.merge(&other.values);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::ListValue {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[2]
        }
    }
    impl self::ListValue {
        pub const VALUES_FIELD_NUMBER: i32 = 1;
        pub fn values(&self) -> &crate::collections::RepeatedField<self::Value> {
            &self.values
        }
        pub fn values_mut(&mut self) -> &mut crate::collections::RepeatedField<self::Value> {
            &mut self.values
        }
    }
    pub(in super::super) mod list_value {
        pub(super) static VALUES_CODEC: crate::Codec<self::super::Value> =
            crate::Codec::message(10);
        pub(in super::super) static VALUES_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::ListValue,
            crate::collections::RepeatedField<self::super::Value>,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::ListValue::values,
            get_mut: self::super::ListValue::values_mut,
        };
    }
    #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
    pub enum NullValue {
        NullValue,
    }
    impl crate::Enum for self::NullValue {
        fn descriptor() -> &'static crate::reflect::EnumDescriptor<'static> {
            &self::file().enums()[0]
        }
    }
    impl ::std::convert::TryFrom<i32> for self::NullValue {
        type Error = crate::VariantUndefinedError;
        fn try_from(value: i32) -> ::std::result::Result<Self, crate::VariantUndefinedError> {
            #[allow(unreachable_patterns)]
            match value {
                0 => ::std::result::Result::Ok(self::NullValue::NullValue),
                _ => ::std::result::Result::Err(crate::VariantUndefinedError),
            }
        }
    }
    impl ::std::convert::From<self::NullValue> for i32 {
        fn from(value: self::NullValue) -> i32 {
            match value {
                self::NullValue::NullValue => 0,
            }
        }
    }
}
static GOOGLE_PROTOBUF_TIMESTAMP_PROTO_BINARY: &'static [u8] = &[
    10, 31, 103, 111, 111, 103, 108, 101, 47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 116, 105,
    109, 101, 115, 116, 97, 109, 112, 46, 112, 114, 111, 116, 111, 18, 15, 103, 111, 111, 103, 108,
    101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 34, 59, 10, 9, 84, 105, 109, 101, 115, 116, 97,
    109, 112, 18, 24, 10, 7, 115, 101, 99, 111, 110, 100, 115, 24, 1, 32, 1, 40, 3, 82, 7, 115,
    101, 99, 111, 110, 100, 115, 18, 20, 10, 5, 110, 97, 110, 111, 115, 24, 2, 32, 1, 40, 5, 82, 5,
    110, 97, 110, 111, 115, 66, 126, 10, 19, 99, 111, 109, 46, 103, 111, 111, 103, 108, 101, 46,
    112, 114, 111, 116, 111, 98, 117, 102, 66, 14, 84, 105, 109, 101, 115, 116, 97, 109, 112, 80,
    114, 111, 116, 111, 80, 1, 90, 43, 103, 105, 116, 104, 117, 98, 46, 99, 111, 109, 47, 103, 111,
    108, 97, 110, 103, 47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 112, 116, 121, 112, 101, 115,
    47, 116, 105, 109, 101, 115, 116, 97, 109, 112, 248, 1, 1, 162, 2, 3, 71, 80, 66, 170, 2, 30,
    71, 111, 111, 103, 108, 101, 46, 80, 114, 111, 116, 111, 98, 117, 102, 46, 87, 101, 108, 108,
    75, 110, 111, 119, 110, 84, 121, 112, 101, 115, 98, 6, 112, 114, 111, 116, 111, 51,
];
pub mod google_protobuf_timestamp_proto {
    pub fn file() -> &'static crate::reflect::FileDescriptor<'static> {
        super::pool()
            .find_file_by_name("google/protobuf/timestamp.proto")
            .unwrap()
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct Timestamp {
        seconds: i64,
        nanos: i32,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::Timestamp {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => *self.seconds_mut() = input.read_int64()?,
                    16 | 18 => *self.nanos_mut() = input.read_int32()?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if *self.seconds() != Self::SECONDS_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::int64(*self.seconds()))?;
            }
            if *self.nanos() != Self::NANOS_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::int32(*self.nanos()))?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if *self.seconds() != Self::SECONDS_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int64(*self.seconds())?;
            }
            if *self.nanos() != Self::NANOS_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_int32(*self.nanos())?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl crate::LiteMessage for self::Timestamp {
        fn merge(&mut self, other: &Self) {
            if *other.seconds() != Self::SECONDS_DEFAULT_VALUE {
                *self.seconds_mut() = *other.seconds();
            }
            if *other.nanos() != Self::NANOS_DEFAULT_VALUE {
                *self.nanos_mut() = *other.nanos();
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::Timestamp {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[0]
        }
    }
    impl self::Timestamp {
        pub const SECONDS_FIELD_NUMBER: i32 = 1;
        pub const SECONDS_DEFAULT_VALUE: i64 = 0;
        pub fn seconds(&self) -> &i64 {
            &self.seconds
        }
        pub fn seconds_mut(&mut self) -> &mut i64 {
            &mut self.seconds
        }
        pub const NANOS_FIELD_NUMBER: i32 = 2;
        pub const NANOS_DEFAULT_VALUE: i32 = 0;
        pub fn nanos(&self) -> &i32 {
            &self.nanos
        }
        pub fn nanos_mut(&mut self) -> &mut i32 {
            &mut self.nanos
        }
    }
    pub(in super::super) mod timestamp {
        pub(in super::super) static SECONDS_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Timestamp,
            i64,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Timestamp::seconds,
            get_mut: self::super::Timestamp::seconds_mut,
        };
        pub(in super::super) static NANOS_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Timestamp,
            i32,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Timestamp::nanos,
            get_mut: self::super::Timestamp::nanos_mut,
        };
    }
}
static GOOGLE_PROTOBUF_TYPE_PROTO_BINARY: &'static [u8] = &[
    10, 26, 103, 111, 111, 103, 108, 101, 47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 116, 121,
    112, 101, 46, 112, 114, 111, 116, 111, 18, 15, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111,
    116, 111, 98, 117, 102, 26, 25, 103, 111, 111, 103, 108, 101, 47, 112, 114, 111, 116, 111, 98,
    117, 102, 47, 97, 110, 121, 46, 112, 114, 111, 116, 111, 26, 36, 103, 111, 111, 103, 108, 101,
    47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 115, 111, 117, 114, 99, 101, 95, 99, 111, 110,
    116, 101, 120, 116, 46, 112, 114, 111, 116, 111, 34, 141, 2, 10, 4, 84, 121, 112, 101, 18, 18,
    10, 4, 110, 97, 109, 101, 24, 1, 32, 1, 40, 9, 82, 4, 110, 97, 109, 101, 18, 46, 10, 6, 102,
    105, 101, 108, 100, 115, 24, 2, 32, 3, 40, 11, 50, 22, 46, 103, 111, 111, 103, 108, 101, 46,
    112, 114, 111, 116, 111, 98, 117, 102, 46, 70, 105, 101, 108, 100, 82, 6, 102, 105, 101, 108,
    100, 115, 18, 22, 10, 6, 111, 110, 101, 111, 102, 115, 24, 3, 32, 3, 40, 9, 82, 6, 111, 110,
    101, 111, 102, 115, 18, 49, 10, 7, 111, 112, 116, 105, 111, 110, 115, 24, 4, 32, 3, 40, 11, 50,
    23, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 79, 112,
    116, 105, 111, 110, 82, 7, 111, 112, 116, 105, 111, 110, 115, 18, 69, 10, 14, 115, 111, 117,
    114, 99, 101, 95, 99, 111, 110, 116, 101, 120, 116, 24, 5, 32, 1, 40, 11, 50, 30, 46, 103, 111,
    111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 83, 111, 117, 114, 99, 101,
    67, 111, 110, 116, 101, 120, 116, 82, 13, 115, 111, 117, 114, 99, 101, 67, 111, 110, 116, 101,
    120, 116, 18, 47, 10, 6, 115, 121, 110, 116, 97, 120, 24, 6, 32, 1, 40, 14, 50, 23, 46, 103,
    111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 83, 121, 110, 116, 97,
    120, 82, 6, 115, 121, 110, 116, 97, 120, 34, 180, 6, 10, 5, 70, 105, 101, 108, 100, 18, 47, 10,
    4, 107, 105, 110, 100, 24, 1, 32, 1, 40, 14, 50, 27, 46, 103, 111, 111, 103, 108, 101, 46, 112,
    114, 111, 116, 111, 98, 117, 102, 46, 70, 105, 101, 108, 100, 46, 75, 105, 110, 100, 82, 4,
    107, 105, 110, 100, 18, 68, 10, 11, 99, 97, 114, 100, 105, 110, 97, 108, 105, 116, 121, 24, 2,
    32, 1, 40, 14, 50, 34, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117,
    102, 46, 70, 105, 101, 108, 100, 46, 67, 97, 114, 100, 105, 110, 97, 108, 105, 116, 121, 82,
    11, 99, 97, 114, 100, 105, 110, 97, 108, 105, 116, 121, 18, 22, 10, 6, 110, 117, 109, 98, 101,
    114, 24, 3, 32, 1, 40, 5, 82, 6, 110, 117, 109, 98, 101, 114, 18, 18, 10, 4, 110, 97, 109, 101,
    24, 4, 32, 1, 40, 9, 82, 4, 110, 97, 109, 101, 18, 25, 10, 8, 116, 121, 112, 101, 95, 117, 114,
    108, 24, 6, 32, 1, 40, 9, 82, 7, 116, 121, 112, 101, 85, 114, 108, 18, 31, 10, 11, 111, 110,
    101, 111, 102, 95, 105, 110, 100, 101, 120, 24, 7, 32, 1, 40, 5, 82, 10, 111, 110, 101, 111,
    102, 73, 110, 100, 101, 120, 18, 22, 10, 6, 112, 97, 99, 107, 101, 100, 24, 8, 32, 1, 40, 8,
    82, 6, 112, 97, 99, 107, 101, 100, 18, 49, 10, 7, 111, 112, 116, 105, 111, 110, 115, 24, 9, 32,
    3, 40, 11, 50, 23, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102,
    46, 79, 112, 116, 105, 111, 110, 82, 7, 111, 112, 116, 105, 111, 110, 115, 18, 27, 10, 9, 106,
    115, 111, 110, 95, 110, 97, 109, 101, 24, 10, 32, 1, 40, 9, 82, 8, 106, 115, 111, 110, 78, 97,
    109, 101, 18, 35, 10, 13, 100, 101, 102, 97, 117, 108, 116, 95, 118, 97, 108, 117, 101, 24, 11,
    32, 1, 40, 9, 82, 12, 100, 101, 102, 97, 117, 108, 116, 86, 97, 108, 117, 101, 34, 200, 2, 10,
    4, 75, 105, 110, 100, 18, 16, 10, 12, 84, 89, 80, 69, 95, 85, 78, 75, 78, 79, 87, 78, 16, 0,
    18, 15, 10, 11, 84, 89, 80, 69, 95, 68, 79, 85, 66, 76, 69, 16, 1, 18, 14, 10, 10, 84, 89, 80,
    69, 95, 70, 76, 79, 65, 84, 16, 2, 18, 14, 10, 10, 84, 89, 80, 69, 95, 73, 78, 84, 54, 52, 16,
    3, 18, 15, 10, 11, 84, 89, 80, 69, 95, 85, 73, 78, 84, 54, 52, 16, 4, 18, 14, 10, 10, 84, 89,
    80, 69, 95, 73, 78, 84, 51, 50, 16, 5, 18, 16, 10, 12, 84, 89, 80, 69, 95, 70, 73, 88, 69, 68,
    54, 52, 16, 6, 18, 16, 10, 12, 84, 89, 80, 69, 95, 70, 73, 88, 69, 68, 51, 50, 16, 7, 18, 13,
    10, 9, 84, 89, 80, 69, 95, 66, 79, 79, 76, 16, 8, 18, 15, 10, 11, 84, 89, 80, 69, 95, 83, 84,
    82, 73, 78, 71, 16, 9, 18, 14, 10, 10, 84, 89, 80, 69, 95, 71, 82, 79, 85, 80, 16, 10, 18, 16,
    10, 12, 84, 89, 80, 69, 95, 77, 69, 83, 83, 65, 71, 69, 16, 11, 18, 14, 10, 10, 84, 89, 80, 69,
    95, 66, 89, 84, 69, 83, 16, 12, 18, 15, 10, 11, 84, 89, 80, 69, 95, 85, 73, 78, 84, 51, 50, 16,
    13, 18, 13, 10, 9, 84, 89, 80, 69, 95, 69, 78, 85, 77, 16, 14, 18, 17, 10, 13, 84, 89, 80, 69,
    95, 83, 70, 73, 88, 69, 68, 51, 50, 16, 15, 18, 17, 10, 13, 84, 89, 80, 69, 95, 83, 70, 73, 88,
    69, 68, 54, 52, 16, 16, 18, 15, 10, 11, 84, 89, 80, 69, 95, 83, 73, 78, 84, 51, 50, 16, 17, 18,
    15, 10, 11, 84, 89, 80, 69, 95, 83, 73, 78, 84, 54, 52, 16, 18, 34, 116, 10, 11, 67, 97, 114,
    100, 105, 110, 97, 108, 105, 116, 121, 18, 23, 10, 19, 67, 65, 82, 68, 73, 78, 65, 76, 73, 84,
    89, 95, 85, 78, 75, 78, 79, 87, 78, 16, 0, 18, 24, 10, 20, 67, 65, 82, 68, 73, 78, 65, 76, 73,
    84, 89, 95, 79, 80, 84, 73, 79, 78, 65, 76, 16, 1, 18, 24, 10, 20, 67, 65, 82, 68, 73, 78, 65,
    76, 73, 84, 89, 95, 82, 69, 81, 85, 73, 82, 69, 68, 16, 2, 18, 24, 10, 20, 67, 65, 82, 68, 73,
    78, 65, 76, 73, 84, 89, 95, 82, 69, 80, 69, 65, 84, 69, 68, 16, 3, 34, 255, 1, 10, 4, 69, 110,
    117, 109, 18, 18, 10, 4, 110, 97, 109, 101, 24, 1, 32, 1, 40, 9, 82, 4, 110, 97, 109, 101, 18,
    56, 10, 9, 101, 110, 117, 109, 118, 97, 108, 117, 101, 24, 2, 32, 3, 40, 11, 50, 26, 46, 103,
    111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 69, 110, 117, 109, 86,
    97, 108, 117, 101, 82, 9, 101, 110, 117, 109, 118, 97, 108, 117, 101, 18, 49, 10, 7, 111, 112,
    116, 105, 111, 110, 115, 24, 3, 32, 3, 40, 11, 50, 23, 46, 103, 111, 111, 103, 108, 101, 46,
    112, 114, 111, 116, 111, 98, 117, 102, 46, 79, 112, 116, 105, 111, 110, 82, 7, 111, 112, 116,
    105, 111, 110, 115, 18, 69, 10, 14, 115, 111, 117, 114, 99, 101, 95, 99, 111, 110, 116, 101,
    120, 116, 24, 4, 32, 1, 40, 11, 50, 30, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111,
    116, 111, 98, 117, 102, 46, 83, 111, 117, 114, 99, 101, 67, 111, 110, 116, 101, 120, 116, 82,
    13, 115, 111, 117, 114, 99, 101, 67, 111, 110, 116, 101, 120, 116, 18, 47, 10, 6, 115, 121,
    110, 116, 97, 120, 24, 5, 32, 1, 40, 14, 50, 23, 46, 103, 111, 111, 103, 108, 101, 46, 112,
    114, 111, 116, 111, 98, 117, 102, 46, 83, 121, 110, 116, 97, 120, 82, 6, 115, 121, 110, 116,
    97, 120, 34, 106, 10, 9, 69, 110, 117, 109, 86, 97, 108, 117, 101, 18, 18, 10, 4, 110, 97, 109,
    101, 24, 1, 32, 1, 40, 9, 82, 4, 110, 97, 109, 101, 18, 22, 10, 6, 110, 117, 109, 98, 101, 114,
    24, 2, 32, 1, 40, 5, 82, 6, 110, 117, 109, 98, 101, 114, 18, 49, 10, 7, 111, 112, 116, 105,
    111, 110, 115, 24, 3, 32, 3, 40, 11, 50, 23, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114,
    111, 116, 111, 98, 117, 102, 46, 79, 112, 116, 105, 111, 110, 82, 7, 111, 112, 116, 105, 111,
    110, 115, 34, 72, 10, 6, 79, 112, 116, 105, 111, 110, 18, 18, 10, 4, 110, 97, 109, 101, 24, 1,
    32, 1, 40, 9, 82, 4, 110, 97, 109, 101, 18, 42, 10, 5, 118, 97, 108, 117, 101, 24, 2, 32, 1,
    40, 11, 50, 20, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102,
    46, 65, 110, 121, 82, 5, 118, 97, 108, 117, 101, 42, 46, 10, 6, 83, 121, 110, 116, 97, 120, 18,
    17, 10, 13, 83, 89, 78, 84, 65, 88, 95, 80, 82, 79, 84, 79, 50, 16, 0, 18, 17, 10, 13, 83, 89,
    78, 84, 65, 88, 95, 80, 82, 79, 84, 79, 51, 16, 1, 66, 125, 10, 19, 99, 111, 109, 46, 103, 111,
    111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 66, 9, 84, 121, 112, 101, 80,
    114, 111, 116, 111, 80, 1, 90, 47, 103, 111, 111, 103, 108, 101, 46, 103, 111, 108, 97, 110,
    103, 46, 111, 114, 103, 47, 103, 101, 110, 112, 114, 111, 116, 111, 47, 112, 114, 111, 116,
    111, 98, 117, 102, 47, 112, 116, 121, 112, 101, 59, 112, 116, 121, 112, 101, 248, 1, 1, 162, 2,
    3, 71, 80, 66, 170, 2, 30, 71, 111, 111, 103, 108, 101, 46, 80, 114, 111, 116, 111, 98, 117,
    102, 46, 87, 101, 108, 108, 75, 110, 111, 119, 110, 84, 121, 112, 101, 115, 98, 6, 112, 114,
    111, 116, 111, 51,
];
pub mod google_protobuf_type_proto {
    pub fn file() -> &'static crate::reflect::FileDescriptor<'static> {
        super::pool()
            .find_file_by_name("google/protobuf/type.proto")
            .unwrap()
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct Type {
        name: ::std::string::String,
        fields: crate::collections::RepeatedField<self::Field>,
        oneofs: crate::collections::RepeatedField<::std::string::String>,
        options: crate::collections::RepeatedField<self::Option>,
        source_context: ::std::option::Option<
            ::std::boxed::Box<self::super::google_protobuf_source_context_proto::SourceContext>,
        >,
        syntax: crate::EnumValue<self::Syntax>,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::Type {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => *self.name_mut() = input.read_string()?,
                    18 => self
                        .fields
                        .add_entries(input, &self::r#type::FIELDS_CODEC)?,
                    26 => self
                        .oneofs
                        .add_entries(input, &self::r#type::ONEOFS_CODEC)?,
                    34 => self
                        .options
                        .add_entries(input, &self::r#type::OPTIONS_CODEC)?,
                    42 => input.read_message(self.source_context_mut())?,
                    48 | 50 => *self.syntax_mut() = input.read_enum_value()?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if **self.name() != *Self::NAME_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(self.name())?)?;
            }
            size = size.checked_add(self.fields().calculate_size(&self::r#type::FIELDS_CODEC)?)?;
            size = size.checked_add(self.oneofs().calculate_size(&self::r#type::ONEOFS_CODEC)?)?;
            size = size.checked_add(
                self.options()
                    .calculate_size(&self::r#type::OPTIONS_CODEC)?,
            )?;
            if let ::std::option::Option::Some(source_context) = self.source_context() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::message(source_context)?)?;
            }
            if *self.syntax() != Self::SYNTAX_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::enum_value(*self.syntax()))?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if **self.name() != *Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(self.name())?;
            }
            self.fields()
                .write_to(output, &self::r#type::FIELDS_CODEC)?;
            self.oneofs()
                .write_to(output, &self::r#type::ONEOFS_CODEC)?;
            self.options()
                .write_to(output, &self::r#type::OPTIONS_CODEC)?;
            if let ::std::option::Option::Some(source_context) = self.source_context() {
                output.write_raw_tag_bytes(&[42])?;
                output.write_message(source_context)?;
            }
            if *self.syntax() != Self::SYNTAX_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[48])?;
                output.write_enum_value(*self.syntax())?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.fields.is_initialized() {
                return false;
            }
            if !self.options.is_initialized() {
                return false;
            }
            if let ::std::option::Option::Some(source_context) = self.source_context() {
                if !crate::CodedMessage::is_initialized(source_context) {
                    return false;
                }
            }
            true
        }
    }
    impl crate::LiteMessage for self::Type {
        fn merge(&mut self, other: &Self) {
            if other.name.len() != 0 {
                *self.name_mut() = ::std::clone::Clone::clone(other.name());
            }
            self.fields.merge(&other.fields);
            self.oneofs.merge(&other.oneofs);
            self.options.merge(&other.options);
            if let ::std::option::Option::Some(source_context) = &other.source_context() {
                crate::LiteMessage::merge(self.source_context_mut(), source_context);
            }
            if *other.syntax() != Self::SYNTAX_DEFAULT_VALUE {
                *self.syntax_mut() = *other.syntax();
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::Type {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[0]
        }
    }
    impl self::Type {
        pub const NAME_FIELD_NUMBER: i32 = 1;
        pub const NAME_DEFAULT_VALUE: &'static str = "";
        pub fn name(&self) -> &::std::string::String {
            &self.name
        }
        pub fn name_mut(&mut self) -> &mut ::std::string::String {
            &mut self.name
        }
        pub const FIELDS_FIELD_NUMBER: i32 = 2;
        pub fn fields(&self) -> &crate::collections::RepeatedField<self::Field> {
            &self.fields
        }
        pub fn fields_mut(&mut self) -> &mut crate::collections::RepeatedField<self::Field> {
            &mut self.fields
        }
        pub const ONEOFS_FIELD_NUMBER: i32 = 3;
        pub fn oneofs(&self) -> &crate::collections::RepeatedField<::std::string::String> {
            &self.oneofs
        }
        pub fn oneofs_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<::std::string::String> {
            &mut self.oneofs
        }
        pub const OPTIONS_FIELD_NUMBER: i32 = 4;
        pub fn options(&self) -> &crate::collections::RepeatedField<self::Option> {
            &self.options
        }
        pub fn options_mut(&mut self) -> &mut crate::collections::RepeatedField<self::Option> {
            &mut self.options
        }
        pub const SOURCE_CONTEXT_FIELD_NUMBER: i32 = 5;
        pub fn source_context(
            &self,
        ) -> ::std::option::Option<&self::super::google_protobuf_source_context_proto::SourceContext>
        {
            self.source_context.as_ref().map(|v| &**v)
        }
        pub fn source_context_mut(
            &mut self,
        ) -> &mut self::super::google_protobuf_source_context_proto::SourceContext {
            self.source_context
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_source_context(&self) -> bool {
            self.source_context.is_some()
        }
        pub fn set_source_context(
            &mut self,
            value: self::super::google_protobuf_source_context_proto::SourceContext,
        ) {
            self.source_context = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_source_context(
            &mut self,
        ) -> ::std::option::Option<self::super::google_protobuf_source_context_proto::SourceContext>
        {
            self.source_context.take().map(|v| *v)
        }
        pub fn clear_source_context(&mut self) {
            self.source_context = ::std::option::Option::None;
        }
        pub const SYNTAX_FIELD_NUMBER: i32 = 6;
        pub const SYNTAX_DEFAULT_VALUE: crate::EnumValue<self::Syntax> =
            crate::EnumValue::Defined(self::Syntax::Proto2);
        pub fn syntax(&self) -> &crate::EnumValue<self::Syntax> {
            &self.syntax
        }
        pub fn syntax_mut(&mut self) -> &mut crate::EnumValue<self::Syntax> {
            &mut self.syntax
        }
    }
    pub(in super::super) mod r#type {
        pub(super) static FIELDS_CODEC: crate::Codec<self::super::Field> =
            crate::Codec::message(18);
        pub(super) static ONEOFS_CODEC: crate::Codec<::std::string::String> =
            crate::Codec::string(26);
        pub(super) static OPTIONS_CODEC: crate::Codec<self::super::Option> =
            crate::Codec::message(34);
        pub(in super::super) static NAME_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Type,
            ::std::string::String,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Type::name,
            get_mut: self::super::Type::name_mut,
        };
        pub(in super::super) static FIELDS_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Type,
            crate::collections::RepeatedField<self::super::Field>,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Type::fields,
            get_mut: self::super::Type::fields_mut,
        };
        pub(in super::super) static ONEOFS_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Type,
            crate::collections::RepeatedField<::std::string::String>,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Type::oneofs,
            get_mut: self::super::Type::oneofs_mut,
        };
        pub(in super::super) static OPTIONS_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Type,
            crate::collections::RepeatedField<self::super::Option>,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Type::options,
            get_mut: self::super::Type::options_mut,
        };
        pub(in super::super) static SOURCE_CONTEXT_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::Type,
                self::super::super::google_protobuf_source_context_proto::SourceContext,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::Type::source_context,
            get_mut: self::super::Type::source_context_mut,
            set: self::super::Type::set_source_context,
            take: self::super::Type::take_source_context,
            clear: self::super::Type::clear_source_context,
        };
        pub(in super::super) static SYNTAX_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Type,
            crate::EnumValue<self::super::Syntax>,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Type::syntax,
            get_mut: self::super::Type::syntax_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct Field {
        kind: crate::EnumValue<self::field::Kind>,
        cardinality: crate::EnumValue<self::field::Cardinality>,
        number: i32,
        name: ::std::string::String,
        type_url: ::std::string::String,
        oneof_index: i32,
        packed: bool,
        options: crate::collections::RepeatedField<self::Option>,
        json_name: ::std::string::String,
        default_value: ::std::string::String,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::Field {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => *self.kind_mut() = input.read_enum_value()?,
                    16 | 18 => *self.cardinality_mut() = input.read_enum_value()?,
                    24 | 26 => *self.number_mut() = input.read_int32()?,
                    34 => *self.name_mut() = input.read_string()?,
                    50 => *self.type_url_mut() = input.read_string()?,
                    56 | 58 => *self.oneof_index_mut() = input.read_int32()?,
                    64 | 66 => *self.packed_mut() = input.read_bool()?,
                    74 => self
                        .options
                        .add_entries(input, &self::field::OPTIONS_CODEC)?,
                    82 => *self.json_name_mut() = input.read_string()?,
                    90 => *self.default_value_mut() = input.read_string()?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if *self.kind() != Self::KIND_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::enum_value(*self.kind()))?;
            }
            if *self.cardinality() != Self::CARDINALITY_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::enum_value(*self.cardinality()))?;
            }
            if *self.number() != Self::NUMBER_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::int32(*self.number()))?;
            }
            if **self.name() != *Self::NAME_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(self.name())?)?;
            }
            if **self.type_url() != *Self::TYPE_URL_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(self.type_url())?)?;
            }
            if *self.oneof_index() != Self::ONEOF_INDEX_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::int32(*self.oneof_index()))?;
            }
            if *self.packed() != Self::PACKED_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(*self.packed()))?;
            }
            size = size.checked_add(self.options().calculate_size(&self::field::OPTIONS_CODEC)?)?;
            if **self.json_name() != *Self::JSON_NAME_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(self.json_name())?)?;
            }
            if **self.default_value() != *Self::DEFAULT_VALUE_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(self.default_value())?)?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if *self.kind() != Self::KIND_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_enum_value(*self.kind())?;
            }
            if *self.cardinality() != Self::CARDINALITY_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_enum_value(*self.cardinality())?;
            }
            if *self.number() != Self::NUMBER_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[24])?;
                output.write_int32(*self.number())?;
            }
            if **self.name() != *Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[34])?;
                output.write_string(self.name())?;
            }
            if **self.type_url() != *Self::TYPE_URL_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[50])?;
                output.write_string(self.type_url())?;
            }
            if *self.oneof_index() != Self::ONEOF_INDEX_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[56])?;
                output.write_int32(*self.oneof_index())?;
            }
            if *self.packed() != Self::PACKED_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[64])?;
                output.write_bool(*self.packed())?;
            }
            self.options()
                .write_to(output, &self::field::OPTIONS_CODEC)?;
            if **self.json_name() != *Self::JSON_NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[82])?;
                output.write_string(self.json_name())?;
            }
            if **self.default_value() != *Self::DEFAULT_VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[90])?;
                output.write_string(self.default_value())?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.options.is_initialized() {
                return false;
            }
            true
        }
    }
    impl crate::LiteMessage for self::Field {
        fn merge(&mut self, other: &Self) {
            if *other.kind() != Self::KIND_DEFAULT_VALUE {
                *self.kind_mut() = *other.kind();
            }
            if *other.cardinality() != Self::CARDINALITY_DEFAULT_VALUE {
                *self.cardinality_mut() = *other.cardinality();
            }
            if *other.number() != Self::NUMBER_DEFAULT_VALUE {
                *self.number_mut() = *other.number();
            }
            if other.name.len() != 0 {
                *self.name_mut() = ::std::clone::Clone::clone(other.name());
            }
            if other.type_url.len() != 0 {
                *self.type_url_mut() = ::std::clone::Clone::clone(other.type_url());
            }
            if *other.oneof_index() != Self::ONEOF_INDEX_DEFAULT_VALUE {
                *self.oneof_index_mut() = *other.oneof_index();
            }
            if *other.packed() != Self::PACKED_DEFAULT_VALUE {
                *self.packed_mut() = *other.packed();
            }
            self.options.merge(&other.options);
            if other.json_name.len() != 0 {
                *self.json_name_mut() = ::std::clone::Clone::clone(other.json_name());
            }
            if other.default_value.len() != 0 {
                *self.default_value_mut() = ::std::clone::Clone::clone(other.default_value());
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::Field {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[1]
        }
    }
    impl self::Field {
        pub const KIND_FIELD_NUMBER: i32 = 1;
        pub const KIND_DEFAULT_VALUE: crate::EnumValue<self::field::Kind> =
            crate::EnumValue::Defined(self::field::Kind::TypeUnknown);
        pub fn kind(&self) -> &crate::EnumValue<self::field::Kind> {
            &self.kind
        }
        pub fn kind_mut(&mut self) -> &mut crate::EnumValue<self::field::Kind> {
            &mut self.kind
        }
        pub const CARDINALITY_FIELD_NUMBER: i32 = 2;
        pub const CARDINALITY_DEFAULT_VALUE: crate::EnumValue<self::field::Cardinality> =
            crate::EnumValue::Defined(self::field::Cardinality::Unknown);
        pub fn cardinality(&self) -> &crate::EnumValue<self::field::Cardinality> {
            &self.cardinality
        }
        pub fn cardinality_mut(&mut self) -> &mut crate::EnumValue<self::field::Cardinality> {
            &mut self.cardinality
        }
        pub const NUMBER_FIELD_NUMBER: i32 = 3;
        pub const NUMBER_DEFAULT_VALUE: i32 = 0;
        pub fn number(&self) -> &i32 {
            &self.number
        }
        pub fn number_mut(&mut self) -> &mut i32 {
            &mut self.number
        }
        pub const NAME_FIELD_NUMBER: i32 = 4;
        pub const NAME_DEFAULT_VALUE: &'static str = "";
        pub fn name(&self) -> &::std::string::String {
            &self.name
        }
        pub fn name_mut(&mut self) -> &mut ::std::string::String {
            &mut self.name
        }
        pub const TYPE_URL_FIELD_NUMBER: i32 = 6;
        pub const TYPE_URL_DEFAULT_VALUE: &'static str = "";
        pub fn type_url(&self) -> &::std::string::String {
            &self.type_url
        }
        pub fn type_url_mut(&mut self) -> &mut ::std::string::String {
            &mut self.type_url
        }
        pub const ONEOF_INDEX_FIELD_NUMBER: i32 = 7;
        pub const ONEOF_INDEX_DEFAULT_VALUE: i32 = 0;
        pub fn oneof_index(&self) -> &i32 {
            &self.oneof_index
        }
        pub fn oneof_index_mut(&mut self) -> &mut i32 {
            &mut self.oneof_index
        }
        pub const PACKED_FIELD_NUMBER: i32 = 8;
        pub const PACKED_DEFAULT_VALUE: bool = false;
        pub fn packed(&self) -> &bool {
            &self.packed
        }
        pub fn packed_mut(&mut self) -> &mut bool {
            &mut self.packed
        }
        pub const OPTIONS_FIELD_NUMBER: i32 = 9;
        pub fn options(&self) -> &crate::collections::RepeatedField<self::Option> {
            &self.options
        }
        pub fn options_mut(&mut self) -> &mut crate::collections::RepeatedField<self::Option> {
            &mut self.options
        }
        pub const JSON_NAME_FIELD_NUMBER: i32 = 10;
        pub const JSON_NAME_DEFAULT_VALUE: &'static str = "";
        pub fn json_name(&self) -> &::std::string::String {
            &self.json_name
        }
        pub fn json_name_mut(&mut self) -> &mut ::std::string::String {
            &mut self.json_name
        }
        pub const DEFAULT_VALUE_FIELD_NUMBER: i32 = 11;
        pub const DEFAULT_VALUE_DEFAULT_VALUE: &'static str = "";
        pub fn default_value(&self) -> &::std::string::String {
            &self.default_value
        }
        pub fn default_value_mut(&mut self) -> &mut ::std::string::String {
            &mut self.default_value
        }
    }
    pub mod field {
        #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
        pub enum Kind {
            TypeUnknown,
            TypeDouble,
            TypeFloat,
            TypeInt64,
            TypeUint64,
            TypeInt32,
            TypeFixed64,
            TypeFixed32,
            TypeBool,
            TypeString,
            TypeGroup,
            TypeMessage,
            TypeBytes,
            TypeUint32,
            TypeEnum,
            TypeSfixed32,
            TypeSfixed64,
            TypeSint32,
            TypeSint64,
        }
        impl crate::Enum for self::Kind {
            fn descriptor() -> &'static crate::reflect::EnumDescriptor<'static> {
                &<self::super::Field as crate::Message>::descriptor().enums()[0]
            }
        }
        impl ::std::convert::TryFrom<i32> for self::Kind {
            type Error = crate::VariantUndefinedError;
            fn try_from(value: i32) -> ::std::result::Result<Self, crate::VariantUndefinedError> {
                #[allow(unreachable_patterns)]
                match value {
                    0 => ::std::result::Result::Ok(self::Kind::TypeUnknown),
                    1 => ::std::result::Result::Ok(self::Kind::TypeDouble),
                    2 => ::std::result::Result::Ok(self::Kind::TypeFloat),
                    3 => ::std::result::Result::Ok(self::Kind::TypeInt64),
                    4 => ::std::result::Result::Ok(self::Kind::TypeUint64),
                    5 => ::std::result::Result::Ok(self::Kind::TypeInt32),
                    6 => ::std::result::Result::Ok(self::Kind::TypeFixed64),
                    7 => ::std::result::Result::Ok(self::Kind::TypeFixed32),
                    8 => ::std::result::Result::Ok(self::Kind::TypeBool),
                    9 => ::std::result::Result::Ok(self::Kind::TypeString),
                    10 => ::std::result::Result::Ok(self::Kind::TypeGroup),
                    11 => ::std::result::Result::Ok(self::Kind::TypeMessage),
                    12 => ::std::result::Result::Ok(self::Kind::TypeBytes),
                    13 => ::std::result::Result::Ok(self::Kind::TypeUint32),
                    14 => ::std::result::Result::Ok(self::Kind::TypeEnum),
                    15 => ::std::result::Result::Ok(self::Kind::TypeSfixed32),
                    16 => ::std::result::Result::Ok(self::Kind::TypeSfixed64),
                    17 => ::std::result::Result::Ok(self::Kind::TypeSint32),
                    18 => ::std::result::Result::Ok(self::Kind::TypeSint64),
                    _ => ::std::result::Result::Err(crate::VariantUndefinedError),
                }
            }
        }
        impl ::std::convert::From<self::Kind> for i32 {
            fn from(value: self::Kind) -> i32 {
                match value {
                    self::Kind::TypeUnknown => 0,
                    self::Kind::TypeDouble => 1,
                    self::Kind::TypeFloat => 2,
                    self::Kind::TypeInt64 => 3,
                    self::Kind::TypeUint64 => 4,
                    self::Kind::TypeInt32 => 5,
                    self::Kind::TypeFixed64 => 6,
                    self::Kind::TypeFixed32 => 7,
                    self::Kind::TypeBool => 8,
                    self::Kind::TypeString => 9,
                    self::Kind::TypeGroup => 10,
                    self::Kind::TypeMessage => 11,
                    self::Kind::TypeBytes => 12,
                    self::Kind::TypeUint32 => 13,
                    self::Kind::TypeEnum => 14,
                    self::Kind::TypeSfixed32 => 15,
                    self::Kind::TypeSfixed64 => 16,
                    self::Kind::TypeSint32 => 17,
                    self::Kind::TypeSint64 => 18,
                }
            }
        }
        #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
        pub enum Cardinality {
            Unknown,
            Optional,
            Required,
            Repeated,
        }
        impl crate::Enum for self::Cardinality {
            fn descriptor() -> &'static crate::reflect::EnumDescriptor<'static> {
                &<self::super::Field as crate::Message>::descriptor().enums()[1]
            }
        }
        impl ::std::convert::TryFrom<i32> for self::Cardinality {
            type Error = crate::VariantUndefinedError;
            fn try_from(value: i32) -> ::std::result::Result<Self, crate::VariantUndefinedError> {
                #[allow(unreachable_patterns)]
                match value {
                    0 => ::std::result::Result::Ok(self::Cardinality::Unknown),
                    1 => ::std::result::Result::Ok(self::Cardinality::Optional),
                    2 => ::std::result::Result::Ok(self::Cardinality::Required),
                    3 => ::std::result::Result::Ok(self::Cardinality::Repeated),
                    _ => ::std::result::Result::Err(crate::VariantUndefinedError),
                }
            }
        }
        impl ::std::convert::From<self::Cardinality> for i32 {
            fn from(value: self::Cardinality) -> i32 {
                match value {
                    self::Cardinality::Unknown => 0,
                    self::Cardinality::Optional => 1,
                    self::Cardinality::Required => 2,
                    self::Cardinality::Repeated => 3,
                }
            }
        }
        pub(super) static OPTIONS_CODEC: crate::Codec<self::super::Option> =
            crate::Codec::message(74);
        pub(in super::super) static KIND_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Field,
            crate::EnumValue<self::Kind>,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Field::kind,
            get_mut: self::super::Field::kind_mut,
        };
        pub(in super::super) static CARDINALITY_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::Field,
                crate::EnumValue<self::Cardinality>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Field::cardinality,
            get_mut: self::super::Field::cardinality_mut,
        };
        pub(in super::super) static NUMBER_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Field,
            i32,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Field::number,
            get_mut: self::super::Field::number_mut,
        };
        pub(in super::super) static NAME_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Field,
            ::std::string::String,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Field::name,
            get_mut: self::super::Field::name_mut,
        };
        pub(in super::super) static TYPE_URL_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<self::super::Field, ::std::string::String> =
            crate::reflect::access::SimpleFieldAccessor {
                get: self::super::Field::type_url,
                get_mut: self::super::Field::type_url_mut,
            };
        pub(in super::super) static ONEOF_INDEX_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<self::super::Field, i32> =
            crate::reflect::access::SimpleFieldAccessor {
                get: self::super::Field::oneof_index,
                get_mut: self::super::Field::oneof_index_mut,
            };
        pub(in super::super) static PACKED_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Field,
            bool,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Field::packed,
            get_mut: self::super::Field::packed_mut,
        };
        pub(in super::super) static OPTIONS_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Field,
            crate::collections::RepeatedField<self::super::Option>,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Field::options,
            get_mut: self::super::Field::options_mut,
        };
        pub(in super::super) static JSON_NAME_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<self::super::Field, ::std::string::String> =
            crate::reflect::access::SimpleFieldAccessor {
                get: self::super::Field::json_name,
                get_mut: self::super::Field::json_name_mut,
            };
        pub(in super::super) static DEFAULT_VALUE_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<self::super::Field, ::std::string::String> =
            crate::reflect::access::SimpleFieldAccessor {
                get: self::super::Field::default_value,
                get_mut: self::super::Field::default_value_mut,
            };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct Enum {
        name: ::std::string::String,
        enumvalue: crate::collections::RepeatedField<self::EnumValue>,
        options: crate::collections::RepeatedField<self::Option>,
        source_context: ::std::option::Option<
            ::std::boxed::Box<self::super::google_protobuf_source_context_proto::SourceContext>,
        >,
        syntax: crate::EnumValue<self::Syntax>,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::Enum {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => *self.name_mut() = input.read_string()?,
                    18 => self
                        .enumvalue
                        .add_entries(input, &self::r#enum::ENUMVALUE_CODEC)?,
                    26 => self
                        .options
                        .add_entries(input, &self::r#enum::OPTIONS_CODEC)?,
                    34 => input.read_message(self.source_context_mut())?,
                    40 | 42 => *self.syntax_mut() = input.read_enum_value()?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if **self.name() != *Self::NAME_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(self.name())?)?;
            }
            size = size.checked_add(
                self.enumvalue()
                    .calculate_size(&self::r#enum::ENUMVALUE_CODEC)?,
            )?;
            size = size.checked_add(
                self.options()
                    .calculate_size(&self::r#enum::OPTIONS_CODEC)?,
            )?;
            if let ::std::option::Option::Some(source_context) = self.source_context() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::message(source_context)?)?;
            }
            if *self.syntax() != Self::SYNTAX_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::enum_value(*self.syntax()))?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if **self.name() != *Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(self.name())?;
            }
            self.enumvalue()
                .write_to(output, &self::r#enum::ENUMVALUE_CODEC)?;
            self.options()
                .write_to(output, &self::r#enum::OPTIONS_CODEC)?;
            if let ::std::option::Option::Some(source_context) = self.source_context() {
                output.write_raw_tag_bytes(&[34])?;
                output.write_message(source_context)?;
            }
            if *self.syntax() != Self::SYNTAX_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[40])?;
                output.write_enum_value(*self.syntax())?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.enumvalue.is_initialized() {
                return false;
            }
            if !self.options.is_initialized() {
                return false;
            }
            if let ::std::option::Option::Some(source_context) = self.source_context() {
                if !crate::CodedMessage::is_initialized(source_context) {
                    return false;
                }
            }
            true
        }
    }
    impl crate::LiteMessage for self::Enum {
        fn merge(&mut self, other: &Self) {
            if other.name.len() != 0 {
                *self.name_mut() = ::std::clone::Clone::clone(other.name());
            }
            self.enumvalue.merge(&other.enumvalue);
            self.options.merge(&other.options);
            if let ::std::option::Option::Some(source_context) = &other.source_context() {
                crate::LiteMessage::merge(self.source_context_mut(), source_context);
            }
            if *other.syntax() != Self::SYNTAX_DEFAULT_VALUE {
                *self.syntax_mut() = *other.syntax();
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::Enum {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[2]
        }
    }
    impl self::Enum {
        pub const NAME_FIELD_NUMBER: i32 = 1;
        pub const NAME_DEFAULT_VALUE: &'static str = "";
        pub fn name(&self) -> &::std::string::String {
            &self.name
        }
        pub fn name_mut(&mut self) -> &mut ::std::string::String {
            &mut self.name
        }
        pub const ENUMVALUE_FIELD_NUMBER: i32 = 2;
        pub fn enumvalue(&self) -> &crate::collections::RepeatedField<self::EnumValue> {
            &self.enumvalue
        }
        pub fn enumvalue_mut(&mut self) -> &mut crate::collections::RepeatedField<self::EnumValue> {
            &mut self.enumvalue
        }
        pub const OPTIONS_FIELD_NUMBER: i32 = 3;
        pub fn options(&self) -> &crate::collections::RepeatedField<self::Option> {
            &self.options
        }
        pub fn options_mut(&mut self) -> &mut crate::collections::RepeatedField<self::Option> {
            &mut self.options
        }
        pub const SOURCE_CONTEXT_FIELD_NUMBER: i32 = 4;
        pub fn source_context(
            &self,
        ) -> ::std::option::Option<&self::super::google_protobuf_source_context_proto::SourceContext>
        {
            self.source_context.as_ref().map(|v| &**v)
        }
        pub fn source_context_mut(
            &mut self,
        ) -> &mut self::super::google_protobuf_source_context_proto::SourceContext {
            self.source_context
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_source_context(&self) -> bool {
            self.source_context.is_some()
        }
        pub fn set_source_context(
            &mut self,
            value: self::super::google_protobuf_source_context_proto::SourceContext,
        ) {
            self.source_context = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_source_context(
            &mut self,
        ) -> ::std::option::Option<self::super::google_protobuf_source_context_proto::SourceContext>
        {
            self.source_context.take().map(|v| *v)
        }
        pub fn clear_source_context(&mut self) {
            self.source_context = ::std::option::Option::None;
        }
        pub const SYNTAX_FIELD_NUMBER: i32 = 5;
        pub const SYNTAX_DEFAULT_VALUE: crate::EnumValue<self::Syntax> =
            crate::EnumValue::Defined(self::Syntax::Proto2);
        pub fn syntax(&self) -> &crate::EnumValue<self::Syntax> {
            &self.syntax
        }
        pub fn syntax_mut(&mut self) -> &mut crate::EnumValue<self::Syntax> {
            &mut self.syntax
        }
    }
    pub(in super::super) mod r#enum {
        pub(super) static ENUMVALUE_CODEC: crate::Codec<self::super::EnumValue> =
            crate::Codec::message(18);
        pub(super) static OPTIONS_CODEC: crate::Codec<self::super::Option> =
            crate::Codec::message(26);
        pub(in super::super) static NAME_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Enum,
            ::std::string::String,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Enum::name,
            get_mut: self::super::Enum::name_mut,
        };
        pub(in super::super) static ENUMVALUE_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::Enum,
                crate::collections::RepeatedField<self::super::EnumValue>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Enum::enumvalue,
            get_mut: self::super::Enum::enumvalue_mut,
        };
        pub(in super::super) static OPTIONS_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Enum,
            crate::collections::RepeatedField<self::super::Option>,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Enum::options,
            get_mut: self::super::Enum::options_mut,
        };
        pub(in super::super) static SOURCE_CONTEXT_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::Enum,
                self::super::super::google_protobuf_source_context_proto::SourceContext,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::Enum::source_context,
            get_mut: self::super::Enum::source_context_mut,
            set: self::super::Enum::set_source_context,
            take: self::super::Enum::take_source_context,
            clear: self::super::Enum::clear_source_context,
        };
        pub(in super::super) static SYNTAX_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Enum,
            crate::EnumValue<self::super::Syntax>,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Enum::syntax,
            get_mut: self::super::Enum::syntax_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct EnumValue {
        name: ::std::string::String,
        number: i32,
        options: crate::collections::RepeatedField<self::Option>,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::EnumValue {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => *self.name_mut() = input.read_string()?,
                    16 | 18 => *self.number_mut() = input.read_int32()?,
                    26 => self
                        .options
                        .add_entries(input, &self::enum_value::OPTIONS_CODEC)?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if **self.name() != *Self::NAME_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(self.name())?)?;
            }
            if *self.number() != Self::NUMBER_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::int32(*self.number()))?;
            }
            size = size.checked_add(
                self.options()
                    .calculate_size(&self::enum_value::OPTIONS_CODEC)?,
            )?;
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if **self.name() != *Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(self.name())?;
            }
            if *self.number() != Self::NUMBER_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_int32(*self.number())?;
            }
            self.options()
                .write_to(output, &self::enum_value::OPTIONS_CODEC)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.options.is_initialized() {
                return false;
            }
            true
        }
    }
    impl crate::LiteMessage for self::EnumValue {
        fn merge(&mut self, other: &Self) {
            if other.name.len() != 0 {
                *self.name_mut() = ::std::clone::Clone::clone(other.name());
            }
            if *other.number() != Self::NUMBER_DEFAULT_VALUE {
                *self.number_mut() = *other.number();
            }
            self.options.merge(&other.options);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::EnumValue {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[3]
        }
    }
    impl self::EnumValue {
        pub const NAME_FIELD_NUMBER: i32 = 1;
        pub const NAME_DEFAULT_VALUE: &'static str = "";
        pub fn name(&self) -> &::std::string::String {
            &self.name
        }
        pub fn name_mut(&mut self) -> &mut ::std::string::String {
            &mut self.name
        }
        pub const NUMBER_FIELD_NUMBER: i32 = 2;
        pub const NUMBER_DEFAULT_VALUE: i32 = 0;
        pub fn number(&self) -> &i32 {
            &self.number
        }
        pub fn number_mut(&mut self) -> &mut i32 {
            &mut self.number
        }
        pub const OPTIONS_FIELD_NUMBER: i32 = 3;
        pub fn options(&self) -> &crate::collections::RepeatedField<self::Option> {
            &self.options
        }
        pub fn options_mut(&mut self) -> &mut crate::collections::RepeatedField<self::Option> {
            &mut self.options
        }
    }
    pub(in super::super) mod enum_value {
        pub(super) static OPTIONS_CODEC: crate::Codec<self::super::Option> =
            crate::Codec::message(26);
        pub(in super::super) static NAME_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::EnumValue,
            ::std::string::String,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::EnumValue::name,
            get_mut: self::super::EnumValue::name_mut,
        };
        pub(in super::super) static NUMBER_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::EnumValue,
            i32,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::EnumValue::number,
            get_mut: self::super::EnumValue::number_mut,
        };
        pub(in super::super) static OPTIONS_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::EnumValue,
            crate::collections::RepeatedField<self::super::Option>,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::EnumValue::options,
            get_mut: self::super::EnumValue::options_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct Option {
        name: ::std::string::String,
        value:
            ::std::option::Option<::std::boxed::Box<self::super::google_protobuf_any_proto::Any>>,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::Option {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => *self.name_mut() = input.read_string()?,
                    18 => input.read_message(self.value_mut())?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if **self.name() != *Self::NAME_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(self.name())?)?;
            }
            if let ::std::option::Option::Some(value) = self.value() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::message(value)?)?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if **self.name() != *Self::NAME_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(self.name())?;
            }
            if let ::std::option::Option::Some(value) = self.value() {
                output.write_raw_tag_bytes(&[18])?;
                output.write_message(value)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(value) = self.value() {
                if !crate::CodedMessage::is_initialized(value) {
                    return false;
                }
            }
            true
        }
    }
    impl crate::LiteMessage for self::Option {
        fn merge(&mut self, other: &Self) {
            if other.name.len() != 0 {
                *self.name_mut() = ::std::clone::Clone::clone(other.name());
            }
            if let ::std::option::Option::Some(value) = &other.value() {
                crate::LiteMessage::merge(self.value_mut(), value);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::Option {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[4]
        }
    }
    impl self::Option {
        pub const NAME_FIELD_NUMBER: i32 = 1;
        pub const NAME_DEFAULT_VALUE: &'static str = "";
        pub fn name(&self) -> &::std::string::String {
            &self.name
        }
        pub fn name_mut(&mut self) -> &mut ::std::string::String {
            &mut self.name
        }
        pub const VALUE_FIELD_NUMBER: i32 = 2;
        pub fn value(&self) -> ::std::option::Option<&self::super::google_protobuf_any_proto::Any> {
            self.value.as_ref().map(|v| &**v)
        }
        pub fn value_mut(&mut self) -> &mut self::super::google_protobuf_any_proto::Any {
            self.value
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }
        pub fn set_value(&mut self, value: self::super::google_protobuf_any_proto::Any) {
            self.value = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_value(
            &mut self,
        ) -> ::std::option::Option<self::super::google_protobuf_any_proto::Any> {
            self.value.take().map(|v| *v)
        }
        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod option {
        pub(in super::super) static NAME_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Option,
            ::std::string::String,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Option::name,
            get_mut: self::super::Option::name_mut,
        };
        pub(in super::super) static VALUE_REFLECTOR: crate::reflect::access::VerboseFieldAccessor<
            self::super::Option,
            self::super::super::google_protobuf_any_proto::Any,
        > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::Option::value,
            get_mut: self::super::Option::value_mut,
            set: self::super::Option::set_value,
            take: self::super::Option::take_value,
            clear: self::super::Option::clear_value,
        };
    }
    #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
    pub enum Syntax {
        Proto2,
        Proto3,
    }
    impl crate::Enum for self::Syntax {
        fn descriptor() -> &'static crate::reflect::EnumDescriptor<'static> {
            &self::file().enums()[0]
        }
    }
    impl ::std::convert::TryFrom<i32> for self::Syntax {
        type Error = crate::VariantUndefinedError;
        fn try_from(value: i32) -> ::std::result::Result<Self, crate::VariantUndefinedError> {
            #[allow(unreachable_patterns)]
            match value {
                0 => ::std::result::Result::Ok(self::Syntax::Proto2),
                1 => ::std::result::Result::Ok(self::Syntax::Proto3),
                _ => ::std::result::Result::Err(crate::VariantUndefinedError),
            }
        }
    }
    impl ::std::convert::From<self::Syntax> for i32 {
        fn from(value: self::Syntax) -> i32 {
            match value {
                self::Syntax::Proto2 => 0,
                self::Syntax::Proto3 => 1,
            }
        }
    }
}
static GOOGLE_PROTOBUF_WRAPPERS_PROTO_BINARY: &'static [u8] = &[
    10, 30, 103, 111, 111, 103, 108, 101, 47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 119, 114,
    97, 112, 112, 101, 114, 115, 46, 112, 114, 111, 116, 111, 18, 15, 103, 111, 111, 103, 108, 101,
    46, 112, 114, 111, 116, 111, 98, 117, 102, 34, 35, 10, 11, 68, 111, 117, 98, 108, 101, 86, 97,
    108, 117, 101, 18, 20, 10, 5, 118, 97, 108, 117, 101, 24, 1, 32, 1, 40, 1, 82, 5, 118, 97, 108,
    117, 101, 34, 34, 10, 10, 70, 108, 111, 97, 116, 86, 97, 108, 117, 101, 18, 20, 10, 5, 118, 97,
    108, 117, 101, 24, 1, 32, 1, 40, 2, 82, 5, 118, 97, 108, 117, 101, 34, 34, 10, 10, 73, 110,
    116, 54, 52, 86, 97, 108, 117, 101, 18, 20, 10, 5, 118, 97, 108, 117, 101, 24, 1, 32, 1, 40, 3,
    82, 5, 118, 97, 108, 117, 101, 34, 35, 10, 11, 85, 73, 110, 116, 54, 52, 86, 97, 108, 117, 101,
    18, 20, 10, 5, 118, 97, 108, 117, 101, 24, 1, 32, 1, 40, 4, 82, 5, 118, 97, 108, 117, 101, 34,
    34, 10, 10, 73, 110, 116, 51, 50, 86, 97, 108, 117, 101, 18, 20, 10, 5, 118, 97, 108, 117, 101,
    24, 1, 32, 1, 40, 5, 82, 5, 118, 97, 108, 117, 101, 34, 35, 10, 11, 85, 73, 110, 116, 51, 50,
    86, 97, 108, 117, 101, 18, 20, 10, 5, 118, 97, 108, 117, 101, 24, 1, 32, 1, 40, 13, 82, 5, 118,
    97, 108, 117, 101, 34, 33, 10, 9, 66, 111, 111, 108, 86, 97, 108, 117, 101, 18, 20, 10, 5, 118,
    97, 108, 117, 101, 24, 1, 32, 1, 40, 8, 82, 5, 118, 97, 108, 117, 101, 34, 35, 10, 11, 83, 116,
    114, 105, 110, 103, 86, 97, 108, 117, 101, 18, 20, 10, 5, 118, 97, 108, 117, 101, 24, 1, 32, 1,
    40, 9, 82, 5, 118, 97, 108, 117, 101, 34, 34, 10, 10, 66, 121, 116, 101, 115, 86, 97, 108, 117,
    101, 18, 20, 10, 5, 118, 97, 108, 117, 101, 24, 1, 32, 1, 40, 12, 82, 5, 118, 97, 108, 117,
    101, 66, 124, 10, 19, 99, 111, 109, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116,
    111, 98, 117, 102, 66, 13, 87, 114, 97, 112, 112, 101, 114, 115, 80, 114, 111, 116, 111, 80, 1,
    90, 42, 103, 105, 116, 104, 117, 98, 46, 99, 111, 109, 47, 103, 111, 108, 97, 110, 103, 47,
    112, 114, 111, 116, 111, 98, 117, 102, 47, 112, 116, 121, 112, 101, 115, 47, 119, 114, 97, 112,
    112, 101, 114, 115, 248, 1, 1, 162, 2, 3, 71, 80, 66, 170, 2, 30, 71, 111, 111, 103, 108, 101,
    46, 80, 114, 111, 116, 111, 98, 117, 102, 46, 87, 101, 108, 108, 75, 110, 111, 119, 110, 84,
    121, 112, 101, 115, 98, 6, 112, 114, 111, 116, 111, 51,
];
pub mod google_protobuf_wrappers_proto {
    pub fn file() -> &'static crate::reflect::FileDescriptor<'static> {
        super::pool()
            .find_file_by_name("google/protobuf/wrappers.proto")
            .unwrap()
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct DoubleValue {
        value: f64,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::DoubleValue {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    9 | 10 => *self.value_mut() = input.read_double()?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if *self.value() != Self::VALUE_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::double(*self.value()))?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if *self.value() != Self::VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[9])?;
                output.write_double(*self.value())?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl crate::LiteMessage for self::DoubleValue {
        fn merge(&mut self, other: &Self) {
            if *other.value() != Self::VALUE_DEFAULT_VALUE {
                *self.value_mut() = *other.value();
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::DoubleValue {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[0]
        }
    }
    impl self::DoubleValue {
        pub const VALUE_FIELD_NUMBER: i32 = 1;
        pub const VALUE_DEFAULT_VALUE: f64 = 0.0;
        pub fn value(&self) -> &f64 {
            &self.value
        }
        pub fn value_mut(&mut self) -> &mut f64 {
            &mut self.value
        }
    }
    pub(in super::super) mod double_value {
        pub(in super::super) static VALUE_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::DoubleValue,
            f64,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::DoubleValue::value,
            get_mut: self::super::DoubleValue::value_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct FloatValue {
        value: f32,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::FloatValue {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    13 | 10 => *self.value_mut() = input.read_float()?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if *self.value() != Self::VALUE_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::float(*self.value()))?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if *self.value() != Self::VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[13])?;
                output.write_float(*self.value())?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl crate::LiteMessage for self::FloatValue {
        fn merge(&mut self, other: &Self) {
            if *other.value() != Self::VALUE_DEFAULT_VALUE {
                *self.value_mut() = *other.value();
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::FloatValue {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[1]
        }
    }
    impl self::FloatValue {
        pub const VALUE_FIELD_NUMBER: i32 = 1;
        pub const VALUE_DEFAULT_VALUE: f32 = 0.0;
        pub fn value(&self) -> &f32 {
            &self.value
        }
        pub fn value_mut(&mut self) -> &mut f32 {
            &mut self.value
        }
    }
    pub(in super::super) mod float_value {
        pub(in super::super) static VALUE_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::FloatValue,
            f32,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::FloatValue::value,
            get_mut: self::super::FloatValue::value_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct Int64Value {
        value: i64,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::Int64Value {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => *self.value_mut() = input.read_int64()?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if *self.value() != Self::VALUE_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::int64(*self.value()))?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if *self.value() != Self::VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int64(*self.value())?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl crate::LiteMessage for self::Int64Value {
        fn merge(&mut self, other: &Self) {
            if *other.value() != Self::VALUE_DEFAULT_VALUE {
                *self.value_mut() = *other.value();
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::Int64Value {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[2]
        }
    }
    impl self::Int64Value {
        pub const VALUE_FIELD_NUMBER: i32 = 1;
        pub const VALUE_DEFAULT_VALUE: i64 = 0;
        pub fn value(&self) -> &i64 {
            &self.value
        }
        pub fn value_mut(&mut self) -> &mut i64 {
            &mut self.value
        }
    }
    pub(in super::super) mod int64_value {
        pub(in super::super) static VALUE_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Int64Value,
            i64,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Int64Value::value,
            get_mut: self::super::Int64Value::value_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct UInt64Value {
        value: u64,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::UInt64Value {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => *self.value_mut() = input.read_uint64()?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if *self.value() != Self::VALUE_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::uint64(*self.value()))?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if *self.value() != Self::VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_uint64(*self.value())?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl crate::LiteMessage for self::UInt64Value {
        fn merge(&mut self, other: &Self) {
            if *other.value() != Self::VALUE_DEFAULT_VALUE {
                *self.value_mut() = *other.value();
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::UInt64Value {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[3]
        }
    }
    impl self::UInt64Value {
        pub const VALUE_FIELD_NUMBER: i32 = 1;
        pub const VALUE_DEFAULT_VALUE: u64 = 0;
        pub fn value(&self) -> &u64 {
            &self.value
        }
        pub fn value_mut(&mut self) -> &mut u64 {
            &mut self.value
        }
    }
    pub(in super::super) mod u_int64_value {
        pub(in super::super) static VALUE_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::UInt64Value,
            u64,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::UInt64Value::value,
            get_mut: self::super::UInt64Value::value_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct Int32Value {
        value: i32,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::Int32Value {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => *self.value_mut() = input.read_int32()?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if *self.value() != Self::VALUE_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::int32(*self.value()))?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if *self.value() != Self::VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(*self.value())?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl crate::LiteMessage for self::Int32Value {
        fn merge(&mut self, other: &Self) {
            if *other.value() != Self::VALUE_DEFAULT_VALUE {
                *self.value_mut() = *other.value();
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::Int32Value {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[4]
        }
    }
    impl self::Int32Value {
        pub const VALUE_FIELD_NUMBER: i32 = 1;
        pub const VALUE_DEFAULT_VALUE: i32 = 0;
        pub fn value(&self) -> &i32 {
            &self.value
        }
        pub fn value_mut(&mut self) -> &mut i32 {
            &mut self.value
        }
    }
    pub(in super::super) mod int32_value {
        pub(in super::super) static VALUE_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::Int32Value,
            i32,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::Int32Value::value,
            get_mut: self::super::Int32Value::value_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct UInt32Value {
        value: u32,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::UInt32Value {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => *self.value_mut() = input.read_uint32()?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if *self.value() != Self::VALUE_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::uint32(*self.value()))?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if *self.value() != Self::VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_uint32(*self.value())?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl crate::LiteMessage for self::UInt32Value {
        fn merge(&mut self, other: &Self) {
            if *other.value() != Self::VALUE_DEFAULT_VALUE {
                *self.value_mut() = *other.value();
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::UInt32Value {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[5]
        }
    }
    impl self::UInt32Value {
        pub const VALUE_FIELD_NUMBER: i32 = 1;
        pub const VALUE_DEFAULT_VALUE: u32 = 0;
        pub fn value(&self) -> &u32 {
            &self.value
        }
        pub fn value_mut(&mut self) -> &mut u32 {
            &mut self.value
        }
    }
    pub(in super::super) mod u_int32_value {
        pub(in super::super) static VALUE_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::UInt32Value,
            u32,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::UInt32Value::value,
            get_mut: self::super::UInt32Value::value_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct BoolValue {
        value: bool,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::BoolValue {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => *self.value_mut() = input.read_bool()?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if *self.value() != Self::VALUE_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bool(*self.value()))?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if *self.value() != Self::VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_bool(*self.value())?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl crate::LiteMessage for self::BoolValue {
        fn merge(&mut self, other: &Self) {
            if *other.value() != Self::VALUE_DEFAULT_VALUE {
                *self.value_mut() = *other.value();
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::BoolValue {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[6]
        }
    }
    impl self::BoolValue {
        pub const VALUE_FIELD_NUMBER: i32 = 1;
        pub const VALUE_DEFAULT_VALUE: bool = false;
        pub fn value(&self) -> &bool {
            &self.value
        }
        pub fn value_mut(&mut self) -> &mut bool {
            &mut self.value
        }
    }
    pub(in super::super) mod bool_value {
        pub(in super::super) static VALUE_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::BoolValue,
            bool,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::BoolValue::value,
            get_mut: self::super::BoolValue::value_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct StringValue {
        value: ::std::string::String,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::StringValue {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => *self.value_mut() = input.read_string()?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if **self.value() != *Self::VALUE_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(self.value())?)?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if **self.value() != *Self::VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(self.value())?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl crate::LiteMessage for self::StringValue {
        fn merge(&mut self, other: &Self) {
            if other.value.len() != 0 {
                *self.value_mut() = ::std::clone::Clone::clone(other.value());
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::StringValue {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[7]
        }
    }
    impl self::StringValue {
        pub const VALUE_FIELD_NUMBER: i32 = 1;
        pub const VALUE_DEFAULT_VALUE: &'static str = "";
        pub fn value(&self) -> &::std::string::String {
            &self.value
        }
        pub fn value_mut(&mut self) -> &mut ::std::string::String {
            &mut self.value
        }
    }
    pub(in super::super) mod string_value {
        pub(in super::super) static VALUE_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::StringValue,
            ::std::string::String,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::StringValue::value,
            get_mut: self::super::StringValue::value_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct BytesValue {
        value: ::std::vec::Vec<u8>,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::BytesValue {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => *self.value_mut() = input.read_bytes()?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if **self.value() != *Self::VALUE_DEFAULT_VALUE {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::bytes(self.value())?)?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if **self.value() != *Self::VALUE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[10])?;
                output.write_bytes(self.value())?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl crate::LiteMessage for self::BytesValue {
        fn merge(&mut self, other: &Self) {
            if other.value.len() != 0 {
                *self.value_mut() = ::std::clone::Clone::clone(other.value());
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::BytesValue {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[8]
        }
    }
    impl self::BytesValue {
        pub const VALUE_FIELD_NUMBER: i32 = 1;
        pub const VALUE_DEFAULT_VALUE: &'static [u8] = &[];
        pub fn value(&self) -> &::std::vec::Vec<u8> {
            &self.value
        }
        pub fn value_mut(&mut self) -> &mut ::std::vec::Vec<u8> {
            &mut self.value
        }
    }
    pub(in super::super) mod bytes_value {
        pub(in super::super) static VALUE_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::BytesValue,
            ::std::vec::Vec<u8>,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::BytesValue::value,
            get_mut: self::super::BytesValue::value_mut,
        };
    }
}
static GOOGLE_PROTOBUF_COMPILER_PLUGIN_PROTO_BINARY: &'static [u8] = &[
    10, 37, 103, 111, 111, 103, 108, 101, 47, 112, 114, 111, 116, 111, 98, 117, 102, 47, 99, 111,
    109, 112, 105, 108, 101, 114, 47, 112, 108, 117, 103, 105, 110, 46, 112, 114, 111, 116, 111,
    18, 24, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 99, 111,
    109, 112, 105, 108, 101, 114, 26, 32, 103, 111, 111, 103, 108, 101, 47, 112, 114, 111, 116,
    111, 98, 117, 102, 47, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 46, 112, 114, 111, 116,
    111, 34, 99, 10, 7, 86, 101, 114, 115, 105, 111, 110, 18, 20, 10, 5, 109, 97, 106, 111, 114,
    24, 1, 32, 1, 40, 5, 82, 5, 109, 97, 106, 111, 114, 18, 20, 10, 5, 109, 105, 110, 111, 114, 24,
    2, 32, 1, 40, 5, 82, 5, 109, 105, 110, 111, 114, 18, 20, 10, 5, 112, 97, 116, 99, 104, 24, 3,
    32, 1, 40, 5, 82, 5, 112, 97, 116, 99, 104, 18, 22, 10, 6, 115, 117, 102, 102, 105, 120, 24, 4,
    32, 1, 40, 9, 82, 6, 115, 117, 102, 102, 105, 120, 34, 241, 1, 10, 20, 67, 111, 100, 101, 71,
    101, 110, 101, 114, 97, 116, 111, 114, 82, 101, 113, 117, 101, 115, 116, 18, 40, 10, 16, 102,
    105, 108, 101, 95, 116, 111, 95, 103, 101, 110, 101, 114, 97, 116, 101, 24, 1, 32, 3, 40, 9,
    82, 14, 102, 105, 108, 101, 84, 111, 71, 101, 110, 101, 114, 97, 116, 101, 18, 28, 10, 9, 112,
    97, 114, 97, 109, 101, 116, 101, 114, 24, 2, 32, 1, 40, 9, 82, 9, 112, 97, 114, 97, 109, 101,
    116, 101, 114, 18, 67, 10, 10, 112, 114, 111, 116, 111, 95, 102, 105, 108, 101, 24, 15, 32, 3,
    40, 11, 50, 36, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102,
    46, 70, 105, 108, 101, 68, 101, 115, 99, 114, 105, 112, 116, 111, 114, 80, 114, 111, 116, 111,
    82, 9, 112, 114, 111, 116, 111, 70, 105, 108, 101, 18, 76, 10, 16, 99, 111, 109, 112, 105, 108,
    101, 114, 95, 118, 101, 114, 115, 105, 111, 110, 24, 3, 32, 1, 40, 11, 50, 33, 46, 103, 111,
    111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 99, 111, 109, 112, 105, 108,
    101, 114, 46, 86, 101, 114, 115, 105, 111, 110, 82, 15, 99, 111, 109, 112, 105, 108, 101, 114,
    86, 101, 114, 115, 105, 111, 110, 34, 214, 1, 10, 21, 67, 111, 100, 101, 71, 101, 110, 101,
    114, 97, 116, 111, 114, 82, 101, 115, 112, 111, 110, 115, 101, 18, 20, 10, 5, 101, 114, 114,
    111, 114, 24, 1, 32, 1, 40, 9, 82, 5, 101, 114, 114, 111, 114, 18, 72, 10, 4, 102, 105, 108,
    101, 24, 15, 32, 3, 40, 11, 50, 52, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116,
    111, 98, 117, 102, 46, 99, 111, 109, 112, 105, 108, 101, 114, 46, 67, 111, 100, 101, 71, 101,
    110, 101, 114, 97, 116, 111, 114, 82, 101, 115, 112, 111, 110, 115, 101, 46, 70, 105, 108, 101,
    82, 4, 102, 105, 108, 101, 26, 93, 10, 4, 70, 105, 108, 101, 18, 18, 10, 4, 110, 97, 109, 101,
    24, 1, 32, 1, 40, 9, 82, 4, 110, 97, 109, 101, 18, 39, 10, 15, 105, 110, 115, 101, 114, 116,
    105, 111, 110, 95, 112, 111, 105, 110, 116, 24, 2, 32, 1, 40, 9, 82, 14, 105, 110, 115, 101,
    114, 116, 105, 111, 110, 80, 111, 105, 110, 116, 18, 24, 10, 7, 99, 111, 110, 116, 101, 110,
    116, 24, 15, 32, 1, 40, 9, 82, 7, 99, 111, 110, 116, 101, 110, 116, 66, 103, 10, 28, 99, 111,
    109, 46, 103, 111, 111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 99, 111,
    109, 112, 105, 108, 101, 114, 66, 12, 80, 108, 117, 103, 105, 110, 80, 114, 111, 116, 111, 115,
    90, 57, 103, 105, 116, 104, 117, 98, 46, 99, 111, 109, 47, 103, 111, 108, 97, 110, 103, 47,
    112, 114, 111, 116, 111, 98, 117, 102, 47, 112, 114, 111, 116, 111, 99, 45, 103, 101, 110, 45,
    103, 111, 47, 112, 108, 117, 103, 105, 110, 59, 112, 108, 117, 103, 105, 110, 95, 103, 111,
];
pub mod google_protobuf_compiler_plugin_proto {
    pub fn file() -> &'static crate::reflect::FileDescriptor<'static> {
        super::pool()
            .find_file_by_name("google/protobuf/compiler/plugin.proto")
            .unwrap()
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct Version {
        major: ::std::option::Option<i32>,
        minor: ::std::option::Option<i32>,
        patch: ::std::option::Option<i32>,
        suffix: ::std::option::Option<::std::string::String>,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::Version {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.set_major(input.read_int32()?),
                    16 | 18 => self.set_minor(input.read_int32()?),
                    24 | 26 => self.set_patch(input.read_int32()?),
                    34 => self.set_suffix(input.read_string()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if let ::std::option::Option::Some(major) = self.major_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::int32(*major))?;
            }
            if let ::std::option::Option::Some(minor) = self.minor_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::int32(*minor))?;
            }
            if let ::std::option::Option::Some(patch) = self.patch_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::int32(*patch))?;
            }
            if let ::std::option::Option::Some(suffix) = self.suffix_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(suffix)?)?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if let ::std::option::Option::Some(major) = self.major_option() {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(*major)?;
            }
            if let ::std::option::Option::Some(minor) = self.minor_option() {
                output.write_raw_tag_bytes(&[16])?;
                output.write_int32(*minor)?;
            }
            if let ::std::option::Option::Some(patch) = self.patch_option() {
                output.write_raw_tag_bytes(&[24])?;
                output.write_int32(*patch)?;
            }
            if let ::std::option::Option::Some(suffix) = self.suffix_option() {
                output.write_raw_tag_bytes(&[34])?;
                output.write_string(suffix)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl crate::LiteMessage for self::Version {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(major) = other.major_option() {
                self.set_major(*major);
            }
            if let ::std::option::Option::Some(minor) = other.minor_option() {
                self.set_minor(*minor);
            }
            if let ::std::option::Option::Some(patch) = other.patch_option() {
                self.set_patch(*patch);
            }
            if let ::std::option::Option::Some(suffix) = other.suffix_option() {
                self.set_suffix(::std::clone::Clone::clone(suffix));
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::Version {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[0]
        }
    }
    impl self::Version {
        pub const MAJOR_FIELD_NUMBER: i32 = 1;
        pub const MAJOR_DEFAULT_VALUE: i32 = 0;
        pub fn major(&self) -> i32 {
            self.major.unwrap_or(Self::MAJOR_DEFAULT_VALUE)
        }
        pub fn major_option(&self) -> ::std::option::Option<&i32> {
            self.major.as_ref()
        }
        pub fn major_mut(&mut self) -> &mut i32 {
            self.major
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_major(&self) -> bool {
            self.major.is_some()
        }
        pub fn set_major(&mut self, value: i32) {
            self.major = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_major(&mut self) -> ::std::option::Option<i32> {
            self.major.take()
        }
        pub fn clear_major(&mut self) {
            self.major = ::std::option::Option::None;
        }
        pub const MINOR_FIELD_NUMBER: i32 = 2;
        pub const MINOR_DEFAULT_VALUE: i32 = 0;
        pub fn minor(&self) -> i32 {
            self.minor.unwrap_or(Self::MINOR_DEFAULT_VALUE)
        }
        pub fn minor_option(&self) -> ::std::option::Option<&i32> {
            self.minor.as_ref()
        }
        pub fn minor_mut(&mut self) -> &mut i32 {
            self.minor
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_minor(&self) -> bool {
            self.minor.is_some()
        }
        pub fn set_minor(&mut self, value: i32) {
            self.minor = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_minor(&mut self) -> ::std::option::Option<i32> {
            self.minor.take()
        }
        pub fn clear_minor(&mut self) {
            self.minor = ::std::option::Option::None;
        }
        pub const PATCH_FIELD_NUMBER: i32 = 3;
        pub const PATCH_DEFAULT_VALUE: i32 = 0;
        pub fn patch(&self) -> i32 {
            self.patch.unwrap_or(Self::PATCH_DEFAULT_VALUE)
        }
        pub fn patch_option(&self) -> ::std::option::Option<&i32> {
            self.patch.as_ref()
        }
        pub fn patch_mut(&mut self) -> &mut i32 {
            self.patch
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_patch(&self) -> bool {
            self.patch.is_some()
        }
        pub fn set_patch(&mut self, value: i32) {
            self.patch = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_patch(&mut self) -> ::std::option::Option<i32> {
            self.patch.take()
        }
        pub fn clear_patch(&mut self) {
            self.patch = ::std::option::Option::None;
        }
        pub const SUFFIX_FIELD_NUMBER: i32 = 4;
        pub const SUFFIX_DEFAULT_VALUE: &'static str = "";
        pub fn suffix(&self) -> &str {
            self.suffix
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::SUFFIX_DEFAULT_VALUE)
        }
        pub fn suffix_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.suffix.as_ref()
        }
        pub fn suffix_mut(&mut self) -> &mut ::std::string::String {
            self.suffix
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_suffix(&self) -> bool {
            self.suffix.is_some()
        }
        pub fn set_suffix(&mut self, value: ::std::string::String) {
            self.suffix = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_suffix(&mut self) -> ::std::option::Option<::std::string::String> {
            self.suffix.take()
        }
        pub fn clear_suffix(&mut self) {
            self.suffix = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod version {
        pub(in super::super) static MAJOR_REFLECTOR: crate::reflect::access::VerboseFieldAccessor<
            self::super::Version,
            i32,
        > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::Version::major_option,
            get_mut: self::super::Version::major_mut,
            set: self::super::Version::set_major,
            take: self::super::Version::take_major,
            clear: self::super::Version::clear_major,
        };
        pub(in super::super) static MINOR_REFLECTOR: crate::reflect::access::VerboseFieldAccessor<
            self::super::Version,
            i32,
        > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::Version::minor_option,
            get_mut: self::super::Version::minor_mut,
            set: self::super::Version::set_minor,
            take: self::super::Version::take_minor,
            clear: self::super::Version::clear_minor,
        };
        pub(in super::super) static PATCH_REFLECTOR: crate::reflect::access::VerboseFieldAccessor<
            self::super::Version,
            i32,
        > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::Version::patch_option,
            get_mut: self::super::Version::patch_mut,
            set: self::super::Version::set_patch,
            take: self::super::Version::take_patch,
            clear: self::super::Version::clear_patch,
        };
        pub(in super::super) static SUFFIX_REFLECTOR: crate::reflect::access::VerboseFieldAccessor<
            self::super::Version,
            ::std::string::String,
        > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::Version::suffix_option,
            get_mut: self::super::Version::suffix_mut,
            set: self::super::Version::set_suffix,
            take: self::super::Version::take_suffix,
            clear: self::super::Version::clear_suffix,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct CodeGeneratorRequest {
        file_to_generate: crate::collections::RepeatedField<::std::string::String>,
        parameter: ::std::option::Option<::std::string::String>,
        proto_file: crate::collections::RepeatedField<
            self::super::google_protobuf_descriptor_proto::FileDescriptorProto,
        >,
        compiler_version: ::std::option::Option<::std::boxed::Box<self::Version>>,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::CodeGeneratorRequest {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => self.file_to_generate.add_entries(
                        input,
                        &self::code_generator_request::FILE_TO_GENERATE_CODEC,
                    )?,
                    18 => self.set_parameter(input.read_string()?),
                    122 => self
                        .proto_file
                        .add_entries(input, &self::code_generator_request::PROTO_FILE_CODEC)?,
                    26 => input.read_message(self.compiler_version_mut())?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            size = size.checked_add(
                self.file_to_generate()
                    .calculate_size(&self::code_generator_request::FILE_TO_GENERATE_CODEC)?,
            )?;
            if let ::std::option::Option::Some(parameter) = self.parameter_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(parameter)?)?;
            }
            size = size.checked_add(
                self.proto_file()
                    .calculate_size(&self::code_generator_request::PROTO_FILE_CODEC)?,
            )?;
            if let ::std::option::Option::Some(compiler_version) = self.compiler_version() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::message(compiler_version)?)?;
            }
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            self.file_to_generate().write_to(
                output,
                &self::code_generator_request::FILE_TO_GENERATE_CODEC,
            )?;
            if let ::std::option::Option::Some(parameter) = self.parameter_option() {
                output.write_raw_tag_bytes(&[18])?;
                output.write_string(parameter)?;
            }
            self.proto_file()
                .write_to(output, &self::code_generator_request::PROTO_FILE_CODEC)?;
            if let ::std::option::Option::Some(compiler_version) = self.compiler_version() {
                output.write_raw_tag_bytes(&[26])?;
                output.write_message(compiler_version)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.proto_file.is_initialized() {
                return false;
            }
            if let ::std::option::Option::Some(compiler_version) = self.compiler_version() {
                if !crate::CodedMessage::is_initialized(compiler_version) {
                    return false;
                }
            }
            true
        }
    }
    impl crate::LiteMessage for self::CodeGeneratorRequest {
        fn merge(&mut self, other: &Self) {
            self.file_to_generate.merge(&other.file_to_generate);
            if let ::std::option::Option::Some(parameter) = other.parameter_option() {
                self.set_parameter(::std::clone::Clone::clone(parameter));
            }
            self.proto_file.merge(&other.proto_file);
            if let ::std::option::Option::Some(compiler_version) = &other.compiler_version() {
                crate::LiteMessage::merge(self.compiler_version_mut(), compiler_version);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::CodeGeneratorRequest {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[1]
        }
    }
    impl self::CodeGeneratorRequest {
        pub const FILE_TO_GENERATE_FIELD_NUMBER: i32 = 1;
        pub fn file_to_generate(
            &self,
        ) -> &crate::collections::RepeatedField<::std::string::String> {
            &self.file_to_generate
        }
        pub fn file_to_generate_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<::std::string::String> {
            &mut self.file_to_generate
        }
        pub const PARAMETER_FIELD_NUMBER: i32 = 2;
        pub const PARAMETER_DEFAULT_VALUE: &'static str = "";
        pub fn parameter(&self) -> &str {
            self.parameter
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::PARAMETER_DEFAULT_VALUE)
        }
        pub fn parameter_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.parameter.as_ref()
        }
        pub fn parameter_mut(&mut self) -> &mut ::std::string::String {
            self.parameter
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_parameter(&self) -> bool {
            self.parameter.is_some()
        }
        pub fn set_parameter(&mut self, value: ::std::string::String) {
            self.parameter = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_parameter(&mut self) -> ::std::option::Option<::std::string::String> {
            self.parameter.take()
        }
        pub fn clear_parameter(&mut self) {
            self.parameter = ::std::option::Option::None;
        }
        pub const PROTO_FILE_FIELD_NUMBER: i32 = 15;
        pub fn proto_file(
            &self,
        ) -> &crate::collections::RepeatedField<
            self::super::google_protobuf_descriptor_proto::FileDescriptorProto,
        > {
            &self.proto_file
        }
        pub fn proto_file_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<
            self::super::google_protobuf_descriptor_proto::FileDescriptorProto,
        > {
            &mut self.proto_file
        }
        pub const COMPILER_VERSION_FIELD_NUMBER: i32 = 3;
        pub fn compiler_version(&self) -> ::std::option::Option<&self::Version> {
            self.compiler_version.as_ref().map(|v| &**v)
        }
        pub fn compiler_version_mut(&mut self) -> &mut self::Version {
            self.compiler_version
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_compiler_version(&self) -> bool {
            self.compiler_version.is_some()
        }
        pub fn set_compiler_version(&mut self, value: self::Version) {
            self.compiler_version = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_compiler_version(&mut self) -> ::std::option::Option<self::Version> {
            self.compiler_version.take().map(|v| *v)
        }
        pub fn clear_compiler_version(&mut self) {
            self.compiler_version = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod code_generator_request {
        pub(super) static FILE_TO_GENERATE_CODEC: crate::Codec<::std::string::String> =
            crate::Codec::string(10);
        pub(super) static PROTO_FILE_CODEC: crate::Codec<
            self::super::super::google_protobuf_descriptor_proto::FileDescriptorProto,
        > = crate::Codec::message(122);
        pub(in super::super) static FILE_TO_GENERATE_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::CodeGeneratorRequest,
                crate::collections::RepeatedField<::std::string::String>,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::CodeGeneratorRequest::file_to_generate,
            get_mut: self::super::CodeGeneratorRequest::file_to_generate_mut,
        };
        pub(in super::super) static PARAMETER_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::CodeGeneratorRequest,
                ::std::string::String,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::CodeGeneratorRequest::parameter_option,
            get_mut: self::super::CodeGeneratorRequest::parameter_mut,
            set: self::super::CodeGeneratorRequest::set_parameter,
            take: self::super::CodeGeneratorRequest::take_parameter,
            clear: self::super::CodeGeneratorRequest::clear_parameter,
        };
        pub(in super::super) static PROTO_FILE_REFLECTOR:
            crate::reflect::access::SimpleFieldAccessor<
                self::super::CodeGeneratorRequest,
                crate::collections::RepeatedField<
                    self::super::super::google_protobuf_descriptor_proto::FileDescriptorProto,
                >,
            > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::CodeGeneratorRequest::proto_file,
            get_mut: self::super::CodeGeneratorRequest::proto_file_mut,
        };
        pub(in super::super) static COMPILER_VERSION_REFLECTOR:
            crate::reflect::access::VerboseFieldAccessor<
                self::super::CodeGeneratorRequest,
                self::super::Version,
            > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::CodeGeneratorRequest::compiler_version,
            get_mut: self::super::CodeGeneratorRequest::compiler_version_mut,
            set: self::super::CodeGeneratorRequest::set_compiler_version,
            take: self::super::CodeGeneratorRequest::take_compiler_version,
            clear: self::super::CodeGeneratorRequest::clear_compiler_version,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct CodeGeneratorResponse {
        error: ::std::option::Option<::std::string::String>,
        file: crate::collections::RepeatedField<self::code_generator_response::File>,
        unknown_fields: crate::UnknownFieldSet,
    }
    impl crate::CodedMessage for self::CodeGeneratorResponse {
        fn merge_from(&mut self, input: &mut crate::io::CodedInput) -> crate::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => self.set_error(input.read_string()?),
                    122 => self
                        .file
                        .add_entries(input, &self::code_generator_response::FILE_CODEC)?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> ::std::option::Option<i32> {
            let mut size = 0i32;
            if let ::std::option::Option::Some(error) = self.error_option() {
                size = size.checked_add(1)?;
                size = size.checked_add(crate::io::sizes::string(error)?)?;
            }
            size = size.checked_add(
                self.file()
                    .calculate_size(&self::code_generator_response::FILE_CODEC)?,
            )?;
            size = size.checked_add(self.unknown_fields.calculate_size()?)?;
            ::std::option::Option::Some(size)
        }
        fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
            if let ::std::option::Option::Some(error) = self.error_option() {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(error)?;
            }
            self.file()
                .write_to(output, &self::code_generator_response::FILE_CODEC)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.file.is_initialized() {
                return false;
            }
            true
        }
    }
    impl crate::LiteMessage for self::CodeGeneratorResponse {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(error) = other.error_option() {
                self.set_error(::std::clone::Clone::clone(error));
            }
            self.file.merge(&other.file);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl crate::Message for self::CodeGeneratorResponse {
        fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
            &self::file().messages()[2]
        }
    }
    impl self::CodeGeneratorResponse {
        pub const ERROR_FIELD_NUMBER: i32 = 1;
        pub const ERROR_DEFAULT_VALUE: &'static str = "";
        pub fn error(&self) -> &str {
            self.error
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::ERROR_DEFAULT_VALUE)
        }
        pub fn error_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.error.as_ref()
        }
        pub fn error_mut(&mut self) -> &mut ::std::string::String {
            self.error
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_error(&self) -> bool {
            self.error.is_some()
        }
        pub fn set_error(&mut self, value: ::std::string::String) {
            self.error = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_error(&mut self) -> ::std::option::Option<::std::string::String> {
            self.error.take()
        }
        pub fn clear_error(&mut self) {
            self.error = ::std::option::Option::None;
        }
        pub const FILE_FIELD_NUMBER: i32 = 15;
        pub fn file(
            &self,
        ) -> &crate::collections::RepeatedField<self::code_generator_response::File> {
            &self.file
        }
        pub fn file_mut(
            &mut self,
        ) -> &mut crate::collections::RepeatedField<self::code_generator_response::File> {
            &mut self.file
        }
    }
    pub mod code_generator_response {
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct File {
            name: ::std::option::Option<::std::string::String>,
            insertion_point: ::std::option::Option<::std::string::String>,
            content: ::std::option::Option<::std::string::String>,
            unknown_fields: crate::UnknownFieldSet,
        }
        impl crate::CodedMessage for self::File {
            fn merge_from(
                &mut self,
                input: &mut crate::io::CodedInput,
            ) -> crate::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        10 => self.set_name(input.read_string()?),
                        18 => self.set_insertion_point(input.read_string()?),
                        122 => self.set_content(input.read_string()?),
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> ::std::option::Option<i32> {
                let mut size = 0i32;
                if let ::std::option::Option::Some(name) = self.name_option() {
                    size = size.checked_add(1)?;
                    size = size.checked_add(crate::io::sizes::string(name)?)?;
                }
                if let ::std::option::Option::Some(insertion_point) = self.insertion_point_option()
                {
                    size = size.checked_add(1)?;
                    size = size.checked_add(crate::io::sizes::string(insertion_point)?)?;
                }
                if let ::std::option::Option::Some(content) = self.content_option() {
                    size = size.checked_add(1)?;
                    size = size.checked_add(crate::io::sizes::string(content)?)?;
                }
                size = size.checked_add(self.unknown_fields.calculate_size()?)?;
                ::std::option::Option::Some(size)
            }
            fn write_to(&self, output: &mut crate::io::CodedOutput) -> crate::io::OutputResult {
                if let ::std::option::Option::Some(name) = self.name_option() {
                    output.write_raw_tag_bytes(&[10])?;
                    output.write_string(name)?;
                }
                if let ::std::option::Option::Some(insertion_point) = self.insertion_point_option()
                {
                    output.write_raw_tag_bytes(&[18])?;
                    output.write_string(insertion_point)?;
                }
                if let ::std::option::Option::Some(content) = self.content_option() {
                    output.write_raw_tag_bytes(&[122])?;
                    output.write_string(content)?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                true
            }
        }
        impl crate::LiteMessage for self::File {
            fn merge(&mut self, other: &Self) {
                if let ::std::option::Option::Some(name) = other.name_option() {
                    self.set_name(::std::clone::Clone::clone(name));
                }
                if let ::std::option::Option::Some(insertion_point) = other.insertion_point_option()
                {
                    self.set_insertion_point(::std::clone::Clone::clone(insertion_point));
                }
                if let ::std::option::Option::Some(content) = other.content_option() {
                    self.set_content(::std::clone::Clone::clone(content));
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl crate::Message for self::File {
            fn descriptor() -> &'static crate::reflect::MessageDescriptor<'static> {
                &<self::super::CodeGeneratorResponse as crate::Message>::descriptor().messages()[0]
            }
        }
        impl self::File {
            pub const NAME_FIELD_NUMBER: i32 = 1;
            pub const NAME_DEFAULT_VALUE: &'static str = "";
            pub fn name(&self) -> &str {
                self.name
                    .as_ref()
                    .map(|v| &**v)
                    .unwrap_or(Self::NAME_DEFAULT_VALUE)
            }
            pub fn name_option(&self) -> ::std::option::Option<&::std::string::String> {
                self.name.as_ref()
            }
            pub fn name_mut(&mut self) -> &mut ::std::string::String {
                self.name
                    .get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_name(&self) -> bool {
                self.name.is_some()
            }
            pub fn set_name(&mut self, value: ::std::string::String) {
                self.name = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_name(&mut self) -> ::std::option::Option<::std::string::String> {
                self.name.take()
            }
            pub fn clear_name(&mut self) {
                self.name = ::std::option::Option::None;
            }
            pub const INSERTION_POINT_FIELD_NUMBER: i32 = 2;
            pub const INSERTION_POINT_DEFAULT_VALUE: &'static str = "";
            pub fn insertion_point(&self) -> &str {
                self.insertion_point
                    .as_ref()
                    .map(|v| &**v)
                    .unwrap_or(Self::INSERTION_POINT_DEFAULT_VALUE)
            }
            pub fn insertion_point_option(&self) -> ::std::option::Option<&::std::string::String> {
                self.insertion_point.as_ref()
            }
            pub fn insertion_point_mut(&mut self) -> &mut ::std::string::String {
                self.insertion_point
                    .get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_insertion_point(&self) -> bool {
                self.insertion_point.is_some()
            }
            pub fn set_insertion_point(&mut self, value: ::std::string::String) {
                self.insertion_point =
                    ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_insertion_point(&mut self) -> ::std::option::Option<::std::string::String> {
                self.insertion_point.take()
            }
            pub fn clear_insertion_point(&mut self) {
                self.insertion_point = ::std::option::Option::None;
            }
            pub const CONTENT_FIELD_NUMBER: i32 = 15;
            pub const CONTENT_DEFAULT_VALUE: &'static str = "";
            pub fn content(&self) -> &str {
                self.content
                    .as_ref()
                    .map(|v| &**v)
                    .unwrap_or(Self::CONTENT_DEFAULT_VALUE)
            }
            pub fn content_option(&self) -> ::std::option::Option<&::std::string::String> {
                self.content.as_ref()
            }
            pub fn content_mut(&mut self) -> &mut ::std::string::String {
                self.content
                    .get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_content(&self) -> bool {
                self.content.is_some()
            }
            pub fn set_content(&mut self, value: ::std::string::String) {
                self.content = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_content(&mut self) -> ::std::option::Option<::std::string::String> {
                self.content.take()
            }
            pub fn clear_content(&mut self) {
                self.content = ::std::option::Option::None;
            }
        }
        pub(in super::super::super) mod file {
            pub(in super::super::super) static NAME_REFLECTOR:
                crate::reflect::access::VerboseFieldAccessor<
                    self::super::File,
                    ::std::string::String,
                > = crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::File::name_option,
                get_mut: self::super::File::name_mut,
                set: self::super::File::set_name,
                take: self::super::File::take_name,
                clear: self::super::File::clear_name,
            };
            pub(in super::super::super) static INSERTION_POINT_REFLECTOR:
                crate::reflect::access::VerboseFieldAccessor<
                    self::super::File,
                    ::std::string::String,
                > = crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::File::insertion_point_option,
                get_mut: self::super::File::insertion_point_mut,
                set: self::super::File::set_insertion_point,
                take: self::super::File::take_insertion_point,
                clear: self::super::File::clear_insertion_point,
            };
            pub(in super::super::super) static CONTENT_REFLECTOR:
                crate::reflect::access::VerboseFieldAccessor<
                    self::super::File,
                    ::std::string::String,
                > = crate::reflect::access::VerboseFieldAccessor {
                get_option: self::super::File::content_option,
                get_mut: self::super::File::content_mut,
                set: self::super::File::set_content,
                take: self::super::File::take_content,
                clear: self::super::File::clear_content,
            };
        }
        pub(super) static FILE_CODEC: crate::Codec<self::File> = crate::Codec::message(122);
        pub(in super::super) static ERROR_REFLECTOR: crate::reflect::access::VerboseFieldAccessor<
            self::super::CodeGeneratorResponse,
            ::std::string::String,
        > = crate::reflect::access::VerboseFieldAccessor {
            get_option: self::super::CodeGeneratorResponse::error_option,
            get_mut: self::super::CodeGeneratorResponse::error_mut,
            set: self::super::CodeGeneratorResponse::set_error,
            take: self::super::CodeGeneratorResponse::take_error,
            clear: self::super::CodeGeneratorResponse::clear_error,
        };
        pub(in super::super) static FILE_REFLECTOR: crate::reflect::access::SimpleFieldAccessor<
            self::super::CodeGeneratorResponse,
            crate::collections::RepeatedField<self::File>,
        > = crate::reflect::access::SimpleFieldAccessor {
            get: self::super::CodeGeneratorResponse::file,
            get_mut: self::super::CodeGeneratorResponse::file_mut,
        };
    }
}
