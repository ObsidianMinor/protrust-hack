use crate::names;
use crate::printer;
use crate::Options;
use protrust::descriptor::FileOptions_OptimizeMode as OptimizeMode;
use protrust::io::WireType;
use protrust::prelude::*;
use protrust::reflect::*;
use std::collections::HashMap;
use std::fmt::Write;

macro_rules! var {
    ($target:expr, $var:expr) => {
        $target
            .get(stringify!($var))
            .ok_or_else(|| Error::MissingVariable(stringify!($var)))?
    };
}

macro_rules! gen {
    ($target:expr; $fmt:expr => $vars:expr, $($arg:ident),*)
        => (write!($target, $fmt, $($arg = var!($vars, $arg)),*)?);
    ($dst:expr, $($arg:tt)*) => (write!($dst, $($arg)*)?);
}

macro_rules! genln {
    ($target:expr; $fmt:expr => $vars:expr, $($arg:ident),*) => {
        writeln!($target)?;
        write!($target, $fmt, $($arg = var!($vars, $arg)),*)?;
    };
    ($dst:expr, $($arg:tt)*) => {
        writeln!($dst)?;
        write!($dst, $($arg)*)?;
    }
}

macro_rules! indent {
    ($target:expr, $block:block) => {
        $target.indent();
        $block
        $target.unindent();
    };
}

macro_rules! generator_new {
    ($type:ty, $p:ident, $o:ident; $($key:expr, $value:expr),*) => {
        impl<'a, W> Generator<'a, $type, W> {
            pub fn new(printer: &'a mut printer::Printer<W>, $p: &'a $type, $o: &'a Options) -> Generator<'a, $type, W> {
                let mut generator = Generator {
                    printer,
                    proto: $p,
                    options: $o,
                    vars: HashMap::new()
                };
                $(
                    generator.vars.insert($key, $value);
                )*
                generator
            }

            #[allow(dead_code)]
            pub fn from_other<'b, T>(other: &'a mut Generator<'b, T, W>, proto: &'b $type) -> Generator<'a, $type, W> {
                Self::new(&mut other.printer, proto, &other.options)
            }
        }
    };
}

pub type Result = std::result::Result<(), Error>;

#[derive(Debug)]
pub enum Error {
    FormatError,
    MissingVariable(&'static str),
}

impl From<std::fmt::Error> for Error {
    fn from(_: std::fmt::Error) -> Error {
        Error::FormatError
    }
}

pub struct Generator<'a, T, W> {
    vars: HashMap<&'static str, String>,
    printer: &'a mut printer::Printer<W>,
    proto: &'a T,
    options: &'a Options,
}

generator_new!(FileDescriptor, proto, options;
    "file", proto.name().to_string(),
    "crate_name", options.crate_name.clone(),
    "dep_count", proto.dependencies().len().to_string());

impl<W: Write> Generator<'_, FileDescriptor, W> {
    pub fn generate(&mut self) -> Result {
        gen!(self.printer, "//! DO NOT EDIT!");
        genln!(
            self.printer,
            "//! Generated by protoc-gen-rust, part of the protrust crate."
        );
        genln!(self.printer, "//!");
        genln!(self.printer; "//! Source: {file}\n" => self.vars, file);

        // static descriptor code
        self.generate_descriptor_code()?;

        // extensions
        //for _extension in self.proto.extensions() {
        //
        //}

        // messages
        for message in self.proto.messages() {
            Generator::<MessageDescriptor, _>::from_other(self, message).generate()?;
        }

        // enums
        for enum_type in self.proto.enums() {
            Generator::<EnumDescriptor, _>::from_other(self, enum_type).generate()?;
        }

        Ok(())
    }

    pub fn generate_descriptor_code(&mut self) -> Result {
        genln!(self.printer, "static FILE_ONCE: ::std::sync::Once = ::std::sync::Once::new();");
        genln!(self.printer; "static mut FILE_POOL: ::std::option::Option<{crate_name}::reflect::DescriptorPool<'static>> = ::std::option::Option::None;" => self.vars, crate_name);
        genln!(self.printer; "static mut FILE_PROTO: ::std::option::Option<[{crate_name}::descriptor::FileDescriptorProto; 1]> = ::std::option::Option::None;" => self.vars, crate_name);
        genln!(self.printer; "static mut FILE_DESCRIPTOR: ::std::option::Option<&'static {crate_name}::reflect::FileDescriptor> = ::std::option::Option::None;" => self.vars, crate_name);
        genln!(self.printer; "static mut FILE_DEPS: ::std::option::Option<[&'static {crate_name}::reflect::DescriptorPool<'static>; {dep_count}]> = ::std::option::Option::None;" => self.vars, crate_name, dep_count);
        genln!(self.printer, "");
        genln!(self.printer, "fn file_once_init() {{");
        indent!(self.printer, {
            genln!(self.printer, "unsafe {{");
            indent!(self.printer, {
                genln!(self.printer; "FILE_PROTO = ::std::option::Option::Some([{crate_name}::LiteMessage::read_new(&mut [" => self.vars, crate_name);
                indent!(self.printer, {
                    genln!(self.printer, "");
                    let mut new_proto = self.proto.proto().clone();
                    new_proto.source_code_info = None;
                    let vec = new_proto.write_to_vec().unwrap();
                    let mut bytes_on_line = 0;
                    for byte in vec {
                        gen!(self.printer, "{}, ", byte);
                        bytes_on_line += 1;
                        if bytes_on_line == 20 {
                            genln!(self.printer, "");
                            bytes_on_line = 0;
                        }
                    }
                });
                genln!(self.printer, "].as_ref()).expect(\"Could not read file descriptor\")]);");
                genln!(self.printer, "FILE_DEPS = ::std::option::Option::Some([");
                for file in self.proto.dependencies() {
                    gen!(self.printer, "{}::pool(), ", names::get_rust_external_mod_name(file, &self.options.crate_name));
                }
                gen!(self.printer, "]);");
                genln!(self.printer; "FILE_POOL = ::std::option::Option::Some({crate_name}::reflect::DescriptorPool::build_generated_pool(" => self.vars, crate_name);
                indent!(self.printer, {
                    genln!(self.printer, "FILE_PROTO.as_ref().unwrap(),");
                    genln!(self.printer, "FILE_DEPS.as_ref().unwrap()");
                });
                genln!(self.printer, "));");
                genln!(self.printer; "FILE_DESCRIPTOR = ::std::option::Option::Some(FILE_POOL.as_ref().unwrap().find_file_by_name(\"{file}\").unwrap());" => self.vars, file);
            });
            genln!(self.printer, "}}");
        });
        genln!(self.printer, "}}");
        genln!(self.printer, "");
        genln!(self.printer; "pub fn pool() -> &'static {crate_name}::reflect::DescriptorPool<'static> {{" => self.vars, crate_name);
        indent!(self.printer, {
            genln!(self.printer, "unsafe {{");
            indent!(self.printer, {
                genln!(self.printer, "FILE_ONCE.call_once(file_once_init);");
                genln!(self.printer, "FILE_POOL.as_ref().unwrap()");
            });
            genln!(self.printer, "}}");
        });
        genln!(self.printer, "}}");
        genln!(self.printer; "pub fn file() -> &'static {crate_name}::reflect::FileDescriptor {{" => self.vars, crate_name);
        indent!(self.printer, {
            genln!(self.printer, "unsafe {{");
            indent!(self.printer, {
                genln!(self.printer, "FILE_ONCE.call_once(file_once_init);");
                genln!(self.printer, "FILE_DESCRIPTOR.as_ref().unwrap()");
            });
            genln!(self.printer, "}}");
        });
        genln!(self.printer, "}}");

        Ok(())
    }
}

generator_new!(MessageDescriptor, proto, options;
    "type_name", names::get_message_type_name(proto),
    "full_type_name", names::get_full_message_type_name(proto, proto.file(), &options.crate_name),
    "crate_name", options.crate_name.clone());

impl<W: Write> Generator<'_, MessageDescriptor, W> {
    pub fn generate(&mut self) -> Result {
        genln!(self.printer, "#[derive(Debug, PartialEq)]");
        genln!(self.printer; "pub struct {type_name} {{" => self.vars, type_name);
        indent!(self.printer, {
            for field in self.proto.message_fields() {
                Generator::<FieldDescriptor, _>::from_other(self, field).generate_struct_field()?;
            }

            for oneof in self.proto.oneofs() {
                Generator::<OneofDescriptor, _>::from_other(self, oneof).generate_struct_field()?;
            }

            genln!(self.printer; "unknown_fields: {crate_name}::UnknownFieldSet" => self.vars, crate_name);
        });
        genln!(self.printer, "}}");

        for field in self.proto.fields() {
            Generator::<FieldDescriptor, _>::from_other(self, field).generate_codec()?;
        }

        for oneof in self.proto.oneofs() {
            Generator::<OneofDescriptor, _>::from_other(self, oneof).generate_type()?;
        }

        self.generate_coded_message_impl()?;
        self.generate_lite_message_impl()?;
        self.generate_clone_impl()?;

        if let Some(EnumValue::Defined(o)) = self.proto.file().options().map(|o| {
            o.optimize_for
                .unwrap_or(EnumValue::Defined(OptimizeMode::Speed))
        }) {
            if o != OptimizeMode::LiteRuntime {
                self.generate_message_impl()?;
            }
        }

        self.generate_struct_impl()?;

        for nested in self.proto.messages().iter().filter(|m| !m.map_entry()) {
            Generator::<MessageDescriptor, _>::from_other(self, nested).generate()?;
        }

        for nested in self.proto.enums() {
            Generator::<EnumDescriptor, _>::from_other(self, nested).generate()?;
        }

        Ok(())
    }

    pub fn generate_coded_message_impl(&mut self) -> Result {
        genln!(self.printer; "impl {crate_name}::CodedMessage for {full_type_name} {{" => self.vars, crate_name, full_type_name);
        indent!(self.printer, {
            genln!(self.printer; "fn merge_from(&mut self, input: &mut {crate_name}::io::CodedInput) -> {crate_name}::io::InputResult<()> {{" => self.vars, crate_name);
            indent!(self.printer, {
                genln!(
                    self.printer,
                    "while let ::std::option::Option::Some(tag) = input.read_tag()? {{"
                );
                indent!(self.printer, {
                    genln!(self.printer, "match tag.get() {{");
                    indent!(self.printer, {
                        for field in self.proto.fields() {
                            Generator::<FieldDescriptor, _>::from_other(self, field)
                                .generate_merge_arm()?;
                        }
                        genln!(
                            self.printer,
                            "tag => self.unknown_fields.merge_from(tag, input)?"
                        );
                    });
                    genln!(self.printer, "}}");
                });
                genln!(self.printer, "}}");
                genln!(self.printer, "::std::result::Result::Ok(())");
            });
            genln!(self.printer, "}}");

            if self.options.size_checks {
                genln!(
                    self.printer,
                    "fn calculate_size(&self) -> ::std::option::Option<i32> {{"
                );
            } else {
                genln!(self.printer, "fn calculate_size(&self) -> i32 {{");
            }
            indent!(self.printer, {
                genln!(self.printer, "let mut size = 0i32;");
                for field in self.proto.fields() {
                    Generator::<FieldDescriptor, _>::from_other(self, field)
                        .generate_size_calculator()?;
                }
                if self.options.size_checks {
                    genln!(
                        self.printer,
                        "size = size.checked_add(self.unknown_fields.calculate_size()?)?;"
                    );
                    genln!(self.printer, "::std::option::Option::Some(size)");
                } else {
                    genln!(
                        self.printer,
                        "size += self.unknown_fields.calculate_size();"
                    );
                    genln!(self.printer, "size");
                }
            });
            genln!(self.printer, "}}");

            genln!(self.printer; "fn write_to(&self, output: &mut {crate_name}::io::CodedOutput) -> {crate_name}::io::OutputResult {{" => self.vars, crate_name);
            indent!(self.printer, {
                for field in self.proto.fields() {
                    Generator::<FieldDescriptor, _>::from_other(self, field).generate_writer()?;
                }
                genln!(self.printer, "self.unknown_fields.write_to(output)?;");
                genln!(self.printer, "::std::result::Result::Ok(())");
            });
            genln!(self.printer, "}}");
        });
        genln!(self.printer, "}}");

        Ok(())
    }

    pub fn generate_lite_message_impl(&mut self) -> Result {
        genln!(self.printer; "impl {crate_name}::LiteMessage for {full_type_name} {{" => self.vars, crate_name, full_type_name);
        indent!(self.printer, {
            genln!(self.printer, "fn new() -> Self {{");
            indent!(self.printer, {
                genln!(self.printer, "Self {{");
                indent!(self.printer, {
                    for field in self.proto.message_fields() {
                        Generator::<FieldDescriptor, _>::from_other(self, field).generate_new()?;
                    }

                    for oneof in self.proto.oneofs() {
                        Generator::<OneofDescriptor, _>::from_other(self, oneof).generate_new()?;
                    }

                    genln!(
                        self.printer,
                        "unknown_fields: {}::UnknownFieldSet::new()",
                        self.options.crate_name
                    );
                });
                genln!(self.printer, "}}");
            });
            genln!(self.printer, "}}");
        });
        genln!(self.printer, "}}");

        Ok(())
    }

    pub fn generate_message_impl(&mut self) -> Result {
        genln!(self.printer; "impl {crate_name}::Message for {full_type_name} {{" => self.vars, crate_name, full_type_name);
        indent!(self.printer, {
            genln!(self.printer; "fn descriptor() -> &'static {crate_name}::reflect::MessageDescriptor {{" => self.vars, crate_name);
            indent!(self.printer, {
                genln!(self.printer, "&self::file()");
                let mut message_access = format!(".messages()[{}]", self.proto.scope_index());
                let mut scope = self.proto.scope();
                while let CompositeScope::Message(m) = scope {
                    message_access.insert_str(0, &format!(".messages()[{}]", m.scope_index()));
                    scope = m.scope();
                }
                gen!(self.printer, "{}", message_access);
            });
            genln!(self.printer, "}}");
        });
        genln!(self.printer, "}}");
        Ok(())
    }

    pub fn generate_clone_impl(&mut self) -> Result {
        genln!(self.printer; "impl ::std::clone::Clone for {full_type_name} {{" => self.vars, full_type_name);
        indent!(self.printer, {
            genln!(self.printer, "fn clone(&self) -> Self {{");
            indent!(self.printer, {
                genln!(self.printer, "Self {{");
                indent!(self.printer, {
                    for field in self.proto.message_fields() {
                        Generator::<FieldDescriptor, _>::from_other(self, field)
                            .generate_clone()?;
                    }

                    for oneof in self.proto.oneofs() {
                        Generator::<OneofDescriptor, _>::from_other(self, oneof)
                            .generate_clone()?;
                    }

                    genln!(self.printer, "unknown_fields: self.unknown_fields.clone()");
                });
                genln!(self.printer, "}}");
            });
            genln!(self.printer, "}}");
            genln!(self.printer, "fn clone_from(&mut self, other: &Self) {{");
            indent!(self.printer, {
                for field in self.proto.fields() {
                    Generator::<FieldDescriptor, _>::from_other(self, field)
                        .generate_field_merge()?;
                }

                genln!(
                    self.printer,
                    "self.unknown_fields.clone_from(&other.unknown_fields);"
                );
            });
            genln!(self.printer, "}}");
        });
        genln!(self.printer, "}}");

        Ok(())
    }

    pub fn generate_struct_impl(&mut self) -> Result {
        genln!(self.printer; "impl {full_type_name} {{" => self.vars, full_type_name);
        indent!(self.printer, {
            for field in self.proto.message_fields() {
                let mut generator = Generator::<FieldDescriptor, _>::from_other(self, field);

                generator.generate_field_number_constant()?;
                generator.generate_default_value()?;
                generator.generate_accessors()?;
            }

            for oneof in self.proto.oneofs() {
                Generator::<OneofDescriptor, _>::from_other(self, oneof).generate_accessor()?;
            }
        });
        genln!(self.printer, "}}");

        Ok(())
    }
}

generator_new!(FieldDescriptor, proto, options;
    "proto_name", proto.name().clone(),
    "proto_type", names::get_proto_type(proto),
    "name", names::get_field_name(proto),
    "field_name", names::get_struct_field_name(proto),
    "base_type", names::get_rust_type(names::TypeResolution::Base, proto, &options.crate_name),
    "indirected_type", names::get_rust_type(names::TypeResolution::Indirection, proto, &options.crate_name),
    "field_type", names::get_rust_type(names::TypeResolution::Full, proto, &options.crate_name),
    "crate_name", options.crate_name.clone(),
    "new_value", default_field_value(proto, &options.crate_name),
    "field_number_const", names::get_field_number_const_name(proto),
    "number", proto.number().to_string(),
    "default", names::get_field_default_value_name(proto),
    "default_type", match proto.field_type() {
        FieldType::String => format!("&'static str"),
        FieldType::Bytes => format!("&'static [u8]"),
        _ => names::get_rust_type(names::TypeResolution::Indirection, proto, &options.crate_name),
    },
    "default_value", {
        match proto.default_value() {
            DefaultValue::Invalid | DefaultValue::None => {
                match proto.field_type() {
                    FieldType::Message(_) | FieldType::Group(_) => String::new(),
                    FieldType::Enum(e) => {
                        match e.values().iter().find(|f| f.number() == 0) {
                            Some(defined) => {
                                format!("{}::EnumValue::Defined({})", options.crate_name, names::get_full_enum_variant_name(defined, proto.file(), &options.crate_name))
                            },
                            None => {
                                format!("{}::EnumValue::Undefined(0)", options.crate_name)
                            }
                        }
                    },
                    FieldType::String => format!("\"\""),
                    FieldType::Bytes => format!("&[]"),
                    FieldType::Bool => format!("false"),
                    FieldType::Float | FieldType::Double => format!("0.0"),
                    _ => format!("0")
                }
            },
            DefaultValue::String(s) => s.chars().flat_map(char::escape_default).collect(),
            DefaultValue::Bool(b) => b.to_string(),
            DefaultValue::Double(d) => d.to_string(),
            DefaultValue::SignedInt(s) => s.to_string(),
            DefaultValue::UnsignedInt(u) => u.to_string(),
            DefaultValue::Enum(e) => format!("{}::EnumValue::Defined({})", options.crate_name, names::get_full_enum_variant_name(e, proto.file(), &options.crate_name)),
            DefaultValue::Bytes(b) => format!("&{:?}", b)
        }
    },
    "codec", names::get_field_codec_name(proto),
    "oneof", {
        match proto.scope() {
            FieldScope::Oneof(o) => names::get_oneof_name(o),
            _ => String::new()
        }
    },
    "tag_size", {
        let wt = proto.wire_type();
        let tag = WireType::make_tag(proto.number(), wt);

        protrust::io::sizes::uint32(tag).to_string()
    },
    "tag", {
        if proto.packed() {
            WireType::make_tag(proto.number(), WireType::LengthDelimited).to_string()
        } else {
            WireType::make_tag(proto.number(), proto.wire_type()).to_string()
        }
    },
    "tags", {
        if proto.packed() {
            format!("{} | {}", WireType::make_tag(proto.number(), proto.wire_type()), WireType::make_tag(proto.number(), WireType::LengthDelimited))
        } else {
            WireType::make_tag(proto.number(), proto.wire_type()).to_string()
        }
    },
    "end_tag", {
        if let FieldType::Group(_) = proto.field_type() {
            WireType::make_tag(proto.number(), WireType::EndGroup).to_string()
        } else {
            String::new()
        }
    },
    "tag_bytes", {
        let tag;
        if proto.packed() {
            tag = WireType::make_tag(proto.number(), WireType::LengthDelimited);
        } else {
            tag = WireType::make_tag(proto.number(), proto.wire_type()).to_le();
        }

        let mut bytes = Vec::with_capacity(protrust::io::sizes::uint32(tag) as usize);
        let mut output = protrust::io::CodedOutput::new(&mut bytes);
        output.write_raw_tag(tag).expect("Couldn't write tag to vector");

        format!("{:?}", bytes)
    },
    "end_tag_bytes", {
        if let FieldType::Group(_) = proto.field_type() {
            let tag = WireType::make_tag(proto.number(), WireType::EndGroup);

            let mut bytes = Vec::with_capacity(protrust::io::sizes::uint32(tag) as usize);
            let mut output = protrust::io::CodedOutput::new(&mut bytes);
            output.write_raw_tag(tag).expect("Couldn't write tag to vector");

            format!("{:?}", bytes)
        } else {
            String::new()
        }
    });

impl<W: Write> Generator<'_, FieldDescriptor, W> {
    pub fn generate_struct_field(&mut self) -> Result {
        if self.options.pub_fields || self.proto.file().syntax() == Syntax::Proto3 {
            genln!(self.printer; "pub {field_name}: {field_type}," => self.vars, field_name, field_type);
        } else {
            genln!(self.printer; "{field_name}: {field_type}," => self.vars, field_name, field_type);
        }

        Ok(())
    }

    pub fn generate_oneof_field(&mut self) -> Result {
        genln!(self.printer; "{name}({field_type})," => self.vars, name, field_type);
        Ok(())
    }

    pub fn generate_new(&mut self) -> Result {
        genln!(self.printer; "{field_name}: {new_value}," => self.vars, field_name, new_value);
        Ok(())
    }

    pub fn generate_field_merge(&mut self) -> Result {
        match self.proto.scope() {
            FieldScope::Oneof(_) => {
                if is_copy_type(self.proto.field_type()) {
                    genln!(self.printer; "if let self::{oneof}::{name}({field_name}) = other.{field_name} {{" => self.vars, oneof, name, field_name);
                } else {
                    genln!(self.printer; "if let self::{oneof}::{name}({field_name}) = &other.{field_name} {{" => self.vars, oneof, name, field_name);
                }
                indent!(self.printer, {
                    match self.proto.field_type() {
                        FieldType::Message(_) | FieldType::Group(_) => {
                            genln!(self.printer; "if let self::{oneof}::{name}(existing) = &mut self.{field_name} {{" => self.vars, oneof, name, field_name);
                            indent!(self.printer, {
                                genln!(self.printer; "existing.clone_from({field_name});" => self.vars, field_name);
                            });
                            genln!(self.printer, "}} else {{");
                            indent!(self.printer, {
                                genln!(self.printer; "self.{field_name} = self::{oneof}::{name}({field_name}.clone());" => self.vars, field_name, name, oneof);
                            });
                            genln!(self.printer, "}}");
                        }
                        FieldType::Bytes | FieldType::String => {
                            genln!(self.printer; "self.{field_name} = self::{oneof}::{name}({field_name}.clone());" => self.vars, field_name, name, oneof);
                        }
                        _ => {
                            genln!(self.printer; "self.{field_name} = self::{oneof}::{name}({field_name});" => self.vars, field_name, name, oneof);
                        }
                    }
                });
                genln!(self.printer, "}}");
            }
            FieldScope::Message(_) => match self.proto.label() {
                FieldLabel::Optional | FieldLabel::Required => match self.proto.field_type() {
                    FieldType::Message(_) | FieldType::Group(_) => {
                        genln!(self.printer; "if let ::std::option::Option::Some({field_name}) = &other.{field_name} {{" => self.vars, field_name);
                        indent!(self.printer, {
                            genln!(self.printer; "self.{field_name}.get_or_insert_with({crate_name}::LiteMessage::new).clone_from({field_name});" => self.vars, crate_name, field_name);
                        });
                        genln!(self.printer, "}}");
                    }
                    FieldType::Bytes | FieldType::String => {
                        genln!(self.printer; "self.{field_name} = other.{field_name}.clone();" => self.vars, field_name);
                    }
                    _ => {
                        genln!(self.printer;"self.{field_name} = other.{field_name};" => self.vars, field_name);
                    }
                },
                FieldLabel::Repeated => {
                    genln!(self.printer; "self.{field_name}.clone_from(&other.{field_name});" => self.vars, field_name);
                }
            },
            _ => {}
        }

        Ok(())
    }

    pub fn generate_merge_arm(&mut self) -> Result {
        genln!(self.printer; "{tags} => " => self.vars, tags);

        match self.proto.label() {
            FieldLabel::Repeated => match self.proto.field_type() {
                FieldType::Message(m) if m.map_entry() => {
                    gen!(self.printer; "self.{field_name}.add_entries(input, &{codec})?" => self.vars, field_name, codec)
                }
                _ => {
                    gen!(self.printer; "self.{field_name}.add_entries(tag.get(), input, &{codec})?" => self.vars, field_name, codec)
                }
            },
            _ => match self.proto.scope() {
                FieldScope::Message(_) => match self.proto.field_type() {
                    FieldType::Message(_) | FieldType::Group(_) => {
                        gen!(self.printer; "input.read_message(self.{field_name}.get_or_insert_with({crate_name}::LiteMessage::new))?" => self.vars, field_name, crate_name)
                    }
                    _ => {
                        gen!(self.printer; "self.{field_name} = " => self.vars, field_name);
                        if self.proto.file().syntax() == Syntax::Proto2 {
                            gen!(self.printer, "::std::option::Option::Some(");
                        }

                        gen!(self.printer; "input.read_{proto_type}()?" => self.vars, proto_type);

                        if self.proto.file().syntax() == Syntax::Proto2 {
                            gen!(self.printer, ")");
                        }
                    }
                },
                FieldScope::Oneof(_) => match self.proto.field_type() {
                    FieldType::Message(_) | FieldType::Group(_) => {
                        indent!(self.printer, {
                            genln!(self.printer; "if let self::{oneof}::{name}({field_name}) = &mut self.{field_name} {{" => self.vars, oneof, name, field_name);
                            indent!(self.printer, {
                                genln!(self.printer; "{field_name}.merge_from(input)?;" => self.vars, field_name);
                            });
                            genln!(self.printer, "}} else {{");
                            indent!(self.printer, {
                                genln!(self.printer; "let mut {field_name} = ::std::boxed::Box::new(<{base_type} as {crate_name}::LiteMessage>::new());" => self.vars, field_name, base_type, crate_name);
                                genln!(self.printer; "{field_name}.merge_from(input)?;" => self.vars, field_name);
                                genln!(self.printer; "self.{field_name} = self::{oneof}::{name}({field_name})" => self.vars, field_name, oneof, name);
                            });
                            genln!(self.printer, "}}");
                        });
                    }
                    _ => {
                        gen!(self.printer; "self.{field_name} = self::{oneof}::{name}(input.read_{proto_type}()?)" => self.vars, field_name, oneof, name, proto_type)
                    }
                },
                _ => unreachable!(),
            },
        }

        gen!(self.printer, ",");

        Ok(())
    }

    pub fn generate_size_calculator(&mut self) -> Result {
        if self.proto.label() == FieldLabel::Repeated {
            if self.options.size_checks {
                genln!(self.printer; "size = size.checked_add(self.{field_name}.calculate_size(&{codec})?)?;" => self.vars, field_name, codec);
            } else {
                genln!(self.printer; "size += self.{field_name}.calculate_size(&{codec});" => self.vars, field_name, codec);
            }
        } else {
            if let FieldScope::Oneof(_) = self.proto.scope() {
                if is_copy_type(self.proto.field_type()) {
                    genln!(self.printer; "if let self::{oneof}::{name}({field_name}) = self.{field_name} {{" => self.vars, oneof, name, field_name);
                } else {
                    genln!(self.printer; "if let self::{oneof}::{name}({field_name}) = &self.{field_name} {{" => self.vars, oneof, name, field_name);
                }
                self.printer.indent();
            } else {
                if is_copy_type(self.proto.field_type()) {
                    genln!(self.printer; "let {field_name} = self.{field_name};" => self.vars, field_name);
                } else {
                    genln!(self.printer; "let {field_name} = &self.{field_name};" => self.vars, field_name);
                }

                match self.proto.field_type() {
                    FieldType::Message(_) | FieldType::Group(_) => {
                        genln!(self.printer; "if let ::std::option::Option::Some({field_name}) = {field_name} {{" => self.vars, field_name);
                        self.printer.indent();
                    }
                    _ => {
                        if self.proto.file().syntax() == Syntax::Proto2 {
                            genln!(self.printer; "if let ::std::option::Option::Some({field_name}) = {field_name} {{" => self.vars, field_name);
                            self.printer.indent();
                        }
                        match self.proto.field_type() {
                            FieldType::Bytes => {
                                genln!(self.printer; "if {field_name}.as_slice() != Self::{default} {{" => self.vars, field_name, default);
                            }
                            _ => {
                                genln!(self.printer; "if {field_name} != Self::{default} {{" => self.vars, field_name, default);
                            }
                        }
                        self.printer.indent();
                    }
                }
            }

            if self.options.size_checks {
                genln!(self.printer; "size = size.checked_add({tag_size})?;" => self.vars, tag_size);
                genln!(self.printer; "size = size.checked_add({crate_name}::io::sizes::{proto_type}({field_name})" => self.vars, field_name, crate_name, proto_type);
            } else {
                genln!(self.printer; "size += {tag_size};" => self.vars, tag_size);
                genln!(self.printer; "size += {crate_name}::io::sizes::{proto_type}({field_name})" => self.vars, field_name, crate_name, proto_type);
            }

            if self.options.size_checks {
                if is_copy_type(self.proto.field_type()) {
                    gen!(self.printer, ")?");
                } else {
                    gen!(self.printer, "?)?");
                }
            }

            gen!(self.printer, ";");

            if let FieldScope::Oneof(_) = self.proto.scope() {
                self.printer.unindent();
                gen!(self.printer, "\n}}");
            } else {
                match self.proto.field_type() {
                    FieldType::Message(_) | FieldType::Group(_) => {
                        self.printer.unindent();
                        gen!(self.printer, "\n}}");
                    }
                    _ => {
                        if self.proto.file().syntax() == Syntax::Proto2 {
                            self.printer.unindent();
                            gen!(self.printer, "\n}}");
                        }
                        self.printer.unindent();
                        gen!(self.printer, "\n}}");
                    }
                }
            }
        }

        Ok(())
    }

    pub fn generate_writer(&mut self) -> Result {
        if self.proto.label() == FieldLabel::Repeated {
            genln!(self.printer; "self.{field_name}.write_to(output, &{codec})?;" => self.vars, field_name, codec);
        } else {
            if let FieldScope::Oneof(_) = self.proto.scope() {
                if is_copy_type(self.proto.field_type()) {
                    genln!(self.printer; "if let self::{oneof}::{name}({field_name}) = self.{field_name} {{" => self.vars, oneof, name, field_name);
                } else {
                    genln!(self.printer; "if let self::{oneof}::{name}({field_name}) = &self.{field_name} {{" => self.vars, oneof, name, field_name);
                }
                self.printer.indent();
            } else {
                if is_copy_type(self.proto.field_type()) {
                    genln!(self.printer; "let {field_name} = self.{field_name};" => self.vars, field_name);
                } else {
                    genln!(self.printer; "let {field_name} = &self.{field_name};" => self.vars, field_name);
                }

                match self.proto.field_type() {
                    FieldType::Message(_) | FieldType::Group(_) => {
                        genln!(self.printer; "if let ::std::option::Option::Some({field_name}) = {field_name} {{" => self.vars, field_name);
                        self.printer.indent();
                    }
                    _ => {
                        if self.proto.file().syntax() == Syntax::Proto2 {
                            genln!(self.printer; "if let ::std::option::Option::Some({field_name}) = {field_name} {{" => self.vars, field_name);
                            self.printer.indent();
                        }
                        match self.proto.field_type() {
                            FieldType::Bytes => {
                                genln!(self.printer; "if {field_name}.as_slice() != Self::{default} {{" => self.vars, field_name, default);
                            }
                            _ => {
                                genln!(self.printer; "if {field_name} != Self::{default} {{" => self.vars, field_name, default);
                            }
                        }
                        self.printer.indent();
                    }
                }
            }

            genln!(self.printer; "output.write_raw_tag_bytes(&{tag_bytes})?;" => self.vars, tag_bytes);
            genln!(self.printer; "output.write_{proto_type}({field_name})?;" => self.vars, proto_type, field_name);

            if let FieldType::Group(_) = self.proto.field_type() {
                genln!(self.printer; "output.write_raw_tag_bytes(&{end_tag_bytes})?;" => self.vars, end_tag_bytes);
            }

            if let FieldScope::Oneof(_) = self.proto.scope() {
                self.printer.unindent();
                genln!(self.printer, "}}");
            } else {
                match self.proto.field_type() {
                    FieldType::Message(_) | FieldType::Group(_) => {
                        self.printer.unindent();
                        genln!(self.printer, "}}");
                    }
                    _ => {
                        if self.proto.file().syntax() == Syntax::Proto2 {
                            self.printer.unindent();
                            genln!(self.printer, "}}");
                        }
                        self.printer.unindent();
                        genln!(self.printer, "}}");
                    }
                }
            }
        }

        Ok(())
    }

    pub fn generate_clone(&mut self) -> Result {
        genln!(self.printer; "{field_name}: self.{field_name}.clone()," => self.vars, field_name);
        Ok(())
    }

    pub fn generate_field_number_constant(&mut self) -> Result {
        genln!(self.printer; "/// Gets the field number of the '{proto_name}' field" => self.vars, proto_name);
        genln!(self.printer; "pub const {field_number_const}: i32 = {number};" => self.vars, field_number_const, number);
        Ok(())
    }

    pub fn generate_default_value(&mut self) -> Result {
        if self.proto.label() != FieldLabel::Repeated {
            match self.proto.field_type() {
                FieldType::Message(_) | FieldType::Group(_) => {}
                _ => {
                    genln!(self.printer; "pub const {default}: {default_type} = {default_value};" => self.vars, default, default_type, default_value);
                }
            }
        }

        Ok(())
    }

    pub fn generate_codec(&mut self) -> Result {
        if self.proto.label() == FieldLabel::Repeated {
            match self.proto.field_type() {
                FieldType::Message(m) if m.map_entry() => {
                    genln!(self.printer; "static {codec}: {crate_name}::collections::MapCodec<" => self.vars, codec, crate_name);
                    let generator =
                        Generator::<FieldDescriptor, _>::from_other(self, &m.fields()[0]);
                    gen!(generator.printer; "{base_type}, " => generator.vars, base_type);
                    let generator =
                        Generator::<FieldDescriptor, _>::from_other(self, &m.fields()[1]);
                    gen!(generator.printer; "{base_type}" => generator.vars, base_type);
                    gen!(self.printer; "> = {crate_name}::collections::MapCodec::new(" => self.vars, crate_name);

                    Generator::<FieldDescriptor, _>::from_other(self, &m.fields()[0])
                        .generate_codec_new()?;
                    gen!(self.printer, ", ");
                    Generator::<FieldDescriptor, _>::from_other(self, &m.fields()[1])
                        .generate_codec_new()?;
                    gen!(self.printer; ", {tag});" => self.vars, tag);
                }
                _ => {
                    genln!(self.printer; "static {codec}: {crate_name}::Codec<{base_type}> = " => self.vars, codec, crate_name, base_type);
                    self.generate_codec_new()?;
                    gen!(self.printer, ";");
                }
            }
        }

        Ok(())
    }

    pub fn generate_codec_new(&mut self) -> Result {
        match self.proto.field_type() {
            FieldType::Group(_) => {
                gen!(self.printer; "{crate_name}::Codec::group({tag}, {end_tag})" => self.vars, crate_name, tag, end_tag)
            }
            _ => {
                gen!(self.printer; "{crate_name}::Codec::{proto_type}({tag})" => self.vars, crate_name, proto_type, tag)
            }
        }
        Ok(())
    }

    pub fn generate_accessors(&mut self) -> Result {
        match self.proto.file().syntax() {
            Syntax::Proto2 => {}
            Syntax::Proto3 => {}
            _ => panic!("Unknown syntax"),
        }

        Ok(())
    }
}

fn default_field_value(field: &FieldDescriptor, crate_name: &str) -> String {
    match field.label() {
        FieldLabel::Optional | FieldLabel::Required => {
            if field.file().syntax() == Syntax::Proto2 {
                format!("::std::option::Option::None")
            } else {
                match field.field_type() {
                    FieldType::Message(_) | FieldType::Group(_) => {
                        format!("::std::option::Option::None")
                    }
                    FieldType::String => format!("::std::string::String::new()"),
                    FieldType::Bytes => format!("::std::vec::Vec::new()"),
                    _ => "Self::".to_string() + &names::get_field_default_value_name(field),
                }
            }
        }
        FieldLabel::Repeated => {
            if let FieldType::Message(m) = field.field_type() {
                if m.map_entry() {
                    return format!("{}::collections::MapField::new()", crate_name);
                }
            }

            format!("{}::collections::RepeatedField::new()", crate_name)
        }
    }
}

fn is_copy_type(ft: &FieldType) -> bool {
    match ft {
        FieldType::Message(_) | FieldType::Group(_) | FieldType::Bytes | FieldType::String => false,
        _ => true,
    }
}

generator_new!(EnumDescriptor, proto, options;
    "type_name", names::get_enum_type_name(proto),
    "crate_name", options.crate_name.clone(),
    "full_type_name", names::get_full_enum_type_name(proto, proto.file(), &options.crate_name));

impl<W: Write> Generator<'_, EnumDescriptor, W> {
    pub fn generate(&mut self) -> Result {
        genln!(
            self.printer,
            "#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]"
        );
        genln!(self.printer; "pub enum {type_name} {{" => self.vars, type_name);
        indent!(self.printer, {
            for value in self.proto.values() {
                Generator::<EnumValueDescriptor, _>::from_other(self, value).generate_variant()?;
            }
        });
        genln!(self.printer, "}}");
        genln!(self.printer; "impl ::std::convert::TryFrom<i32> for {full_type_name} {{" => self.vars, full_type_name);
        indent!(self.printer, {
            genln!(self.printer; "type Error = {crate_name}::VariantUndefinedError;" => self.vars, crate_name);
            genln!(self.printer; "fn try_from(value: i32) -> ::std::result::Result<Self, {crate_name}::VariantUndefinedError> {{" => self.vars, crate_name);
            indent!(self.printer, {
                genln!(self.printer, "match value {{");
                indent!(self.printer, {
                    for value in self.proto.values() {
                        Generator::<EnumValueDescriptor, _>::from_other(self, value)
                            .generate_int_match()?;
                    }
                    genln!(self.printer; "_ => ::std::result::Result::Err({crate_name}::VariantUndefinedError)" => self.vars, crate_name);
                });
                genln!(self.printer, "}}");
            });
            genln!(self.printer, "}}");
        });
        genln!(self.printer, "}}");
        genln!(self.printer; "impl ::std::convert::From<{full_type_name}> for i32 {{" => self.vars, full_type_name);
        indent!(self.printer, {
            genln!(self.printer; "fn from(value: {full_type_name}) -> i32 {{" => self.vars, full_type_name);
            indent!(self.printer, {
                genln!(self.printer, "value as i32");
            });
            genln!(self.printer, "}}");
        });
        genln!(self.printer, "}}");

        Ok(())
    }
}

generator_new!(EnumValueDescriptor, proto, options;
    "full_variant", names::get_full_enum_variant_name(proto, proto.file(), &options.crate_name),
    "variant", names::get_enum_variant_name(proto),
    "number", proto.number().to_string());

impl<W: Write> Generator<'_, EnumValueDescriptor, W> {
    pub fn generate_variant(&mut self) -> Result {
        genln!(self.printer; "{variant} = {number}," => self.vars, variant, number);
        Ok(())
    }

    pub fn generate_int_match(&mut self) -> Result {
        genln!(self.printer; "{number} => ::std::result::Result::Ok({full_variant})," => self.vars, number, full_variant);
        Ok(())
    }
}

generator_new!(OneofDescriptor, proto, options;
    "name", proto.name().clone(),
    "field_name", proto.name().clone(),
    "type_name", names::get_oneof_name(proto));

impl<W: Write> Generator<'_, OneofDescriptor, W> {
    pub fn generate_type(&mut self) -> Result {
        genln!(self.printer, "#[derive(Clone, Debug, PartialEq)]");
        genln!(self.printer; "pub enum {type_name} {{" => self.vars, type_name);
        indent!(self.printer, {
            genln!(self.printer, "None,");

            for field in self.proto.fields() {
                Generator::<FieldDescriptor, _>::from_other(self, field).generate_oneof_field()?;
            }
        });
        genln!(self.printer, "}}");
        Ok(())
    }

    pub fn generate_clone(&mut self) -> Result {
        genln!(self.printer; "{field_name}: self.{field_name}.clone()," => self.vars, field_name);
        Ok(())
    }

    pub fn generate_struct_field(&mut self) -> Result {
        if self.options.pub_fields || self.proto.file().syntax() == Syntax::Proto3 {
            genln!(self.printer; "pub {field_name}: {type_name}," => self.vars, field_name, type_name);
        } else {
            genln!(self.printer; "{field_name}: {type_name}," => self.vars, field_name, type_name);
        }
        Ok(())
    }

    pub fn generate_new(&mut self) -> Result {
        genln!(self.printer; "{field_name}: self::{type_name}::None," => self.vars, field_name, type_name);
        Ok(())
    }

    pub fn generate_accessor(&mut self) -> Result {
        genln!(self.printer; "pub fn {field_name}(&self) -> &{type_name} {{" => self.vars, field_name, type_name);
        indent!(self.printer, {
            genln!(self.printer; "&self.{field_name}" => self.vars, field_name);
        });
        genln!(self.printer, "}}");

        genln!(self.printer; "pub fn {field_name}_mut(&mut self) -> &mut {type_name} {{" => self.vars, field_name, type_name);
        indent!(self.printer, {
            genln!(self.printer; "&mut self.{field_name}" => self.vars, field_name);
        });
        genln!(self.printer, "}}");

        Ok(())
    }
}
