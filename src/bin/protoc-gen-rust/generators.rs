use crate::{names, printer, Options};
use protrust::descriptor::FileOptions_OptimizeMode as OptimizeMode;
use protrust::io::{self, WireType};
use protrust::prelude::*;
use protrust::reflect::*;
use pulldown_cmark::{Parser, Event, Tag};
use std::collections::HashMap;
use std::fmt::Write;

macro_rules! var {
    ($target:expr, $var:expr) => {
        $target
            .get(stringify!($var))
            .ok_or_else(|| Error::MissingVariable(stringify!($var)))?
    };
}

macro_rules! gen {
    ($target:expr; $fmt:expr => $vars:expr, $($arg:ident),*) => (write!($target, $fmt, $($arg = var!($vars, $arg)),*)?);
    ($dst:expr, $($arg:tt)*) => (write!($dst, $($arg)*)?);
}

macro_rules! genln {
    ($target:expr; $fmt:expr => $vars:expr, $($arg:ident),*) => {
        {
            writeln!($target)?; 
            write!($target, $fmt, $($arg = var!($vars, $arg)),*)?;
        }
    };
    ($dst:expr, $($arg:tt)*) => {
        {
            writeln!($dst)?; 
            write!($dst, $($arg)*)?;
        }
    };
    ($dst:expr) => (writeln!($dst)?)
}

macro_rules! indent {
    ($target:expr, $block:block) => {
        $target.indent();
        $block
        $target.unindent();
    };
}

macro_rules! generator_new {
    ($type:ty, $p:ident, $o:ident; $($key:expr, $value:expr),*) => {
        impl<'a, W> Generator<'a, $type, W> {
            pub fn new(printer: &'a mut printer::Printer<W>, $p: &'a $type, $o: &'a Options) -> Generator<'a, $type, W> {
                let mut generator = Generator {
                    printer,
                    proto: $p,
                    options: $o,
                    vars: HashMap::new()
                };
                $(
                    generator.vars.insert($key, $value);
                )*
                generator
            }

            #[allow(dead_code)]
            pub fn from_other<'b, T>(other: &'a mut Generator<'b, T, W>, proto: &'b $type) -> Generator<'a, $type, W> {
                Self::new(&mut other.printer, proto, &other.options)
            }
        }
    };
}

pub type Result = std::result::Result<(), Error>;

#[derive(Debug)]
pub enum Error {
    FormatError,
    MissingVariable(&'static str),
}

impl From<std::fmt::Error> for Error {
    fn from(_: std::fmt::Error) -> Error {
        Error::FormatError
    }
}

pub struct Generator<'a, T, W> {
    vars: HashMap<&'static str, String>,
    printer: &'a mut printer::Printer<W>,
    proto: &'a T,
    options: &'a Options,
}

generator_new!(FileDescriptor, proto, options;
    "file", proto.name().to_string(),
    "crate_name", options.crate_name.clone(),
    "dep_count", proto.dependencies().len().to_string());

impl<W: Write> Generator<'_, FileDescriptor, W> {
    pub fn generate(&mut self) -> Result {
        gen!(self.printer, "// DO NOT EDIT!");
        genln!(
            self.printer,
            "// Generated by protoc-gen-rust, part of the protrust crate."
        );
        genln!(self.printer, "//");
        genln!(self.printer; "// Source: {file}\n" => self.vars, file);

        // static descriptor code
        if self.proto.file().options().map(|o| o.optimize_for())
            != Some(EnumValue::Defined(OptimizeMode::LiteRuntime))
        {
            self.generate_descriptor_code()?;
        }

        // extensions
        //for _extension in self.proto.extensions() {
        //
        //}

        // messages
        for message in self.proto.messages() {
            Generator::<MessageDescriptor, _>::from_other(self, message).generate()?;
        }

        // enums
        for enum_type in self.proto.enums() {
            Generator::<EnumDescriptor, _>::from_other(self, enum_type).generate()?;
        }

        Ok(())
    }

    pub fn generate_descriptor_code(&mut self) -> Result {
        genln!(
            self.printer,
            "static FILE_ONCE: ::std::sync::Once = ::std::sync::Once::new();"
        );
        genln!(self.printer; "static mut FILE_POOL: ::std::option::Option<{crate_name}::reflect::DescriptorPool<'static>> = ::std::option::Option::None;" => self.vars, crate_name);
        genln!(self.printer; "static mut FILE_PROTO: ::std::option::Option<[{crate_name}::descriptor::FileDescriptorProto; 1]> = ::std::option::Option::None;" => self.vars, crate_name);
        genln!(self.printer; "static mut FILE_DESCRIPTOR: ::std::option::Option<&'static {crate_name}::reflect::FileDescriptor> = ::std::option::Option::None;" => self.vars, crate_name);
        genln!(self.printer; "static mut FILE_DEPS: ::std::option::Option<[&'static {crate_name}::reflect::DescriptorPool<'static>; {dep_count}]> = ::std::option::Option::None;" => self.vars, crate_name, dep_count);
        genln!(self.printer, "static FILE_BINARY: &'static [u8] = &[");
        indent!(self.printer, {
            genln!(self.printer);
            let mut new_proto = self.proto.proto().clone();
            new_proto.clear_source_code_info();
            let vec = new_proto.write_to_vec().unwrap();
            let mut bytes_on_line = 0;
            for byte in vec {
                gen!(self.printer, "{}, ", byte);
                bytes_on_line += 1;
                if bytes_on_line == 20 {
                    genln!(self.printer);
                    bytes_on_line = 0;
                }
            }
        });
        genln!(self.printer, "];");
        genln!(self.printer);
        genln!(self.printer, "fn file_once_init() {{");
        indent!(self.printer, {
            genln!(self.printer, "unsafe {{");
            indent!(self.printer, {
                genln!(self.printer; "FILE_PROTO = ::std::option::Option::Some([{crate_name}::LiteMessage::read_new(&mut FILE_BINARY.as_ref()).expect(\"Could not read file descriptor\")]);" => self.vars, crate_name);
                genln!(self.printer, "FILE_DEPS = ::std::option::Option::Some([");
                for file in self.proto.dependencies() {
                    gen!(
                        self.printer,
                        "{}::pool(), ",
                        names::get_rust_external_mod_name(file, &self.options.crate_name)
                    );
                }
                gen!(self.printer, "]);");
                genln!(self.printer; "FILE_POOL = ::std::option::Option::Some({crate_name}::reflect::DescriptorPool::build_generated_pool(" => self.vars, crate_name);
                indent!(self.printer, {
                    genln!(self.printer, "FILE_PROTO.as_ref().unwrap(),");
                    genln!(self.printer, "FILE_DEPS.as_ref().unwrap(),");
                    genln!(self.printer; "{crate_name}::reflect::GeneratedCodeInfo {{" => self.vars, crate_name);
                    indent!(self.printer, {
                        if self.proto.messages().len() == 0 {
                            genln!(self.printer, "structs: ::std::option::Option::None,");
                        } else {
                            genln!(self.printer, "structs: ::std::option::Option::Some(::std::boxed::Box::new([");
                            indent!(self.printer, {
                                for message in self.proto.messages().iter().filter(|m| !m.map_entry()) {
                                    Generator::<MessageDescriptor, _>::from_other(self, message).generate_struct_info()?;
                                }
                            });
                            genln!(self.printer, "])),");
                        }
                    });
                    genln!(self.printer, "}}");
                });
                genln!(self.printer, "));");
                genln!(self.printer; "FILE_DESCRIPTOR = ::std::option::Option::Some(FILE_POOL.as_ref().unwrap().find_file_by_name(\"{file}\").unwrap());" => self.vars, file);
            });
            genln!(self.printer, "}}");
        });
        genln!(self.printer, "}}");
        genln!(self.printer);
        genln!(
            self.printer,
            "/// Gets the pool containing all the symbols in this proto file and its dependencies"
        );
        genln!(self.printer; "pub fn pool() -> &'static {crate_name}::reflect::DescriptorPool<'static> {{" => self.vars, crate_name);
        indent!(self.printer, {
            genln!(self.printer, "unsafe {{");
            indent!(self.printer, {
                genln!(self.printer, "FILE_ONCE.call_once(file_once_init);");
                genln!(self.printer, "FILE_POOL.as_ref().unwrap()");
            });
            genln!(self.printer, "}}");
        });
        genln!(self.printer, "}}");
        genln!(
            self.printer,
            "/// Gets the file descriptor representing the proto that created this generated file"
        );
        genln!(self.printer; "pub fn file() -> &'static {crate_name}::reflect::FileDescriptor {{" => self.vars, crate_name);
        indent!(self.printer, {
            genln!(self.printer, "unsafe {{");
            indent!(self.printer, {
                genln!(self.printer, "FILE_ONCE.call_once(file_once_init);");
                genln!(self.printer, "FILE_DESCRIPTOR.as_ref().unwrap()");
            });
            genln!(self.printer, "}}");
        });
        genln!(self.printer, "}}");

        Ok(())
    }
}

generator_new!(MessageDescriptor, proto, options;
    "type_name", names::get_message_type_name(proto),
    "full_type_name", names::get_full_message_type_name(proto, proto.file(), &options.crate_name),
    "crate_name", options.crate_name.clone());

impl<W: Write> Generator<'_, MessageDescriptor, W> {
    pub fn generate_rustdoc_comments(&mut self) -> Result {
        if let Some(source_info) = self.proto.source_code_info() {
            generate_rustdoc_comments(self.printer, source_info)?;
        }

        Ok(())
    }

    pub fn generate_struct_info(&mut self) -> Result {
        genln!(self.printer; "{crate_name}::reflect::GeneratedStructInfo {{" => self.vars, crate_name);
        indent!(self.printer, {
            genln!(self.printer; "new: || ::std::boxed::Box::new(<{full_type_name} as {crate_name}::LiteMessage>::new())," => self.vars, full_type_name, crate_name);
            if self.proto.messages().len() == 0 {
                genln!(self.printer, "structs: ::std::option::Option::None,");
            } else {
                genln!(self.printer, "structs: ::std::option::Option::Some(::std::boxed::Box::new([");
                indent!(self.printer, {
                    for message in self.proto.messages().iter().filter(|m| !m.map_entry()) {
                        Generator::<MessageDescriptor, _>::from_other(self, message).generate_struct_info()?;
                    }
                });
                genln!(self.printer, "])),");
            }
        });
        genln!(self.printer, "}},");
        Ok(())
    }

    pub fn generate(&mut self) -> Result {
        self.generate_rustdoc_comments()?;
        genln!(self.printer, "#[derive(Clone, Debug, PartialEq)]");
        genln!(self.printer; "pub struct {type_name} {{" => self.vars, type_name);
        indent!(self.printer, {
            for field in self.proto.message_fields() {
                Generator::<FieldDescriptor, _>::from_other(self, field).generate_struct_field()?;
            }

            for oneof in self.proto.oneofs() {
                Generator::<OneofDescriptor, _>::from_other(self, oneof).generate_struct_field()?;
            }

            genln!(self.printer; "unknown_fields: {crate_name}::UnknownFieldSet" => self.vars, crate_name);
        });
        genln!(self.printer, "}}");

        for field in self.proto.fields() {
            Generator::<FieldDescriptor, _>::from_other(self, field).generate_codec()?;
        }

        for oneof in self.proto.oneofs() {
            Generator::<OneofDescriptor, _>::from_other(self, oneof).generate_type()?;
        }

        self.generate_coded_message_impl()?;
        self.generate_lite_message_impl()?;

        if self.proto.file().options().map(|o| o.optimize_for())
            != Some(EnumValue::Defined(OptimizeMode::LiteRuntime))
        {
            self.generate_message_impl()?;
        }

        self.generate_struct_impl()?;

        for nested in self.proto.messages().iter().filter(|m| !m.map_entry()) {
            Generator::<MessageDescriptor, _>::from_other(self, nested).generate()?;
        }

        for nested in self.proto.enums() {
            Generator::<EnumDescriptor, _>::from_other(self, nested).generate()?;
        }

        Ok(())
    }

    pub fn generate_coded_message_impl(&mut self) -> Result {
        genln!(self.printer; "impl {crate_name}::CodedMessage for {full_type_name} {{" => self.vars, crate_name, full_type_name);
        indent!(self.printer, {
            genln!(self.printer; "fn merge_from(&mut self, input: &mut {crate_name}::io::CodedInput) -> {crate_name}::io::InputResult<()> {{" => self.vars, crate_name);
            indent!(self.printer, {
                genln!(
                    self.printer,
                    "while let ::std::option::Option::Some(tag) = input.read_tag()? {{"
                );
                indent!(self.printer, {
                    genln!(self.printer, "match tag.get() {{");
                    indent!(self.printer, {
                        for field in self.proto.fields() {
                            Generator::<FieldDescriptor, _>::from_other(self, field)
                                .generate_merge_arm()?;
                        }
                        genln!(
                            self.printer,
                            "_ => self.unknown_fields.merge_from(tag, input)?"
                        );
                    });
                    genln!(self.printer, "}}");
                });
                genln!(self.printer, "}}");
                genln!(self.printer, "::std::result::Result::Ok(())");
            });
            genln!(self.printer, "}}");

            if self.options.size_checks {
                genln!(
                    self.printer,
                    "fn calculate_size(&self) -> ::std::option::Option<i32> {{"
                );
            } else {
                genln!(self.printer, "fn calculate_size(&self) -> i32 {{");
            }
            indent!(self.printer, {
                genln!(self.printer, "let mut size = 0i32;");
                for field in self.proto.fields() {
                    Generator::<FieldDescriptor, _>::from_other(self, field)
                        .generate_size_calculator()?;
                }
                if self.options.size_checks {
                    genln!(
                        self.printer,
                        "size = size.checked_add(self.unknown_fields.calculate_size()?)?;"
                    );
                    genln!(self.printer, "::std::option::Option::Some(size)");
                } else {
                    genln!(
                        self.printer,
                        "size += self.unknown_fields.calculate_size();"
                    );
                    genln!(self.printer, "size");
                }
            });
            genln!(self.printer, "}}");

            genln!(self.printer; "fn write_to(&self, output: &mut {crate_name}::io::CodedOutput) -> {crate_name}::io::OutputResult {{" => self.vars, crate_name);
            indent!(self.printer, {
                for field in self.proto.fields() {
                    Generator::<FieldDescriptor, _>::from_other(self, field).generate_writer()?;
                }
                genln!(self.printer, "self.unknown_fields.write_to(output)?;");
                genln!(self.printer, "::std::result::Result::Ok(())");
            });
            genln!(self.printer, "}}");
        });
        genln!(self.printer, "}}");

        Ok(())
    }

    pub fn generate_lite_message_impl(&mut self) -> Result {
        genln!(self.printer; "impl {crate_name}::LiteMessage for {full_type_name} {{" => self.vars, crate_name, full_type_name);
        indent!(self.printer, {
            genln!(self.printer, "fn new() -> Self {{");
            indent!(self.printer, {
                genln!(self.printer, "Self {{");
                indent!(self.printer, {
                    for field in self.proto.message_fields() {
                        Generator::<FieldDescriptor, _>::from_other(self, field).generate_new()?;
                    }

                    for oneof in self.proto.oneofs() {
                        Generator::<OneofDescriptor, _>::from_other(self, oneof).generate_new()?;
                    }

                    genln!(
                        self.printer,
                        "unknown_fields: {}::UnknownFieldSet::new()",
                        self.options.crate_name
                    );
                });
                genln!(self.printer, "}}");
            });
            genln!(self.printer, "}}");
            genln!(self.printer, "fn merge(&mut self, other: &Self) {{");
            indent!(self.printer, {
                for field in self.proto.fields() {
                    Generator::<FieldDescriptor, _>::from_other(self, field)
                        .generate_field_merge()?;
                }

                genln!(
                    self.printer,
                    "self.unknown_fields.merge(&other.unknown_fields);"
                );
            });
            genln!(self.printer, "}}");
        });
        genln!(self.printer, "}}");

        Ok(())
    }

    pub fn generate_message_impl(&mut self) -> Result {
        genln!(self.printer; "impl {crate_name}::Message for {full_type_name} {{" => self.vars, crate_name, full_type_name);
        indent!(self.printer, {
            genln!(self.printer; "fn descriptor() -> &'static {crate_name}::reflect::MessageDescriptor {{" => self.vars, crate_name);
            indent!(self.printer, {
                genln!(self.printer, "&self::file()");
                let mut message_access = format!(".messages()[{}]", self.proto.scope_index());
                let mut scope = self.proto.scope();
                while let CompositeScope::Message(m) = scope {
                    message_access.insert_str(0, &format!(".messages()[{}]", m.scope_index()));
                    scope = m.scope();
                }
                gen!(self.printer, "{}", message_access);
            });
            genln!(self.printer, "}}");
        });
        genln!(self.printer, "}}");
        Ok(())
    }

    pub fn generate_struct_impl(&mut self) -> Result {
        genln!(self.printer; "impl {full_type_name} {{" => self.vars, full_type_name);
        indent!(self.printer, {
            for field in self.proto.message_fields() {
                let mut generator = Generator::<FieldDescriptor, _>::from_other(self, field);

                generator.generate_field_number_constant()?;
                generator.generate_default_value()?;
                generator.generate_accessors()?;
            }

            for oneof in self.proto.oneofs() {
                Generator::<OneofDescriptor, _>::from_other(self, oneof).generate_accessor()?;
            }
        });
        genln!(self.printer, "}}");

        Ok(())
    }
}

generator_new!(FieldDescriptor, proto, options;
    "proto_name", proto.name().to_string(),
    "proto_type", names::get_proto_type(proto),
    "name", names::get_field_name(proto),
    "field_name", names::get_struct_field_name(proto),
    "base_type", names::get_rust_type(names::TypeResolution::Base, proto, &options.crate_name),
    "indirected_type", names::get_rust_type(names::TypeResolution::Indirection, proto, &options.crate_name),
    "field_type", names::get_rust_type(names::TypeResolution::Full, proto, &options.crate_name),
    "crate_name", options.crate_name.clone(),
    "new_value", default_field_value(proto, &options.crate_name),
    "field_number_const", names::get_field_number_const_name(proto),
    "number", proto.number().get().to_string(),
    "default", names::get_field_default_value_name(proto),
    "default_type", match proto.field_type() {
        FieldType::String => format!("&'static str"),
        FieldType::Bytes => format!("&'static [u8]"),
        _ => names::get_rust_type(names::TypeResolution::Indirection, proto, &options.crate_name),
    },
    "default_value", {
        match proto.default_value() {
            DefaultValue::Invalid | DefaultValue::None => {
                match proto.field_type() {
                    FieldType::Message(_) | FieldType::Group(_) => String::new(),
                    FieldType::Enum(e) => {
                        match e.values().iter().find(|f| f.number() == 0) {
                            Some(defined) => {
                                format!("{}::EnumValue::Defined({})", options.crate_name, names::get_full_enum_variant_name(defined, proto.file(), &options.crate_name))
                            },
                            None => {
                                format!("{}::EnumValue::Undefined(0)", options.crate_name)
                            }
                        }
                    },
                    FieldType::String => format!("\"\""),
                    FieldType::Bytes => format!("&[]"),
                    FieldType::Bool => format!("false"),
                    FieldType::Float | FieldType::Double => format!("0.0"),
                    _ => format!("0")
                }
            },
            DefaultValue::String(s) => s.chars().flat_map(char::escape_default).collect(),
            DefaultValue::Bool(b) => b.to_string(),
            DefaultValue::Double(d) => d.to_string(),
            DefaultValue::SignedInt(s) => s.to_string(),
            DefaultValue::UnsignedInt(u) => u.to_string(),
            DefaultValue::Enum(e) => format!("{}::EnumValue::Defined({})", options.crate_name, names::get_full_enum_variant_name(e, proto.file(), &options.crate_name)),
            DefaultValue::Bytes(b) => format!("&{:?}", b)
        }
    },
    "codec", names::get_field_codec_name(proto),
    "oneof", {
        match proto.scope() {
            FieldScope::Oneof(o) => names::get_oneof_name(o),
            _ => String::new()
        }
    },
    "tag_size", protrust::io::sizes::uint32(io::Tag::new(proto.number(), proto.wire_type()).get()).to_string(),
    "tag", io::Tag::new(proto.number(), proto.wire_type()).get().to_string(),
    "tags", {
        if proto.packed() {
            format!("{} | {}", io::Tag::new(proto.number(), proto.wire_type()).get(), io::Tag::new(proto.number(), proto.field_type().wire_type()).get())
        } else {
            io::Tag::new(proto.number(), proto.wire_type()).get().to_string()
        }
    },
    "end_tag", {
        if let FieldType::Group(_) = proto.field_type() {
            io::Tag::new(proto.number(), WireType::EndGroup).get().to_string()
        } else {
            String::new()
        }
    },
    "tag_bytes", {
        let tag = io::Tag::new(proto.number(), proto.wire_type()).get().to_le();

        let mut bytes = Vec::with_capacity(protrust::io::sizes::uint32(tag) as usize);
        let mut output = protrust::io::CodedOutput::new(&mut bytes);
        output.write_raw_tag(tag).expect("Couldn't write tag to vector");

        format!("{:?}", bytes)
    },
    "end_tag_bytes", {
        if let FieldType::Group(_) = proto.field_type() {
            let tag = io::Tag::new(proto.number(), WireType::EndGroup).get().to_le();

            let mut bytes = Vec::with_capacity(protrust::io::sizes::uint32(tag) as usize);
            let mut output = protrust::io::CodedOutput::new(&mut bytes);
            output.write_raw_tag(tag).expect("Couldn't write tag to vector");

            format!("{:?}", bytes)
        } else {
            String::new()
        }
    });

impl<W: Write> Generator<'_, FieldDescriptor, W> {
    pub fn generate_rustdoc_comments(&mut self) -> Result {
        if let Some(source_info) = self.proto.source_code_info() {
            generate_rustdoc_comments(self.printer, source_info)?
        }

        Ok(())
    }

    pub fn generate_struct_field(&mut self) -> Result {
        genln!(self.printer; "{field_name}: {field_type}," => self.vars, field_name, field_type);

        Ok(())
    }

    pub fn generate_oneof_field(&mut self) -> Result {
        self.generate_rustdoc_comments()?;
        genln!(self.printer; "{name}({indirected_type})," => self.vars, name, indirected_type);
        Ok(())
    }

    pub fn generate_new(&mut self) -> Result {
        genln!(self.printer; "{field_name}: {new_value}," => self.vars, field_name, new_value);
        Ok(())
    }

    pub fn generate_field_merge(&mut self) -> Result {
        match self.proto.scope() {
            FieldScope::Oneof(_) => {
                if is_copy_type(self.proto.field_type()) {
                    genln!(self.printer; "if let self::{oneof}::{name}({field_name}) = other.{field_name} {{" => self.vars, oneof, name, field_name);
                } else {
                    genln!(self.printer; "if let self::{oneof}::{name}({field_name}) = &other.{field_name} {{" => self.vars, oneof, name, field_name);
                }
                indent!(self.printer, {
                    match self.proto.field_type() {
                        FieldType::Message(_) | FieldType::Group(_) => {
                            genln!(self.printer; "if let self::{oneof}::{name}(existing) = &mut self.{field_name} {{" => self.vars, oneof, name, field_name);
                            indent!(self.printer, {
                                genln!(self.printer; "existing.merge({field_name});" => self.vars, field_name);
                            });
                            genln!(self.printer, "}} else {{");
                            indent!(self.printer, {
                                genln!(self.printer; "self.{field_name} = self::{oneof}::{name}({field_name}.clone());" => self.vars, field_name, name, oneof);
                            });
                            genln!(self.printer, "}}");
                        }
                        FieldType::Bytes | FieldType::String => {
                            genln!(self.printer; "self.{field_name} = self::{oneof}::{name}({field_name}.clone());" => self.vars, field_name, name, oneof);
                        }
                        _ => {
                            genln!(self.printer; "self.{field_name} = self::{oneof}::{name}({field_name});" => self.vars, field_name, name, oneof);
                        }
                    }
                });
                genln!(self.printer, "}}");
            }
            FieldScope::Message(_) => match self.proto.label() {
                FieldLabel::Optional | FieldLabel::Required => match self.proto.field_type() {
                    FieldType::Message(_) | FieldType::Group(_) => {
                        genln!(self.printer; "if let ::std::option::Option::Some({field_name}) = &other.{field_name} {{" => self.vars, field_name);
                        indent!(self.printer, {
                            genln!(self.printer; "self.{field_name}.get_or_insert_with(|| ::std::boxed::Box::new({crate_name}::LiteMessage::new())).merge({field_name});" => self.vars, crate_name, field_name);
                        });
                        genln!(self.printer, "}}");
                    }
                    FieldType::Bytes | FieldType::String => {
                        genln!(self.printer; "self.{field_name} = other.{field_name}.clone();" => self.vars, field_name);
                    }
                    _ => {
                        genln!(self.printer;"self.{field_name} = other.{field_name};" => self.vars, field_name);
                    }
                },
                FieldLabel::Repeated => {
                    genln!(self.printer; "self.{field_name}.merge(&other.{field_name});" => self.vars, field_name);
                }
            },
            _ => {}
        }

        Ok(())
    }

    pub fn generate_merge_arm(&mut self) -> Result {
        genln!(self.printer; "{tags} => " => self.vars, tags);

        match self.proto.label() {
            FieldLabel::Repeated => match self.proto.field_type() {
                FieldType::Message(m) if m.map_entry() => {
                    gen!(self.printer; "self.{field_name}.add_entries(input, &{codec})?" => self.vars, field_name, codec)
                }
                _ => {
                    gen!(self.printer; "self.{field_name}.add_entries(tag.get(), input, &{codec})?" => self.vars, field_name, codec)
                }
            },
            _ => match self.proto.scope() {
                FieldScope::Message(_) => match self.proto.field_type() {
                    FieldType::Message(_) | FieldType::Group(_) => {
                        gen!(self.printer; "input.read_message(&mut **self.{field_name}.get_or_insert_with(|| ::std::boxed::Box::new({crate_name}::LiteMessage::new())))?" => self.vars, field_name, crate_name)
                    }
                    _ => {
                        gen!(self.printer; "self.{field_name} = " => self.vars, field_name);
                        if self.proto.file().syntax() == Syntax::Proto2 {
                            gen!(self.printer, "::std::option::Option::Some(");
                        }

                        gen!(self.printer; "input.read_{proto_type}()?" => self.vars, proto_type);

                        if self.proto.file().syntax() == Syntax::Proto2 {
                            gen!(self.printer, ")");
                        }
                    }
                },
                FieldScope::Oneof(_) => match self.proto.field_type() {
                    FieldType::Message(_) | FieldType::Group(_) => {
                        indent!(self.printer, {
                            genln!(self.printer; "if let self::{oneof}::{name}({field_name}) = &mut self.{field_name} {{" => self.vars, oneof, name, field_name);
                            indent!(self.printer, {
                                genln!(self.printer; "{field_name}.merge_from(input)?;" => self.vars, field_name);
                            });
                            genln!(self.printer, "}} else {{");
                            indent!(self.printer, {
                                genln!(self.printer; "let mut {field_name} = ::std::boxed::Box::new(<{base_type} as {crate_name}::LiteMessage>::new());" => self.vars, field_name, base_type, crate_name);
                                genln!(self.printer; "{field_name}.merge_from(input)?;" => self.vars, field_name);
                                genln!(self.printer; "self.{field_name} = self::{oneof}::{name}({field_name})" => self.vars, field_name, oneof, name);
                            });
                            genln!(self.printer, "}}");
                        });
                    }
                    _ => {
                        gen!(self.printer; "self.{field_name} = self::{oneof}::{name}(input.read_{proto_type}()?)" => self.vars, field_name, oneof, name, proto_type)
                    }
                },
                _ => unreachable!(),
            },
        }

        gen!(self.printer, ",");

        Ok(())
    }

    pub fn generate_size_calculator(&mut self) -> Result {
        if self.proto.label() == FieldLabel::Repeated {
            if self.options.size_checks {
                genln!(self.printer; "size = size.checked_add(self.{field_name}.calculate_size(&{codec})?)?;" => self.vars, field_name, codec);
            } else {
                genln!(self.printer; "size += self.{field_name}.calculate_size(&{codec});" => self.vars, field_name, codec);
            }
        } else {
            if let FieldScope::Oneof(_) = self.proto.scope() {
                if is_copy_type(self.proto.field_type()) {
                    genln!(self.printer; "if let self::{oneof}::{name}({field_name}) = self.{field_name} {{" => self.vars, oneof, name, field_name);
                } else {
                    genln!(self.printer; "if let self::{oneof}::{name}({field_name}) = &self.{field_name} {{" => self.vars, oneof, name, field_name);
                }
                self.printer.indent();
            } else {
                if is_copy_type(self.proto.field_type()) {
                    genln!(self.printer; "let {field_name} = self.{field_name};" => self.vars, field_name);
                } else {
                    genln!(self.printer; "let {field_name} = &self.{field_name};" => self.vars, field_name);
                }

                match self.proto.field_type() {
                    FieldType::Message(_) | FieldType::Group(_) => {
                        genln!(self.printer; "if let ::std::option::Option::Some({field_name}) = {field_name} {{" => self.vars, field_name);
                        self.printer.indent();
                    }
                    _ => {
                        if self.proto.file().syntax() == Syntax::Proto2 {
                            genln!(self.printer; "if let ::std::option::Option::Some({field_name}) = {field_name} {{" => self.vars, field_name);
                            self.printer.indent();
                        }
                        match self.proto.field_type() {
                            FieldType::Bytes => {
                                genln!(self.printer; "if {field_name}.as_slice() != Self::{default} {{" => self.vars, field_name, default);
                            }
                            _ => {
                                genln!(self.printer; "if {field_name} != Self::{default} {{" => self.vars, field_name, default);
                            }
                        }
                        self.printer.indent();
                    }
                }
            }

            if self.options.size_checks {
                genln!(self.printer; "size = size.checked_add({tag_size})?;" => self.vars, tag_size);

                match self.proto.field_type() {
                    FieldType::Message(_) | FieldType::Group(_) => {
                        genln!(self.printer; "size = size.checked_add({crate_name}::io::sizes::{proto_type}(&**{field_name}));" => self.vars, field_name, crate_name, proto_type);
                    },
                    _ => {
                        genln!(self.printer; "size = size.checked_add({crate_name}::io::sizes::{proto_type}({field_name}));" => self.vars, field_name, crate_name, proto_type);
                    }
                }
            } else {
                genln!(self.printer; "size += {tag_size};" => self.vars, tag_size);

                match self.proto.field_type() {
                    FieldType::Message(_) | FieldType::Group(_) => {
                        genln!(self.printer; "size += {crate_name}::io::sizes::{proto_type}(&**{field_name});" => self.vars, field_name, crate_name, proto_type);
                    },
                    _ => {
                        genln!(self.printer; "size += {crate_name}::io::sizes::{proto_type}({field_name});" => self.vars, field_name, crate_name, proto_type);
                    }
                }
            }

            if let FieldScope::Oneof(_) = self.proto.scope() {
                self.printer.unindent();
                gen!(self.printer, "\n}}");
            } else {
                match self.proto.field_type() {
                    FieldType::Message(_) | FieldType::Group(_) => {
                        self.printer.unindent();
                        gen!(self.printer, "\n}}");
                    }
                    _ => {
                        if self.proto.file().syntax() == Syntax::Proto2 {
                            self.printer.unindent();
                            gen!(self.printer, "\n}}");
                        }
                        self.printer.unindent();
                        gen!(self.printer, "\n}}");
                    }
                }
            }
        }

        Ok(())
    }

    pub fn generate_writer(&mut self) -> Result {
        if self.proto.label() == FieldLabel::Repeated {
            genln!(self.printer; "self.{field_name}.write_to(output, &{codec})?;" => self.vars, field_name, codec);
        } else {
            if let FieldScope::Oneof(_) = self.proto.scope() {
                if is_copy_type(self.proto.field_type()) {
                    genln!(self.printer; "if let self::{oneof}::{name}({field_name}) = self.{field_name} {{" => self.vars, oneof, name, field_name);
                } else {
                    genln!(self.printer; "if let self::{oneof}::{name}({field_name}) = &self.{field_name} {{" => self.vars, oneof, name, field_name);
                }
                self.printer.indent();
            } else {
                if is_copy_type(self.proto.field_type()) {
                    genln!(self.printer; "let {field_name} = self.{field_name};" => self.vars, field_name);
                } else {
                    genln!(self.printer; "let {field_name} = &self.{field_name};" => self.vars, field_name);
                }

                match self.proto.field_type() {
                    FieldType::Message(_) | FieldType::Group(_) => {
                        genln!(self.printer; "if let ::std::option::Option::Some({field_name}) = {field_name} {{" => self.vars, field_name);
                        self.printer.indent();
                    }
                    _ => {
                        if self.proto.file().syntax() == Syntax::Proto2 {
                            genln!(self.printer; "if let ::std::option::Option::Some({field_name}) = {field_name} {{" => self.vars, field_name);
                            self.printer.indent();
                        }
                        match self.proto.field_type() {
                            FieldType::Bytes => {
                                genln!(self.printer; "if {field_name}.as_slice() != Self::{default} {{" => self.vars, field_name, default);
                            }
                            _ => {
                                genln!(self.printer; "if {field_name} != Self::{default} {{" => self.vars, field_name, default);
                            }
                        }
                        self.printer.indent();
                    }
                }
            }

            genln!(self.printer; "output.write_raw_tag_bytes(&{tag_bytes})?;" => self.vars, tag_bytes);
            match self.proto.field_type() {
                FieldType::Message(_) | FieldType::Group(_) => {
                    genln!(self.printer; "output.write_{proto_type}(&**{field_name})?;" => self.vars, proto_type, field_name);
                },
                _ => {
                    genln!(self.printer; "output.write_{proto_type}({field_name})?;" => self.vars, proto_type, field_name);
                }
            }

            if let FieldType::Group(_) = self.proto.field_type() {
                genln!(self.printer; "output.write_raw_tag_bytes(&{end_tag_bytes})?;" => self.vars, end_tag_bytes);
            }

            if let FieldScope::Oneof(_) = self.proto.scope() {
                self.printer.unindent();
                genln!(self.printer, "}}");
            } else {
                match self.proto.field_type() {
                    FieldType::Message(_) | FieldType::Group(_) => {
                        self.printer.unindent();
                        genln!(self.printer, "}}");
                    }
                    _ => {
                        if self.proto.file().syntax() == Syntax::Proto2 {
                            self.printer.unindent();
                            genln!(self.printer, "}}");
                        }
                        self.printer.unindent();
                        genln!(self.printer, "}}");
                    }
                }
            }
        }

        Ok(())
    }

    pub fn generate_field_number_constant(&mut self) -> Result {
        genln!(self.printer; "/// Gets the field number of the [`{proto_name}`] field" => self.vars, proto_name);
        genln!(self.printer, "///");
        genln!(self.printer; "/// [`{proto_name}`]: #method.{name}" => self.vars, proto_name, name);
        genln!(self.printer; "pub const {field_number_const}: i32 = {number};" => self.vars, field_number_const, number);
        Ok(())
    }

    pub fn generate_default_value(&mut self) -> Result {
        if self.proto.label() != FieldLabel::Repeated {
            match self.proto.field_type() {
                FieldType::Message(_) | FieldType::Group(_) => {}
                _ => {
                    genln!(self.printer; "/// A constant value representing the default value of the [`{proto_name}`] field" => self.vars, proto_name);
                    genln!(self.printer, "///");
                    genln!(self.printer; "/// [`{proto_name}`]: #method.{name}" => self.vars, proto_name, name);
                    genln!(self.printer; "pub const {default}: {default_type} = {default_value};" => self.vars, default, default_type, default_value);
                }
            }
        }

        Ok(())
    }

    pub fn generate_codec(&mut self) -> Result {
        if self.proto.label() == FieldLabel::Repeated {
            match self.proto.field_type() {
                FieldType::Message(m) if m.map_entry() => {
                    genln!(self.printer; "static {codec}: {crate_name}::collections::MapCodec<" => self.vars, codec, crate_name);
                    let generator =
                        Generator::<FieldDescriptor, _>::from_other(self, &m.fields()[0]);
                    gen!(generator.printer; "{base_type}, " => generator.vars, base_type);
                    let generator =
                        Generator::<FieldDescriptor, _>::from_other(self, &m.fields()[1]);
                    gen!(generator.printer; "{base_type}" => generator.vars, base_type);
                    gen!(self.printer; "> = {crate_name}::collections::MapCodec::new(" => self.vars, crate_name);

                    Generator::<FieldDescriptor, _>::from_other(self, &m.fields()[0])
                        .generate_codec_new()?;
                    gen!(self.printer, ", ");
                    Generator::<FieldDescriptor, _>::from_other(self, &m.fields()[1])
                        .generate_codec_new()?;
                    gen!(self.printer; ", {tag});" => self.vars, tag);
                }
                _ => {
                    genln!(self.printer; "static {codec}: {crate_name}::Codec<{base_type}> = " => self.vars, codec, crate_name, base_type);
                    self.generate_codec_new()?;
                    gen!(self.printer, ";");
                }
            }
        }

        Ok(())
    }

    pub fn generate_codec_new(&mut self) -> Result {
        match self.proto.field_type() {
            FieldType::Group(_) => {
                gen!(self.printer; "{crate_name}::Codec::group({tag}, {end_tag})" => self.vars, crate_name, tag, end_tag)
            }
            _ => {
                gen!(self.printer; "{crate_name}::Codec::{proto_type}({tag})" => self.vars, crate_name, proto_type, tag)
            }
        }
        Ok(())
    }

    pub fn generate_accessors(&mut self) -> Result {
        match self.proto.label() {
            FieldLabel::Repeated => {
                self.generate_rustdoc_comments()?;
                genln!(self.printer; "pub fn {field_name}(&self) -> &{field_type} {{" => self.vars, field_name, field_type);
                indent!(self.printer, {
                    genln!(self.printer; "&self.{field_name}" => self.vars, field_name);
                });
                genln!(self.printer, "}}");
                genln!(self.printer; "/// Returns a unique reference to the [`{proto_name}`] field" => self.vars, proto_name);
                genln!(self.printer, "///");
                genln!(self.printer; "/// [`{proto_name}`]: #method.{name}" => self.vars, proto_name, name);
                genln!(self.printer; "pub fn {name}_mut(&mut self) -> &mut {field_type} {{" => self.vars, name, field_type);
                indent!(self.printer, {
                    genln!(self.printer; "&mut self.{field_name}" => self.vars, field_name);
                });
                genln!(self.printer, "}}");
            },
            _ => 
                match self.proto.file().syntax() {
                    Syntax::Proto2 =>
                        match self.proto.field_type() {
                            FieldType::Message(_) | FieldType::Group(_) => {
                                self.generate_rustdoc_comments()?;
                                genln!(self.printer; "pub fn {name}_option(&self) -> ::std::option::Option<&{base_type}> {{" => self.vars, name, base_type);
                                indent!(self.printer, {
                                    genln!(self.printer; "self.{field_name}.as_ref().map(|b| &**b)" => self.vars, field_name);
                                });
                                genln!(self.printer, "}}");
                                genln!(self.printer; "/// Returns a unique reference to the [`{proto_name}`] field" => self.vars, proto_name);
                                genln!(self.printer, "///");
                                genln!(self.printer; "/// [`{proto_name}`]: #method.{name}" => self.vars, proto_name, name);
                                genln!(self.printer; "pub fn {name}_mut(&mut self) -> &mut {base_type} {{" => self.vars, name, base_type);
                                indent!(self.printer, {
                                    genln!(self.printer; "self.{field_name}.get_or_insert_with(|| ::std::boxed::Box::new({crate_name}::LiteMessage::new())).as_mut()" => self.vars, crate_name, field_name);
                                });
                                genln!(self.printer, "}}");
                                genln!(self.printer; "/// Returns a bool indicating the presence of the [`{proto_name}`] field" => self.vars, proto_name);
                                genln!(self.printer, "///");
                                genln!(self.printer; "/// [`{proto_name}`]: #method.{name}" => self.vars, proto_name, name);
                                genln!(self.printer; "pub fn has_{name}(&self) -> bool {{" => self.vars, name);
                                indent!(self.printer, {
                                    genln!(self.printer; "self.{field_name}.is_some()" => self.vars, field_name);
                                });
                                genln!(self.printer, "}}");
                                genln!(self.printer; "/// Sets the value of the [`{proto_name}`] field" => self.vars, proto_name);
                                genln!(self.printer, "///");
                                genln!(self.printer; "/// [`{proto_name}`]: #method.{name}" => self.vars, proto_name, name);
                                genln!(self.printer; "pub fn set_{name}(&mut self, value: {base_type}) {{" => self.vars, name, base_type);
                                indent!(self.printer, {
                                    genln!(self.printer; "self.{field_name} = ::std::option::Option::Some(::std::boxed::Box::new(value))" => self.vars, field_name);
                                });
                                genln!(self.printer, "}}");
                                genln!(self.printer; "/// Takes the value of the [`{proto_name}`] field, leaving it empty" => self.vars, proto_name);
                                genln!(self.printer, "///");
                                genln!(self.printer; "/// [`{proto_name}`]: #method.{name}" => self.vars, proto_name, name);
                                genln!(self.printer; "pub fn take_{name}(&mut self) -> ::std::option::Option<{base_type}> {{" => self.vars, name, base_type);
                                indent!(self.printer, {
                                    genln!(self.printer; "self.{field_name}.take().map(|b| *b)" => self.vars, field_name);
                                });
                                genln!(self.printer, "}}");
                                genln!(self.printer; "/// Clears the value of the [`{proto_name}`] field" => self.vars, proto_name);
                                genln!(self.printer, "///");
                                genln!(self.printer; "/// [`{proto_name}`]: #method.{name}" => self.vars, proto_name, name);
                                genln!(self.printer; "pub fn clear_{name}(&mut self) {{" => self.vars, name);
                                indent!(self.printer, {
                                    genln!(self.printer; "self.{field_name} = ::std::option::Option::None" => self.vars, field_name);
                                });
                                genln!(self.printer, "}}");
                            }
                            FieldType::String | FieldType::Bytes => {
                                self.generate_rustdoc_comments()?;
                                if *self.proto.field_type() == FieldType::String {
                                    genln!(self.printer; "pub fn {field_name}(&self) -> &str {{" => self.vars, field_name);
                                } else {
                                    genln!(self.printer; "pub fn {field_name}(&self) -> &[u8] {{" => self.vars, field_name);
                                }
                                indent!(self.printer, {
                                    genln!(self.printer; "self.{field_name}.as_ref().map(|v| &**v).unwrap_or(Self::{default})" => self.vars, default, field_name);
                                });
                                genln!(self.printer, "}}");
                                genln!(self.printer; "/// Returns an [`Option`] representing the presence of the [`{proto_name}`] field" => self.vars, proto_name);
                                genln!(self.printer, "///");
                                genln!(self.printer; "/// [`{proto_name}`]: #method.{name}" => self.vars, proto_name, name);
                                genln!(self.printer, "/// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html");
                                genln!(self.printer; "pub fn {name}_option(&self) -> ::std::option::Option<&{base_type}> {{" => self.vars, name, base_type);
                                indent!(self.printer, {
                                    genln!(self.printer; "self.{field_name}.as_ref()" => self.vars, field_name);
                                });
                                genln!(self.printer, "}}");
                                genln!(self.printer; "/// Returns a unique reference to the [`{proto_name}`] field" => self.vars, proto_name);
                                genln!(self.printer, "///");
                                genln!(self.printer; "/// [`{proto_name}`]: #method.{name}" => self.vars, proto_name, name);
                                genln!(self.printer; "pub fn {name}_mut(&mut self) -> &mut {base_type} {{" => self.vars, name, base_type);
                                indent!(self.printer, {
                                    if *self.proto.field_type() == FieldType::String {
                                        genln!(self.printer; "self.{field_name}.get_or_insert_with(::std::string::String::new)" => self.vars, field_name);
                                    } else {
                                        genln!(self.printer; "self.{field_name}.get_or_insert_with(::std::vec::Vec::new)" => self.vars, field_name);
                                    }
                                });
                                genln!(self.printer, "}}");
                                genln!(self.printer; "/// Returns a bool indicating the presence of the [`{proto_name}`] field" => self.vars, proto_name);
                                genln!(self.printer, "///");
                                genln!(self.printer; "/// [`{proto_name}`]: #method.{name}" => self.vars, proto_name, name);
                                genln!(self.printer; "pub fn has_{name}(&self) -> bool {{" => self.vars, name);
                                indent!(self.printer, {
                                    genln!(self.printer; "self.{name}.is_some()" => self.vars, name);
                                });
                                genln!(self.printer, "}}");
                                genln!(self.printer; "/// Sets the value of the [`{proto_name}`] field" => self.vars, proto_name);
                                genln!(self.printer, "///");
                                genln!(self.printer; "/// [`{proto_name}`]: #method.{name}" => self.vars, proto_name, name);
                                genln!(self.printer; "pub fn set_{name}(&mut self, value: {indirected_type}) {{" => self.vars, name, indirected_type);
                                indent!(self.printer, {
                                    genln!(self.printer; "self.{field_name} = ::std::option::Option::Some(value)" => self.vars, field_name);
                                });
                                genln!(self.printer, "}}");
                                genln!(self.printer; "/// Takes the value of the [`{proto_name}`] field, leaving it empty" => self.vars, proto_name);
                                genln!(self.printer, "///");
                                genln!(self.printer; "/// [`{proto_name}`]: #method.{name}" => self.vars, proto_name, name);
                                genln!(self.printer; "pub fn take_{name}(&mut self) -> {field_type} {{" => self.vars, name, field_type);
                                indent!(self.printer, {
                                    genln!(self.printer; "self.{field_name}.take()" => self.vars, field_name);
                                });
                                genln!(self.printer, "}}");
                                genln!(self.printer; "/// Clears the value of the [`{proto_name}`] field" => self.vars, proto_name);
                                genln!(self.printer, "///");
                                genln!(self.printer; "/// [`{proto_name}`]: #method.{name}" => self.vars, proto_name, name);
                                genln!(self.printer; "pub fn clear_{name}(&mut self) {{" => self.vars, name);
                                indent!(self.printer, {
                                    genln!(self.printer; "self.{field_name} = ::std::option::Option::None" => self.vars, field_name);
                                });
                                genln!(self.printer, "}}");
                            }
                            _ => {
                                self.generate_rustdoc_comments()?;
                                genln!(self.printer; "pub fn {field_name}(&self) -> {base_type} {{" => self.vars, field_name, base_type);
                                indent!(self.printer, {
                                    genln!(self.printer; "self.{field_name}.unwrap_or(Self::{default})" => self.vars, default, field_name);
                                });
                                genln!(self.printer, "}}");
                                genln!(self.printer; "/// Returns an [`Option`] representing the presence of the [`{proto_name}`] field" => self.vars, proto_name);
                                genln!(self.printer, "///");
                                genln!(self.printer; "/// [`{proto_name}`]: #method.{name}" => self.vars, proto_name, name);
                                genln!(self.printer, "/// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html");
                                genln!(self.printer; "pub fn {name}_option(&self) -> ::std::option::Option<{base_type}> {{" => self.vars, name, base_type);
                                indent!(self.printer, {
                                    genln!(self.printer; "self.{field_name}" => self.vars, field_name);
                                });
                                genln!(self.printer, "}}");
                                genln!(self.printer; "/// Returns a bool indicating the presence of the [`{proto_name}`] field" => self.vars, proto_name);
                                genln!(self.printer, "///");
                                genln!(self.printer; "/// [`{proto_name}`]: #method.{name}" => self.vars, proto_name, name);
                                genln!(self.printer; "pub fn has_{name}(&self) -> bool {{" => self.vars, name);
                                indent!(self.printer, {
                                    genln!(self.printer; "self.{field_name}.is_some()" => self.vars, field_name);
                                });
                                genln!(self.printer, "}}");
                                genln!(self.printer; "/// Sets the value of the [`{proto_name}`] field" => self.vars, proto_name);
                                genln!(self.printer, "///");
                                genln!(self.printer; "/// [`{proto_name}`]: #method.{name}" => self.vars, proto_name, name);
                                genln!(self.printer; "pub fn set_{name}(&mut self, value: {indirected_type}) {{" => self.vars, name, indirected_type);
                                indent!(self.printer, {
                                    genln!(self.printer; "self.{field_name} = ::std::option::Option::Some(value)" => self.vars, field_name);
                                });
                                genln!(self.printer, "}}");
                                genln!(self.printer; "/// Clears the value of the [`{proto_name}`] field" => self.vars, proto_name);
                                genln!(self.printer, "///");
                                genln!(self.printer; "/// [`{proto_name}`]: #method.{name}" => self.vars, proto_name, name);
                                genln!(self.printer; "pub fn clear_{name}(&mut self) {{" => self.vars, name);
                                indent!(self.printer, {
                                    genln!(self.printer; "self.{field_name} = ::std::option::Option::None" => self.vars, field_name);
                                });
                                genln!(self.printer, "}}");
                            }
                        },
                    Syntax::Proto3 => {
                        self.generate_rustdoc_comments()?;
                        if is_copy_type(self.proto.field_type()) {
                            genln!(self.printer; "pub fn {field_name}(&self) -> {field_type} {{" => self.vars, field_name, field_type);
                            indent!(self.printer, {
                                genln!(self.printer; "self.{field_name}" => self.vars, field_name);
                            });
                            genln!(self.printer, "}}");
                        } else {
                            genln!(self.printer; "pub fn {field_name}(&self) -> &{field_type} {{" => self.vars, field_name, field_type);
                            indent!(self.printer, {
                                genln!(self.printer; "&self.{field_name}" => self.vars, field_name);
                            });
                            genln!(self.printer, "}}");
                        }
                        genln!(self.printer; "/// Returns a unique reference to the [`{proto_name}`] field" => self.vars, proto_name);
                        genln!(self.printer, "///");
                        genln!(self.printer; "/// [`{proto_name}`]: #method.{name}" => self.vars, proto_name, name);
                        genln!(self.printer; "pub fn {name}_mut(&mut self) -> &mut {field_type} {{" => self.vars, name, field_type);
                        indent!(self.printer, {
                            genln!(self.printer; "&mut self.{field_name}" => self.vars, field_name);
                        });
                        genln!(self.printer, "}}");
                    },
                    _ => panic!("Unknown syntax"),
                }
        }

        Ok(())
    }
}

fn default_field_value(field: &FieldDescriptor, crate_name: &str) -> String {
    match field.label() {
        FieldLabel::Optional | FieldLabel::Required => {
            if field.file().syntax() == Syntax::Proto2 {
                format!("::std::option::Option::None")
            } else {
                match field.field_type() {
                    FieldType::Message(_) | FieldType::Group(_) => {
                        format!("::std::option::Option::None")
                    }
                    FieldType::String => format!("::std::string::String::new()"),
                    FieldType::Bytes => format!("::std::vec::Vec::new()"),
                    _ => "Self::".to_string() + &names::get_field_default_value_name(field),
                }
            }
        }
        FieldLabel::Repeated => {
            if let FieldType::Message(m) = field.field_type() {
                if m.map_entry() {
                    return format!("{}::collections::MapField::new()", crate_name);
                }
            }

            format!("{}::collections::RepeatedField::new()", crate_name)
        }
    }
}

fn is_copy_type(ft: &FieldType) -> bool {
    match ft {
        FieldType::Message(_) | FieldType::Group(_) | FieldType::Bytes | FieldType::String => false,
        _ => true,
    }
}

generator_new!(EnumDescriptor, proto, options;
    "type_name", names::get_enum_type_name(proto),
    "crate_name", options.crate_name.clone(),
    "full_type_name", names::get_full_enum_type_name(proto, proto.file(), &options.crate_name));

impl<W: Write> Generator<'_, EnumDescriptor, W> {
    pub fn generate_rustdoc_comments(&mut self) -> Result {
        if let Some(source_info) = self.proto.source_code_info() {
            generate_rustdoc_comments(self.printer, source_info)?
        }

        Ok(())
    }

    pub fn generate(&mut self) -> Result {
        let mut values: HashMap<String, &EnumValueDescriptor> = HashMap::new();
        for value in self.proto.values() {
            let mut name = names::get_enum_variant_name(value);
            while values.contains_key(&name) {
                eprintln!("{} already exists, adding '_' to differentiate", name);
                name += "_";
            }
            values.insert(name, value);
        }

        let mut values = values.iter().collect::<Vec<_>>();
        values.sort_unstable_by_key(|(_, v)| v.index());

        self.generate_rustdoc_comments()?;
        genln!(
            self.printer,
            "#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]"
        );
        genln!(self.printer; "pub enum {type_name} {{" => self.vars, type_name);
        indent!(self.printer, {
            for (name, value) in values.iter() {
                if let Some(source_info) = value.source_code_info() {
                    generate_rustdoc_comments(self.printer, source_info)?;
                }
                genln!(self.printer, "{variant},", variant = name);
            }
        });
        genln!(self.printer, "}}");
        genln!(self.printer; "impl ::std::convert::TryFrom<i32> for {full_type_name} {{" => self.vars, full_type_name);
        indent!(self.printer, {
            genln!(self.printer; "type Error = {crate_name}::VariantUndefinedError;" => self.vars, crate_name);
            genln!(self.printer; "fn try_from(value: i32) -> ::std::result::Result<Self, {crate_name}::VariantUndefinedError> {{" => self.vars, crate_name);
            indent!(self.printer, {
                genln!(self.printer, "match value {{");
                indent!(self.printer, {
                    for (name, value) in values.iter() {
                        genln!(self.printer, "{} => ::std::result::Result::Ok(self::{}::{}),", value.number(), names::get_enum_type_name(value.enum_type()), name);
                    }
                    genln!(self.printer; "_ => ::std::result::Result::Err({crate_name}::VariantUndefinedError)" => self.vars, crate_name);
                });
                genln!(self.printer, "}}");
            });
            genln!(self.printer, "}}");
        });
        genln!(self.printer, "}}");
        genln!(self.printer; "impl ::std::convert::From<{full_type_name}> for i32 {{" => self.vars, full_type_name);
        indent!(self.printer, {
            genln!(self.printer; "fn from(value: {full_type_name}) -> i32 {{" => self.vars, full_type_name);
            indent!(self.printer, {
                genln!(self.printer, "match value {{");
                indent!(self.printer, {
                    for (name, value) in values.iter() {
                        genln!(self.printer, "{}::{} => {},", names::get_enum_type_name(value.enum_type()), name, value.number());
                    }
                });
                genln!(self.printer, "}}");
            });
            genln!(self.printer, "}}");
        });
        genln!(self.printer, "}}");

        Ok(())
    }
}

generator_new!(OneofDescriptor, proto, options;
    "name", proto.name().to_string(),
    "field_name", proto.name().to_string(),
    "type_name", names::get_oneof_name(proto));

impl<W: Write> Generator<'_, OneofDescriptor, W> {
    pub fn generate_rustdoc_comments(&mut self) -> Result {
        if let Some(source_info) = self.proto.source_code_info() {
            generate_rustdoc_comments(self.printer, source_info)?
        }

        Ok(())
    }

    pub fn generate_type(&mut self) -> Result {
        self.generate_rustdoc_comments()?;
        genln!(self.printer, "#[derive(Clone, Debug, PartialEq)]");
        genln!(self.printer; "pub enum {type_name} {{" => self.vars, type_name);
        indent!(self.printer, {
            genln!(self.printer, "/// No value");
            genln!(self.printer, "None,");

            for field in self.proto.fields() {
                Generator::<FieldDescriptor, _>::from_other(self, field).generate_oneof_field()?;
            }
        });
        genln!(self.printer, "}}");
        Ok(())
    }

    pub fn generate_struct_field(&mut self) -> Result {
        genln!(self.printer; "{field_name}: self::{type_name}," => self.vars, field_name, type_name);
        Ok(())
    }

    pub fn generate_new(&mut self) -> Result {
        genln!(self.printer; "{field_name}: self::{type_name}::None," => self.vars, field_name, type_name);
        Ok(())
    }

    pub fn generate_accessor(&mut self) -> Result {
        genln!(self.printer; "/// Gets a shared reference to the [`{name}`] oneof field" => self.vars, name);
        genln!(self.printer, "///");
        genln!(self.printer; "/// [`{name}`]: enum.{type_name}.html" => self.vars, type_name, name);
        genln!(self.printer; "pub fn {field_name}(&self) -> &self::{type_name} {{" => self.vars, field_name, type_name);
        indent!(self.printer, {
            genln!(self.printer; "&self.{field_name}" => self.vars, field_name);
        });
        genln!(self.printer, "}}");

        genln!(self.printer; "/// Gets a unique reference to the [`{name}`] oneof field" => self.vars, name);
        genln!(self.printer, "///");
        genln!(self.printer; "/// [`{name}`]: enum.{type_name}.html" => self.vars, type_name, name);
        genln!(self.printer; "pub fn {field_name}_mut(&mut self) -> &mut self::{type_name} {{" => self.vars, field_name, type_name);
        indent!(self.printer, {
            genln!(self.printer; "&mut self.{field_name}" => self.vars, field_name);
        });
        genln!(self.printer, "}}");

        Ok(())
    }
}

fn generate_rustdoc_comments<W: Write>(printer: &mut printer::Printer<W>, source_info: &SourceCodeInfo) -> Result {
    if let Some(comments) = source_info
        .leading_comments()
        .or(source_info.trailing_comments())
    {
        let mut printer = printer::DocPrinter::new(printer);
        let mut events = Parser::new(comments).peekable();
        while let Some(event) = events.next() {
            let peek = events.peek();
            match event {
                Event::End(Tag::Paragraph) if peek == None => { },
                Event::Start(Tag::Paragraph) | Event::End(Tag::Paragraph) => genln!(printer),
                Event::Start(Tag::Code) | Event::End(Tag::Code) => gen!(printer, "`"),
                Event::Text(val) |
                Event::FootnoteReference(val) |
                Event::Html(val) |
                Event::InlineHtml(val) => gen!(printer, "{}", val),
                Event::SoftBreak | Event::HardBreak => genln!(printer),
                Event::Start(Tag::CodeBlock(std::borrow::Cow::Borrowed(""))) => gen!(printer, "```text\n"),
                Event::Start(Tag::CodeBlock(code)) => gen!(printer, "```{}\n", code),
                Event::End(Tag::CodeBlock(_)) => gen!(printer, "```\n"),
                Event::Start(Tag::Header(i)) => gen!(printer, "{} ", "#".repeat(i as usize)),
                Event::Start(Tag::List(start)) => {
                    printer.start_list(start);
                    genln!(printer);
                },
                Event::End(Tag::List(_)) => {
                    printer.end_list();
                },
                Event::Start(Tag::Item) => {
                    printer.start_item();
                    match printer.current_item_number() {
                        Some(number) => gen!(printer, "{}. ", number),
                        None => gen!(printer, "* ")
                    }
                },
                Event::End(Tag::Item) => {
                    printer.end_item();
                    genln!(printer);
                },
                Event::Start(Tag::Link(_, ref title)) if title.is_empty() => gen!(printer, "["),
                Event::Start(Tag::Link(_, _)) => gen!(printer, "["),
                Event::End(Tag::Link(ref link, ref title)) if title.is_empty() => gen!(printer, "]({})", link),
                Event::End(Tag::Link(_, ref title)) => gen!(printer, "][{}]", title),
                Event::End(Tag::Header(_)) => genln!(printer),
                Event::Start(Tag::Emphasis) | Event::End(Tag::Emphasis) => gen!(printer, "*"),
                Event::Start(Tag::Strong) | Event::End(Tag::Strong) => gen!(printer, "**"),
                u => panic!("Unknown event / tag: {:?}", u)
            }
        }
    }

    Ok(())
}