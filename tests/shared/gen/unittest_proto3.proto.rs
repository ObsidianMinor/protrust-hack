// DO NOT EDIT!
// Generated by protoc-gen-rust, part of the protrust crate.
//
// Source: unittest_proto3.proto


pub fn file() -> &'static ::protrust::reflect::FileDescriptor {
    super::pool().find_file_by_name("unittest_proto3.proto").unwrap()
}

///  This proto includes every type of field in both singular and repeated
///  forms.
#[derive(Clone, Debug, PartialEq, Default)]
pub struct TestAllTypes {
    optional_int32: i32,
    optional_int64: i64,
    optional_uint32: u32,
    optional_uint64: u64,
    optional_sint32: i32,
    optional_sint64: i64,
    optional_fixed32: u32,
    optional_fixed64: u64,
    optional_sfixed32: i32,
    optional_sfixed64: i64,
    optional_float: f32,
    optional_double: f64,
    optional_bool: bool,
    optional_string: ::std::string::String,
    optional_bytes: ::std::vec::Vec<u8>,
    optional_nested_message: ::std::option::Option<::std::boxed::Box<self::test_all_types::NestedMessage>>,
    optional_foreign_message: ::std::option::Option<::std::boxed::Box<self::ForeignMessage>>,
    optional_import_message: ::std::option::Option<::std::boxed::Box<self::super::unittest_import_proto::ImportMessage>>,
    optional_nested_enum: ::protrust::EnumValue<self::test_all_types::NestedEnum>,
    optional_foreign_enum: ::protrust::EnumValue<self::ForeignEnum>,
    optional_string_piece: ::std::string::String,
    optional_cord: ::std::string::String,
    optional_public_import_message: ::std::option::Option<::std::boxed::Box<self::super::unittest_import_public_proto::PublicImportMessage>>,
    optional_lazy_message: ::std::option::Option<::std::boxed::Box<self::test_all_types::NestedMessage>>,
    optional_lazy_import_message: ::std::option::Option<::std::boxed::Box<self::super::unittest_import_proto::ImportMessage>>,
    repeated_int32: ::protrust::collections::RepeatedField<i32>,
    repeated_int64: ::protrust::collections::RepeatedField<i64>,
    repeated_uint32: ::protrust::collections::RepeatedField<u32>,
    repeated_uint64: ::protrust::collections::RepeatedField<u64>,
    repeated_sint32: ::protrust::collections::RepeatedField<i32>,
    repeated_sint64: ::protrust::collections::RepeatedField<i64>,
    repeated_fixed32: ::protrust::collections::RepeatedField<u32>,
    repeated_fixed64: ::protrust::collections::RepeatedField<u64>,
    repeated_sfixed32: ::protrust::collections::RepeatedField<i32>,
    repeated_sfixed64: ::protrust::collections::RepeatedField<i64>,
    repeated_float: ::protrust::collections::RepeatedField<f32>,
    repeated_double: ::protrust::collections::RepeatedField<f64>,
    repeated_bool: ::protrust::collections::RepeatedField<bool>,
    repeated_string: ::protrust::collections::RepeatedField<::std::string::String>,
    repeated_bytes: ::protrust::collections::RepeatedField<::std::vec::Vec<u8>>,
    repeated_nested_message: ::protrust::collections::RepeatedField<self::test_all_types::NestedMessage>,
    repeated_foreign_message: ::protrust::collections::RepeatedField<self::ForeignMessage>,
    repeated_import_message: ::protrust::collections::RepeatedField<self::super::unittest_import_proto::ImportMessage>,
    repeated_nested_enum: ::protrust::collections::RepeatedField<::protrust::EnumValue<self::test_all_types::NestedEnum>>,
    repeated_foreign_enum: ::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>>,
    repeated_string_piece: ::protrust::collections::RepeatedField<::std::string::String>,
    repeated_cord: ::protrust::collections::RepeatedField<::std::string::String>,
    repeated_lazy_message: ::protrust::collections::RepeatedField<self::test_all_types::NestedMessage>,
    oneof_field: self::test_all_types::OneofField,
    unknown_fields: ::protrust::UnknownFieldSet,
}
static TEST_ALL_TYPES_REPEATED_INT32_CODEC: ::protrust::Codec<i32> = ::protrust::Codec::int32(250);
static TEST_ALL_TYPES_REPEATED_INT64_CODEC: ::protrust::Codec<i64> = ::protrust::Codec::int64(258);
static TEST_ALL_TYPES_REPEATED_UINT32_CODEC: ::protrust::Codec<u32> = ::protrust::Codec::uint32(266);
static TEST_ALL_TYPES_REPEATED_UINT64_CODEC: ::protrust::Codec<u64> = ::protrust::Codec::uint64(274);
static TEST_ALL_TYPES_REPEATED_SINT32_CODEC: ::protrust::Codec<i32> = ::protrust::Codec::sint32(282);
static TEST_ALL_TYPES_REPEATED_SINT64_CODEC: ::protrust::Codec<i64> = ::protrust::Codec::sint64(290);
static TEST_ALL_TYPES_REPEATED_FIXED32_CODEC: ::protrust::Codec<u32> = ::protrust::Codec::fixed32(298);
static TEST_ALL_TYPES_REPEATED_FIXED64_CODEC: ::protrust::Codec<u64> = ::protrust::Codec::fixed64(306);
static TEST_ALL_TYPES_REPEATED_SFIXED32_CODEC: ::protrust::Codec<i32> = ::protrust::Codec::sfixed32(314);
static TEST_ALL_TYPES_REPEATED_SFIXED64_CODEC: ::protrust::Codec<i64> = ::protrust::Codec::sfixed64(322);
static TEST_ALL_TYPES_REPEATED_FLOAT_CODEC: ::protrust::Codec<f32> = ::protrust::Codec::float(330);
static TEST_ALL_TYPES_REPEATED_DOUBLE_CODEC: ::protrust::Codec<f64> = ::protrust::Codec::double(338);
static TEST_ALL_TYPES_REPEATED_BOOL_CODEC: ::protrust::Codec<bool> = ::protrust::Codec::bool(346);
static TEST_ALL_TYPES_REPEATED_STRING_CODEC: ::protrust::Codec<::std::string::String> = ::protrust::Codec::string(354);
static TEST_ALL_TYPES_REPEATED_BYTES_CODEC: ::protrust::Codec<::std::vec::Vec<u8>> = ::protrust::Codec::bytes(362);
static TEST_ALL_TYPES_REPEATED_NESTED_MESSAGE_CODEC: ::protrust::Codec<self::test_all_types::NestedMessage> = ::protrust::Codec::message(386);
static TEST_ALL_TYPES_REPEATED_FOREIGN_MESSAGE_CODEC: ::protrust::Codec<self::ForeignMessage> = ::protrust::Codec::message(394);
static TEST_ALL_TYPES_REPEATED_IMPORT_MESSAGE_CODEC: ::protrust::Codec<self::super::unittest_import_proto::ImportMessage> = ::protrust::Codec::message(402);
static TEST_ALL_TYPES_REPEATED_NESTED_ENUM_CODEC: ::protrust::Codec<::protrust::EnumValue<self::test_all_types::NestedEnum>> = ::protrust::Codec::enum_value(410);
static TEST_ALL_TYPES_REPEATED_FOREIGN_ENUM_CODEC: ::protrust::Codec<::protrust::EnumValue<self::ForeignEnum>> = ::protrust::Codec::enum_value(418);
static TEST_ALL_TYPES_REPEATED_STRING_PIECE_CODEC: ::protrust::Codec<::std::string::String> = ::protrust::Codec::string(434);
static TEST_ALL_TYPES_REPEATED_CORD_CODEC: ::protrust::Codec<::std::string::String> = ::protrust::Codec::string(442);
static TEST_ALL_TYPES_REPEATED_LAZY_MESSAGE_CODEC: ::protrust::Codec<self::test_all_types::NestedMessage> = ::protrust::Codec::message(458);
impl ::protrust::CodedMessage for self::TestAllTypes {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 | 10 => self.optional_int32 = input.read_int32()?,
                16 | 18 => self.optional_int64 = input.read_int64()?,
                24 | 26 => self.optional_uint32 = input.read_uint32()?,
                32 | 34 => self.optional_uint64 = input.read_uint64()?,
                40 | 42 => self.optional_sint32 = input.read_sint32()?,
                48 | 50 => self.optional_sint64 = input.read_sint64()?,
                61 | 58 => self.optional_fixed32 = input.read_fixed32()?,
                65 | 66 => self.optional_fixed64 = input.read_fixed64()?,
                77 | 74 => self.optional_sfixed32 = input.read_sfixed32()?,
                81 | 82 => self.optional_sfixed64 = input.read_sfixed64()?,
                93 | 90 => self.optional_float = input.read_float()?,
                97 | 98 => self.optional_double = input.read_double()?,
                104 | 106 => self.optional_bool = input.read_bool()?,
                114 => self.optional_string = input.read_string()?,
                122 => self.optional_bytes = input.read_bytes()?,
                146 => input.read_message(&mut **self.optional_nested_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                154 => input.read_message(&mut **self.optional_foreign_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                162 => input.read_message(&mut **self.optional_import_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                168 | 170 => self.optional_nested_enum = input.read_enum_value()?,
                176 | 178 => self.optional_foreign_enum = input.read_enum_value()?,
                194 => self.optional_string_piece = input.read_string()?,
                202 => self.optional_cord = input.read_string()?,
                210 => input.read_message(&mut **self.optional_public_import_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                218 => input.read_message(&mut **self.optional_lazy_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                922 => input.read_message(&mut **self.optional_lazy_import_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                248 | 250 => self.repeated_int32.add_entries(input, &TEST_ALL_TYPES_REPEATED_INT32_CODEC)?,
                256 | 258 => self.repeated_int64.add_entries(input, &TEST_ALL_TYPES_REPEATED_INT64_CODEC)?,
                264 | 266 => self.repeated_uint32.add_entries(input, &TEST_ALL_TYPES_REPEATED_UINT32_CODEC)?,
                272 | 274 => self.repeated_uint64.add_entries(input, &TEST_ALL_TYPES_REPEATED_UINT64_CODEC)?,
                280 | 282 => self.repeated_sint32.add_entries(input, &TEST_ALL_TYPES_REPEATED_SINT32_CODEC)?,
                288 | 290 => self.repeated_sint64.add_entries(input, &TEST_ALL_TYPES_REPEATED_SINT64_CODEC)?,
                301 | 298 => self.repeated_fixed32.add_entries(input, &TEST_ALL_TYPES_REPEATED_FIXED32_CODEC)?,
                305 | 306 => self.repeated_fixed64.add_entries(input, &TEST_ALL_TYPES_REPEATED_FIXED64_CODEC)?,
                317 | 314 => self.repeated_sfixed32.add_entries(input, &TEST_ALL_TYPES_REPEATED_SFIXED32_CODEC)?,
                321 | 322 => self.repeated_sfixed64.add_entries(input, &TEST_ALL_TYPES_REPEATED_SFIXED64_CODEC)?,
                333 | 330 => self.repeated_float.add_entries(input, &TEST_ALL_TYPES_REPEATED_FLOAT_CODEC)?,
                337 | 338 => self.repeated_double.add_entries(input, &TEST_ALL_TYPES_REPEATED_DOUBLE_CODEC)?,
                344 | 346 => self.repeated_bool.add_entries(input, &TEST_ALL_TYPES_REPEATED_BOOL_CODEC)?,
                354 => self.repeated_string.add_entries(input, &TEST_ALL_TYPES_REPEATED_STRING_CODEC)?,
                362 => self.repeated_bytes.add_entries(input, &TEST_ALL_TYPES_REPEATED_BYTES_CODEC)?,
                386 => self.repeated_nested_message.add_entries(input, &TEST_ALL_TYPES_REPEATED_NESTED_MESSAGE_CODEC)?,
                394 => self.repeated_foreign_message.add_entries(input, &TEST_ALL_TYPES_REPEATED_FOREIGN_MESSAGE_CODEC)?,
                402 => self.repeated_import_message.add_entries(input, &TEST_ALL_TYPES_REPEATED_IMPORT_MESSAGE_CODEC)?,
                408 | 410 => self.repeated_nested_enum.add_entries(input, &TEST_ALL_TYPES_REPEATED_NESTED_ENUM_CODEC)?,
                416 | 418 => self.repeated_foreign_enum.add_entries(input, &TEST_ALL_TYPES_REPEATED_FOREIGN_ENUM_CODEC)?,
                434 => self.repeated_string_piece.add_entries(input, &TEST_ALL_TYPES_REPEATED_STRING_PIECE_CODEC)?,
                442 => self.repeated_cord.add_entries(input, &TEST_ALL_TYPES_REPEATED_CORD_CODEC)?,
                458 => self.repeated_lazy_message.add_entries(input, &TEST_ALL_TYPES_REPEATED_LAZY_MESSAGE_CODEC)?,
                888 | 890 => self.oneof_field = self::test_all_types::OneofField::OneofUint32(input.read_uint32()?),
                898 => 
                    if let self::test_all_types::OneofField::OneofNestedMessage(oneof_field) = &mut self.oneof_field {
                        input.read_message(&mut **oneof_field)?;
                    } else {
                        let mut oneof_field = ::std::boxed::Box::new(<self::test_all_types::NestedMessage as ::protrust::LiteMessage>::new());
                        input.read_message(&mut *oneof_field)?;
                        self.oneof_field = self::test_all_types::OneofField::OneofNestedMessage(oneof_field)
                    },
                906 => self.oneof_field = self::test_all_types::OneofField::OneofString(input.read_string()?),
                914 => self.oneof_field = self::test_all_types::OneofField::OneofBytes(input.read_bytes()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let optional_int32 = self.optional_int32;
        if optional_int32 != Self::OPTIONAL_INT32_DEFAULT_VALUE {
            size += 1;
            size += ::protrust::io::sizes::int32(optional_int32);
        }
        let optional_int64 = self.optional_int64;
        if optional_int64 != Self::OPTIONAL_INT64_DEFAULT_VALUE {
            size += 1;
            size += ::protrust::io::sizes::int64(optional_int64);
        }
        let optional_uint32 = self.optional_uint32;
        if optional_uint32 != Self::OPTIONAL_UINT32_DEFAULT_VALUE {
            size += 1;
            size += ::protrust::io::sizes::uint32(optional_uint32);
        }
        let optional_uint64 = self.optional_uint64;
        if optional_uint64 != Self::OPTIONAL_UINT64_DEFAULT_VALUE {
            size += 1;
            size += ::protrust::io::sizes::uint64(optional_uint64);
        }
        let optional_sint32 = self.optional_sint32;
        if optional_sint32 != Self::OPTIONAL_SINT32_DEFAULT_VALUE {
            size += 1;
            size += ::protrust::io::sizes::sint32(optional_sint32);
        }
        let optional_sint64 = self.optional_sint64;
        if optional_sint64 != Self::OPTIONAL_SINT64_DEFAULT_VALUE {
            size += 1;
            size += ::protrust::io::sizes::sint64(optional_sint64);
        }
        let optional_fixed32 = self.optional_fixed32;
        if optional_fixed32 != Self::OPTIONAL_FIXED32_DEFAULT_VALUE {
            size += 1;
            size += ::protrust::io::sizes::fixed32(optional_fixed32);
        }
        let optional_fixed64 = self.optional_fixed64;
        if optional_fixed64 != Self::OPTIONAL_FIXED64_DEFAULT_VALUE {
            size += 1;
            size += ::protrust::io::sizes::fixed64(optional_fixed64);
        }
        let optional_sfixed32 = self.optional_sfixed32;
        if optional_sfixed32 != Self::OPTIONAL_SFIXED32_DEFAULT_VALUE {
            size += 1;
            size += ::protrust::io::sizes::sfixed32(optional_sfixed32);
        }
        let optional_sfixed64 = self.optional_sfixed64;
        if optional_sfixed64 != Self::OPTIONAL_SFIXED64_DEFAULT_VALUE {
            size += 1;
            size += ::protrust::io::sizes::sfixed64(optional_sfixed64);
        }
        let optional_float = self.optional_float;
        if optional_float != Self::OPTIONAL_FLOAT_DEFAULT_VALUE {
            size += 1;
            size += ::protrust::io::sizes::float(optional_float);
        }
        let optional_double = self.optional_double;
        if optional_double != Self::OPTIONAL_DOUBLE_DEFAULT_VALUE {
            size += 1;
            size += ::protrust::io::sizes::double(optional_double);
        }
        let optional_bool = self.optional_bool;
        if optional_bool != Self::OPTIONAL_BOOL_DEFAULT_VALUE {
            size += 1;
            size += ::protrust::io::sizes::bool(optional_bool);
        }
        let optional_string = &self.optional_string;
        if optional_string != Self::OPTIONAL_STRING_DEFAULT_VALUE {
            size += 1;
            size += ::protrust::io::sizes::string(optional_string);
        }
        let optional_bytes = &self.optional_bytes;
        if optional_bytes.as_slice() != Self::OPTIONAL_BYTES_DEFAULT_VALUE {
            size += 1;
            size += ::protrust::io::sizes::bytes(optional_bytes);
        }
        let optional_nested_message = &self.optional_nested_message;
        if let ::std::option::Option::Some(optional_nested_message) = optional_nested_message {
            size += 2;
            size += ::protrust::io::sizes::message(&**optional_nested_message);
        }
        let optional_foreign_message = &self.optional_foreign_message;
        if let ::std::option::Option::Some(optional_foreign_message) = optional_foreign_message {
            size += 2;
            size += ::protrust::io::sizes::message(&**optional_foreign_message);
        }
        let optional_import_message = &self.optional_import_message;
        if let ::std::option::Option::Some(optional_import_message) = optional_import_message {
            size += 2;
            size += ::protrust::io::sizes::message(&**optional_import_message);
        }
        let optional_nested_enum = self.optional_nested_enum;
        if optional_nested_enum != Self::OPTIONAL_NESTED_ENUM_DEFAULT_VALUE {
            size += 2;
            size += ::protrust::io::sizes::enum_value(optional_nested_enum);
        }
        let optional_foreign_enum = self.optional_foreign_enum;
        if optional_foreign_enum != Self::OPTIONAL_FOREIGN_ENUM_DEFAULT_VALUE {
            size += 2;
            size += ::protrust::io::sizes::enum_value(optional_foreign_enum);
        }
        let optional_string_piece = &self.optional_string_piece;
        if optional_string_piece != Self::OPTIONAL_STRING_PIECE_DEFAULT_VALUE {
            size += 2;
            size += ::protrust::io::sizes::string(optional_string_piece);
        }
        let optional_cord = &self.optional_cord;
        if optional_cord != Self::OPTIONAL_CORD_DEFAULT_VALUE {
            size += 2;
            size += ::protrust::io::sizes::string(optional_cord);
        }
        let optional_public_import_message = &self.optional_public_import_message;
        if let ::std::option::Option::Some(optional_public_import_message) = optional_public_import_message {
            size += 2;
            size += ::protrust::io::sizes::message(&**optional_public_import_message);
        }
        let optional_lazy_message = &self.optional_lazy_message;
        if let ::std::option::Option::Some(optional_lazy_message) = optional_lazy_message {
            size += 2;
            size += ::protrust::io::sizes::message(&**optional_lazy_message);
        }
        let optional_lazy_import_message = &self.optional_lazy_import_message;
        if let ::std::option::Option::Some(optional_lazy_import_message) = optional_lazy_import_message {
            size += 2;
            size += ::protrust::io::sizes::message(&**optional_lazy_import_message);
        }
        size += self.repeated_int32.calculate_size(&TEST_ALL_TYPES_REPEATED_INT32_CODEC);
        size += self.repeated_int64.calculate_size(&TEST_ALL_TYPES_REPEATED_INT64_CODEC);
        size += self.repeated_uint32.calculate_size(&TEST_ALL_TYPES_REPEATED_UINT32_CODEC);
        size += self.repeated_uint64.calculate_size(&TEST_ALL_TYPES_REPEATED_UINT64_CODEC);
        size += self.repeated_sint32.calculate_size(&TEST_ALL_TYPES_REPEATED_SINT32_CODEC);
        size += self.repeated_sint64.calculate_size(&TEST_ALL_TYPES_REPEATED_SINT64_CODEC);
        size += self.repeated_fixed32.calculate_size(&TEST_ALL_TYPES_REPEATED_FIXED32_CODEC);
        size += self.repeated_fixed64.calculate_size(&TEST_ALL_TYPES_REPEATED_FIXED64_CODEC);
        size += self.repeated_sfixed32.calculate_size(&TEST_ALL_TYPES_REPEATED_SFIXED32_CODEC);
        size += self.repeated_sfixed64.calculate_size(&TEST_ALL_TYPES_REPEATED_SFIXED64_CODEC);
        size += self.repeated_float.calculate_size(&TEST_ALL_TYPES_REPEATED_FLOAT_CODEC);
        size += self.repeated_double.calculate_size(&TEST_ALL_TYPES_REPEATED_DOUBLE_CODEC);
        size += self.repeated_bool.calculate_size(&TEST_ALL_TYPES_REPEATED_BOOL_CODEC);
        size += self.repeated_string.calculate_size(&TEST_ALL_TYPES_REPEATED_STRING_CODEC);
        size += self.repeated_bytes.calculate_size(&TEST_ALL_TYPES_REPEATED_BYTES_CODEC);
        size += self.repeated_nested_message.calculate_size(&TEST_ALL_TYPES_REPEATED_NESTED_MESSAGE_CODEC);
        size += self.repeated_foreign_message.calculate_size(&TEST_ALL_TYPES_REPEATED_FOREIGN_MESSAGE_CODEC);
        size += self.repeated_import_message.calculate_size(&TEST_ALL_TYPES_REPEATED_IMPORT_MESSAGE_CODEC);
        size += self.repeated_nested_enum.calculate_size(&TEST_ALL_TYPES_REPEATED_NESTED_ENUM_CODEC);
        size += self.repeated_foreign_enum.calculate_size(&TEST_ALL_TYPES_REPEATED_FOREIGN_ENUM_CODEC);
        size += self.repeated_string_piece.calculate_size(&TEST_ALL_TYPES_REPEATED_STRING_PIECE_CODEC);
        size += self.repeated_cord.calculate_size(&TEST_ALL_TYPES_REPEATED_CORD_CODEC);
        size += self.repeated_lazy_message.calculate_size(&TEST_ALL_TYPES_REPEATED_LAZY_MESSAGE_CODEC);
        if let self::test_all_types::OneofField::OneofUint32(oneof_field) = self.oneof_field {
            size += 2;
            size += ::protrust::io::sizes::uint32(oneof_field);
        }
        if let self::test_all_types::OneofField::OneofNestedMessage(oneof_field) = &self.oneof_field {
            size += 2;
            size += ::protrust::io::sizes::message(&**oneof_field);
        }
        if let self::test_all_types::OneofField::OneofString(oneof_field) = &self.oneof_field {
            size += 2;
            size += ::protrust::io::sizes::string(oneof_field);
        }
        if let self::test_all_types::OneofField::OneofBytes(oneof_field) = &self.oneof_field {
            size += 2;
            size += ::protrust::io::sizes::bytes(oneof_field);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let optional_int32 = self.optional_int32;
        if optional_int32 != Self::OPTIONAL_INT32_DEFAULT_VALUE {
            output.write_raw_tag_bytes(&[8])?;
            output.write_int32(optional_int32)?;
        }
        let optional_int64 = self.optional_int64;
        if optional_int64 != Self::OPTIONAL_INT64_DEFAULT_VALUE {
            output.write_raw_tag_bytes(&[16])?;
            output.write_int64(optional_int64)?;
        }
        let optional_uint32 = self.optional_uint32;
        if optional_uint32 != Self::OPTIONAL_UINT32_DEFAULT_VALUE {
            output.write_raw_tag_bytes(&[24])?;
            output.write_uint32(optional_uint32)?;
        }
        let optional_uint64 = self.optional_uint64;
        if optional_uint64 != Self::OPTIONAL_UINT64_DEFAULT_VALUE {
            output.write_raw_tag_bytes(&[32])?;
            output.write_uint64(optional_uint64)?;
        }
        let optional_sint32 = self.optional_sint32;
        if optional_sint32 != Self::OPTIONAL_SINT32_DEFAULT_VALUE {
            output.write_raw_tag_bytes(&[40])?;
            output.write_sint32(optional_sint32)?;
        }
        let optional_sint64 = self.optional_sint64;
        if optional_sint64 != Self::OPTIONAL_SINT64_DEFAULT_VALUE {
            output.write_raw_tag_bytes(&[48])?;
            output.write_sint64(optional_sint64)?;
        }
        let optional_fixed32 = self.optional_fixed32;
        if optional_fixed32 != Self::OPTIONAL_FIXED32_DEFAULT_VALUE {
            output.write_raw_tag_bytes(&[61])?;
            output.write_fixed32(optional_fixed32)?;
        }
        let optional_fixed64 = self.optional_fixed64;
        if optional_fixed64 != Self::OPTIONAL_FIXED64_DEFAULT_VALUE {
            output.write_raw_tag_bytes(&[65])?;
            output.write_fixed64(optional_fixed64)?;
        }
        let optional_sfixed32 = self.optional_sfixed32;
        if optional_sfixed32 != Self::OPTIONAL_SFIXED32_DEFAULT_VALUE {
            output.write_raw_tag_bytes(&[77])?;
            output.write_sfixed32(optional_sfixed32)?;
        }
        let optional_sfixed64 = self.optional_sfixed64;
        if optional_sfixed64 != Self::OPTIONAL_SFIXED64_DEFAULT_VALUE {
            output.write_raw_tag_bytes(&[81])?;
            output.write_sfixed64(optional_sfixed64)?;
        }
        let optional_float = self.optional_float;
        if optional_float != Self::OPTIONAL_FLOAT_DEFAULT_VALUE {
            output.write_raw_tag_bytes(&[93])?;
            output.write_float(optional_float)?;
        }
        let optional_double = self.optional_double;
        if optional_double != Self::OPTIONAL_DOUBLE_DEFAULT_VALUE {
            output.write_raw_tag_bytes(&[97])?;
            output.write_double(optional_double)?;
        }
        let optional_bool = self.optional_bool;
        if optional_bool != Self::OPTIONAL_BOOL_DEFAULT_VALUE {
            output.write_raw_tag_bytes(&[104])?;
            output.write_bool(optional_bool)?;
        }
        let optional_string = &self.optional_string;
        if optional_string != Self::OPTIONAL_STRING_DEFAULT_VALUE {
            output.write_raw_tag_bytes(&[114])?;
            output.write_string(optional_string)?;
        }
        let optional_bytes = &self.optional_bytes;
        if optional_bytes.as_slice() != Self::OPTIONAL_BYTES_DEFAULT_VALUE {
            output.write_raw_tag_bytes(&[122])?;
            output.write_bytes(optional_bytes)?;
        }
        let optional_nested_message = &self.optional_nested_message;
        if let ::std::option::Option::Some(optional_nested_message) = optional_nested_message {
            output.write_raw_tag_bytes(&[146, 1])?;
            output.write_message(&**optional_nested_message)?;
        }
        let optional_foreign_message = &self.optional_foreign_message;
        if let ::std::option::Option::Some(optional_foreign_message) = optional_foreign_message {
            output.write_raw_tag_bytes(&[154, 1])?;
            output.write_message(&**optional_foreign_message)?;
        }
        let optional_import_message = &self.optional_import_message;
        if let ::std::option::Option::Some(optional_import_message) = optional_import_message {
            output.write_raw_tag_bytes(&[162, 1])?;
            output.write_message(&**optional_import_message)?;
        }
        let optional_nested_enum = self.optional_nested_enum;
        if optional_nested_enum != Self::OPTIONAL_NESTED_ENUM_DEFAULT_VALUE {
            output.write_raw_tag_bytes(&[168, 1])?;
            output.write_enum_value(optional_nested_enum)?;
        }
        let optional_foreign_enum = self.optional_foreign_enum;
        if optional_foreign_enum != Self::OPTIONAL_FOREIGN_ENUM_DEFAULT_VALUE {
            output.write_raw_tag_bytes(&[176, 1])?;
            output.write_enum_value(optional_foreign_enum)?;
        }
        let optional_string_piece = &self.optional_string_piece;
        if optional_string_piece != Self::OPTIONAL_STRING_PIECE_DEFAULT_VALUE {
            output.write_raw_tag_bytes(&[194, 1])?;
            output.write_string(optional_string_piece)?;
        }
        let optional_cord = &self.optional_cord;
        if optional_cord != Self::OPTIONAL_CORD_DEFAULT_VALUE {
            output.write_raw_tag_bytes(&[202, 1])?;
            output.write_string(optional_cord)?;
        }
        let optional_public_import_message = &self.optional_public_import_message;
        if let ::std::option::Option::Some(optional_public_import_message) = optional_public_import_message {
            output.write_raw_tag_bytes(&[210, 1])?;
            output.write_message(&**optional_public_import_message)?;
        }
        let optional_lazy_message = &self.optional_lazy_message;
        if let ::std::option::Option::Some(optional_lazy_message) = optional_lazy_message {
            output.write_raw_tag_bytes(&[218, 1])?;
            output.write_message(&**optional_lazy_message)?;
        }
        let optional_lazy_import_message = &self.optional_lazy_import_message;
        if let ::std::option::Option::Some(optional_lazy_import_message) = optional_lazy_import_message {
            output.write_raw_tag_bytes(&[154, 7])?;
            output.write_message(&**optional_lazy_import_message)?;
        }
        self.repeated_int32.write_to(output, &TEST_ALL_TYPES_REPEATED_INT32_CODEC)?;
        self.repeated_int64.write_to(output, &TEST_ALL_TYPES_REPEATED_INT64_CODEC)?;
        self.repeated_uint32.write_to(output, &TEST_ALL_TYPES_REPEATED_UINT32_CODEC)?;
        self.repeated_uint64.write_to(output, &TEST_ALL_TYPES_REPEATED_UINT64_CODEC)?;
        self.repeated_sint32.write_to(output, &TEST_ALL_TYPES_REPEATED_SINT32_CODEC)?;
        self.repeated_sint64.write_to(output, &TEST_ALL_TYPES_REPEATED_SINT64_CODEC)?;
        self.repeated_fixed32.write_to(output, &TEST_ALL_TYPES_REPEATED_FIXED32_CODEC)?;
        self.repeated_fixed64.write_to(output, &TEST_ALL_TYPES_REPEATED_FIXED64_CODEC)?;
        self.repeated_sfixed32.write_to(output, &TEST_ALL_TYPES_REPEATED_SFIXED32_CODEC)?;
        self.repeated_sfixed64.write_to(output, &TEST_ALL_TYPES_REPEATED_SFIXED64_CODEC)?;
        self.repeated_float.write_to(output, &TEST_ALL_TYPES_REPEATED_FLOAT_CODEC)?;
        self.repeated_double.write_to(output, &TEST_ALL_TYPES_REPEATED_DOUBLE_CODEC)?;
        self.repeated_bool.write_to(output, &TEST_ALL_TYPES_REPEATED_BOOL_CODEC)?;
        self.repeated_string.write_to(output, &TEST_ALL_TYPES_REPEATED_STRING_CODEC)?;
        self.repeated_bytes.write_to(output, &TEST_ALL_TYPES_REPEATED_BYTES_CODEC)?;
        self.repeated_nested_message.write_to(output, &TEST_ALL_TYPES_REPEATED_NESTED_MESSAGE_CODEC)?;
        self.repeated_foreign_message.write_to(output, &TEST_ALL_TYPES_REPEATED_FOREIGN_MESSAGE_CODEC)?;
        self.repeated_import_message.write_to(output, &TEST_ALL_TYPES_REPEATED_IMPORT_MESSAGE_CODEC)?;
        self.repeated_nested_enum.write_to(output, &TEST_ALL_TYPES_REPEATED_NESTED_ENUM_CODEC)?;
        self.repeated_foreign_enum.write_to(output, &TEST_ALL_TYPES_REPEATED_FOREIGN_ENUM_CODEC)?;
        self.repeated_string_piece.write_to(output, &TEST_ALL_TYPES_REPEATED_STRING_PIECE_CODEC)?;
        self.repeated_cord.write_to(output, &TEST_ALL_TYPES_REPEATED_CORD_CODEC)?;
        self.repeated_lazy_message.write_to(output, &TEST_ALL_TYPES_REPEATED_LAZY_MESSAGE_CODEC)?;
        if let self::test_all_types::OneofField::OneofUint32(oneof_field) = self.oneof_field {
            output.write_raw_tag_bytes(&[248, 6])?;
            output.write_uint32(oneof_field)?;
        }
        if let self::test_all_types::OneofField::OneofNestedMessage(oneof_field) = &self.oneof_field {
            output.write_raw_tag_bytes(&[130, 7])?;
            output.write_message(&**oneof_field)?;
        }
        if let self::test_all_types::OneofField::OneofString(oneof_field) = &self.oneof_field {
            output.write_raw_tag_bytes(&[138, 7])?;
            output.write_string(oneof_field)?;
        }
        if let self::test_all_types::OneofField::OneofBytes(oneof_field) = &self.oneof_field {
            output.write_raw_tag_bytes(&[146, 7])?;
            output.write_bytes(oneof_field)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::TestAllTypes {
    fn new() -> Self {
        Self {
            optional_int32: Self::OPTIONAL_INT32_DEFAULT_VALUE,
            optional_int64: Self::OPTIONAL_INT64_DEFAULT_VALUE,
            optional_uint32: Self::OPTIONAL_UINT32_DEFAULT_VALUE,
            optional_uint64: Self::OPTIONAL_UINT64_DEFAULT_VALUE,
            optional_sint32: Self::OPTIONAL_SINT32_DEFAULT_VALUE,
            optional_sint64: Self::OPTIONAL_SINT64_DEFAULT_VALUE,
            optional_fixed32: Self::OPTIONAL_FIXED32_DEFAULT_VALUE,
            optional_fixed64: Self::OPTIONAL_FIXED64_DEFAULT_VALUE,
            optional_sfixed32: Self::OPTIONAL_SFIXED32_DEFAULT_VALUE,
            optional_sfixed64: Self::OPTIONAL_SFIXED64_DEFAULT_VALUE,
            optional_float: Self::OPTIONAL_FLOAT_DEFAULT_VALUE,
            optional_double: Self::OPTIONAL_DOUBLE_DEFAULT_VALUE,
            optional_bool: Self::OPTIONAL_BOOL_DEFAULT_VALUE,
            optional_string: ::std::string::String::new(),
            optional_bytes: ::std::vec::Vec::new(),
            optional_nested_message: ::std::option::Option::None,
            optional_foreign_message: ::std::option::Option::None,
            optional_import_message: ::std::option::Option::None,
            optional_nested_enum: Self::OPTIONAL_NESTED_ENUM_DEFAULT_VALUE,
            optional_foreign_enum: Self::OPTIONAL_FOREIGN_ENUM_DEFAULT_VALUE,
            optional_string_piece: ::std::string::String::new(),
            optional_cord: ::std::string::String::new(),
            optional_public_import_message: ::std::option::Option::None,
            optional_lazy_message: ::std::option::Option::None,
            optional_lazy_import_message: ::std::option::Option::None,
            repeated_int32: ::protrust::collections::RepeatedField::new(),
            repeated_int64: ::protrust::collections::RepeatedField::new(),
            repeated_uint32: ::protrust::collections::RepeatedField::new(),
            repeated_uint64: ::protrust::collections::RepeatedField::new(),
            repeated_sint32: ::protrust::collections::RepeatedField::new(),
            repeated_sint64: ::protrust::collections::RepeatedField::new(),
            repeated_fixed32: ::protrust::collections::RepeatedField::new(),
            repeated_fixed64: ::protrust::collections::RepeatedField::new(),
            repeated_sfixed32: ::protrust::collections::RepeatedField::new(),
            repeated_sfixed64: ::protrust::collections::RepeatedField::new(),
            repeated_float: ::protrust::collections::RepeatedField::new(),
            repeated_double: ::protrust::collections::RepeatedField::new(),
            repeated_bool: ::protrust::collections::RepeatedField::new(),
            repeated_string: ::protrust::collections::RepeatedField::new(),
            repeated_bytes: ::protrust::collections::RepeatedField::new(),
            repeated_nested_message: ::protrust::collections::RepeatedField::new(),
            repeated_foreign_message: ::protrust::collections::RepeatedField::new(),
            repeated_import_message: ::protrust::collections::RepeatedField::new(),
            repeated_nested_enum: ::protrust::collections::RepeatedField::new(),
            repeated_foreign_enum: ::protrust::collections::RepeatedField::new(),
            repeated_string_piece: ::protrust::collections::RepeatedField::new(),
            repeated_cord: ::protrust::collections::RepeatedField::new(),
            repeated_lazy_message: ::protrust::collections::RepeatedField::new(),
            oneof_field: self::test_all_types::OneofField::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.optional_int32 = other.optional_int32;
        self.optional_int64 = other.optional_int64;
        self.optional_uint32 = other.optional_uint32;
        self.optional_uint64 = other.optional_uint64;
        self.optional_sint32 = other.optional_sint32;
        self.optional_sint64 = other.optional_sint64;
        self.optional_fixed32 = other.optional_fixed32;
        self.optional_fixed64 = other.optional_fixed64;
        self.optional_sfixed32 = other.optional_sfixed32;
        self.optional_sfixed64 = other.optional_sfixed64;
        self.optional_float = other.optional_float;
        self.optional_double = other.optional_double;
        self.optional_bool = other.optional_bool;
        self.optional_string = other.optional_string.clone();
        self.optional_bytes = other.optional_bytes.clone();
        if let ::std::option::Option::Some(optional_nested_message) = &other.optional_nested_message {
            self.optional_nested_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(optional_nested_message);
        }
        if let ::std::option::Option::Some(optional_foreign_message) = &other.optional_foreign_message {
            self.optional_foreign_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(optional_foreign_message);
        }
        if let ::std::option::Option::Some(optional_import_message) = &other.optional_import_message {
            self.optional_import_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(optional_import_message);
        }
        self.optional_nested_enum = other.optional_nested_enum;
        self.optional_foreign_enum = other.optional_foreign_enum;
        self.optional_string_piece = other.optional_string_piece.clone();
        self.optional_cord = other.optional_cord.clone();
        if let ::std::option::Option::Some(optional_public_import_message) = &other.optional_public_import_message {
            self.optional_public_import_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(optional_public_import_message);
        }
        if let ::std::option::Option::Some(optional_lazy_message) = &other.optional_lazy_message {
            self.optional_lazy_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(optional_lazy_message);
        }
        if let ::std::option::Option::Some(optional_lazy_import_message) = &other.optional_lazy_import_message {
            self.optional_lazy_import_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(optional_lazy_import_message);
        }
        self.repeated_int32.merge(&other.repeated_int32);
        self.repeated_int64.merge(&other.repeated_int64);
        self.repeated_uint32.merge(&other.repeated_uint32);
        self.repeated_uint64.merge(&other.repeated_uint64);
        self.repeated_sint32.merge(&other.repeated_sint32);
        self.repeated_sint64.merge(&other.repeated_sint64);
        self.repeated_fixed32.merge(&other.repeated_fixed32);
        self.repeated_fixed64.merge(&other.repeated_fixed64);
        self.repeated_sfixed32.merge(&other.repeated_sfixed32);
        self.repeated_sfixed64.merge(&other.repeated_sfixed64);
        self.repeated_float.merge(&other.repeated_float);
        self.repeated_double.merge(&other.repeated_double);
        self.repeated_bool.merge(&other.repeated_bool);
        self.repeated_string.merge(&other.repeated_string);
        self.repeated_bytes.merge(&other.repeated_bytes);
        self.repeated_nested_message.merge(&other.repeated_nested_message);
        self.repeated_foreign_message.merge(&other.repeated_foreign_message);
        self.repeated_import_message.merge(&other.repeated_import_message);
        self.repeated_nested_enum.merge(&other.repeated_nested_enum);
        self.repeated_foreign_enum.merge(&other.repeated_foreign_enum);
        self.repeated_string_piece.merge(&other.repeated_string_piece);
        self.repeated_cord.merge(&other.repeated_cord);
        self.repeated_lazy_message.merge(&other.repeated_lazy_message);
        if let self::test_all_types::OneofField::OneofUint32(oneof_field) = other.oneof_field {
            self.oneof_field = self::test_all_types::OneofField::OneofUint32(oneof_field);
        }
        if let self::test_all_types::OneofField::OneofNestedMessage(oneof_field) = &other.oneof_field {
            if let self::test_all_types::OneofField::OneofNestedMessage(existing) = &mut self.oneof_field {
                existing.merge(oneof_field);
            } else {
                self.oneof_field = self::test_all_types::OneofField::OneofNestedMessage(oneof_field.clone());
            }
        }
        if let self::test_all_types::OneofField::OneofString(oneof_field) = &other.oneof_field {
            self.oneof_field = self::test_all_types::OneofField::OneofString(oneof_field.clone());
        }
        if let self::test_all_types::OneofField::OneofBytes(oneof_field) = &other.oneof_field {
            self.oneof_field = self::test_all_types::OneofField::OneofBytes(oneof_field.clone());
        }
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestAllTypes {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[0]
    }
}
impl self::TestAllTypes {
    /// Gets the field number of the [`optional_int32`] field
    ///
    /// [`optional_int32`]: #method.optional_int32
    pub const OPTIONAL_INT32_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`optional_int32`] field
    ///
    /// [`optional_int32`]: #method.optional_int32
    pub const OPTIONAL_INT32_DEFAULT_VALUE: i32 = 0;
    ///  Singular
    pub fn optional_int32(&self) -> i32 {
        self.optional_int32
    }
    /// Returns a unique reference to the [`optional_int32`] field
    ///
    /// [`optional_int32`]: #method.optional_int32
    pub fn optional_int32_mut(&mut self) -> &mut i32 {
        &mut self.optional_int32
    }
    /// Gets the field number of the [`optional_int64`] field
    ///
    /// [`optional_int64`]: #method.optional_int64
    pub const OPTIONAL_INT64_FIELD_NUMBER: i32 = 2;
    /// A constant value representing the default value of the [`optional_int64`] field
    ///
    /// [`optional_int64`]: #method.optional_int64
    pub const OPTIONAL_INT64_DEFAULT_VALUE: i64 = 0;
    pub fn optional_int64(&self) -> i64 {
        self.optional_int64
    }
    /// Returns a unique reference to the [`optional_int64`] field
    ///
    /// [`optional_int64`]: #method.optional_int64
    pub fn optional_int64_mut(&mut self) -> &mut i64 {
        &mut self.optional_int64
    }
    /// Gets the field number of the [`optional_uint32`] field
    ///
    /// [`optional_uint32`]: #method.optional_uint32
    pub const OPTIONAL_UINT32_FIELD_NUMBER: i32 = 3;
    /// A constant value representing the default value of the [`optional_uint32`] field
    ///
    /// [`optional_uint32`]: #method.optional_uint32
    pub const OPTIONAL_UINT32_DEFAULT_VALUE: u32 = 0;
    pub fn optional_uint32(&self) -> u32 {
        self.optional_uint32
    }
    /// Returns a unique reference to the [`optional_uint32`] field
    ///
    /// [`optional_uint32`]: #method.optional_uint32
    pub fn optional_uint32_mut(&mut self) -> &mut u32 {
        &mut self.optional_uint32
    }
    /// Gets the field number of the [`optional_uint64`] field
    ///
    /// [`optional_uint64`]: #method.optional_uint64
    pub const OPTIONAL_UINT64_FIELD_NUMBER: i32 = 4;
    /// A constant value representing the default value of the [`optional_uint64`] field
    ///
    /// [`optional_uint64`]: #method.optional_uint64
    pub const OPTIONAL_UINT64_DEFAULT_VALUE: u64 = 0;
    pub fn optional_uint64(&self) -> u64 {
        self.optional_uint64
    }
    /// Returns a unique reference to the [`optional_uint64`] field
    ///
    /// [`optional_uint64`]: #method.optional_uint64
    pub fn optional_uint64_mut(&mut self) -> &mut u64 {
        &mut self.optional_uint64
    }
    /// Gets the field number of the [`optional_sint32`] field
    ///
    /// [`optional_sint32`]: #method.optional_sint32
    pub const OPTIONAL_SINT32_FIELD_NUMBER: i32 = 5;
    /// A constant value representing the default value of the [`optional_sint32`] field
    ///
    /// [`optional_sint32`]: #method.optional_sint32
    pub const OPTIONAL_SINT32_DEFAULT_VALUE: i32 = 0;
    pub fn optional_sint32(&self) -> i32 {
        self.optional_sint32
    }
    /// Returns a unique reference to the [`optional_sint32`] field
    ///
    /// [`optional_sint32`]: #method.optional_sint32
    pub fn optional_sint32_mut(&mut self) -> &mut i32 {
        &mut self.optional_sint32
    }
    /// Gets the field number of the [`optional_sint64`] field
    ///
    /// [`optional_sint64`]: #method.optional_sint64
    pub const OPTIONAL_SINT64_FIELD_NUMBER: i32 = 6;
    /// A constant value representing the default value of the [`optional_sint64`] field
    ///
    /// [`optional_sint64`]: #method.optional_sint64
    pub const OPTIONAL_SINT64_DEFAULT_VALUE: i64 = 0;
    pub fn optional_sint64(&self) -> i64 {
        self.optional_sint64
    }
    /// Returns a unique reference to the [`optional_sint64`] field
    ///
    /// [`optional_sint64`]: #method.optional_sint64
    pub fn optional_sint64_mut(&mut self) -> &mut i64 {
        &mut self.optional_sint64
    }
    /// Gets the field number of the [`optional_fixed32`] field
    ///
    /// [`optional_fixed32`]: #method.optional_fixed32
    pub const OPTIONAL_FIXED32_FIELD_NUMBER: i32 = 7;
    /// A constant value representing the default value of the [`optional_fixed32`] field
    ///
    /// [`optional_fixed32`]: #method.optional_fixed32
    pub const OPTIONAL_FIXED32_DEFAULT_VALUE: u32 = 0;
    pub fn optional_fixed32(&self) -> u32 {
        self.optional_fixed32
    }
    /// Returns a unique reference to the [`optional_fixed32`] field
    ///
    /// [`optional_fixed32`]: #method.optional_fixed32
    pub fn optional_fixed32_mut(&mut self) -> &mut u32 {
        &mut self.optional_fixed32
    }
    /// Gets the field number of the [`optional_fixed64`] field
    ///
    /// [`optional_fixed64`]: #method.optional_fixed64
    pub const OPTIONAL_FIXED64_FIELD_NUMBER: i32 = 8;
    /// A constant value representing the default value of the [`optional_fixed64`] field
    ///
    /// [`optional_fixed64`]: #method.optional_fixed64
    pub const OPTIONAL_FIXED64_DEFAULT_VALUE: u64 = 0;
    pub fn optional_fixed64(&self) -> u64 {
        self.optional_fixed64
    }
    /// Returns a unique reference to the [`optional_fixed64`] field
    ///
    /// [`optional_fixed64`]: #method.optional_fixed64
    pub fn optional_fixed64_mut(&mut self) -> &mut u64 {
        &mut self.optional_fixed64
    }
    /// Gets the field number of the [`optional_sfixed32`] field
    ///
    /// [`optional_sfixed32`]: #method.optional_sfixed32
    pub const OPTIONAL_SFIXED32_FIELD_NUMBER: i32 = 9;
    /// A constant value representing the default value of the [`optional_sfixed32`] field
    ///
    /// [`optional_sfixed32`]: #method.optional_sfixed32
    pub const OPTIONAL_SFIXED32_DEFAULT_VALUE: i32 = 0;
    pub fn optional_sfixed32(&self) -> i32 {
        self.optional_sfixed32
    }
    /// Returns a unique reference to the [`optional_sfixed32`] field
    ///
    /// [`optional_sfixed32`]: #method.optional_sfixed32
    pub fn optional_sfixed32_mut(&mut self) -> &mut i32 {
        &mut self.optional_sfixed32
    }
    /// Gets the field number of the [`optional_sfixed64`] field
    ///
    /// [`optional_sfixed64`]: #method.optional_sfixed64
    pub const OPTIONAL_SFIXED64_FIELD_NUMBER: i32 = 10;
    /// A constant value representing the default value of the [`optional_sfixed64`] field
    ///
    /// [`optional_sfixed64`]: #method.optional_sfixed64
    pub const OPTIONAL_SFIXED64_DEFAULT_VALUE: i64 = 0;
    pub fn optional_sfixed64(&self) -> i64 {
        self.optional_sfixed64
    }
    /// Returns a unique reference to the [`optional_sfixed64`] field
    ///
    /// [`optional_sfixed64`]: #method.optional_sfixed64
    pub fn optional_sfixed64_mut(&mut self) -> &mut i64 {
        &mut self.optional_sfixed64
    }
    /// Gets the field number of the [`optional_float`] field
    ///
    /// [`optional_float`]: #method.optional_float
    pub const OPTIONAL_FLOAT_FIELD_NUMBER: i32 = 11;
    /// A constant value representing the default value of the [`optional_float`] field
    ///
    /// [`optional_float`]: #method.optional_float
    pub const OPTIONAL_FLOAT_DEFAULT_VALUE: f32 = 0.0;
    pub fn optional_float(&self) -> f32 {
        self.optional_float
    }
    /// Returns a unique reference to the [`optional_float`] field
    ///
    /// [`optional_float`]: #method.optional_float
    pub fn optional_float_mut(&mut self) -> &mut f32 {
        &mut self.optional_float
    }
    /// Gets the field number of the [`optional_double`] field
    ///
    /// [`optional_double`]: #method.optional_double
    pub const OPTIONAL_DOUBLE_FIELD_NUMBER: i32 = 12;
    /// A constant value representing the default value of the [`optional_double`] field
    ///
    /// [`optional_double`]: #method.optional_double
    pub const OPTIONAL_DOUBLE_DEFAULT_VALUE: f64 = 0.0;
    pub fn optional_double(&self) -> f64 {
        self.optional_double
    }
    /// Returns a unique reference to the [`optional_double`] field
    ///
    /// [`optional_double`]: #method.optional_double
    pub fn optional_double_mut(&mut self) -> &mut f64 {
        &mut self.optional_double
    }
    /// Gets the field number of the [`optional_bool`] field
    ///
    /// [`optional_bool`]: #method.optional_bool
    pub const OPTIONAL_BOOL_FIELD_NUMBER: i32 = 13;
    /// A constant value representing the default value of the [`optional_bool`] field
    ///
    /// [`optional_bool`]: #method.optional_bool
    pub const OPTIONAL_BOOL_DEFAULT_VALUE: bool = false;
    pub fn optional_bool(&self) -> bool {
        self.optional_bool
    }
    /// Returns a unique reference to the [`optional_bool`] field
    ///
    /// [`optional_bool`]: #method.optional_bool
    pub fn optional_bool_mut(&mut self) -> &mut bool {
        &mut self.optional_bool
    }
    /// Gets the field number of the [`optional_string`] field
    ///
    /// [`optional_string`]: #method.optional_string
    pub const OPTIONAL_STRING_FIELD_NUMBER: i32 = 14;
    /// A constant value representing the default value of the [`optional_string`] field
    ///
    /// [`optional_string`]: #method.optional_string
    pub const OPTIONAL_STRING_DEFAULT_VALUE: &'static str = "";
    pub fn optional_string(&self) -> &::std::string::String {
        &self.optional_string
    }
    /// Returns a unique reference to the [`optional_string`] field
    ///
    /// [`optional_string`]: #method.optional_string
    pub fn optional_string_mut(&mut self) -> &mut ::std::string::String {
        &mut self.optional_string
    }
    /// Gets the field number of the [`optional_bytes`] field
    ///
    /// [`optional_bytes`]: #method.optional_bytes
    pub const OPTIONAL_BYTES_FIELD_NUMBER: i32 = 15;
    /// A constant value representing the default value of the [`optional_bytes`] field
    ///
    /// [`optional_bytes`]: #method.optional_bytes
    pub const OPTIONAL_BYTES_DEFAULT_VALUE: &'static [u8] = &[];
    pub fn optional_bytes(&self) -> &::std::vec::Vec<u8> {
        &self.optional_bytes
    }
    /// Returns a unique reference to the [`optional_bytes`] field
    ///
    /// [`optional_bytes`]: #method.optional_bytes
    pub fn optional_bytes_mut(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.optional_bytes
    }
    /// Gets the field number of the [`optional_nested_message`] field
    ///
    /// [`optional_nested_message`]: #method.optional_nested_message
    pub const OPTIONAL_NESTED_MESSAGE_FIELD_NUMBER: i32 = 18;
    pub fn optional_nested_message(&self) -> &::std::option::Option<::std::boxed::Box<self::test_all_types::NestedMessage>> {
        &self.optional_nested_message
    }
    /// Returns a unique reference to the [`optional_nested_message`] field
    ///
    /// [`optional_nested_message`]: #method.optional_nested_message
    pub fn optional_nested_message_mut(&mut self) -> &mut ::std::option::Option<::std::boxed::Box<self::test_all_types::NestedMessage>> {
        &mut self.optional_nested_message
    }
    /// Gets the field number of the [`optional_foreign_message`] field
    ///
    /// [`optional_foreign_message`]: #method.optional_foreign_message
    pub const OPTIONAL_FOREIGN_MESSAGE_FIELD_NUMBER: i32 = 19;
    pub fn optional_foreign_message(&self) -> &::std::option::Option<::std::boxed::Box<self::ForeignMessage>> {
        &self.optional_foreign_message
    }
    /// Returns a unique reference to the [`optional_foreign_message`] field
    ///
    /// [`optional_foreign_message`]: #method.optional_foreign_message
    pub fn optional_foreign_message_mut(&mut self) -> &mut ::std::option::Option<::std::boxed::Box<self::ForeignMessage>> {
        &mut self.optional_foreign_message
    }
    /// Gets the field number of the [`optional_import_message`] field
    ///
    /// [`optional_import_message`]: #method.optional_import_message
    pub const OPTIONAL_IMPORT_MESSAGE_FIELD_NUMBER: i32 = 20;
    pub fn optional_import_message(&self) -> &::std::option::Option<::std::boxed::Box<self::super::unittest_import_proto::ImportMessage>> {
        &self.optional_import_message
    }
    /// Returns a unique reference to the [`optional_import_message`] field
    ///
    /// [`optional_import_message`]: #method.optional_import_message
    pub fn optional_import_message_mut(&mut self) -> &mut ::std::option::Option<::std::boxed::Box<self::super::unittest_import_proto::ImportMessage>> {
        &mut self.optional_import_message
    }
    /// Gets the field number of the [`optional_nested_enum`] field
    ///
    /// [`optional_nested_enum`]: #method.optional_nested_enum
    pub const OPTIONAL_NESTED_ENUM_FIELD_NUMBER: i32 = 21;
    /// A constant value representing the default value of the [`optional_nested_enum`] field
    ///
    /// [`optional_nested_enum`]: #method.optional_nested_enum
    pub const OPTIONAL_NESTED_ENUM_DEFAULT_VALUE: ::protrust::EnumValue<self::test_all_types::NestedEnum> = ::protrust::EnumValue::Defined(self::test_all_types::NestedEnum::Zero);
    pub fn optional_nested_enum(&self) -> ::protrust::EnumValue<self::test_all_types::NestedEnum> {
        self.optional_nested_enum
    }
    /// Returns a unique reference to the [`optional_nested_enum`] field
    ///
    /// [`optional_nested_enum`]: #method.optional_nested_enum
    pub fn optional_nested_enum_mut(&mut self) -> &mut ::protrust::EnumValue<self::test_all_types::NestedEnum> {
        &mut self.optional_nested_enum
    }
    /// Gets the field number of the [`optional_foreign_enum`] field
    ///
    /// [`optional_foreign_enum`]: #method.optional_foreign_enum
    pub const OPTIONAL_FOREIGN_ENUM_FIELD_NUMBER: i32 = 22;
    /// A constant value representing the default value of the [`optional_foreign_enum`] field
    ///
    /// [`optional_foreign_enum`]: #method.optional_foreign_enum
    pub const OPTIONAL_FOREIGN_ENUM_DEFAULT_VALUE: ::protrust::EnumValue<self::ForeignEnum> = ::protrust::EnumValue::Defined(self::ForeignEnum::ForeignZero);
    pub fn optional_foreign_enum(&self) -> ::protrust::EnumValue<self::ForeignEnum> {
        self.optional_foreign_enum
    }
    /// Returns a unique reference to the [`optional_foreign_enum`] field
    ///
    /// [`optional_foreign_enum`]: #method.optional_foreign_enum
    pub fn optional_foreign_enum_mut(&mut self) -> &mut ::protrust::EnumValue<self::ForeignEnum> {
        &mut self.optional_foreign_enum
    }
    /// Gets the field number of the [`optional_string_piece`] field
    ///
    /// [`optional_string_piece`]: #method.optional_string_piece
    pub const OPTIONAL_STRING_PIECE_FIELD_NUMBER: i32 = 24;
    /// A constant value representing the default value of the [`optional_string_piece`] field
    ///
    /// [`optional_string_piece`]: #method.optional_string_piece
    pub const OPTIONAL_STRING_PIECE_DEFAULT_VALUE: &'static str = "";
    pub fn optional_string_piece(&self) -> &::std::string::String {
        &self.optional_string_piece
    }
    /// Returns a unique reference to the [`optional_string_piece`] field
    ///
    /// [`optional_string_piece`]: #method.optional_string_piece
    pub fn optional_string_piece_mut(&mut self) -> &mut ::std::string::String {
        &mut self.optional_string_piece
    }
    /// Gets the field number of the [`optional_cord`] field
    ///
    /// [`optional_cord`]: #method.optional_cord
    pub const OPTIONAL_CORD_FIELD_NUMBER: i32 = 25;
    /// A constant value representing the default value of the [`optional_cord`] field
    ///
    /// [`optional_cord`]: #method.optional_cord
    pub const OPTIONAL_CORD_DEFAULT_VALUE: &'static str = "";
    pub fn optional_cord(&self) -> &::std::string::String {
        &self.optional_cord
    }
    /// Returns a unique reference to the [`optional_cord`] field
    ///
    /// [`optional_cord`]: #method.optional_cord
    pub fn optional_cord_mut(&mut self) -> &mut ::std::string::String {
        &mut self.optional_cord
    }
    /// Gets the field number of the [`optional_public_import_message`] field
    ///
    /// [`optional_public_import_message`]: #method.optional_public_import_message
    pub const OPTIONAL_PUBLIC_IMPORT_MESSAGE_FIELD_NUMBER: i32 = 26;
    ///  Defined in unittest_import_public.proto
    pub fn optional_public_import_message(&self) -> &::std::option::Option<::std::boxed::Box<self::super::unittest_import_public_proto::PublicImportMessage>> {
        &self.optional_public_import_message
    }
    /// Returns a unique reference to the [`optional_public_import_message`] field
    ///
    /// [`optional_public_import_message`]: #method.optional_public_import_message
    pub fn optional_public_import_message_mut(&mut self) -> &mut ::std::option::Option<::std::boxed::Box<self::super::unittest_import_public_proto::PublicImportMessage>> {
        &mut self.optional_public_import_message
    }
    /// Gets the field number of the [`optional_lazy_message`] field
    ///
    /// [`optional_lazy_message`]: #method.optional_lazy_message
    pub const OPTIONAL_LAZY_MESSAGE_FIELD_NUMBER: i32 = 27;
    pub fn optional_lazy_message(&self) -> &::std::option::Option<::std::boxed::Box<self::test_all_types::NestedMessage>> {
        &self.optional_lazy_message
    }
    /// Returns a unique reference to the [`optional_lazy_message`] field
    ///
    /// [`optional_lazy_message`]: #method.optional_lazy_message
    pub fn optional_lazy_message_mut(&mut self) -> &mut ::std::option::Option<::std::boxed::Box<self::test_all_types::NestedMessage>> {
        &mut self.optional_lazy_message
    }
    /// Gets the field number of the [`optional_lazy_import_message`] field
    ///
    /// [`optional_lazy_import_message`]: #method.optional_lazy_import_message
    pub const OPTIONAL_LAZY_IMPORT_MESSAGE_FIELD_NUMBER: i32 = 115;
    pub fn optional_lazy_import_message(&self) -> &::std::option::Option<::std::boxed::Box<self::super::unittest_import_proto::ImportMessage>> {
        &self.optional_lazy_import_message
    }
    /// Returns a unique reference to the [`optional_lazy_import_message`] field
    ///
    /// [`optional_lazy_import_message`]: #method.optional_lazy_import_message
    pub fn optional_lazy_import_message_mut(&mut self) -> &mut ::std::option::Option<::std::boxed::Box<self::super::unittest_import_proto::ImportMessage>> {
        &mut self.optional_lazy_import_message
    }
    /// Gets the field number of the [`repeated_int32`] field
    ///
    /// [`repeated_int32`]: #method.repeated_int32
    pub const REPEATED_INT32_FIELD_NUMBER: i32 = 31;
    ///  Repeated
    pub fn repeated_int32(&self) -> &::protrust::collections::RepeatedField<i32> {
        &self.repeated_int32
    }
    /// Returns a unique reference to the [`repeated_int32`] field
    ///
    /// [`repeated_int32`]: #method.repeated_int32
    pub fn repeated_int32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
        &mut self.repeated_int32
    }
    /// Gets the field number of the [`repeated_int64`] field
    ///
    /// [`repeated_int64`]: #method.repeated_int64
    pub const REPEATED_INT64_FIELD_NUMBER: i32 = 32;
    pub fn repeated_int64(&self) -> &::protrust::collections::RepeatedField<i64> {
        &self.repeated_int64
    }
    /// Returns a unique reference to the [`repeated_int64`] field
    ///
    /// [`repeated_int64`]: #method.repeated_int64
    pub fn repeated_int64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
        &mut self.repeated_int64
    }
    /// Gets the field number of the [`repeated_uint32`] field
    ///
    /// [`repeated_uint32`]: #method.repeated_uint32
    pub const REPEATED_UINT32_FIELD_NUMBER: i32 = 33;
    pub fn repeated_uint32(&self) -> &::protrust::collections::RepeatedField<u32> {
        &self.repeated_uint32
    }
    /// Returns a unique reference to the [`repeated_uint32`] field
    ///
    /// [`repeated_uint32`]: #method.repeated_uint32
    pub fn repeated_uint32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u32> {
        &mut self.repeated_uint32
    }
    /// Gets the field number of the [`repeated_uint64`] field
    ///
    /// [`repeated_uint64`]: #method.repeated_uint64
    pub const REPEATED_UINT64_FIELD_NUMBER: i32 = 34;
    pub fn repeated_uint64(&self) -> &::protrust::collections::RepeatedField<u64> {
        &self.repeated_uint64
    }
    /// Returns a unique reference to the [`repeated_uint64`] field
    ///
    /// [`repeated_uint64`]: #method.repeated_uint64
    pub fn repeated_uint64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u64> {
        &mut self.repeated_uint64
    }
    /// Gets the field number of the [`repeated_sint32`] field
    ///
    /// [`repeated_sint32`]: #method.repeated_sint32
    pub const REPEATED_SINT32_FIELD_NUMBER: i32 = 35;
    pub fn repeated_sint32(&self) -> &::protrust::collections::RepeatedField<i32> {
        &self.repeated_sint32
    }
    /// Returns a unique reference to the [`repeated_sint32`] field
    ///
    /// [`repeated_sint32`]: #method.repeated_sint32
    pub fn repeated_sint32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
        &mut self.repeated_sint32
    }
    /// Gets the field number of the [`repeated_sint64`] field
    ///
    /// [`repeated_sint64`]: #method.repeated_sint64
    pub const REPEATED_SINT64_FIELD_NUMBER: i32 = 36;
    pub fn repeated_sint64(&self) -> &::protrust::collections::RepeatedField<i64> {
        &self.repeated_sint64
    }
    /// Returns a unique reference to the [`repeated_sint64`] field
    ///
    /// [`repeated_sint64`]: #method.repeated_sint64
    pub fn repeated_sint64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
        &mut self.repeated_sint64
    }
    /// Gets the field number of the [`repeated_fixed32`] field
    ///
    /// [`repeated_fixed32`]: #method.repeated_fixed32
    pub const REPEATED_FIXED32_FIELD_NUMBER: i32 = 37;
    pub fn repeated_fixed32(&self) -> &::protrust::collections::RepeatedField<u32> {
        &self.repeated_fixed32
    }
    /// Returns a unique reference to the [`repeated_fixed32`] field
    ///
    /// [`repeated_fixed32`]: #method.repeated_fixed32
    pub fn repeated_fixed32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u32> {
        &mut self.repeated_fixed32
    }
    /// Gets the field number of the [`repeated_fixed64`] field
    ///
    /// [`repeated_fixed64`]: #method.repeated_fixed64
    pub const REPEATED_FIXED64_FIELD_NUMBER: i32 = 38;
    pub fn repeated_fixed64(&self) -> &::protrust::collections::RepeatedField<u64> {
        &self.repeated_fixed64
    }
    /// Returns a unique reference to the [`repeated_fixed64`] field
    ///
    /// [`repeated_fixed64`]: #method.repeated_fixed64
    pub fn repeated_fixed64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u64> {
        &mut self.repeated_fixed64
    }
    /// Gets the field number of the [`repeated_sfixed32`] field
    ///
    /// [`repeated_sfixed32`]: #method.repeated_sfixed32
    pub const REPEATED_SFIXED32_FIELD_NUMBER: i32 = 39;
    pub fn repeated_sfixed32(&self) -> &::protrust::collections::RepeatedField<i32> {
        &self.repeated_sfixed32
    }
    /// Returns a unique reference to the [`repeated_sfixed32`] field
    ///
    /// [`repeated_sfixed32`]: #method.repeated_sfixed32
    pub fn repeated_sfixed32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
        &mut self.repeated_sfixed32
    }
    /// Gets the field number of the [`repeated_sfixed64`] field
    ///
    /// [`repeated_sfixed64`]: #method.repeated_sfixed64
    pub const REPEATED_SFIXED64_FIELD_NUMBER: i32 = 40;
    pub fn repeated_sfixed64(&self) -> &::protrust::collections::RepeatedField<i64> {
        &self.repeated_sfixed64
    }
    /// Returns a unique reference to the [`repeated_sfixed64`] field
    ///
    /// [`repeated_sfixed64`]: #method.repeated_sfixed64
    pub fn repeated_sfixed64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
        &mut self.repeated_sfixed64
    }
    /// Gets the field number of the [`repeated_float`] field
    ///
    /// [`repeated_float`]: #method.repeated_float
    pub const REPEATED_FLOAT_FIELD_NUMBER: i32 = 41;
    pub fn repeated_float(&self) -> &::protrust::collections::RepeatedField<f32> {
        &self.repeated_float
    }
    /// Returns a unique reference to the [`repeated_float`] field
    ///
    /// [`repeated_float`]: #method.repeated_float
    pub fn repeated_float_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<f32> {
        &mut self.repeated_float
    }
    /// Gets the field number of the [`repeated_double`] field
    ///
    /// [`repeated_double`]: #method.repeated_double
    pub const REPEATED_DOUBLE_FIELD_NUMBER: i32 = 42;
    pub fn repeated_double(&self) -> &::protrust::collections::RepeatedField<f64> {
        &self.repeated_double
    }
    /// Returns a unique reference to the [`repeated_double`] field
    ///
    /// [`repeated_double`]: #method.repeated_double
    pub fn repeated_double_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<f64> {
        &mut self.repeated_double
    }
    /// Gets the field number of the [`repeated_bool`] field
    ///
    /// [`repeated_bool`]: #method.repeated_bool
    pub const REPEATED_BOOL_FIELD_NUMBER: i32 = 43;
    pub fn repeated_bool(&self) -> &::protrust::collections::RepeatedField<bool> {
        &self.repeated_bool
    }
    /// Returns a unique reference to the [`repeated_bool`] field
    ///
    /// [`repeated_bool`]: #method.repeated_bool
    pub fn repeated_bool_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<bool> {
        &mut self.repeated_bool
    }
    /// Gets the field number of the [`repeated_string`] field
    ///
    /// [`repeated_string`]: #method.repeated_string
    pub const REPEATED_STRING_FIELD_NUMBER: i32 = 44;
    pub fn repeated_string(&self) -> &::protrust::collections::RepeatedField<::std::string::String> {
        &self.repeated_string
    }
    /// Returns a unique reference to the [`repeated_string`] field
    ///
    /// [`repeated_string`]: #method.repeated_string
    pub fn repeated_string_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<::std::string::String> {
        &mut self.repeated_string
    }
    /// Gets the field number of the [`repeated_bytes`] field
    ///
    /// [`repeated_bytes`]: #method.repeated_bytes
    pub const REPEATED_BYTES_FIELD_NUMBER: i32 = 45;
    pub fn repeated_bytes(&self) -> &::protrust::collections::RepeatedField<::std::vec::Vec<u8>> {
        &self.repeated_bytes
    }
    /// Returns a unique reference to the [`repeated_bytes`] field
    ///
    /// [`repeated_bytes`]: #method.repeated_bytes
    pub fn repeated_bytes_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.repeated_bytes
    }
    /// Gets the field number of the [`repeated_nested_message`] field
    ///
    /// [`repeated_nested_message`]: #method.repeated_nested_message
    pub const REPEATED_NESTED_MESSAGE_FIELD_NUMBER: i32 = 48;
    pub fn repeated_nested_message(&self) -> &::protrust::collections::RepeatedField<self::test_all_types::NestedMessage> {
        &self.repeated_nested_message
    }
    /// Returns a unique reference to the [`repeated_nested_message`] field
    ///
    /// [`repeated_nested_message`]: #method.repeated_nested_message
    pub fn repeated_nested_message_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<self::test_all_types::NestedMessage> {
        &mut self.repeated_nested_message
    }
    /// Gets the field number of the [`repeated_foreign_message`] field
    ///
    /// [`repeated_foreign_message`]: #method.repeated_foreign_message
    pub const REPEATED_FOREIGN_MESSAGE_FIELD_NUMBER: i32 = 49;
    pub fn repeated_foreign_message(&self) -> &::protrust::collections::RepeatedField<self::ForeignMessage> {
        &self.repeated_foreign_message
    }
    /// Returns a unique reference to the [`repeated_foreign_message`] field
    ///
    /// [`repeated_foreign_message`]: #method.repeated_foreign_message
    pub fn repeated_foreign_message_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<self::ForeignMessage> {
        &mut self.repeated_foreign_message
    }
    /// Gets the field number of the [`repeated_import_message`] field
    ///
    /// [`repeated_import_message`]: #method.repeated_import_message
    pub const REPEATED_IMPORT_MESSAGE_FIELD_NUMBER: i32 = 50;
    pub fn repeated_import_message(&self) -> &::protrust::collections::RepeatedField<self::super::unittest_import_proto::ImportMessage> {
        &self.repeated_import_message
    }
    /// Returns a unique reference to the [`repeated_import_message`] field
    ///
    /// [`repeated_import_message`]: #method.repeated_import_message
    pub fn repeated_import_message_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<self::super::unittest_import_proto::ImportMessage> {
        &mut self.repeated_import_message
    }
    /// Gets the field number of the [`repeated_nested_enum`] field
    ///
    /// [`repeated_nested_enum`]: #method.repeated_nested_enum
    pub const REPEATED_NESTED_ENUM_FIELD_NUMBER: i32 = 51;
    pub fn repeated_nested_enum(&self) -> &::protrust::collections::RepeatedField<::protrust::EnumValue<self::test_all_types::NestedEnum>> {
        &self.repeated_nested_enum
    }
    /// Returns a unique reference to the [`repeated_nested_enum`] field
    ///
    /// [`repeated_nested_enum`]: #method.repeated_nested_enum
    pub fn repeated_nested_enum_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<::protrust::EnumValue<self::test_all_types::NestedEnum>> {
        &mut self.repeated_nested_enum
    }
    /// Gets the field number of the [`repeated_foreign_enum`] field
    ///
    /// [`repeated_foreign_enum`]: #method.repeated_foreign_enum
    pub const REPEATED_FOREIGN_ENUM_FIELD_NUMBER: i32 = 52;
    pub fn repeated_foreign_enum(&self) -> &::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>> {
        &self.repeated_foreign_enum
    }
    /// Returns a unique reference to the [`repeated_foreign_enum`] field
    ///
    /// [`repeated_foreign_enum`]: #method.repeated_foreign_enum
    pub fn repeated_foreign_enum_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>> {
        &mut self.repeated_foreign_enum
    }
    /// Gets the field number of the [`repeated_string_piece`] field
    ///
    /// [`repeated_string_piece`]: #method.repeated_string_piece
    pub const REPEATED_STRING_PIECE_FIELD_NUMBER: i32 = 54;
    pub fn repeated_string_piece(&self) -> &::protrust::collections::RepeatedField<::std::string::String> {
        &self.repeated_string_piece
    }
    /// Returns a unique reference to the [`repeated_string_piece`] field
    ///
    /// [`repeated_string_piece`]: #method.repeated_string_piece
    pub fn repeated_string_piece_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<::std::string::String> {
        &mut self.repeated_string_piece
    }
    /// Gets the field number of the [`repeated_cord`] field
    ///
    /// [`repeated_cord`]: #method.repeated_cord
    pub const REPEATED_CORD_FIELD_NUMBER: i32 = 55;
    pub fn repeated_cord(&self) -> &::protrust::collections::RepeatedField<::std::string::String> {
        &self.repeated_cord
    }
    /// Returns a unique reference to the [`repeated_cord`] field
    ///
    /// [`repeated_cord`]: #method.repeated_cord
    pub fn repeated_cord_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<::std::string::String> {
        &mut self.repeated_cord
    }
    /// Gets the field number of the [`repeated_lazy_message`] field
    ///
    /// [`repeated_lazy_message`]: #method.repeated_lazy_message
    pub const REPEATED_LAZY_MESSAGE_FIELD_NUMBER: i32 = 57;
    pub fn repeated_lazy_message(&self) -> &::protrust::collections::RepeatedField<self::test_all_types::NestedMessage> {
        &self.repeated_lazy_message
    }
    /// Returns a unique reference to the [`repeated_lazy_message`] field
    ///
    /// [`repeated_lazy_message`]: #method.repeated_lazy_message
    pub fn repeated_lazy_message_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<self::test_all_types::NestedMessage> {
        &mut self.repeated_lazy_message
    }
    /// Gets the field number of the [`oneof_uint32`] field
    ///
    /// [`oneof_uint32`]: #method.oneof_uint32
    pub const ONEOF_UINT32_FIELD_NUMBER: i32 = 111;
    /// A constant value representing the default value of the [`oneof_uint32`] field
    ///
    /// [`oneof_uint32`]: #method.oneof_uint32
    pub const ONEOF_UINT32_DEFAULT_VALUE: u32 = 0;
    pub fn oneof_uint32(&self) -> ::std::option::Option<&u32> {
        match &self.oneof_field {
            self::test_all_types::OneofField::OneofUint32(ref oneof_field) => ::std::option::Option::Some(oneof_field),
            _ => ::std::option::Option::None
        }
    }
    /// Returns a unique reference to the ['oneof_uint32'] field
    ///
    /// [`oneof_uint32`]: #method.oneof_uint32
    pub fn oneof_uint32_mut(&mut self) -> &mut u32 {
        match self.oneof_field {
            self::test_all_types::OneofField::OneofUint32(ref mut value) => value,
            _ => {
                self.set_oneof_uint32(::std::default::Default::default());
                self.oneof_uint32_mut()
            }
        }
    }
    pub fn has_oneof_uint32(&self) -> bool {
        match &self.oneof_field {
            self::test_all_types::OneofField::OneofUint32(_) => true,
            _ => false
        }
    }
    pub fn set_oneof_uint32(&mut self, value: u32) {
        self.oneof_field = self::test_all_types::OneofField::OneofUint32(value)
    }
    pub fn take_oneof_uint32(&mut self) -> ::std::option::Option<u32> {
        match ::std::mem::replace(&mut self.oneof_field, self::test_all_types::OneofField::None) {
            self::test_all_types::OneofField::OneofUint32(value) => {
                ::std::option::Option::Some(value)
            }
            value => {
                self.oneof_field = value;
                ::std::option::Option::None
            }
        }
    }
    pub fn clear_oneof_uint32(&mut self) {
        self.oneof_field = self::test_all_types::OneofField::None
    }
    /// Gets the field number of the [`oneof_nested_message`] field
    ///
    /// [`oneof_nested_message`]: #method.oneof_nested_message
    pub const ONEOF_NESTED_MESSAGE_FIELD_NUMBER: i32 = 112;
    pub fn oneof_nested_message(&self) -> ::std::option::Option<&self::test_all_types::NestedMessage> {
        match &self.oneof_field {
            self::test_all_types::OneofField::OneofNestedMessage(ref oneof_field) => ::std::option::Option::Some(&**oneof_field),
            _ => ::std::option::Option::None
        }
    }
    /// Returns a unique reference to the ['oneof_nested_message'] field
    ///
    /// [`oneof_nested_message`]: #method.oneof_nested_message
    pub fn oneof_nested_message_mut(&mut self) -> &mut self::test_all_types::NestedMessage {
        match self.oneof_field {
            self::test_all_types::OneofField::OneofNestedMessage(ref mut value) => value,
            _ => {
                self.set_oneof_nested_message(::std::default::Default::default());
                self.oneof_nested_message_mut()
            }
        }
    }
    pub fn has_oneof_nested_message(&self) -> bool {
        match &self.oneof_field {
            self::test_all_types::OneofField::OneofNestedMessage(_) => true,
            _ => false
        }
    }
    pub fn set_oneof_nested_message(&mut self, value: self::test_all_types::NestedMessage) {
        self.oneof_field = self::test_all_types::OneofField::OneofNestedMessage(::std::boxed::Box::new(value))
    }
    pub fn take_oneof_nested_message(&mut self) -> ::std::option::Option<self::test_all_types::NestedMessage> {
        match ::std::mem::replace(&mut self.oneof_field, self::test_all_types::OneofField::None) {
            self::test_all_types::OneofField::OneofNestedMessage(value) => {
                ::std::option::Option::Some(*value)
            }
            value => {
                self.oneof_field = value;
                ::std::option::Option::None
            }
        }
    }
    pub fn clear_oneof_nested_message(&mut self) {
        self.oneof_field = self::test_all_types::OneofField::None
    }
    /// Gets the field number of the [`oneof_string`] field
    ///
    /// [`oneof_string`]: #method.oneof_string
    pub const ONEOF_STRING_FIELD_NUMBER: i32 = 113;
    /// A constant value representing the default value of the [`oneof_string`] field
    ///
    /// [`oneof_string`]: #method.oneof_string
    pub const ONEOF_STRING_DEFAULT_VALUE: &'static str = "";
    pub fn oneof_string(&self) -> ::std::option::Option<&::std::string::String> {
        match &self.oneof_field {
            self::test_all_types::OneofField::OneofString(ref oneof_field) => ::std::option::Option::Some(oneof_field),
            _ => ::std::option::Option::None
        }
    }
    /// Returns a unique reference to the ['oneof_string'] field
    ///
    /// [`oneof_string`]: #method.oneof_string
    pub fn oneof_string_mut(&mut self) -> &mut ::std::string::String {
        match self.oneof_field {
            self::test_all_types::OneofField::OneofString(ref mut value) => value,
            _ => {
                self.set_oneof_string(::std::default::Default::default());
                self.oneof_string_mut()
            }
        }
    }
    pub fn has_oneof_string(&self) -> bool {
        match &self.oneof_field {
            self::test_all_types::OneofField::OneofString(_) => true,
            _ => false
        }
    }
    pub fn set_oneof_string(&mut self, value: ::std::string::String) {
        self.oneof_field = self::test_all_types::OneofField::OneofString(value)
    }
    pub fn take_oneof_string(&mut self) -> ::std::option::Option<::std::string::String> {
        match ::std::mem::replace(&mut self.oneof_field, self::test_all_types::OneofField::None) {
            self::test_all_types::OneofField::OneofString(value) => {
                ::std::option::Option::Some(value)
            }
            value => {
                self.oneof_field = value;
                ::std::option::Option::None
            }
        }
    }
    pub fn clear_oneof_string(&mut self) {
        self.oneof_field = self::test_all_types::OneofField::None
    }
    /// Gets the field number of the [`oneof_bytes`] field
    ///
    /// [`oneof_bytes`]: #method.oneof_bytes
    pub const ONEOF_BYTES_FIELD_NUMBER: i32 = 114;
    /// A constant value representing the default value of the [`oneof_bytes`] field
    ///
    /// [`oneof_bytes`]: #method.oneof_bytes
    pub const ONEOF_BYTES_DEFAULT_VALUE: &'static [u8] = &[];
    pub fn oneof_bytes(&self) -> ::std::option::Option<&::std::vec::Vec<u8>> {
        match &self.oneof_field {
            self::test_all_types::OneofField::OneofBytes(ref oneof_field) => ::std::option::Option::Some(oneof_field),
            _ => ::std::option::Option::None
        }
    }
    /// Returns a unique reference to the ['oneof_bytes'] field
    ///
    /// [`oneof_bytes`]: #method.oneof_bytes
    pub fn oneof_bytes_mut(&mut self) -> &mut ::std::vec::Vec<u8> {
        match self.oneof_field {
            self::test_all_types::OneofField::OneofBytes(ref mut value) => value,
            _ => {
                self.set_oneof_bytes(::std::default::Default::default());
                self.oneof_bytes_mut()
            }
        }
    }
    pub fn has_oneof_bytes(&self) -> bool {
        match &self.oneof_field {
            self::test_all_types::OneofField::OneofBytes(_) => true,
            _ => false
        }
    }
    pub fn set_oneof_bytes(&mut self, value: ::std::vec::Vec<u8>) {
        self.oneof_field = self::test_all_types::OneofField::OneofBytes(value)
    }
    pub fn take_oneof_bytes(&mut self) -> ::std::option::Option<::std::vec::Vec<u8>> {
        match ::std::mem::replace(&mut self.oneof_field, self::test_all_types::OneofField::None) {
            self::test_all_types::OneofField::OneofBytes(value) => {
                ::std::option::Option::Some(value)
            }
            value => {
                self.oneof_field = value;
                ::std::option::Option::None
            }
        }
    }
    pub fn clear_oneof_bytes(&mut self) {
        self.oneof_field = self::test_all_types::OneofField::None
    }
    /// Gets a shared reference to the [`oneof_field`] oneof field
    ///
    /// [`oneof_field`]: enum.OneofField.html
    pub fn oneof_field(&self) -> &self::test_all_types::OneofField {
        &self.oneof_field
    }
    /// Gets a unique reference to the [`oneof_field`] oneof field
    ///
    /// [`oneof_field`]: enum.OneofField.html
    pub fn oneof_field_mut(&mut self) -> &mut self::test_all_types::OneofField {
        &mut self.oneof_field
    }
}
///  This proto includes every type of field in both singular and repeated
///  forms.
pub mod test_all_types {
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct NestedMessage {
        bb: i32,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::NestedMessage {
        fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.bb = input.read_int32()?,
                    _ => self.unknown_fields.merge_from(tag, input)?
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            let bb = self.bb;
            if bb != Self::BB_DEFAULT_VALUE {
                size += 1;
                size += ::protrust::io::sizes::int32(bb);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
            let bb = self.bb;
            if bb != Self::BB_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(bb)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
    }
    impl ::protrust::LiteMessage for self::NestedMessage {
        fn new() -> Self {
            Self {
                bb: Self::BB_DEFAULT_VALUE,
                unknown_fields: ::protrust::UnknownFieldSet::new(),
            }
        }
        fn merge(&mut self, other: &Self) {
            self.bb = other.bb;
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::NestedMessage {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
            &self::super::file().messages()[0].messages()[0]
        }
    }
    impl self::NestedMessage {
        /// Gets the field number of the [`bb`] field
        ///
        /// [`bb`]: #method.bb
        pub const BB_FIELD_NUMBER: i32 = 1;
        /// A constant value representing the default value of the [`bb`] field
        ///
        /// [`bb`]: #method.bb
        pub const BB_DEFAULT_VALUE: i32 = 0;
        ///  The field name "b" fails to compile in proto1 because it conflicts with
        ///  a local variable named "b" in one of the generated methods.  Doh.
        ///  This file needs to compile in proto1 to test backwards-compatibility.
        pub fn bb(&self) -> i32 {
            self.bb
        }
        /// Returns a unique reference to the [`bb`] field
        ///
        /// [`bb`]: #method.bb
        pub fn bb_mut(&mut self) -> &mut i32 {
            &mut self.bb
        }
    }
    #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
    pub enum NestedEnum {
        Zero,
        Foo,
        Bar,
        Baz,
        ///  Intentionally negative.
        Neg,
    }
    impl ::protrust::Enum for self::NestedEnum {
        fn descriptor() -> &'static ::protrust::reflect::EnumDescriptor {
            &self::super::file().messages()[0].enums()[0]
        }
    }
    impl ::std::convert::TryFrom<i32> for self::NestedEnum {
        type Error = ::protrust::VariantUndefinedError;
        fn try_from(value: i32) -> ::std::result::Result<Self, ::protrust::VariantUndefinedError> {
            #[allow(unreachable_patterns)]
            match value {
                0 => ::std::result::Result::Ok(self::NestedEnum::Zero),
                1 => ::std::result::Result::Ok(self::NestedEnum::Foo),
                2 => ::std::result::Result::Ok(self::NestedEnum::Bar),
                3 => ::std::result::Result::Ok(self::NestedEnum::Baz),
                -1 => ::std::result::Result::Ok(self::NestedEnum::Neg),
                _ => ::std::result::Result::Err(::protrust::VariantUndefinedError)
            }
        }
    }
    impl ::std::convert::From<self::NestedEnum> for i32 {
        fn from(value: self::NestedEnum) -> i32 {
            match value {
                NestedEnum::Zero => 0,
                NestedEnum::Foo => 1,
                NestedEnum::Bar => 2,
                NestedEnum::Baz => 3,
                NestedEnum::Neg => -1,
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    pub enum OneofField {
        /// No value
        None,
        OneofUint32(u32),
        OneofNestedMessage(::std::boxed::Box<self::super::test_all_types::NestedMessage>),
        OneofString(::std::string::String),
        OneofBytes(::std::vec::Vec<u8>),
    }
    impl ::std::default::Default for self::OneofField {
        fn default() -> Self {
            self::OneofField::None
        }
    }
}
#[derive(Clone, Debug, PartialEq, Default)]
pub struct TestPackedTypes {
    packed_int32: ::protrust::collections::RepeatedField<i32>,
    packed_int64: ::protrust::collections::RepeatedField<i64>,
    packed_uint32: ::protrust::collections::RepeatedField<u32>,
    packed_uint64: ::protrust::collections::RepeatedField<u64>,
    packed_sint32: ::protrust::collections::RepeatedField<i32>,
    packed_sint64: ::protrust::collections::RepeatedField<i64>,
    packed_fixed32: ::protrust::collections::RepeatedField<u32>,
    packed_fixed64: ::protrust::collections::RepeatedField<u64>,
    packed_sfixed32: ::protrust::collections::RepeatedField<i32>,
    packed_sfixed64: ::protrust::collections::RepeatedField<i64>,
    packed_float: ::protrust::collections::RepeatedField<f32>,
    packed_double: ::protrust::collections::RepeatedField<f64>,
    packed_bool: ::protrust::collections::RepeatedField<bool>,
    packed_enum: ::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
static TEST_PACKED_TYPES_PACKED_INT32_CODEC: ::protrust::Codec<i32> = ::protrust::Codec::int32(722);
static TEST_PACKED_TYPES_PACKED_INT64_CODEC: ::protrust::Codec<i64> = ::protrust::Codec::int64(730);
static TEST_PACKED_TYPES_PACKED_UINT32_CODEC: ::protrust::Codec<u32> = ::protrust::Codec::uint32(738);
static TEST_PACKED_TYPES_PACKED_UINT64_CODEC: ::protrust::Codec<u64> = ::protrust::Codec::uint64(746);
static TEST_PACKED_TYPES_PACKED_SINT32_CODEC: ::protrust::Codec<i32> = ::protrust::Codec::sint32(754);
static TEST_PACKED_TYPES_PACKED_SINT64_CODEC: ::protrust::Codec<i64> = ::protrust::Codec::sint64(762);
static TEST_PACKED_TYPES_PACKED_FIXED32_CODEC: ::protrust::Codec<u32> = ::protrust::Codec::fixed32(770);
static TEST_PACKED_TYPES_PACKED_FIXED64_CODEC: ::protrust::Codec<u64> = ::protrust::Codec::fixed64(778);
static TEST_PACKED_TYPES_PACKED_SFIXED32_CODEC: ::protrust::Codec<i32> = ::protrust::Codec::sfixed32(786);
static TEST_PACKED_TYPES_PACKED_SFIXED64_CODEC: ::protrust::Codec<i64> = ::protrust::Codec::sfixed64(794);
static TEST_PACKED_TYPES_PACKED_FLOAT_CODEC: ::protrust::Codec<f32> = ::protrust::Codec::float(802);
static TEST_PACKED_TYPES_PACKED_DOUBLE_CODEC: ::protrust::Codec<f64> = ::protrust::Codec::double(810);
static TEST_PACKED_TYPES_PACKED_BOOL_CODEC: ::protrust::Codec<bool> = ::protrust::Codec::bool(818);
static TEST_PACKED_TYPES_PACKED_ENUM_CODEC: ::protrust::Codec<::protrust::EnumValue<self::ForeignEnum>> = ::protrust::Codec::enum_value(826);
impl ::protrust::CodedMessage for self::TestPackedTypes {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                720 | 722 => self.packed_int32.add_entries(input, &TEST_PACKED_TYPES_PACKED_INT32_CODEC)?,
                728 | 730 => self.packed_int64.add_entries(input, &TEST_PACKED_TYPES_PACKED_INT64_CODEC)?,
                736 | 738 => self.packed_uint32.add_entries(input, &TEST_PACKED_TYPES_PACKED_UINT32_CODEC)?,
                744 | 746 => self.packed_uint64.add_entries(input, &TEST_PACKED_TYPES_PACKED_UINT64_CODEC)?,
                752 | 754 => self.packed_sint32.add_entries(input, &TEST_PACKED_TYPES_PACKED_SINT32_CODEC)?,
                760 | 762 => self.packed_sint64.add_entries(input, &TEST_PACKED_TYPES_PACKED_SINT64_CODEC)?,
                773 | 770 => self.packed_fixed32.add_entries(input, &TEST_PACKED_TYPES_PACKED_FIXED32_CODEC)?,
                777 | 778 => self.packed_fixed64.add_entries(input, &TEST_PACKED_TYPES_PACKED_FIXED64_CODEC)?,
                789 | 786 => self.packed_sfixed32.add_entries(input, &TEST_PACKED_TYPES_PACKED_SFIXED32_CODEC)?,
                793 | 794 => self.packed_sfixed64.add_entries(input, &TEST_PACKED_TYPES_PACKED_SFIXED64_CODEC)?,
                805 | 802 => self.packed_float.add_entries(input, &TEST_PACKED_TYPES_PACKED_FLOAT_CODEC)?,
                809 | 810 => self.packed_double.add_entries(input, &TEST_PACKED_TYPES_PACKED_DOUBLE_CODEC)?,
                816 | 818 => self.packed_bool.add_entries(input, &TEST_PACKED_TYPES_PACKED_BOOL_CODEC)?,
                824 | 826 => self.packed_enum.add_entries(input, &TEST_PACKED_TYPES_PACKED_ENUM_CODEC)?,
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.packed_int32.calculate_size(&TEST_PACKED_TYPES_PACKED_INT32_CODEC);
        size += self.packed_int64.calculate_size(&TEST_PACKED_TYPES_PACKED_INT64_CODEC);
        size += self.packed_uint32.calculate_size(&TEST_PACKED_TYPES_PACKED_UINT32_CODEC);
        size += self.packed_uint64.calculate_size(&TEST_PACKED_TYPES_PACKED_UINT64_CODEC);
        size += self.packed_sint32.calculate_size(&TEST_PACKED_TYPES_PACKED_SINT32_CODEC);
        size += self.packed_sint64.calculate_size(&TEST_PACKED_TYPES_PACKED_SINT64_CODEC);
        size += self.packed_fixed32.calculate_size(&TEST_PACKED_TYPES_PACKED_FIXED32_CODEC);
        size += self.packed_fixed64.calculate_size(&TEST_PACKED_TYPES_PACKED_FIXED64_CODEC);
        size += self.packed_sfixed32.calculate_size(&TEST_PACKED_TYPES_PACKED_SFIXED32_CODEC);
        size += self.packed_sfixed64.calculate_size(&TEST_PACKED_TYPES_PACKED_SFIXED64_CODEC);
        size += self.packed_float.calculate_size(&TEST_PACKED_TYPES_PACKED_FLOAT_CODEC);
        size += self.packed_double.calculate_size(&TEST_PACKED_TYPES_PACKED_DOUBLE_CODEC);
        size += self.packed_bool.calculate_size(&TEST_PACKED_TYPES_PACKED_BOOL_CODEC);
        size += self.packed_enum.calculate_size(&TEST_PACKED_TYPES_PACKED_ENUM_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        self.packed_int32.write_to(output, &TEST_PACKED_TYPES_PACKED_INT32_CODEC)?;
        self.packed_int64.write_to(output, &TEST_PACKED_TYPES_PACKED_INT64_CODEC)?;
        self.packed_uint32.write_to(output, &TEST_PACKED_TYPES_PACKED_UINT32_CODEC)?;
        self.packed_uint64.write_to(output, &TEST_PACKED_TYPES_PACKED_UINT64_CODEC)?;
        self.packed_sint32.write_to(output, &TEST_PACKED_TYPES_PACKED_SINT32_CODEC)?;
        self.packed_sint64.write_to(output, &TEST_PACKED_TYPES_PACKED_SINT64_CODEC)?;
        self.packed_fixed32.write_to(output, &TEST_PACKED_TYPES_PACKED_FIXED32_CODEC)?;
        self.packed_fixed64.write_to(output, &TEST_PACKED_TYPES_PACKED_FIXED64_CODEC)?;
        self.packed_sfixed32.write_to(output, &TEST_PACKED_TYPES_PACKED_SFIXED32_CODEC)?;
        self.packed_sfixed64.write_to(output, &TEST_PACKED_TYPES_PACKED_SFIXED64_CODEC)?;
        self.packed_float.write_to(output, &TEST_PACKED_TYPES_PACKED_FLOAT_CODEC)?;
        self.packed_double.write_to(output, &TEST_PACKED_TYPES_PACKED_DOUBLE_CODEC)?;
        self.packed_bool.write_to(output, &TEST_PACKED_TYPES_PACKED_BOOL_CODEC)?;
        self.packed_enum.write_to(output, &TEST_PACKED_TYPES_PACKED_ENUM_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::TestPackedTypes {
    fn new() -> Self {
        Self {
            packed_int32: ::protrust::collections::RepeatedField::new(),
            packed_int64: ::protrust::collections::RepeatedField::new(),
            packed_uint32: ::protrust::collections::RepeatedField::new(),
            packed_uint64: ::protrust::collections::RepeatedField::new(),
            packed_sint32: ::protrust::collections::RepeatedField::new(),
            packed_sint64: ::protrust::collections::RepeatedField::new(),
            packed_fixed32: ::protrust::collections::RepeatedField::new(),
            packed_fixed64: ::protrust::collections::RepeatedField::new(),
            packed_sfixed32: ::protrust::collections::RepeatedField::new(),
            packed_sfixed64: ::protrust::collections::RepeatedField::new(),
            packed_float: ::protrust::collections::RepeatedField::new(),
            packed_double: ::protrust::collections::RepeatedField::new(),
            packed_bool: ::protrust::collections::RepeatedField::new(),
            packed_enum: ::protrust::collections::RepeatedField::new(),
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.packed_int32.merge(&other.packed_int32);
        self.packed_int64.merge(&other.packed_int64);
        self.packed_uint32.merge(&other.packed_uint32);
        self.packed_uint64.merge(&other.packed_uint64);
        self.packed_sint32.merge(&other.packed_sint32);
        self.packed_sint64.merge(&other.packed_sint64);
        self.packed_fixed32.merge(&other.packed_fixed32);
        self.packed_fixed64.merge(&other.packed_fixed64);
        self.packed_sfixed32.merge(&other.packed_sfixed32);
        self.packed_sfixed64.merge(&other.packed_sfixed64);
        self.packed_float.merge(&other.packed_float);
        self.packed_double.merge(&other.packed_double);
        self.packed_bool.merge(&other.packed_bool);
        self.packed_enum.merge(&other.packed_enum);
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestPackedTypes {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[1]
    }
}
impl self::TestPackedTypes {
    /// Gets the field number of the [`packed_int32`] field
    ///
    /// [`packed_int32`]: #method.packed_int32
    pub const PACKED_INT32_FIELD_NUMBER: i32 = 90;
    pub fn packed_int32(&self) -> &::protrust::collections::RepeatedField<i32> {
        &self.packed_int32
    }
    /// Returns a unique reference to the [`packed_int32`] field
    ///
    /// [`packed_int32`]: #method.packed_int32
    pub fn packed_int32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
        &mut self.packed_int32
    }
    /// Gets the field number of the [`packed_int64`] field
    ///
    /// [`packed_int64`]: #method.packed_int64
    pub const PACKED_INT64_FIELD_NUMBER: i32 = 91;
    pub fn packed_int64(&self) -> &::protrust::collections::RepeatedField<i64> {
        &self.packed_int64
    }
    /// Returns a unique reference to the [`packed_int64`] field
    ///
    /// [`packed_int64`]: #method.packed_int64
    pub fn packed_int64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
        &mut self.packed_int64
    }
    /// Gets the field number of the [`packed_uint32`] field
    ///
    /// [`packed_uint32`]: #method.packed_uint32
    pub const PACKED_UINT32_FIELD_NUMBER: i32 = 92;
    pub fn packed_uint32(&self) -> &::protrust::collections::RepeatedField<u32> {
        &self.packed_uint32
    }
    /// Returns a unique reference to the [`packed_uint32`] field
    ///
    /// [`packed_uint32`]: #method.packed_uint32
    pub fn packed_uint32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u32> {
        &mut self.packed_uint32
    }
    /// Gets the field number of the [`packed_uint64`] field
    ///
    /// [`packed_uint64`]: #method.packed_uint64
    pub const PACKED_UINT64_FIELD_NUMBER: i32 = 93;
    pub fn packed_uint64(&self) -> &::protrust::collections::RepeatedField<u64> {
        &self.packed_uint64
    }
    /// Returns a unique reference to the [`packed_uint64`] field
    ///
    /// [`packed_uint64`]: #method.packed_uint64
    pub fn packed_uint64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u64> {
        &mut self.packed_uint64
    }
    /// Gets the field number of the [`packed_sint32`] field
    ///
    /// [`packed_sint32`]: #method.packed_sint32
    pub const PACKED_SINT32_FIELD_NUMBER: i32 = 94;
    pub fn packed_sint32(&self) -> &::protrust::collections::RepeatedField<i32> {
        &self.packed_sint32
    }
    /// Returns a unique reference to the [`packed_sint32`] field
    ///
    /// [`packed_sint32`]: #method.packed_sint32
    pub fn packed_sint32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
        &mut self.packed_sint32
    }
    /// Gets the field number of the [`packed_sint64`] field
    ///
    /// [`packed_sint64`]: #method.packed_sint64
    pub const PACKED_SINT64_FIELD_NUMBER: i32 = 95;
    pub fn packed_sint64(&self) -> &::protrust::collections::RepeatedField<i64> {
        &self.packed_sint64
    }
    /// Returns a unique reference to the [`packed_sint64`] field
    ///
    /// [`packed_sint64`]: #method.packed_sint64
    pub fn packed_sint64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
        &mut self.packed_sint64
    }
    /// Gets the field number of the [`packed_fixed32`] field
    ///
    /// [`packed_fixed32`]: #method.packed_fixed32
    pub const PACKED_FIXED32_FIELD_NUMBER: i32 = 96;
    pub fn packed_fixed32(&self) -> &::protrust::collections::RepeatedField<u32> {
        &self.packed_fixed32
    }
    /// Returns a unique reference to the [`packed_fixed32`] field
    ///
    /// [`packed_fixed32`]: #method.packed_fixed32
    pub fn packed_fixed32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u32> {
        &mut self.packed_fixed32
    }
    /// Gets the field number of the [`packed_fixed64`] field
    ///
    /// [`packed_fixed64`]: #method.packed_fixed64
    pub const PACKED_FIXED64_FIELD_NUMBER: i32 = 97;
    pub fn packed_fixed64(&self) -> &::protrust::collections::RepeatedField<u64> {
        &self.packed_fixed64
    }
    /// Returns a unique reference to the [`packed_fixed64`] field
    ///
    /// [`packed_fixed64`]: #method.packed_fixed64
    pub fn packed_fixed64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u64> {
        &mut self.packed_fixed64
    }
    /// Gets the field number of the [`packed_sfixed32`] field
    ///
    /// [`packed_sfixed32`]: #method.packed_sfixed32
    pub const PACKED_SFIXED32_FIELD_NUMBER: i32 = 98;
    pub fn packed_sfixed32(&self) -> &::protrust::collections::RepeatedField<i32> {
        &self.packed_sfixed32
    }
    /// Returns a unique reference to the [`packed_sfixed32`] field
    ///
    /// [`packed_sfixed32`]: #method.packed_sfixed32
    pub fn packed_sfixed32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
        &mut self.packed_sfixed32
    }
    /// Gets the field number of the [`packed_sfixed64`] field
    ///
    /// [`packed_sfixed64`]: #method.packed_sfixed64
    pub const PACKED_SFIXED64_FIELD_NUMBER: i32 = 99;
    pub fn packed_sfixed64(&self) -> &::protrust::collections::RepeatedField<i64> {
        &self.packed_sfixed64
    }
    /// Returns a unique reference to the [`packed_sfixed64`] field
    ///
    /// [`packed_sfixed64`]: #method.packed_sfixed64
    pub fn packed_sfixed64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
        &mut self.packed_sfixed64
    }
    /// Gets the field number of the [`packed_float`] field
    ///
    /// [`packed_float`]: #method.packed_float
    pub const PACKED_FLOAT_FIELD_NUMBER: i32 = 100;
    pub fn packed_float(&self) -> &::protrust::collections::RepeatedField<f32> {
        &self.packed_float
    }
    /// Returns a unique reference to the [`packed_float`] field
    ///
    /// [`packed_float`]: #method.packed_float
    pub fn packed_float_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<f32> {
        &mut self.packed_float
    }
    /// Gets the field number of the [`packed_double`] field
    ///
    /// [`packed_double`]: #method.packed_double
    pub const PACKED_DOUBLE_FIELD_NUMBER: i32 = 101;
    pub fn packed_double(&self) -> &::protrust::collections::RepeatedField<f64> {
        &self.packed_double
    }
    /// Returns a unique reference to the [`packed_double`] field
    ///
    /// [`packed_double`]: #method.packed_double
    pub fn packed_double_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<f64> {
        &mut self.packed_double
    }
    /// Gets the field number of the [`packed_bool`] field
    ///
    /// [`packed_bool`]: #method.packed_bool
    pub const PACKED_BOOL_FIELD_NUMBER: i32 = 102;
    pub fn packed_bool(&self) -> &::protrust::collections::RepeatedField<bool> {
        &self.packed_bool
    }
    /// Returns a unique reference to the [`packed_bool`] field
    ///
    /// [`packed_bool`]: #method.packed_bool
    pub fn packed_bool_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<bool> {
        &mut self.packed_bool
    }
    /// Gets the field number of the [`packed_enum`] field
    ///
    /// [`packed_enum`]: #method.packed_enum
    pub const PACKED_ENUM_FIELD_NUMBER: i32 = 103;
    pub fn packed_enum(&self) -> &::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>> {
        &self.packed_enum
    }
    /// Returns a unique reference to the [`packed_enum`] field
    ///
    /// [`packed_enum`]: #method.packed_enum
    pub fn packed_enum_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>> {
        &mut self.packed_enum
    }
}
///  Explicitly set packed to false
#[derive(Clone, Debug, PartialEq, Default)]
pub struct TestUnpackedTypes {
    repeated_int32: ::protrust::collections::RepeatedField<i32>,
    repeated_int64: ::protrust::collections::RepeatedField<i64>,
    repeated_uint32: ::protrust::collections::RepeatedField<u32>,
    repeated_uint64: ::protrust::collections::RepeatedField<u64>,
    repeated_sint32: ::protrust::collections::RepeatedField<i32>,
    repeated_sint64: ::protrust::collections::RepeatedField<i64>,
    repeated_fixed32: ::protrust::collections::RepeatedField<u32>,
    repeated_fixed64: ::protrust::collections::RepeatedField<u64>,
    repeated_sfixed32: ::protrust::collections::RepeatedField<i32>,
    repeated_sfixed64: ::protrust::collections::RepeatedField<i64>,
    repeated_float: ::protrust::collections::RepeatedField<f32>,
    repeated_double: ::protrust::collections::RepeatedField<f64>,
    repeated_bool: ::protrust::collections::RepeatedField<bool>,
    repeated_nested_enum: ::protrust::collections::RepeatedField<::protrust::EnumValue<self::test_all_types::NestedEnum>>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
static TEST_UNPACKED_TYPES_REPEATED_INT32_CODEC: ::protrust::Codec<i32> = ::protrust::Codec::int32(8);
static TEST_UNPACKED_TYPES_REPEATED_INT64_CODEC: ::protrust::Codec<i64> = ::protrust::Codec::int64(16);
static TEST_UNPACKED_TYPES_REPEATED_UINT32_CODEC: ::protrust::Codec<u32> = ::protrust::Codec::uint32(24);
static TEST_UNPACKED_TYPES_REPEATED_UINT64_CODEC: ::protrust::Codec<u64> = ::protrust::Codec::uint64(32);
static TEST_UNPACKED_TYPES_REPEATED_SINT32_CODEC: ::protrust::Codec<i32> = ::protrust::Codec::sint32(40);
static TEST_UNPACKED_TYPES_REPEATED_SINT64_CODEC: ::protrust::Codec<i64> = ::protrust::Codec::sint64(48);
static TEST_UNPACKED_TYPES_REPEATED_FIXED32_CODEC: ::protrust::Codec<u32> = ::protrust::Codec::fixed32(61);
static TEST_UNPACKED_TYPES_REPEATED_FIXED64_CODEC: ::protrust::Codec<u64> = ::protrust::Codec::fixed64(65);
static TEST_UNPACKED_TYPES_REPEATED_SFIXED32_CODEC: ::protrust::Codec<i32> = ::protrust::Codec::sfixed32(77);
static TEST_UNPACKED_TYPES_REPEATED_SFIXED64_CODEC: ::protrust::Codec<i64> = ::protrust::Codec::sfixed64(81);
static TEST_UNPACKED_TYPES_REPEATED_FLOAT_CODEC: ::protrust::Codec<f32> = ::protrust::Codec::float(93);
static TEST_UNPACKED_TYPES_REPEATED_DOUBLE_CODEC: ::protrust::Codec<f64> = ::protrust::Codec::double(97);
static TEST_UNPACKED_TYPES_REPEATED_BOOL_CODEC: ::protrust::Codec<bool> = ::protrust::Codec::bool(104);
static TEST_UNPACKED_TYPES_REPEATED_NESTED_ENUM_CODEC: ::protrust::Codec<::protrust::EnumValue<self::test_all_types::NestedEnum>> = ::protrust::Codec::enum_value(112);
impl ::protrust::CodedMessage for self::TestUnpackedTypes {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 | 10 => self.repeated_int32.add_entries(input, &TEST_UNPACKED_TYPES_REPEATED_INT32_CODEC)?,
                16 | 18 => self.repeated_int64.add_entries(input, &TEST_UNPACKED_TYPES_REPEATED_INT64_CODEC)?,
                24 | 26 => self.repeated_uint32.add_entries(input, &TEST_UNPACKED_TYPES_REPEATED_UINT32_CODEC)?,
                32 | 34 => self.repeated_uint64.add_entries(input, &TEST_UNPACKED_TYPES_REPEATED_UINT64_CODEC)?,
                40 | 42 => self.repeated_sint32.add_entries(input, &TEST_UNPACKED_TYPES_REPEATED_SINT32_CODEC)?,
                48 | 50 => self.repeated_sint64.add_entries(input, &TEST_UNPACKED_TYPES_REPEATED_SINT64_CODEC)?,
                61 | 58 => self.repeated_fixed32.add_entries(input, &TEST_UNPACKED_TYPES_REPEATED_FIXED32_CODEC)?,
                65 | 66 => self.repeated_fixed64.add_entries(input, &TEST_UNPACKED_TYPES_REPEATED_FIXED64_CODEC)?,
                77 | 74 => self.repeated_sfixed32.add_entries(input, &TEST_UNPACKED_TYPES_REPEATED_SFIXED32_CODEC)?,
                81 | 82 => self.repeated_sfixed64.add_entries(input, &TEST_UNPACKED_TYPES_REPEATED_SFIXED64_CODEC)?,
                93 | 90 => self.repeated_float.add_entries(input, &TEST_UNPACKED_TYPES_REPEATED_FLOAT_CODEC)?,
                97 | 98 => self.repeated_double.add_entries(input, &TEST_UNPACKED_TYPES_REPEATED_DOUBLE_CODEC)?,
                104 | 106 => self.repeated_bool.add_entries(input, &TEST_UNPACKED_TYPES_REPEATED_BOOL_CODEC)?,
                112 | 114 => self.repeated_nested_enum.add_entries(input, &TEST_UNPACKED_TYPES_REPEATED_NESTED_ENUM_CODEC)?,
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.repeated_int32.calculate_size(&TEST_UNPACKED_TYPES_REPEATED_INT32_CODEC);
        size += self.repeated_int64.calculate_size(&TEST_UNPACKED_TYPES_REPEATED_INT64_CODEC);
        size += self.repeated_uint32.calculate_size(&TEST_UNPACKED_TYPES_REPEATED_UINT32_CODEC);
        size += self.repeated_uint64.calculate_size(&TEST_UNPACKED_TYPES_REPEATED_UINT64_CODEC);
        size += self.repeated_sint32.calculate_size(&TEST_UNPACKED_TYPES_REPEATED_SINT32_CODEC);
        size += self.repeated_sint64.calculate_size(&TEST_UNPACKED_TYPES_REPEATED_SINT64_CODEC);
        size += self.repeated_fixed32.calculate_size(&TEST_UNPACKED_TYPES_REPEATED_FIXED32_CODEC);
        size += self.repeated_fixed64.calculate_size(&TEST_UNPACKED_TYPES_REPEATED_FIXED64_CODEC);
        size += self.repeated_sfixed32.calculate_size(&TEST_UNPACKED_TYPES_REPEATED_SFIXED32_CODEC);
        size += self.repeated_sfixed64.calculate_size(&TEST_UNPACKED_TYPES_REPEATED_SFIXED64_CODEC);
        size += self.repeated_float.calculate_size(&TEST_UNPACKED_TYPES_REPEATED_FLOAT_CODEC);
        size += self.repeated_double.calculate_size(&TEST_UNPACKED_TYPES_REPEATED_DOUBLE_CODEC);
        size += self.repeated_bool.calculate_size(&TEST_UNPACKED_TYPES_REPEATED_BOOL_CODEC);
        size += self.repeated_nested_enum.calculate_size(&TEST_UNPACKED_TYPES_REPEATED_NESTED_ENUM_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        self.repeated_int32.write_to(output, &TEST_UNPACKED_TYPES_REPEATED_INT32_CODEC)?;
        self.repeated_int64.write_to(output, &TEST_UNPACKED_TYPES_REPEATED_INT64_CODEC)?;
        self.repeated_uint32.write_to(output, &TEST_UNPACKED_TYPES_REPEATED_UINT32_CODEC)?;
        self.repeated_uint64.write_to(output, &TEST_UNPACKED_TYPES_REPEATED_UINT64_CODEC)?;
        self.repeated_sint32.write_to(output, &TEST_UNPACKED_TYPES_REPEATED_SINT32_CODEC)?;
        self.repeated_sint64.write_to(output, &TEST_UNPACKED_TYPES_REPEATED_SINT64_CODEC)?;
        self.repeated_fixed32.write_to(output, &TEST_UNPACKED_TYPES_REPEATED_FIXED32_CODEC)?;
        self.repeated_fixed64.write_to(output, &TEST_UNPACKED_TYPES_REPEATED_FIXED64_CODEC)?;
        self.repeated_sfixed32.write_to(output, &TEST_UNPACKED_TYPES_REPEATED_SFIXED32_CODEC)?;
        self.repeated_sfixed64.write_to(output, &TEST_UNPACKED_TYPES_REPEATED_SFIXED64_CODEC)?;
        self.repeated_float.write_to(output, &TEST_UNPACKED_TYPES_REPEATED_FLOAT_CODEC)?;
        self.repeated_double.write_to(output, &TEST_UNPACKED_TYPES_REPEATED_DOUBLE_CODEC)?;
        self.repeated_bool.write_to(output, &TEST_UNPACKED_TYPES_REPEATED_BOOL_CODEC)?;
        self.repeated_nested_enum.write_to(output, &TEST_UNPACKED_TYPES_REPEATED_NESTED_ENUM_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::TestUnpackedTypes {
    fn new() -> Self {
        Self {
            repeated_int32: ::protrust::collections::RepeatedField::new(),
            repeated_int64: ::protrust::collections::RepeatedField::new(),
            repeated_uint32: ::protrust::collections::RepeatedField::new(),
            repeated_uint64: ::protrust::collections::RepeatedField::new(),
            repeated_sint32: ::protrust::collections::RepeatedField::new(),
            repeated_sint64: ::protrust::collections::RepeatedField::new(),
            repeated_fixed32: ::protrust::collections::RepeatedField::new(),
            repeated_fixed64: ::protrust::collections::RepeatedField::new(),
            repeated_sfixed32: ::protrust::collections::RepeatedField::new(),
            repeated_sfixed64: ::protrust::collections::RepeatedField::new(),
            repeated_float: ::protrust::collections::RepeatedField::new(),
            repeated_double: ::protrust::collections::RepeatedField::new(),
            repeated_bool: ::protrust::collections::RepeatedField::new(),
            repeated_nested_enum: ::protrust::collections::RepeatedField::new(),
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.repeated_int32.merge(&other.repeated_int32);
        self.repeated_int64.merge(&other.repeated_int64);
        self.repeated_uint32.merge(&other.repeated_uint32);
        self.repeated_uint64.merge(&other.repeated_uint64);
        self.repeated_sint32.merge(&other.repeated_sint32);
        self.repeated_sint64.merge(&other.repeated_sint64);
        self.repeated_fixed32.merge(&other.repeated_fixed32);
        self.repeated_fixed64.merge(&other.repeated_fixed64);
        self.repeated_sfixed32.merge(&other.repeated_sfixed32);
        self.repeated_sfixed64.merge(&other.repeated_sfixed64);
        self.repeated_float.merge(&other.repeated_float);
        self.repeated_double.merge(&other.repeated_double);
        self.repeated_bool.merge(&other.repeated_bool);
        self.repeated_nested_enum.merge(&other.repeated_nested_enum);
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestUnpackedTypes {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[2]
    }
}
impl self::TestUnpackedTypes {
    /// Gets the field number of the [`repeated_int32`] field
    ///
    /// [`repeated_int32`]: #method.repeated_int32
    pub const REPEATED_INT32_FIELD_NUMBER: i32 = 1;
    pub fn repeated_int32(&self) -> &::protrust::collections::RepeatedField<i32> {
        &self.repeated_int32
    }
    /// Returns a unique reference to the [`repeated_int32`] field
    ///
    /// [`repeated_int32`]: #method.repeated_int32
    pub fn repeated_int32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
        &mut self.repeated_int32
    }
    /// Gets the field number of the [`repeated_int64`] field
    ///
    /// [`repeated_int64`]: #method.repeated_int64
    pub const REPEATED_INT64_FIELD_NUMBER: i32 = 2;
    pub fn repeated_int64(&self) -> &::protrust::collections::RepeatedField<i64> {
        &self.repeated_int64
    }
    /// Returns a unique reference to the [`repeated_int64`] field
    ///
    /// [`repeated_int64`]: #method.repeated_int64
    pub fn repeated_int64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
        &mut self.repeated_int64
    }
    /// Gets the field number of the [`repeated_uint32`] field
    ///
    /// [`repeated_uint32`]: #method.repeated_uint32
    pub const REPEATED_UINT32_FIELD_NUMBER: i32 = 3;
    pub fn repeated_uint32(&self) -> &::protrust::collections::RepeatedField<u32> {
        &self.repeated_uint32
    }
    /// Returns a unique reference to the [`repeated_uint32`] field
    ///
    /// [`repeated_uint32`]: #method.repeated_uint32
    pub fn repeated_uint32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u32> {
        &mut self.repeated_uint32
    }
    /// Gets the field number of the [`repeated_uint64`] field
    ///
    /// [`repeated_uint64`]: #method.repeated_uint64
    pub const REPEATED_UINT64_FIELD_NUMBER: i32 = 4;
    pub fn repeated_uint64(&self) -> &::protrust::collections::RepeatedField<u64> {
        &self.repeated_uint64
    }
    /// Returns a unique reference to the [`repeated_uint64`] field
    ///
    /// [`repeated_uint64`]: #method.repeated_uint64
    pub fn repeated_uint64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u64> {
        &mut self.repeated_uint64
    }
    /// Gets the field number of the [`repeated_sint32`] field
    ///
    /// [`repeated_sint32`]: #method.repeated_sint32
    pub const REPEATED_SINT32_FIELD_NUMBER: i32 = 5;
    pub fn repeated_sint32(&self) -> &::protrust::collections::RepeatedField<i32> {
        &self.repeated_sint32
    }
    /// Returns a unique reference to the [`repeated_sint32`] field
    ///
    /// [`repeated_sint32`]: #method.repeated_sint32
    pub fn repeated_sint32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
        &mut self.repeated_sint32
    }
    /// Gets the field number of the [`repeated_sint64`] field
    ///
    /// [`repeated_sint64`]: #method.repeated_sint64
    pub const REPEATED_SINT64_FIELD_NUMBER: i32 = 6;
    pub fn repeated_sint64(&self) -> &::protrust::collections::RepeatedField<i64> {
        &self.repeated_sint64
    }
    /// Returns a unique reference to the [`repeated_sint64`] field
    ///
    /// [`repeated_sint64`]: #method.repeated_sint64
    pub fn repeated_sint64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
        &mut self.repeated_sint64
    }
    /// Gets the field number of the [`repeated_fixed32`] field
    ///
    /// [`repeated_fixed32`]: #method.repeated_fixed32
    pub const REPEATED_FIXED32_FIELD_NUMBER: i32 = 7;
    pub fn repeated_fixed32(&self) -> &::protrust::collections::RepeatedField<u32> {
        &self.repeated_fixed32
    }
    /// Returns a unique reference to the [`repeated_fixed32`] field
    ///
    /// [`repeated_fixed32`]: #method.repeated_fixed32
    pub fn repeated_fixed32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u32> {
        &mut self.repeated_fixed32
    }
    /// Gets the field number of the [`repeated_fixed64`] field
    ///
    /// [`repeated_fixed64`]: #method.repeated_fixed64
    pub const REPEATED_FIXED64_FIELD_NUMBER: i32 = 8;
    pub fn repeated_fixed64(&self) -> &::protrust::collections::RepeatedField<u64> {
        &self.repeated_fixed64
    }
    /// Returns a unique reference to the [`repeated_fixed64`] field
    ///
    /// [`repeated_fixed64`]: #method.repeated_fixed64
    pub fn repeated_fixed64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u64> {
        &mut self.repeated_fixed64
    }
    /// Gets the field number of the [`repeated_sfixed32`] field
    ///
    /// [`repeated_sfixed32`]: #method.repeated_sfixed32
    pub const REPEATED_SFIXED32_FIELD_NUMBER: i32 = 9;
    pub fn repeated_sfixed32(&self) -> &::protrust::collections::RepeatedField<i32> {
        &self.repeated_sfixed32
    }
    /// Returns a unique reference to the [`repeated_sfixed32`] field
    ///
    /// [`repeated_sfixed32`]: #method.repeated_sfixed32
    pub fn repeated_sfixed32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
        &mut self.repeated_sfixed32
    }
    /// Gets the field number of the [`repeated_sfixed64`] field
    ///
    /// [`repeated_sfixed64`]: #method.repeated_sfixed64
    pub const REPEATED_SFIXED64_FIELD_NUMBER: i32 = 10;
    pub fn repeated_sfixed64(&self) -> &::protrust::collections::RepeatedField<i64> {
        &self.repeated_sfixed64
    }
    /// Returns a unique reference to the [`repeated_sfixed64`] field
    ///
    /// [`repeated_sfixed64`]: #method.repeated_sfixed64
    pub fn repeated_sfixed64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
        &mut self.repeated_sfixed64
    }
    /// Gets the field number of the [`repeated_float`] field
    ///
    /// [`repeated_float`]: #method.repeated_float
    pub const REPEATED_FLOAT_FIELD_NUMBER: i32 = 11;
    pub fn repeated_float(&self) -> &::protrust::collections::RepeatedField<f32> {
        &self.repeated_float
    }
    /// Returns a unique reference to the [`repeated_float`] field
    ///
    /// [`repeated_float`]: #method.repeated_float
    pub fn repeated_float_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<f32> {
        &mut self.repeated_float
    }
    /// Gets the field number of the [`repeated_double`] field
    ///
    /// [`repeated_double`]: #method.repeated_double
    pub const REPEATED_DOUBLE_FIELD_NUMBER: i32 = 12;
    pub fn repeated_double(&self) -> &::protrust::collections::RepeatedField<f64> {
        &self.repeated_double
    }
    /// Returns a unique reference to the [`repeated_double`] field
    ///
    /// [`repeated_double`]: #method.repeated_double
    pub fn repeated_double_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<f64> {
        &mut self.repeated_double
    }
    /// Gets the field number of the [`repeated_bool`] field
    ///
    /// [`repeated_bool`]: #method.repeated_bool
    pub const REPEATED_BOOL_FIELD_NUMBER: i32 = 13;
    pub fn repeated_bool(&self) -> &::protrust::collections::RepeatedField<bool> {
        &self.repeated_bool
    }
    /// Returns a unique reference to the [`repeated_bool`] field
    ///
    /// [`repeated_bool`]: #method.repeated_bool
    pub fn repeated_bool_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<bool> {
        &mut self.repeated_bool
    }
    /// Gets the field number of the [`repeated_nested_enum`] field
    ///
    /// [`repeated_nested_enum`]: #method.repeated_nested_enum
    pub const REPEATED_NESTED_ENUM_FIELD_NUMBER: i32 = 14;
    pub fn repeated_nested_enum(&self) -> &::protrust::collections::RepeatedField<::protrust::EnumValue<self::test_all_types::NestedEnum>> {
        &self.repeated_nested_enum
    }
    /// Returns a unique reference to the [`repeated_nested_enum`] field
    ///
    /// [`repeated_nested_enum`]: #method.repeated_nested_enum
    pub fn repeated_nested_enum_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<::protrust::EnumValue<self::test_all_types::NestedEnum>> {
        &mut self.repeated_nested_enum
    }
}
///  This proto includes a recusively nested message.
#[derive(Clone, Debug, PartialEq, Default)]
pub struct NestedTestAllTypes {
    child: ::std::option::Option<::std::boxed::Box<self::NestedTestAllTypes>>,
    payload: ::std::option::Option<::std::boxed::Box<self::TestAllTypes>>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::NestedTestAllTypes {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => input.read_message(&mut **self.child.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                18 => input.read_message(&mut **self.payload.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let child = &self.child;
        if let ::std::option::Option::Some(child) = child {
            size += 1;
            size += ::protrust::io::sizes::message(&**child);
        }
        let payload = &self.payload;
        if let ::std::option::Option::Some(payload) = payload {
            size += 1;
            size += ::protrust::io::sizes::message(&**payload);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let child = &self.child;
        if let ::std::option::Option::Some(child) = child {
            output.write_raw_tag_bytes(&[10])?;
            output.write_message(&**child)?;
        }
        let payload = &self.payload;
        if let ::std::option::Option::Some(payload) = payload {
            output.write_raw_tag_bytes(&[18])?;
            output.write_message(&**payload)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::NestedTestAllTypes {
    fn new() -> Self {
        Self {
            child: ::std::option::Option::None,
            payload: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        if let ::std::option::Option::Some(child) = &other.child {
            self.child.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(child);
        }
        if let ::std::option::Option::Some(payload) = &other.payload {
            self.payload.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(payload);
        }
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::NestedTestAllTypes {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[3]
    }
}
impl self::NestedTestAllTypes {
    /// Gets the field number of the [`child`] field
    ///
    /// [`child`]: #method.child
    pub const CHILD_FIELD_NUMBER: i32 = 1;
    pub fn child(&self) -> &::std::option::Option<::std::boxed::Box<self::NestedTestAllTypes>> {
        &self.child
    }
    /// Returns a unique reference to the [`child`] field
    ///
    /// [`child`]: #method.child
    pub fn child_mut(&mut self) -> &mut ::std::option::Option<::std::boxed::Box<self::NestedTestAllTypes>> {
        &mut self.child
    }
    /// Gets the field number of the [`payload`] field
    ///
    /// [`payload`]: #method.payload
    pub const PAYLOAD_FIELD_NUMBER: i32 = 2;
    pub fn payload(&self) -> &::std::option::Option<::std::boxed::Box<self::TestAllTypes>> {
        &self.payload
    }
    /// Returns a unique reference to the [`payload`] field
    ///
    /// [`payload`]: #method.payload
    pub fn payload_mut(&mut self) -> &mut ::std::option::Option<::std::boxed::Box<self::TestAllTypes>> {
        &mut self.payload
    }
}
///  Define these after TestAllTypes to make sure the compiler can handle
///  that.
#[derive(Clone, Debug, PartialEq, Default)]
pub struct ForeignMessage {
    c: i32,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::ForeignMessage {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 | 10 => self.c = input.read_int32()?,
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let c = self.c;
        if c != Self::C_DEFAULT_VALUE {
            size += 1;
            size += ::protrust::io::sizes::int32(c);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let c = self.c;
        if c != Self::C_DEFAULT_VALUE {
            output.write_raw_tag_bytes(&[8])?;
            output.write_int32(c)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::ForeignMessage {
    fn new() -> Self {
        Self {
            c: Self::C_DEFAULT_VALUE,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.c = other.c;
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::ForeignMessage {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[4]
    }
}
impl self::ForeignMessage {
    /// Gets the field number of the [`c`] field
    ///
    /// [`c`]: #method.c
    pub const C_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`c`] field
    ///
    /// [`c`]: #method.c
    pub const C_DEFAULT_VALUE: i32 = 0;
    pub fn c(&self) -> i32 {
        self.c
    }
    /// Returns a unique reference to the [`c`] field
    ///
    /// [`c`]: #method.c
    pub fn c_mut(&mut self) -> &mut i32 {
        &mut self.c
    }
}
///  TestEmptyMessage is used to test behavior of unknown fields.
#[derive(Clone, Debug, PartialEq, Default)]
pub struct TestEmptyMessage {
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::TestEmptyMessage {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::TestEmptyMessage {
    fn new() -> Self {
        Self {
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestEmptyMessage {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[5]
    }
}
impl self::TestEmptyMessage {
}
///  Same layout as TestOneof2 in unittest.proto to test unknown enum value
///  parsing behavior in oneof.
#[derive(Clone, Debug, PartialEq, Default)]
pub struct TestOneof2 {
    foo: self::test_oneof2::Foo,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::TestOneof2 {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                48 | 50 => self.foo = self::test_oneof2::Foo::FooEnum(input.read_enum_value()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        if let self::test_oneof2::Foo::FooEnum(foo) = self.foo {
            size += 1;
            size += ::protrust::io::sizes::enum_value(foo);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        if let self::test_oneof2::Foo::FooEnum(foo) = self.foo {
            output.write_raw_tag_bytes(&[48])?;
            output.write_enum_value(foo)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::TestOneof2 {
    fn new() -> Self {
        Self {
            foo: self::test_oneof2::Foo::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        if let self::test_oneof2::Foo::FooEnum(foo) = other.foo {
            self.foo = self::test_oneof2::Foo::FooEnum(foo);
        }
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestOneof2 {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[6]
    }
}
impl self::TestOneof2 {
    /// Gets the field number of the [`foo_enum`] field
    ///
    /// [`foo_enum`]: #method.foo_enum
    pub const FOO_ENUM_FIELD_NUMBER: i32 = 6;
    /// A constant value representing the default value of the [`foo_enum`] field
    ///
    /// [`foo_enum`]: #method.foo_enum
    pub const FOO_ENUM_DEFAULT_VALUE: ::protrust::EnumValue<self::test_oneof2::NestedEnum> = ::protrust::EnumValue::Defined(self::test_oneof2::NestedEnum::Unknown);
    pub fn foo_enum(&self) -> ::std::option::Option<&::protrust::EnumValue<self::test_oneof2::NestedEnum>> {
        match &self.foo {
            self::test_oneof2::Foo::FooEnum(ref foo) => ::std::option::Option::Some(foo),
            _ => ::std::option::Option::None
        }
    }
    /// Returns a unique reference to the ['foo_enum'] field
    ///
    /// [`foo_enum`]: #method.foo_enum
    pub fn foo_enum_mut(&mut self) -> &mut ::protrust::EnumValue<self::test_oneof2::NestedEnum> {
        match self.foo {
            self::test_oneof2::Foo::FooEnum(ref mut value) => value,
            _ => {
                self.set_foo_enum(::std::default::Default::default());
                self.foo_enum_mut()
            }
        }
    }
    pub fn has_foo_enum(&self) -> bool {
        match &self.foo {
            self::test_oneof2::Foo::FooEnum(_) => true,
            _ => false
        }
    }
    pub fn set_foo_enum(&mut self, value: ::protrust::EnumValue<self::test_oneof2::NestedEnum>) {
        self.foo = self::test_oneof2::Foo::FooEnum(value)
    }
    pub fn take_foo_enum(&mut self) -> ::std::option::Option<::protrust::EnumValue<self::test_oneof2::NestedEnum>> {
        match ::std::mem::replace(&mut self.foo, self::test_oneof2::Foo::None) {
            self::test_oneof2::Foo::FooEnum(value) => {
                ::std::option::Option::Some(value)
            }
            value => {
                self.foo = value;
                ::std::option::Option::None
            }
        }
    }
    pub fn clear_foo_enum(&mut self) {
        self.foo = self::test_oneof2::Foo::None
    }
    /// Gets a shared reference to the [`foo`] oneof field
    ///
    /// [`foo`]: enum.Foo.html
    pub fn foo(&self) -> &self::test_oneof2::Foo {
        &self.foo
    }
    /// Gets a unique reference to the [`foo`] oneof field
    ///
    /// [`foo`]: enum.Foo.html
    pub fn foo_mut(&mut self) -> &mut self::test_oneof2::Foo {
        &mut self.foo
    }
}
///  Same layout as TestOneof2 in unittest.proto to test unknown enum value
///  parsing behavior in oneof.
pub mod test_oneof2 {
    #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
    pub enum NestedEnum {
        Unknown,
        Foo,
        Bar,
        Baz,
    }
    impl ::protrust::Enum for self::NestedEnum {
        fn descriptor() -> &'static ::protrust::reflect::EnumDescriptor {
            &self::super::file().messages()[6].enums()[0]
        }
    }
    impl ::std::convert::TryFrom<i32> for self::NestedEnum {
        type Error = ::protrust::VariantUndefinedError;
        fn try_from(value: i32) -> ::std::result::Result<Self, ::protrust::VariantUndefinedError> {
            #[allow(unreachable_patterns)]
            match value {
                0 => ::std::result::Result::Ok(self::NestedEnum::Unknown),
                1 => ::std::result::Result::Ok(self::NestedEnum::Foo),
                2 => ::std::result::Result::Ok(self::NestedEnum::Bar),
                3 => ::std::result::Result::Ok(self::NestedEnum::Baz),
                _ => ::std::result::Result::Err(::protrust::VariantUndefinedError)
            }
        }
    }
    impl ::std::convert::From<self::NestedEnum> for i32 {
        fn from(value: self::NestedEnum) -> i32 {
            match value {
                NestedEnum::Unknown => 0,
                NestedEnum::Foo => 1,
                NestedEnum::Bar => 2,
                NestedEnum::Baz => 3,
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    pub enum Foo {
        /// No value
        None,
        FooEnum(::protrust::EnumValue<self::super::test_oneof2::NestedEnum>),
    }
    impl ::std::default::Default for self::Foo {
        fn default() -> Self {
            self::Foo::None
        }
    }
}
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ForeignEnum {
    ForeignZero,
    ForeignFoo,
    ForeignBar,
    ForeignBaz,
}
impl ::protrust::Enum for self::ForeignEnum {
    fn descriptor() -> &'static ::protrust::reflect::EnumDescriptor {
        &self::file().enums()[0]
    }
}
impl ::std::convert::TryFrom<i32> for self::ForeignEnum {
    type Error = ::protrust::VariantUndefinedError;
    fn try_from(value: i32) -> ::std::result::Result<Self, ::protrust::VariantUndefinedError> {
        #[allow(unreachable_patterns)]
        match value {
            0 => ::std::result::Result::Ok(self::ForeignEnum::ForeignZero),
            4 => ::std::result::Result::Ok(self::ForeignEnum::ForeignFoo),
            5 => ::std::result::Result::Ok(self::ForeignEnum::ForeignBar),
            6 => ::std::result::Result::Ok(self::ForeignEnum::ForeignBaz),
            _ => ::std::result::Result::Err(::protrust::VariantUndefinedError)
        }
    }
}
impl ::std::convert::From<self::ForeignEnum> for i32 {
    fn from(value: self::ForeignEnum) -> i32 {
        match value {
            ForeignEnum::ForeignZero => 0,
            ForeignEnum::ForeignFoo => 4,
            ForeignEnum::ForeignBar => 5,
            ForeignEnum::ForeignBaz => 6,
        }
    }
}