// DO NOT EDIT!
// Generated by protoc-gen-rust, part of the protrust crate.
//
// Source: unittest.proto


pub fn file() -> &'static ::protrust::reflect::FileDescriptor {
    super::pool().find_file_by_name("unittest.proto").unwrap()
}

/// Singular
pub static OPTIONAL_INT32_EXTENSION: ::protrust::Extension<self::TestAllExtensions, i32, i32> = ::protrust::Extension::int32(8, 0);
pub static OPTIONAL_INT64_EXTENSION: ::protrust::Extension<self::TestAllExtensions, i64, i64> = ::protrust::Extension::int64(16, 0);
pub static OPTIONAL_UINT32_EXTENSION: ::protrust::Extension<self::TestAllExtensions, u32, u32> = ::protrust::Extension::uint32(24, 0);
pub static OPTIONAL_UINT64_EXTENSION: ::protrust::Extension<self::TestAllExtensions, u64, u64> = ::protrust::Extension::uint64(32, 0);
pub static OPTIONAL_SINT32_EXTENSION: ::protrust::Extension<self::TestAllExtensions, i32, i32> = ::protrust::Extension::sint32(40, 0);
pub static OPTIONAL_SINT64_EXTENSION: ::protrust::Extension<self::TestAllExtensions, i64, i64> = ::protrust::Extension::sint64(48, 0);
pub static OPTIONAL_FIXED32_EXTENSION: ::protrust::Extension<self::TestAllExtensions, u32, u32> = ::protrust::Extension::fixed32(61, 0);
pub static OPTIONAL_FIXED64_EXTENSION: ::protrust::Extension<self::TestAllExtensions, u64, u64> = ::protrust::Extension::fixed64(65, 0);
pub static OPTIONAL_SFIXED32_EXTENSION: ::protrust::Extension<self::TestAllExtensions, i32, i32> = ::protrust::Extension::sfixed32(77, 0);
pub static OPTIONAL_SFIXED64_EXTENSION: ::protrust::Extension<self::TestAllExtensions, i64, i64> = ::protrust::Extension::sfixed64(81, 0);
pub static OPTIONAL_FLOAT_EXTENSION: ::protrust::Extension<self::TestAllExtensions, f32, f32> = ::protrust::Extension::float(93, 0.0);
pub static OPTIONAL_DOUBLE_EXTENSION: ::protrust::Extension<self::TestAllExtensions, f64, f64> = ::protrust::Extension::double(97, 0.0);
pub static OPTIONAL_BOOL_EXTENSION: ::protrust::Extension<self::TestAllExtensions, bool, bool> = ::protrust::Extension::bool(104, false);
pub static OPTIONAL_STRING_EXTENSION: ::protrust::Extension<self::TestAllExtensions, ::std::string::String, &'static str> = ::protrust::Extension::string(114, "");
pub static OPTIONAL_BYTES_EXTENSION: ::protrust::Extension<self::TestAllExtensions, ::std::vec::Vec<u8>, &'static [u8]> = ::protrust::Extension::bytes(122, &[]);
pub static OPTIONALGROUP_EXTENSION: ::protrust::Extension<self::TestAllExtensions, self::OptionalGroup_extension, self::OptionalGroup_extension> = ::protrust::Extension::group(131, 132);
pub static OPTIONAL_NESTED_MESSAGE_EXTENSION: ::protrust::Extension<self::TestAllExtensions, self::test_all_types::NestedMessage, self::test_all_types::NestedMessage> = ::protrust::Extension::message(146);
pub static OPTIONAL_FOREIGN_MESSAGE_EXTENSION: ::protrust::Extension<self::TestAllExtensions, self::ForeignMessage, self::ForeignMessage> = ::protrust::Extension::message(154);
pub static OPTIONAL_IMPORT_MESSAGE_EXTENSION: ::protrust::Extension<self::TestAllExtensions, self::super::unittest_import_proto::ImportMessage, self::super::unittest_import_proto::ImportMessage> = ::protrust::Extension::message(162);
pub static OPTIONAL_NESTED_ENUM_EXTENSION: ::protrust::Extension<self::TestAllExtensions, ::protrust::EnumValue<self::test_all_types::NestedEnum>, ::protrust::EnumValue<self::test_all_types::NestedEnum>> = ::protrust::Extension::enum_value(168, ::protrust::EnumValue::Undefined(0));
pub static OPTIONAL_FOREIGN_ENUM_EXTENSION: ::protrust::Extension<self::TestAllExtensions, ::protrust::EnumValue<self::ForeignEnum>, ::protrust::EnumValue<self::ForeignEnum>> = ::protrust::Extension::enum_value(176, ::protrust::EnumValue::Undefined(0));
pub static OPTIONAL_IMPORT_ENUM_EXTENSION: ::protrust::Extension<self::TestAllExtensions, ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>, ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>> = ::protrust::Extension::enum_value(184, ::protrust::EnumValue::Undefined(0));
pub static OPTIONAL_STRING_PIECE_EXTENSION: ::protrust::Extension<self::TestAllExtensions, ::std::string::String, &'static str> = ::protrust::Extension::string(194, "");
pub static OPTIONAL_CORD_EXTENSION: ::protrust::Extension<self::TestAllExtensions, ::std::string::String, &'static str> = ::protrust::Extension::string(202, "");
pub static OPTIONAL_PUBLIC_IMPORT_MESSAGE_EXTENSION: ::protrust::Extension<self::TestAllExtensions, self::super::unittest_import_public_proto::PublicImportMessage, self::super::unittest_import_public_proto::PublicImportMessage> = ::protrust::Extension::message(210);
pub static OPTIONAL_LAZY_MESSAGE_EXTENSION: ::protrust::Extension<self::TestAllExtensions, self::test_all_types::NestedMessage, self::test_all_types::NestedMessage> = ::protrust::Extension::message(218);
/// Repeated
pub static REPEATED_INT32_EXTENSION: ::protrust::RepeatedExtension<self::TestAllExtensions, i32> = ::protrust::RepeatedExtension::int32(248);
pub static REPEATED_INT64_EXTENSION: ::protrust::RepeatedExtension<self::TestAllExtensions, i64> = ::protrust::RepeatedExtension::int64(256);
pub static REPEATED_UINT32_EXTENSION: ::protrust::RepeatedExtension<self::TestAllExtensions, u32> = ::protrust::RepeatedExtension::uint32(264);
pub static REPEATED_UINT64_EXTENSION: ::protrust::RepeatedExtension<self::TestAllExtensions, u64> = ::protrust::RepeatedExtension::uint64(272);
pub static REPEATED_SINT32_EXTENSION: ::protrust::RepeatedExtension<self::TestAllExtensions, i32> = ::protrust::RepeatedExtension::sint32(280);
pub static REPEATED_SINT64_EXTENSION: ::protrust::RepeatedExtension<self::TestAllExtensions, i64> = ::protrust::RepeatedExtension::sint64(288);
pub static REPEATED_FIXED32_EXTENSION: ::protrust::RepeatedExtension<self::TestAllExtensions, u32> = ::protrust::RepeatedExtension::fixed32(301);
pub static REPEATED_FIXED64_EXTENSION: ::protrust::RepeatedExtension<self::TestAllExtensions, u64> = ::protrust::RepeatedExtension::fixed64(305);
pub static REPEATED_SFIXED32_EXTENSION: ::protrust::RepeatedExtension<self::TestAllExtensions, i32> = ::protrust::RepeatedExtension::sfixed32(317);
pub static REPEATED_SFIXED64_EXTENSION: ::protrust::RepeatedExtension<self::TestAllExtensions, i64> = ::protrust::RepeatedExtension::sfixed64(321);
pub static REPEATED_FLOAT_EXTENSION: ::protrust::RepeatedExtension<self::TestAllExtensions, f32> = ::protrust::RepeatedExtension::float(333);
pub static REPEATED_DOUBLE_EXTENSION: ::protrust::RepeatedExtension<self::TestAllExtensions, f64> = ::protrust::RepeatedExtension::double(337);
pub static REPEATED_BOOL_EXTENSION: ::protrust::RepeatedExtension<self::TestAllExtensions, bool> = ::protrust::RepeatedExtension::bool(344);
pub static REPEATED_STRING_EXTENSION: ::protrust::RepeatedExtension<self::TestAllExtensions, ::std::string::String> = ::protrust::RepeatedExtension::string(354);
pub static REPEATED_BYTES_EXTENSION: ::protrust::RepeatedExtension<self::TestAllExtensions, ::std::vec::Vec<u8>> = ::protrust::RepeatedExtension::bytes(362);
pub static REPEATEDGROUP_EXTENSION: ::protrust::RepeatedExtension<self::TestAllExtensions, self::RepeatedGroup_extension> = ::protrust::RepeatedExtension::group(371, 372);
pub static REPEATED_NESTED_MESSAGE_EXTENSION: ::protrust::RepeatedExtension<self::TestAllExtensions, self::test_all_types::NestedMessage> = ::protrust::RepeatedExtension::message(386);
pub static REPEATED_FOREIGN_MESSAGE_EXTENSION: ::protrust::RepeatedExtension<self::TestAllExtensions, self::ForeignMessage> = ::protrust::RepeatedExtension::message(394);
pub static REPEATED_IMPORT_MESSAGE_EXTENSION: ::protrust::RepeatedExtension<self::TestAllExtensions, self::super::unittest_import_proto::ImportMessage> = ::protrust::RepeatedExtension::message(402);
pub static REPEATED_NESTED_ENUM_EXTENSION: ::protrust::RepeatedExtension<self::TestAllExtensions, ::protrust::EnumValue<self::test_all_types::NestedEnum>> = ::protrust::RepeatedExtension::enum_value(408);
pub static REPEATED_FOREIGN_ENUM_EXTENSION: ::protrust::RepeatedExtension<self::TestAllExtensions, ::protrust::EnumValue<self::ForeignEnum>> = ::protrust::RepeatedExtension::enum_value(416);
pub static REPEATED_IMPORT_ENUM_EXTENSION: ::protrust::RepeatedExtension<self::TestAllExtensions, ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>> = ::protrust::RepeatedExtension::enum_value(424);
pub static REPEATED_STRING_PIECE_EXTENSION: ::protrust::RepeatedExtension<self::TestAllExtensions, ::std::string::String> = ::protrust::RepeatedExtension::string(434);
pub static REPEATED_CORD_EXTENSION: ::protrust::RepeatedExtension<self::TestAllExtensions, ::std::string::String> = ::protrust::RepeatedExtension::string(442);
pub static REPEATED_LAZY_MESSAGE_EXTENSION: ::protrust::RepeatedExtension<self::TestAllExtensions, self::test_all_types::NestedMessage> = ::protrust::RepeatedExtension::message(458);
/// Singular with defaults
pub static DEFAULT_INT32_EXTENSION: ::protrust::Extension<self::TestAllExtensions, i32, i32> = ::protrust::Extension::int32(488, 41);
pub static DEFAULT_INT64_EXTENSION: ::protrust::Extension<self::TestAllExtensions, i64, i64> = ::protrust::Extension::int64(496, 42);
pub static DEFAULT_UINT32_EXTENSION: ::protrust::Extension<self::TestAllExtensions, u32, u32> = ::protrust::Extension::uint32(504, 43);
pub static DEFAULT_UINT64_EXTENSION: ::protrust::Extension<self::TestAllExtensions, u64, u64> = ::protrust::Extension::uint64(512, 44);
pub static DEFAULT_SINT32_EXTENSION: ::protrust::Extension<self::TestAllExtensions, i32, i32> = ::protrust::Extension::sint32(520, -45);
pub static DEFAULT_SINT64_EXTENSION: ::protrust::Extension<self::TestAllExtensions, i64, i64> = ::protrust::Extension::sint64(528, 46);
pub static DEFAULT_FIXED32_EXTENSION: ::protrust::Extension<self::TestAllExtensions, u32, u32> = ::protrust::Extension::fixed32(541, 47);
pub static DEFAULT_FIXED64_EXTENSION: ::protrust::Extension<self::TestAllExtensions, u64, u64> = ::protrust::Extension::fixed64(545, 48);
pub static DEFAULT_SFIXED32_EXTENSION: ::protrust::Extension<self::TestAllExtensions, i32, i32> = ::protrust::Extension::sfixed32(557, 49);
pub static DEFAULT_SFIXED64_EXTENSION: ::protrust::Extension<self::TestAllExtensions, i64, i64> = ::protrust::Extension::sfixed64(561, -50);
pub static DEFAULT_FLOAT_EXTENSION: ::protrust::Extension<self::TestAllExtensions, f32, f32> = ::protrust::Extension::float(573, 51.5);
pub static DEFAULT_DOUBLE_EXTENSION: ::protrust::Extension<self::TestAllExtensions, f64, f64> = ::protrust::Extension::double(577, 52000.0);
pub static DEFAULT_BOOL_EXTENSION: ::protrust::Extension<self::TestAllExtensions, bool, bool> = ::protrust::Extension::bool(584, false);
pub static DEFAULT_STRING_EXTENSION: ::protrust::Extension<self::TestAllExtensions, ::std::string::String, &'static str> = ::protrust::Extension::string(594, "hello");
pub static DEFAULT_BYTES_EXTENSION: ::protrust::Extension<self::TestAllExtensions, ::std::vec::Vec<u8>, &'static [u8]> = ::protrust::Extension::bytes(602, &[119, 111, 114, 108, 100]);
pub static DEFAULT_NESTED_ENUM_EXTENSION: ::protrust::Extension<self::TestAllExtensions, ::protrust::EnumValue<self::test_all_types::NestedEnum>, ::protrust::EnumValue<self::test_all_types::NestedEnum>> = ::protrust::Extension::enum_value(648, ::protrust::EnumValue::Defined(self::test_all_types::NestedEnum::Bar));
pub static DEFAULT_FOREIGN_ENUM_EXTENSION: ::protrust::Extension<self::TestAllExtensions, ::protrust::EnumValue<self::ForeignEnum>, ::protrust::EnumValue<self::ForeignEnum>> = ::protrust::Extension::enum_value(656, ::protrust::EnumValue::Defined(self::ForeignEnum::ForeignBar));
pub static DEFAULT_IMPORT_ENUM_EXTENSION: ::protrust::Extension<self::TestAllExtensions, ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>, ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>> = ::protrust::Extension::enum_value(664, ::protrust::EnumValue::Defined(self::super::unittest_import_proto::ImportEnum::ImportBar));
pub static DEFAULT_STRING_PIECE_EXTENSION: ::protrust::Extension<self::TestAllExtensions, ::std::string::String, &'static str> = ::protrust::Extension::string(674, "abc");
pub static DEFAULT_CORD_EXTENSION: ::protrust::Extension<self::TestAllExtensions, ::std::string::String, &'static str> = ::protrust::Extension::string(682, "123");
/// For oneof test
pub static ONEOF_UINT32_EXTENSION: ::protrust::Extension<self::TestAllExtensions, u32, u32> = ::protrust::Extension::uint32(888, 0);
pub static ONEOF_NESTED_MESSAGE_EXTENSION: ::protrust::Extension<self::TestAllExtensions, self::test_all_types::NestedMessage, self::test_all_types::NestedMessage> = ::protrust::Extension::message(898);
pub static ONEOF_STRING_EXTENSION: ::protrust::Extension<self::TestAllExtensions, ::std::string::String, &'static str> = ::protrust::Extension::string(906, "");
pub static ONEOF_BYTES_EXTENSION: ::protrust::Extension<self::TestAllExtensions, ::std::vec::Vec<u8>, &'static [u8]> = ::protrust::Extension::bytes(914, &[]);
pub static MY_EXTENSION_STRING: ::protrust::Extension<self::TestFieldOrderings, ::std::string::String, &'static str> = ::protrust::Extension::string(402, "");
pub static MY_EXTENSION_INT: ::protrust::Extension<self::TestFieldOrderings, i32, i32> = ::protrust::Extension::int32(40, 0);
pub static PACKED_INT32_EXTENSION: ::protrust::RepeatedExtension<self::TestPackedExtensions, i32> = ::protrust::RepeatedExtension::int32(722);
pub static PACKED_INT64_EXTENSION: ::protrust::RepeatedExtension<self::TestPackedExtensions, i64> = ::protrust::RepeatedExtension::int64(730);
pub static PACKED_UINT32_EXTENSION: ::protrust::RepeatedExtension<self::TestPackedExtensions, u32> = ::protrust::RepeatedExtension::uint32(738);
pub static PACKED_UINT64_EXTENSION: ::protrust::RepeatedExtension<self::TestPackedExtensions, u64> = ::protrust::RepeatedExtension::uint64(746);
pub static PACKED_SINT32_EXTENSION: ::protrust::RepeatedExtension<self::TestPackedExtensions, i32> = ::protrust::RepeatedExtension::sint32(754);
pub static PACKED_SINT64_EXTENSION: ::protrust::RepeatedExtension<self::TestPackedExtensions, i64> = ::protrust::RepeatedExtension::sint64(762);
pub static PACKED_FIXED32_EXTENSION: ::protrust::RepeatedExtension<self::TestPackedExtensions, u32> = ::protrust::RepeatedExtension::fixed32(770);
pub static PACKED_FIXED64_EXTENSION: ::protrust::RepeatedExtension<self::TestPackedExtensions, u64> = ::protrust::RepeatedExtension::fixed64(778);
pub static PACKED_SFIXED32_EXTENSION: ::protrust::RepeatedExtension<self::TestPackedExtensions, i32> = ::protrust::RepeatedExtension::sfixed32(786);
pub static PACKED_SFIXED64_EXTENSION: ::protrust::RepeatedExtension<self::TestPackedExtensions, i64> = ::protrust::RepeatedExtension::sfixed64(794);
pub static PACKED_FLOAT_EXTENSION: ::protrust::RepeatedExtension<self::TestPackedExtensions, f32> = ::protrust::RepeatedExtension::float(802);
pub static PACKED_DOUBLE_EXTENSION: ::protrust::RepeatedExtension<self::TestPackedExtensions, f64> = ::protrust::RepeatedExtension::double(810);
pub static PACKED_BOOL_EXTENSION: ::protrust::RepeatedExtension<self::TestPackedExtensions, bool> = ::protrust::RepeatedExtension::bool(818);
pub static PACKED_ENUM_EXTENSION: ::protrust::RepeatedExtension<self::TestPackedExtensions, ::protrust::EnumValue<self::ForeignEnum>> = ::protrust::RepeatedExtension::enum_value(826);
pub static UNPACKED_INT32_EXTENSION: ::protrust::RepeatedExtension<self::TestUnpackedExtensions, i32> = ::protrust::RepeatedExtension::int32(720);
pub static UNPACKED_INT64_EXTENSION: ::protrust::RepeatedExtension<self::TestUnpackedExtensions, i64> = ::protrust::RepeatedExtension::int64(728);
pub static UNPACKED_UINT32_EXTENSION: ::protrust::RepeatedExtension<self::TestUnpackedExtensions, u32> = ::protrust::RepeatedExtension::uint32(736);
pub static UNPACKED_UINT64_EXTENSION: ::protrust::RepeatedExtension<self::TestUnpackedExtensions, u64> = ::protrust::RepeatedExtension::uint64(744);
pub static UNPACKED_SINT32_EXTENSION: ::protrust::RepeatedExtension<self::TestUnpackedExtensions, i32> = ::protrust::RepeatedExtension::sint32(752);
pub static UNPACKED_SINT64_EXTENSION: ::protrust::RepeatedExtension<self::TestUnpackedExtensions, i64> = ::protrust::RepeatedExtension::sint64(760);
pub static UNPACKED_FIXED32_EXTENSION: ::protrust::RepeatedExtension<self::TestUnpackedExtensions, u32> = ::protrust::RepeatedExtension::fixed32(773);
pub static UNPACKED_FIXED64_EXTENSION: ::protrust::RepeatedExtension<self::TestUnpackedExtensions, u64> = ::protrust::RepeatedExtension::fixed64(777);
pub static UNPACKED_SFIXED32_EXTENSION: ::protrust::RepeatedExtension<self::TestUnpackedExtensions, i32> = ::protrust::RepeatedExtension::sfixed32(789);
pub static UNPACKED_SFIXED64_EXTENSION: ::protrust::RepeatedExtension<self::TestUnpackedExtensions, i64> = ::protrust::RepeatedExtension::sfixed64(793);
pub static UNPACKED_FLOAT_EXTENSION: ::protrust::RepeatedExtension<self::TestUnpackedExtensions, f32> = ::protrust::RepeatedExtension::float(805);
pub static UNPACKED_DOUBLE_EXTENSION: ::protrust::RepeatedExtension<self::TestUnpackedExtensions, f64> = ::protrust::RepeatedExtension::double(809);
pub static UNPACKED_BOOL_EXTENSION: ::protrust::RepeatedExtension<self::TestUnpackedExtensions, bool> = ::protrust::RepeatedExtension::bool(816);
pub static UNPACKED_ENUM_EXTENSION: ::protrust::RepeatedExtension<self::TestUnpackedExtensions, ::protrust::EnumValue<self::ForeignEnum>> = ::protrust::RepeatedExtension::enum_value(824);
pub static TEST_ALL_TYPES: ::protrust::Extension<self::TestHugeFieldNumbers, self::TestAllTypes, self::TestAllTypes> = ::protrust::Extension::message(4294880002);
pub static TEST_EXTENSION_INSIDE_TABLE_EXTENSION: ::protrust::Extension<self::TestExtensionInsideTable, i32, i32> = ::protrust::Extension::int32(40, 0);
/// This proto includes every type of field in both singular and repeated
/// forms.
#[derive(Clone, Debug, PartialEq)]
pub struct TestAllTypes {
    optional_int32: ::std::option::Option<i32>,
    optional_int64: ::std::option::Option<i64>,
    optional_uint32: ::std::option::Option<u32>,
    optional_uint64: ::std::option::Option<u64>,
    optional_sint32: ::std::option::Option<i32>,
    optional_sint64: ::std::option::Option<i64>,
    optional_fixed32: ::std::option::Option<u32>,
    optional_fixed64: ::std::option::Option<u64>,
    optional_sfixed32: ::std::option::Option<i32>,
    optional_sfixed64: ::std::option::Option<i64>,
    optional_float: ::std::option::Option<f32>,
    optional_double: ::std::option::Option<f64>,
    optional_bool: ::std::option::Option<bool>,
    optional_string: ::std::option::Option<::std::string::String>,
    optional_bytes: ::std::option::Option<::std::vec::Vec<u8>>,
    optionalgroup: ::std::option::Option<::std::boxed::Box<self::test_all_types::OptionalGroup>>,
    optional_nested_message: ::std::option::Option<::std::boxed::Box<self::test_all_types::NestedMessage>>,
    optional_foreign_message: ::std::option::Option<::std::boxed::Box<self::ForeignMessage>>,
    optional_import_message: ::std::option::Option<::std::boxed::Box<self::super::unittest_import_proto::ImportMessage>>,
    optional_nested_enum: ::std::option::Option<::protrust::EnumValue<self::test_all_types::NestedEnum>>,
    optional_foreign_enum: ::std::option::Option<::protrust::EnumValue<self::ForeignEnum>>,
    optional_import_enum: ::std::option::Option<::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>>,
    optional_string_piece: ::std::option::Option<::std::string::String>,
    optional_cord: ::std::option::Option<::std::string::String>,
    optional_public_import_message: ::std::option::Option<::std::boxed::Box<self::super::unittest_import_public_proto::PublicImportMessage>>,
    optional_lazy_message: ::std::option::Option<::std::boxed::Box<self::test_all_types::NestedMessage>>,
    repeated_int32: ::protrust::collections::RepeatedField<i32>,
    repeated_int64: ::protrust::collections::RepeatedField<i64>,
    repeated_uint32: ::protrust::collections::RepeatedField<u32>,
    repeated_uint64: ::protrust::collections::RepeatedField<u64>,
    repeated_sint32: ::protrust::collections::RepeatedField<i32>,
    repeated_sint64: ::protrust::collections::RepeatedField<i64>,
    repeated_fixed32: ::protrust::collections::RepeatedField<u32>,
    repeated_fixed64: ::protrust::collections::RepeatedField<u64>,
    repeated_sfixed32: ::protrust::collections::RepeatedField<i32>,
    repeated_sfixed64: ::protrust::collections::RepeatedField<i64>,
    repeated_float: ::protrust::collections::RepeatedField<f32>,
    repeated_double: ::protrust::collections::RepeatedField<f64>,
    repeated_bool: ::protrust::collections::RepeatedField<bool>,
    repeated_string: ::protrust::collections::RepeatedField<::std::string::String>,
    repeated_bytes: ::protrust::collections::RepeatedField<::std::vec::Vec<u8>>,
    repeatedgroup: ::protrust::collections::RepeatedField<self::test_all_types::RepeatedGroup>,
    repeated_nested_message: ::protrust::collections::RepeatedField<self::test_all_types::NestedMessage>,
    repeated_foreign_message: ::protrust::collections::RepeatedField<self::ForeignMessage>,
    repeated_import_message: ::protrust::collections::RepeatedField<self::super::unittest_import_proto::ImportMessage>,
    repeated_nested_enum: ::protrust::collections::RepeatedField<::protrust::EnumValue<self::test_all_types::NestedEnum>>,
    repeated_foreign_enum: ::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>>,
    repeated_import_enum: ::protrust::collections::RepeatedField<::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>>,
    repeated_string_piece: ::protrust::collections::RepeatedField<::std::string::String>,
    repeated_cord: ::protrust::collections::RepeatedField<::std::string::String>,
    repeated_lazy_message: ::protrust::collections::RepeatedField<self::test_all_types::NestedMessage>,
    default_int32: ::std::option::Option<i32>,
    default_int64: ::std::option::Option<i64>,
    default_uint32: ::std::option::Option<u32>,
    default_uint64: ::std::option::Option<u64>,
    default_sint32: ::std::option::Option<i32>,
    default_sint64: ::std::option::Option<i64>,
    default_fixed32: ::std::option::Option<u32>,
    default_fixed64: ::std::option::Option<u64>,
    default_sfixed32: ::std::option::Option<i32>,
    default_sfixed64: ::std::option::Option<i64>,
    default_float: ::std::option::Option<f32>,
    default_double: ::std::option::Option<f64>,
    default_bool: ::std::option::Option<bool>,
    default_string: ::std::option::Option<::std::string::String>,
    default_bytes: ::std::option::Option<::std::vec::Vec<u8>>,
    default_nested_enum: ::std::option::Option<::protrust::EnumValue<self::test_all_types::NestedEnum>>,
    default_foreign_enum: ::std::option::Option<::protrust::EnumValue<self::ForeignEnum>>,
    default_import_enum: ::std::option::Option<::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>>,
    default_string_piece: ::std::option::Option<::std::string::String>,
    default_cord: ::std::option::Option<::std::string::String>,
    oneof_field: self::test_all_types::OneofField,
    unknown_fields: ::protrust::UnknownFieldSet,
}
static TEST_ALL_TYPES_REPEATED_INT32_CODEC: ::protrust::Codec<i32> = ::protrust::Codec::int32(248);
static TEST_ALL_TYPES_REPEATED_INT64_CODEC: ::protrust::Codec<i64> = ::protrust::Codec::int64(256);
static TEST_ALL_TYPES_REPEATED_UINT32_CODEC: ::protrust::Codec<u32> = ::protrust::Codec::uint32(264);
static TEST_ALL_TYPES_REPEATED_UINT64_CODEC: ::protrust::Codec<u64> = ::protrust::Codec::uint64(272);
static TEST_ALL_TYPES_REPEATED_SINT32_CODEC: ::protrust::Codec<i32> = ::protrust::Codec::sint32(280);
static TEST_ALL_TYPES_REPEATED_SINT64_CODEC: ::protrust::Codec<i64> = ::protrust::Codec::sint64(288);
static TEST_ALL_TYPES_REPEATED_FIXED32_CODEC: ::protrust::Codec<u32> = ::protrust::Codec::fixed32(301);
static TEST_ALL_TYPES_REPEATED_FIXED64_CODEC: ::protrust::Codec<u64> = ::protrust::Codec::fixed64(305);
static TEST_ALL_TYPES_REPEATED_SFIXED32_CODEC: ::protrust::Codec<i32> = ::protrust::Codec::sfixed32(317);
static TEST_ALL_TYPES_REPEATED_SFIXED64_CODEC: ::protrust::Codec<i64> = ::protrust::Codec::sfixed64(321);
static TEST_ALL_TYPES_REPEATED_FLOAT_CODEC: ::protrust::Codec<f32> = ::protrust::Codec::float(333);
static TEST_ALL_TYPES_REPEATED_DOUBLE_CODEC: ::protrust::Codec<f64> = ::protrust::Codec::double(337);
static TEST_ALL_TYPES_REPEATED_BOOL_CODEC: ::protrust::Codec<bool> = ::protrust::Codec::bool(344);
static TEST_ALL_TYPES_REPEATED_STRING_CODEC: ::protrust::Codec<::std::string::String> = ::protrust::Codec::string(354);
static TEST_ALL_TYPES_REPEATED_BYTES_CODEC: ::protrust::Codec<::std::vec::Vec<u8>> = ::protrust::Codec::bytes(362);
static TEST_ALL_TYPES_REPEATEDGROUP_CODEC: ::protrust::Codec<self::test_all_types::RepeatedGroup> = ::protrust::Codec::group(371, 372);
static TEST_ALL_TYPES_REPEATED_NESTED_MESSAGE_CODEC: ::protrust::Codec<self::test_all_types::NestedMessage> = ::protrust::Codec::message(386);
static TEST_ALL_TYPES_REPEATED_FOREIGN_MESSAGE_CODEC: ::protrust::Codec<self::ForeignMessage> = ::protrust::Codec::message(394);
static TEST_ALL_TYPES_REPEATED_IMPORT_MESSAGE_CODEC: ::protrust::Codec<self::super::unittest_import_proto::ImportMessage> = ::protrust::Codec::message(402);
static TEST_ALL_TYPES_REPEATED_NESTED_ENUM_CODEC: ::protrust::Codec<::protrust::EnumValue<self::test_all_types::NestedEnum>> = ::protrust::Codec::enum_value(408);
static TEST_ALL_TYPES_REPEATED_FOREIGN_ENUM_CODEC: ::protrust::Codec<::protrust::EnumValue<self::ForeignEnum>> = ::protrust::Codec::enum_value(416);
static TEST_ALL_TYPES_REPEATED_IMPORT_ENUM_CODEC: ::protrust::Codec<::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>> = ::protrust::Codec::enum_value(424);
static TEST_ALL_TYPES_REPEATED_STRING_PIECE_CODEC: ::protrust::Codec<::std::string::String> = ::protrust::Codec::string(434);
static TEST_ALL_TYPES_REPEATED_CORD_CODEC: ::protrust::Codec<::std::string::String> = ::protrust::Codec::string(442);
static TEST_ALL_TYPES_REPEATED_LAZY_MESSAGE_CODEC: ::protrust::Codec<self::test_all_types::NestedMessage> = ::protrust::Codec::message(458);
impl ::protrust::CodedMessage for self::TestAllTypes {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 | 10 => self.optional_int32 = ::std::option::Option::Some(input.read_int32()?),
                16 | 18 => self.optional_int64 = ::std::option::Option::Some(input.read_int64()?),
                24 | 26 => self.optional_uint32 = ::std::option::Option::Some(input.read_uint32()?),
                32 | 34 => self.optional_uint64 = ::std::option::Option::Some(input.read_uint64()?),
                40 | 42 => self.optional_sint32 = ::std::option::Option::Some(input.read_sint32()?),
                48 | 50 => self.optional_sint64 = ::std::option::Option::Some(input.read_sint64()?),
                61 | 58 => self.optional_fixed32 = ::std::option::Option::Some(input.read_fixed32()?),
                65 | 66 => self.optional_fixed64 = ::std::option::Option::Some(input.read_fixed64()?),
                77 | 74 => self.optional_sfixed32 = ::std::option::Option::Some(input.read_sfixed32()?),
                81 | 82 => self.optional_sfixed64 = ::std::option::Option::Some(input.read_sfixed64()?),
                93 | 90 => self.optional_float = ::std::option::Option::Some(input.read_float()?),
                97 | 98 => self.optional_double = ::std::option::Option::Some(input.read_double()?),
                104 | 106 => self.optional_bool = ::std::option::Option::Some(input.read_bool()?),
                114 => self.optional_string = ::std::option::Option::Some(input.read_string()?),
                122 => self.optional_bytes = ::std::option::Option::Some(input.read_bytes()?),
                131 => input.read_group(&mut **self.optionalgroup.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                146 => input.read_message(&mut **self.optional_nested_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                154 => input.read_message(&mut **self.optional_foreign_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                162 => input.read_message(&mut **self.optional_import_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                168 | 170 => self.optional_nested_enum = ::std::option::Option::Some(input.read_enum_value()?),
                176 | 178 => self.optional_foreign_enum = ::std::option::Option::Some(input.read_enum_value()?),
                184 | 186 => self.optional_import_enum = ::std::option::Option::Some(input.read_enum_value()?),
                194 => self.optional_string_piece = ::std::option::Option::Some(input.read_string()?),
                202 => self.optional_cord = ::std::option::Option::Some(input.read_string()?),
                210 => input.read_message(&mut **self.optional_public_import_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                218 => input.read_message(&mut **self.optional_lazy_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                248 | 250 => self.repeated_int32.add_entries(input, &TEST_ALL_TYPES_REPEATED_INT32_CODEC)?,
                256 | 258 => self.repeated_int64.add_entries(input, &TEST_ALL_TYPES_REPEATED_INT64_CODEC)?,
                264 | 266 => self.repeated_uint32.add_entries(input, &TEST_ALL_TYPES_REPEATED_UINT32_CODEC)?,
                272 | 274 => self.repeated_uint64.add_entries(input, &TEST_ALL_TYPES_REPEATED_UINT64_CODEC)?,
                280 | 282 => self.repeated_sint32.add_entries(input, &TEST_ALL_TYPES_REPEATED_SINT32_CODEC)?,
                288 | 290 => self.repeated_sint64.add_entries(input, &TEST_ALL_TYPES_REPEATED_SINT64_CODEC)?,
                301 | 298 => self.repeated_fixed32.add_entries(input, &TEST_ALL_TYPES_REPEATED_FIXED32_CODEC)?,
                305 | 306 => self.repeated_fixed64.add_entries(input, &TEST_ALL_TYPES_REPEATED_FIXED64_CODEC)?,
                317 | 314 => self.repeated_sfixed32.add_entries(input, &TEST_ALL_TYPES_REPEATED_SFIXED32_CODEC)?,
                321 | 322 => self.repeated_sfixed64.add_entries(input, &TEST_ALL_TYPES_REPEATED_SFIXED64_CODEC)?,
                333 | 330 => self.repeated_float.add_entries(input, &TEST_ALL_TYPES_REPEATED_FLOAT_CODEC)?,
                337 | 338 => self.repeated_double.add_entries(input, &TEST_ALL_TYPES_REPEATED_DOUBLE_CODEC)?,
                344 | 346 => self.repeated_bool.add_entries(input, &TEST_ALL_TYPES_REPEATED_BOOL_CODEC)?,
                354 => self.repeated_string.add_entries(input, &TEST_ALL_TYPES_REPEATED_STRING_CODEC)?,
                362 => self.repeated_bytes.add_entries(input, &TEST_ALL_TYPES_REPEATED_BYTES_CODEC)?,
                371 => self.repeatedgroup.add_entries(input, &TEST_ALL_TYPES_REPEATEDGROUP_CODEC)?,
                386 => self.repeated_nested_message.add_entries(input, &TEST_ALL_TYPES_REPEATED_NESTED_MESSAGE_CODEC)?,
                394 => self.repeated_foreign_message.add_entries(input, &TEST_ALL_TYPES_REPEATED_FOREIGN_MESSAGE_CODEC)?,
                402 => self.repeated_import_message.add_entries(input, &TEST_ALL_TYPES_REPEATED_IMPORT_MESSAGE_CODEC)?,
                408 | 410 => self.repeated_nested_enum.add_entries(input, &TEST_ALL_TYPES_REPEATED_NESTED_ENUM_CODEC)?,
                416 | 418 => self.repeated_foreign_enum.add_entries(input, &TEST_ALL_TYPES_REPEATED_FOREIGN_ENUM_CODEC)?,
                424 | 426 => self.repeated_import_enum.add_entries(input, &TEST_ALL_TYPES_REPEATED_IMPORT_ENUM_CODEC)?,
                434 => self.repeated_string_piece.add_entries(input, &TEST_ALL_TYPES_REPEATED_STRING_PIECE_CODEC)?,
                442 => self.repeated_cord.add_entries(input, &TEST_ALL_TYPES_REPEATED_CORD_CODEC)?,
                458 => self.repeated_lazy_message.add_entries(input, &TEST_ALL_TYPES_REPEATED_LAZY_MESSAGE_CODEC)?,
                488 | 490 => self.default_int32 = ::std::option::Option::Some(input.read_int32()?),
                496 | 498 => self.default_int64 = ::std::option::Option::Some(input.read_int64()?),
                504 | 506 => self.default_uint32 = ::std::option::Option::Some(input.read_uint32()?),
                512 | 514 => self.default_uint64 = ::std::option::Option::Some(input.read_uint64()?),
                520 | 522 => self.default_sint32 = ::std::option::Option::Some(input.read_sint32()?),
                528 | 530 => self.default_sint64 = ::std::option::Option::Some(input.read_sint64()?),
                541 | 538 => self.default_fixed32 = ::std::option::Option::Some(input.read_fixed32()?),
                545 | 546 => self.default_fixed64 = ::std::option::Option::Some(input.read_fixed64()?),
                557 | 554 => self.default_sfixed32 = ::std::option::Option::Some(input.read_sfixed32()?),
                561 | 562 => self.default_sfixed64 = ::std::option::Option::Some(input.read_sfixed64()?),
                573 | 570 => self.default_float = ::std::option::Option::Some(input.read_float()?),
                577 | 578 => self.default_double = ::std::option::Option::Some(input.read_double()?),
                584 | 586 => self.default_bool = ::std::option::Option::Some(input.read_bool()?),
                594 => self.default_string = ::std::option::Option::Some(input.read_string()?),
                602 => self.default_bytes = ::std::option::Option::Some(input.read_bytes()?),
                648 | 650 => self.default_nested_enum = ::std::option::Option::Some(input.read_enum_value()?),
                656 | 658 => self.default_foreign_enum = ::std::option::Option::Some(input.read_enum_value()?),
                664 | 666 => self.default_import_enum = ::std::option::Option::Some(input.read_enum_value()?),
                674 => self.default_string_piece = ::std::option::Option::Some(input.read_string()?),
                682 => self.default_cord = ::std::option::Option::Some(input.read_string()?),
                888 | 890 => self.oneof_field = self::test_all_types::OneofField::OneofUint32(input.read_uint32()?),
                898 => 
                    if let self::test_all_types::OneofField::OneofNestedMessage(oneof_field) = &mut self.oneof_field {
                        input.read_message(&mut **oneof_field)?;
                    } else {
                        let mut oneof_field = ::std::boxed::Box::new(<self::test_all_types::NestedMessage as ::protrust::LiteMessage>::new());
                        input.read_message(&mut *oneof_field)?;
                        self.oneof_field = self::test_all_types::OneofField::OneofNestedMessage(oneof_field)
                    },
                906 => self.oneof_field = self::test_all_types::OneofField::OneofString(input.read_string()?),
                914 => self.oneof_field = self::test_all_types::OneofField::OneofBytes(input.read_bytes()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let optional_int32 = self.optional_int32;
        if let ::std::option::Option::Some(optional_int32) = optional_int32 {
            size += 1;
            size += ::protrust::io::sizes::int32(optional_int32);
        }
        let optional_int64 = self.optional_int64;
        if let ::std::option::Option::Some(optional_int64) = optional_int64 {
            size += 1;
            size += ::protrust::io::sizes::int64(optional_int64);
        }
        let optional_uint32 = self.optional_uint32;
        if let ::std::option::Option::Some(optional_uint32) = optional_uint32 {
            size += 1;
            size += ::protrust::io::sizes::uint32(optional_uint32);
        }
        let optional_uint64 = self.optional_uint64;
        if let ::std::option::Option::Some(optional_uint64) = optional_uint64 {
            size += 1;
            size += ::protrust::io::sizes::uint64(optional_uint64);
        }
        let optional_sint32 = self.optional_sint32;
        if let ::std::option::Option::Some(optional_sint32) = optional_sint32 {
            size += 1;
            size += ::protrust::io::sizes::sint32(optional_sint32);
        }
        let optional_sint64 = self.optional_sint64;
        if let ::std::option::Option::Some(optional_sint64) = optional_sint64 {
            size += 1;
            size += ::protrust::io::sizes::sint64(optional_sint64);
        }
        let optional_fixed32 = self.optional_fixed32;
        if let ::std::option::Option::Some(optional_fixed32) = optional_fixed32 {
            size += 1;
            size += ::protrust::io::sizes::fixed32(optional_fixed32);
        }
        let optional_fixed64 = self.optional_fixed64;
        if let ::std::option::Option::Some(optional_fixed64) = optional_fixed64 {
            size += 1;
            size += ::protrust::io::sizes::fixed64(optional_fixed64);
        }
        let optional_sfixed32 = self.optional_sfixed32;
        if let ::std::option::Option::Some(optional_sfixed32) = optional_sfixed32 {
            size += 1;
            size += ::protrust::io::sizes::sfixed32(optional_sfixed32);
        }
        let optional_sfixed64 = self.optional_sfixed64;
        if let ::std::option::Option::Some(optional_sfixed64) = optional_sfixed64 {
            size += 1;
            size += ::protrust::io::sizes::sfixed64(optional_sfixed64);
        }
        let optional_float = self.optional_float;
        if let ::std::option::Option::Some(optional_float) = optional_float {
            size += 1;
            size += ::protrust::io::sizes::float(optional_float);
        }
        let optional_double = self.optional_double;
        if let ::std::option::Option::Some(optional_double) = optional_double {
            size += 1;
            size += ::protrust::io::sizes::double(optional_double);
        }
        let optional_bool = self.optional_bool;
        if let ::std::option::Option::Some(optional_bool) = optional_bool {
            size += 1;
            size += ::protrust::io::sizes::bool(optional_bool);
        }
        let optional_string = &self.optional_string;
        if let ::std::option::Option::Some(optional_string) = optional_string {
            size += 1;
            size += ::protrust::io::sizes::string(optional_string);
        }
        let optional_bytes = &self.optional_bytes;
        if let ::std::option::Option::Some(optional_bytes) = optional_bytes {
            size += 1;
            size += ::protrust::io::sizes::bytes(optional_bytes);
        }
        let optionalgroup = &self.optionalgroup;
        if let ::std::option::Option::Some(optionalgroup) = optionalgroup {
            size += 2;
            size += ::protrust::io::sizes::group(&**optionalgroup);
            size += 2;
        }
        let optional_nested_message = &self.optional_nested_message;
        if let ::std::option::Option::Some(optional_nested_message) = optional_nested_message {
            size += 2;
            size += ::protrust::io::sizes::message(&**optional_nested_message);
        }
        let optional_foreign_message = &self.optional_foreign_message;
        if let ::std::option::Option::Some(optional_foreign_message) = optional_foreign_message {
            size += 2;
            size += ::protrust::io::sizes::message(&**optional_foreign_message);
        }
        let optional_import_message = &self.optional_import_message;
        if let ::std::option::Option::Some(optional_import_message) = optional_import_message {
            size += 2;
            size += ::protrust::io::sizes::message(&**optional_import_message);
        }
        let optional_nested_enum = self.optional_nested_enum;
        if let ::std::option::Option::Some(optional_nested_enum) = optional_nested_enum {
            size += 2;
            size += ::protrust::io::sizes::enum_value(optional_nested_enum);
        }
        let optional_foreign_enum = self.optional_foreign_enum;
        if let ::std::option::Option::Some(optional_foreign_enum) = optional_foreign_enum {
            size += 2;
            size += ::protrust::io::sizes::enum_value(optional_foreign_enum);
        }
        let optional_import_enum = self.optional_import_enum;
        if let ::std::option::Option::Some(optional_import_enum) = optional_import_enum {
            size += 2;
            size += ::protrust::io::sizes::enum_value(optional_import_enum);
        }
        let optional_string_piece = &self.optional_string_piece;
        if let ::std::option::Option::Some(optional_string_piece) = optional_string_piece {
            size += 2;
            size += ::protrust::io::sizes::string(optional_string_piece);
        }
        let optional_cord = &self.optional_cord;
        if let ::std::option::Option::Some(optional_cord) = optional_cord {
            size += 2;
            size += ::protrust::io::sizes::string(optional_cord);
        }
        let optional_public_import_message = &self.optional_public_import_message;
        if let ::std::option::Option::Some(optional_public_import_message) = optional_public_import_message {
            size += 2;
            size += ::protrust::io::sizes::message(&**optional_public_import_message);
        }
        let optional_lazy_message = &self.optional_lazy_message;
        if let ::std::option::Option::Some(optional_lazy_message) = optional_lazy_message {
            size += 2;
            size += ::protrust::io::sizes::message(&**optional_lazy_message);
        }
        size += self.repeated_int32.calculate_size(&TEST_ALL_TYPES_REPEATED_INT32_CODEC);
        size += self.repeated_int64.calculate_size(&TEST_ALL_TYPES_REPEATED_INT64_CODEC);
        size += self.repeated_uint32.calculate_size(&TEST_ALL_TYPES_REPEATED_UINT32_CODEC);
        size += self.repeated_uint64.calculate_size(&TEST_ALL_TYPES_REPEATED_UINT64_CODEC);
        size += self.repeated_sint32.calculate_size(&TEST_ALL_TYPES_REPEATED_SINT32_CODEC);
        size += self.repeated_sint64.calculate_size(&TEST_ALL_TYPES_REPEATED_SINT64_CODEC);
        size += self.repeated_fixed32.calculate_size(&TEST_ALL_TYPES_REPEATED_FIXED32_CODEC);
        size += self.repeated_fixed64.calculate_size(&TEST_ALL_TYPES_REPEATED_FIXED64_CODEC);
        size += self.repeated_sfixed32.calculate_size(&TEST_ALL_TYPES_REPEATED_SFIXED32_CODEC);
        size += self.repeated_sfixed64.calculate_size(&TEST_ALL_TYPES_REPEATED_SFIXED64_CODEC);
        size += self.repeated_float.calculate_size(&TEST_ALL_TYPES_REPEATED_FLOAT_CODEC);
        size += self.repeated_double.calculate_size(&TEST_ALL_TYPES_REPEATED_DOUBLE_CODEC);
        size += self.repeated_bool.calculate_size(&TEST_ALL_TYPES_REPEATED_BOOL_CODEC);
        size += self.repeated_string.calculate_size(&TEST_ALL_TYPES_REPEATED_STRING_CODEC);
        size += self.repeated_bytes.calculate_size(&TEST_ALL_TYPES_REPEATED_BYTES_CODEC);
        size += self.repeatedgroup.calculate_size(&TEST_ALL_TYPES_REPEATEDGROUP_CODEC);
        size += self.repeated_nested_message.calculate_size(&TEST_ALL_TYPES_REPEATED_NESTED_MESSAGE_CODEC);
        size += self.repeated_foreign_message.calculate_size(&TEST_ALL_TYPES_REPEATED_FOREIGN_MESSAGE_CODEC);
        size += self.repeated_import_message.calculate_size(&TEST_ALL_TYPES_REPEATED_IMPORT_MESSAGE_CODEC);
        size += self.repeated_nested_enum.calculate_size(&TEST_ALL_TYPES_REPEATED_NESTED_ENUM_CODEC);
        size += self.repeated_foreign_enum.calculate_size(&TEST_ALL_TYPES_REPEATED_FOREIGN_ENUM_CODEC);
        size += self.repeated_import_enum.calculate_size(&TEST_ALL_TYPES_REPEATED_IMPORT_ENUM_CODEC);
        size += self.repeated_string_piece.calculate_size(&TEST_ALL_TYPES_REPEATED_STRING_PIECE_CODEC);
        size += self.repeated_cord.calculate_size(&TEST_ALL_TYPES_REPEATED_CORD_CODEC);
        size += self.repeated_lazy_message.calculate_size(&TEST_ALL_TYPES_REPEATED_LAZY_MESSAGE_CODEC);
        let default_int32 = self.default_int32;
        if let ::std::option::Option::Some(default_int32) = default_int32 {
            size += 2;
            size += ::protrust::io::sizes::int32(default_int32);
        }
        let default_int64 = self.default_int64;
        if let ::std::option::Option::Some(default_int64) = default_int64 {
            size += 2;
            size += ::protrust::io::sizes::int64(default_int64);
        }
        let default_uint32 = self.default_uint32;
        if let ::std::option::Option::Some(default_uint32) = default_uint32 {
            size += 2;
            size += ::protrust::io::sizes::uint32(default_uint32);
        }
        let default_uint64 = self.default_uint64;
        if let ::std::option::Option::Some(default_uint64) = default_uint64 {
            size += 2;
            size += ::protrust::io::sizes::uint64(default_uint64);
        }
        let default_sint32 = self.default_sint32;
        if let ::std::option::Option::Some(default_sint32) = default_sint32 {
            size += 2;
            size += ::protrust::io::sizes::sint32(default_sint32);
        }
        let default_sint64 = self.default_sint64;
        if let ::std::option::Option::Some(default_sint64) = default_sint64 {
            size += 2;
            size += ::protrust::io::sizes::sint64(default_sint64);
        }
        let default_fixed32 = self.default_fixed32;
        if let ::std::option::Option::Some(default_fixed32) = default_fixed32 {
            size += 2;
            size += ::protrust::io::sizes::fixed32(default_fixed32);
        }
        let default_fixed64 = self.default_fixed64;
        if let ::std::option::Option::Some(default_fixed64) = default_fixed64 {
            size += 2;
            size += ::protrust::io::sizes::fixed64(default_fixed64);
        }
        let default_sfixed32 = self.default_sfixed32;
        if let ::std::option::Option::Some(default_sfixed32) = default_sfixed32 {
            size += 2;
            size += ::protrust::io::sizes::sfixed32(default_sfixed32);
        }
        let default_sfixed64 = self.default_sfixed64;
        if let ::std::option::Option::Some(default_sfixed64) = default_sfixed64 {
            size += 2;
            size += ::protrust::io::sizes::sfixed64(default_sfixed64);
        }
        let default_float = self.default_float;
        if let ::std::option::Option::Some(default_float) = default_float {
            size += 2;
            size += ::protrust::io::sizes::float(default_float);
        }
        let default_double = self.default_double;
        if let ::std::option::Option::Some(default_double) = default_double {
            size += 2;
            size += ::protrust::io::sizes::double(default_double);
        }
        let default_bool = self.default_bool;
        if let ::std::option::Option::Some(default_bool) = default_bool {
            size += 2;
            size += ::protrust::io::sizes::bool(default_bool);
        }
        let default_string = &self.default_string;
        if let ::std::option::Option::Some(default_string) = default_string {
            size += 2;
            size += ::protrust::io::sizes::string(default_string);
        }
        let default_bytes = &self.default_bytes;
        if let ::std::option::Option::Some(default_bytes) = default_bytes {
            size += 2;
            size += ::protrust::io::sizes::bytes(default_bytes);
        }
        let default_nested_enum = self.default_nested_enum;
        if let ::std::option::Option::Some(default_nested_enum) = default_nested_enum {
            size += 2;
            size += ::protrust::io::sizes::enum_value(default_nested_enum);
        }
        let default_foreign_enum = self.default_foreign_enum;
        if let ::std::option::Option::Some(default_foreign_enum) = default_foreign_enum {
            size += 2;
            size += ::protrust::io::sizes::enum_value(default_foreign_enum);
        }
        let default_import_enum = self.default_import_enum;
        if let ::std::option::Option::Some(default_import_enum) = default_import_enum {
            size += 2;
            size += ::protrust::io::sizes::enum_value(default_import_enum);
        }
        let default_string_piece = &self.default_string_piece;
        if let ::std::option::Option::Some(default_string_piece) = default_string_piece {
            size += 2;
            size += ::protrust::io::sizes::string(default_string_piece);
        }
        let default_cord = &self.default_cord;
        if let ::std::option::Option::Some(default_cord) = default_cord {
            size += 2;
            size += ::protrust::io::sizes::string(default_cord);
        }
        if let self::test_all_types::OneofField::OneofUint32(oneof_field) = self.oneof_field {
            size += 2;
            size += ::protrust::io::sizes::uint32(oneof_field);
        }
        if let self::test_all_types::OneofField::OneofNestedMessage(oneof_field) = &self.oneof_field {
            size += 2;
            size += ::protrust::io::sizes::message(&**oneof_field);
        }
        if let self::test_all_types::OneofField::OneofString(oneof_field) = &self.oneof_field {
            size += 2;
            size += ::protrust::io::sizes::string(oneof_field);
        }
        if let self::test_all_types::OneofField::OneofBytes(oneof_field) = &self.oneof_field {
            size += 2;
            size += ::protrust::io::sizes::bytes(oneof_field);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let optional_int32 = self.optional_int32;
        if let ::std::option::Option::Some(optional_int32) = optional_int32 {
            output.write_raw_tag_bytes(&[8])?;
            output.write_int32(optional_int32)?;
        }
        let optional_int64 = self.optional_int64;
        if let ::std::option::Option::Some(optional_int64) = optional_int64 {
            output.write_raw_tag_bytes(&[16])?;
            output.write_int64(optional_int64)?;
        }
        let optional_uint32 = self.optional_uint32;
        if let ::std::option::Option::Some(optional_uint32) = optional_uint32 {
            output.write_raw_tag_bytes(&[24])?;
            output.write_uint32(optional_uint32)?;
        }
        let optional_uint64 = self.optional_uint64;
        if let ::std::option::Option::Some(optional_uint64) = optional_uint64 {
            output.write_raw_tag_bytes(&[32])?;
            output.write_uint64(optional_uint64)?;
        }
        let optional_sint32 = self.optional_sint32;
        if let ::std::option::Option::Some(optional_sint32) = optional_sint32 {
            output.write_raw_tag_bytes(&[40])?;
            output.write_sint32(optional_sint32)?;
        }
        let optional_sint64 = self.optional_sint64;
        if let ::std::option::Option::Some(optional_sint64) = optional_sint64 {
            output.write_raw_tag_bytes(&[48])?;
            output.write_sint64(optional_sint64)?;
        }
        let optional_fixed32 = self.optional_fixed32;
        if let ::std::option::Option::Some(optional_fixed32) = optional_fixed32 {
            output.write_raw_tag_bytes(&[61])?;
            output.write_fixed32(optional_fixed32)?;
        }
        let optional_fixed64 = self.optional_fixed64;
        if let ::std::option::Option::Some(optional_fixed64) = optional_fixed64 {
            output.write_raw_tag_bytes(&[65])?;
            output.write_fixed64(optional_fixed64)?;
        }
        let optional_sfixed32 = self.optional_sfixed32;
        if let ::std::option::Option::Some(optional_sfixed32) = optional_sfixed32 {
            output.write_raw_tag_bytes(&[77])?;
            output.write_sfixed32(optional_sfixed32)?;
        }
        let optional_sfixed64 = self.optional_sfixed64;
        if let ::std::option::Option::Some(optional_sfixed64) = optional_sfixed64 {
            output.write_raw_tag_bytes(&[81])?;
            output.write_sfixed64(optional_sfixed64)?;
        }
        let optional_float = self.optional_float;
        if let ::std::option::Option::Some(optional_float) = optional_float {
            output.write_raw_tag_bytes(&[93])?;
            output.write_float(optional_float)?;
        }
        let optional_double = self.optional_double;
        if let ::std::option::Option::Some(optional_double) = optional_double {
            output.write_raw_tag_bytes(&[97])?;
            output.write_double(optional_double)?;
        }
        let optional_bool = self.optional_bool;
        if let ::std::option::Option::Some(optional_bool) = optional_bool {
            output.write_raw_tag_bytes(&[104])?;
            output.write_bool(optional_bool)?;
        }
        let optional_string = &self.optional_string;
        if let ::std::option::Option::Some(optional_string) = optional_string {
            output.write_raw_tag_bytes(&[114])?;
            output.write_string(optional_string)?;
        }
        let optional_bytes = &self.optional_bytes;
        if let ::std::option::Option::Some(optional_bytes) = optional_bytes {
            output.write_raw_tag_bytes(&[122])?;
            output.write_bytes(optional_bytes)?;
        }
        let optionalgroup = &self.optionalgroup;
        if let ::std::option::Option::Some(optionalgroup) = optionalgroup {
            output.write_raw_tag_bytes(&[131, 1])?;
            output.write_group(&**optionalgroup)?;
            output.write_raw_tag_bytes(&[132, 1])?;
        }
        let optional_nested_message = &self.optional_nested_message;
        if let ::std::option::Option::Some(optional_nested_message) = optional_nested_message {
            output.write_raw_tag_bytes(&[146, 1])?;
            output.write_message(&**optional_nested_message)?;
        }
        let optional_foreign_message = &self.optional_foreign_message;
        if let ::std::option::Option::Some(optional_foreign_message) = optional_foreign_message {
            output.write_raw_tag_bytes(&[154, 1])?;
            output.write_message(&**optional_foreign_message)?;
        }
        let optional_import_message = &self.optional_import_message;
        if let ::std::option::Option::Some(optional_import_message) = optional_import_message {
            output.write_raw_tag_bytes(&[162, 1])?;
            output.write_message(&**optional_import_message)?;
        }
        let optional_nested_enum = self.optional_nested_enum;
        if let ::std::option::Option::Some(optional_nested_enum) = optional_nested_enum {
            output.write_raw_tag_bytes(&[168, 1])?;
            output.write_enum_value(optional_nested_enum)?;
        }
        let optional_foreign_enum = self.optional_foreign_enum;
        if let ::std::option::Option::Some(optional_foreign_enum) = optional_foreign_enum {
            output.write_raw_tag_bytes(&[176, 1])?;
            output.write_enum_value(optional_foreign_enum)?;
        }
        let optional_import_enum = self.optional_import_enum;
        if let ::std::option::Option::Some(optional_import_enum) = optional_import_enum {
            output.write_raw_tag_bytes(&[184, 1])?;
            output.write_enum_value(optional_import_enum)?;
        }
        let optional_string_piece = &self.optional_string_piece;
        if let ::std::option::Option::Some(optional_string_piece) = optional_string_piece {
            output.write_raw_tag_bytes(&[194, 1])?;
            output.write_string(optional_string_piece)?;
        }
        let optional_cord = &self.optional_cord;
        if let ::std::option::Option::Some(optional_cord) = optional_cord {
            output.write_raw_tag_bytes(&[202, 1])?;
            output.write_string(optional_cord)?;
        }
        let optional_public_import_message = &self.optional_public_import_message;
        if let ::std::option::Option::Some(optional_public_import_message) = optional_public_import_message {
            output.write_raw_tag_bytes(&[210, 1])?;
            output.write_message(&**optional_public_import_message)?;
        }
        let optional_lazy_message = &self.optional_lazy_message;
        if let ::std::option::Option::Some(optional_lazy_message) = optional_lazy_message {
            output.write_raw_tag_bytes(&[218, 1])?;
            output.write_message(&**optional_lazy_message)?;
        }
        self.repeated_int32.write_to(output, &TEST_ALL_TYPES_REPEATED_INT32_CODEC)?;
        self.repeated_int64.write_to(output, &TEST_ALL_TYPES_REPEATED_INT64_CODEC)?;
        self.repeated_uint32.write_to(output, &TEST_ALL_TYPES_REPEATED_UINT32_CODEC)?;
        self.repeated_uint64.write_to(output, &TEST_ALL_TYPES_REPEATED_UINT64_CODEC)?;
        self.repeated_sint32.write_to(output, &TEST_ALL_TYPES_REPEATED_SINT32_CODEC)?;
        self.repeated_sint64.write_to(output, &TEST_ALL_TYPES_REPEATED_SINT64_CODEC)?;
        self.repeated_fixed32.write_to(output, &TEST_ALL_TYPES_REPEATED_FIXED32_CODEC)?;
        self.repeated_fixed64.write_to(output, &TEST_ALL_TYPES_REPEATED_FIXED64_CODEC)?;
        self.repeated_sfixed32.write_to(output, &TEST_ALL_TYPES_REPEATED_SFIXED32_CODEC)?;
        self.repeated_sfixed64.write_to(output, &TEST_ALL_TYPES_REPEATED_SFIXED64_CODEC)?;
        self.repeated_float.write_to(output, &TEST_ALL_TYPES_REPEATED_FLOAT_CODEC)?;
        self.repeated_double.write_to(output, &TEST_ALL_TYPES_REPEATED_DOUBLE_CODEC)?;
        self.repeated_bool.write_to(output, &TEST_ALL_TYPES_REPEATED_BOOL_CODEC)?;
        self.repeated_string.write_to(output, &TEST_ALL_TYPES_REPEATED_STRING_CODEC)?;
        self.repeated_bytes.write_to(output, &TEST_ALL_TYPES_REPEATED_BYTES_CODEC)?;
        self.repeatedgroup.write_to(output, &TEST_ALL_TYPES_REPEATEDGROUP_CODEC)?;
        self.repeated_nested_message.write_to(output, &TEST_ALL_TYPES_REPEATED_NESTED_MESSAGE_CODEC)?;
        self.repeated_foreign_message.write_to(output, &TEST_ALL_TYPES_REPEATED_FOREIGN_MESSAGE_CODEC)?;
        self.repeated_import_message.write_to(output, &TEST_ALL_TYPES_REPEATED_IMPORT_MESSAGE_CODEC)?;
        self.repeated_nested_enum.write_to(output, &TEST_ALL_TYPES_REPEATED_NESTED_ENUM_CODEC)?;
        self.repeated_foreign_enum.write_to(output, &TEST_ALL_TYPES_REPEATED_FOREIGN_ENUM_CODEC)?;
        self.repeated_import_enum.write_to(output, &TEST_ALL_TYPES_REPEATED_IMPORT_ENUM_CODEC)?;
        self.repeated_string_piece.write_to(output, &TEST_ALL_TYPES_REPEATED_STRING_PIECE_CODEC)?;
        self.repeated_cord.write_to(output, &TEST_ALL_TYPES_REPEATED_CORD_CODEC)?;
        self.repeated_lazy_message.write_to(output, &TEST_ALL_TYPES_REPEATED_LAZY_MESSAGE_CODEC)?;
        let default_int32 = self.default_int32;
        if let ::std::option::Option::Some(default_int32) = default_int32 {
            output.write_raw_tag_bytes(&[232, 3])?;
            output.write_int32(default_int32)?;
        }
        let default_int64 = self.default_int64;
        if let ::std::option::Option::Some(default_int64) = default_int64 {
            output.write_raw_tag_bytes(&[240, 3])?;
            output.write_int64(default_int64)?;
        }
        let default_uint32 = self.default_uint32;
        if let ::std::option::Option::Some(default_uint32) = default_uint32 {
            output.write_raw_tag_bytes(&[248, 3])?;
            output.write_uint32(default_uint32)?;
        }
        let default_uint64 = self.default_uint64;
        if let ::std::option::Option::Some(default_uint64) = default_uint64 {
            output.write_raw_tag_bytes(&[128, 4])?;
            output.write_uint64(default_uint64)?;
        }
        let default_sint32 = self.default_sint32;
        if let ::std::option::Option::Some(default_sint32) = default_sint32 {
            output.write_raw_tag_bytes(&[136, 4])?;
            output.write_sint32(default_sint32)?;
        }
        let default_sint64 = self.default_sint64;
        if let ::std::option::Option::Some(default_sint64) = default_sint64 {
            output.write_raw_tag_bytes(&[144, 4])?;
            output.write_sint64(default_sint64)?;
        }
        let default_fixed32 = self.default_fixed32;
        if let ::std::option::Option::Some(default_fixed32) = default_fixed32 {
            output.write_raw_tag_bytes(&[157, 4])?;
            output.write_fixed32(default_fixed32)?;
        }
        let default_fixed64 = self.default_fixed64;
        if let ::std::option::Option::Some(default_fixed64) = default_fixed64 {
            output.write_raw_tag_bytes(&[161, 4])?;
            output.write_fixed64(default_fixed64)?;
        }
        let default_sfixed32 = self.default_sfixed32;
        if let ::std::option::Option::Some(default_sfixed32) = default_sfixed32 {
            output.write_raw_tag_bytes(&[173, 4])?;
            output.write_sfixed32(default_sfixed32)?;
        }
        let default_sfixed64 = self.default_sfixed64;
        if let ::std::option::Option::Some(default_sfixed64) = default_sfixed64 {
            output.write_raw_tag_bytes(&[177, 4])?;
            output.write_sfixed64(default_sfixed64)?;
        }
        let default_float = self.default_float;
        if let ::std::option::Option::Some(default_float) = default_float {
            output.write_raw_tag_bytes(&[189, 4])?;
            output.write_float(default_float)?;
        }
        let default_double = self.default_double;
        if let ::std::option::Option::Some(default_double) = default_double {
            output.write_raw_tag_bytes(&[193, 4])?;
            output.write_double(default_double)?;
        }
        let default_bool = self.default_bool;
        if let ::std::option::Option::Some(default_bool) = default_bool {
            output.write_raw_tag_bytes(&[200, 4])?;
            output.write_bool(default_bool)?;
        }
        let default_string = &self.default_string;
        if let ::std::option::Option::Some(default_string) = default_string {
            output.write_raw_tag_bytes(&[210, 4])?;
            output.write_string(default_string)?;
        }
        let default_bytes = &self.default_bytes;
        if let ::std::option::Option::Some(default_bytes) = default_bytes {
            output.write_raw_tag_bytes(&[218, 4])?;
            output.write_bytes(default_bytes)?;
        }
        let default_nested_enum = self.default_nested_enum;
        if let ::std::option::Option::Some(default_nested_enum) = default_nested_enum {
            output.write_raw_tag_bytes(&[136, 5])?;
            output.write_enum_value(default_nested_enum)?;
        }
        let default_foreign_enum = self.default_foreign_enum;
        if let ::std::option::Option::Some(default_foreign_enum) = default_foreign_enum {
            output.write_raw_tag_bytes(&[144, 5])?;
            output.write_enum_value(default_foreign_enum)?;
        }
        let default_import_enum = self.default_import_enum;
        if let ::std::option::Option::Some(default_import_enum) = default_import_enum {
            output.write_raw_tag_bytes(&[152, 5])?;
            output.write_enum_value(default_import_enum)?;
        }
        let default_string_piece = &self.default_string_piece;
        if let ::std::option::Option::Some(default_string_piece) = default_string_piece {
            output.write_raw_tag_bytes(&[162, 5])?;
            output.write_string(default_string_piece)?;
        }
        let default_cord = &self.default_cord;
        if let ::std::option::Option::Some(default_cord) = default_cord {
            output.write_raw_tag_bytes(&[170, 5])?;
            output.write_string(default_cord)?;
        }
        if let self::test_all_types::OneofField::OneofUint32(oneof_field) = self.oneof_field {
            output.write_raw_tag_bytes(&[248, 6])?;
            output.write_uint32(oneof_field)?;
        }
        if let self::test_all_types::OneofField::OneofNestedMessage(oneof_field) = &self.oneof_field {
            output.write_raw_tag_bytes(&[130, 7])?;
            output.write_message(&**oneof_field)?;
        }
        if let self::test_all_types::OneofField::OneofString(oneof_field) = &self.oneof_field {
            output.write_raw_tag_bytes(&[138, 7])?;
            output.write_string(oneof_field)?;
        }
        if let self::test_all_types::OneofField::OneofBytes(oneof_field) = &self.oneof_field {
            output.write_raw_tag_bytes(&[146, 7])?;
            output.write_bytes(oneof_field)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        if let Some(optionalgroup) = &self.optionalgroup {
            if !::protrust::CodedMessage::is_initialized(&**optionalgroup) {
                return false;
            }
        }
        if let Some(optional_nested_message) = &self.optional_nested_message {
            if !::protrust::CodedMessage::is_initialized(&**optional_nested_message) {
                return false;
            }
        }
        if let Some(optional_foreign_message) = &self.optional_foreign_message {
            if !::protrust::CodedMessage::is_initialized(&**optional_foreign_message) {
                return false;
            }
        }
        if let Some(optional_import_message) = &self.optional_import_message {
            if !::protrust::CodedMessage::is_initialized(&**optional_import_message) {
                return false;
            }
        }
        if let Some(optional_public_import_message) = &self.optional_public_import_message {
            if !::protrust::CodedMessage::is_initialized(&**optional_public_import_message) {
                return false;
            }
        }
        if let Some(optional_lazy_message) = &self.optional_lazy_message {
            if !::protrust::CodedMessage::is_initialized(&**optional_lazy_message) {
                return false;
            }
        }
        if !self.repeated_nested_message.is_initialized() {
            return false;
        }
        if !self.repeated_foreign_message.is_initialized() {
            return false;
        }
        if !self.repeated_import_message.is_initialized() {
            return false;
        }
        if !self.repeated_lazy_message.is_initialized() {
            return false;
        }
        if let self::test_all_types::OneofField::OneofNestedMessage(oneof_field) = &self.oneof_field {
            if !::protrust::CodedMessage::is_initialized(&**oneof_field) {
                return false;
            }
        }
        true
    }
}
impl ::protrust::LiteMessage for self::TestAllTypes {
    fn new() -> Self {
        Self {
            optional_int32: ::std::option::Option::None,
            optional_int64: ::std::option::Option::None,
            optional_uint32: ::std::option::Option::None,
            optional_uint64: ::std::option::Option::None,
            optional_sint32: ::std::option::Option::None,
            optional_sint64: ::std::option::Option::None,
            optional_fixed32: ::std::option::Option::None,
            optional_fixed64: ::std::option::Option::None,
            optional_sfixed32: ::std::option::Option::None,
            optional_sfixed64: ::std::option::Option::None,
            optional_float: ::std::option::Option::None,
            optional_double: ::std::option::Option::None,
            optional_bool: ::std::option::Option::None,
            optional_string: ::std::option::Option::None,
            optional_bytes: ::std::option::Option::None,
            optionalgroup: ::std::option::Option::None,
            optional_nested_message: ::std::option::Option::None,
            optional_foreign_message: ::std::option::Option::None,
            optional_import_message: ::std::option::Option::None,
            optional_nested_enum: ::std::option::Option::None,
            optional_foreign_enum: ::std::option::Option::None,
            optional_import_enum: ::std::option::Option::None,
            optional_string_piece: ::std::option::Option::None,
            optional_cord: ::std::option::Option::None,
            optional_public_import_message: ::std::option::Option::None,
            optional_lazy_message: ::std::option::Option::None,
            repeated_int32: ::protrust::collections::RepeatedField::new(),
            repeated_int64: ::protrust::collections::RepeatedField::new(),
            repeated_uint32: ::protrust::collections::RepeatedField::new(),
            repeated_uint64: ::protrust::collections::RepeatedField::new(),
            repeated_sint32: ::protrust::collections::RepeatedField::new(),
            repeated_sint64: ::protrust::collections::RepeatedField::new(),
            repeated_fixed32: ::protrust::collections::RepeatedField::new(),
            repeated_fixed64: ::protrust::collections::RepeatedField::new(),
            repeated_sfixed32: ::protrust::collections::RepeatedField::new(),
            repeated_sfixed64: ::protrust::collections::RepeatedField::new(),
            repeated_float: ::protrust::collections::RepeatedField::new(),
            repeated_double: ::protrust::collections::RepeatedField::new(),
            repeated_bool: ::protrust::collections::RepeatedField::new(),
            repeated_string: ::protrust::collections::RepeatedField::new(),
            repeated_bytes: ::protrust::collections::RepeatedField::new(),
            repeatedgroup: ::protrust::collections::RepeatedField::new(),
            repeated_nested_message: ::protrust::collections::RepeatedField::new(),
            repeated_foreign_message: ::protrust::collections::RepeatedField::new(),
            repeated_import_message: ::protrust::collections::RepeatedField::new(),
            repeated_nested_enum: ::protrust::collections::RepeatedField::new(),
            repeated_foreign_enum: ::protrust::collections::RepeatedField::new(),
            repeated_import_enum: ::protrust::collections::RepeatedField::new(),
            repeated_string_piece: ::protrust::collections::RepeatedField::new(),
            repeated_cord: ::protrust::collections::RepeatedField::new(),
            repeated_lazy_message: ::protrust::collections::RepeatedField::new(),
            default_int32: ::std::option::Option::None,
            default_int64: ::std::option::Option::None,
            default_uint32: ::std::option::Option::None,
            default_uint64: ::std::option::Option::None,
            default_sint32: ::std::option::Option::None,
            default_sint64: ::std::option::Option::None,
            default_fixed32: ::std::option::Option::None,
            default_fixed64: ::std::option::Option::None,
            default_sfixed32: ::std::option::Option::None,
            default_sfixed64: ::std::option::Option::None,
            default_float: ::std::option::Option::None,
            default_double: ::std::option::Option::None,
            default_bool: ::std::option::Option::None,
            default_string: ::std::option::Option::None,
            default_bytes: ::std::option::Option::None,
            default_nested_enum: ::std::option::Option::None,
            default_foreign_enum: ::std::option::Option::None,
            default_import_enum: ::std::option::Option::None,
            default_string_piece: ::std::option::Option::None,
            default_cord: ::std::option::Option::None,
            oneof_field: self::test_all_types::OneofField::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.optional_int32 = other.optional_int32;
        self.optional_int64 = other.optional_int64;
        self.optional_uint32 = other.optional_uint32;
        self.optional_uint64 = other.optional_uint64;
        self.optional_sint32 = other.optional_sint32;
        self.optional_sint64 = other.optional_sint64;
        self.optional_fixed32 = other.optional_fixed32;
        self.optional_fixed64 = other.optional_fixed64;
        self.optional_sfixed32 = other.optional_sfixed32;
        self.optional_sfixed64 = other.optional_sfixed64;
        self.optional_float = other.optional_float;
        self.optional_double = other.optional_double;
        self.optional_bool = other.optional_bool;
        self.optional_string = other.optional_string.clone();
        self.optional_bytes = other.optional_bytes.clone();
        if let ::std::option::Option::Some(optionalgroup) = &other.optionalgroup {
            self.optionalgroup.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(optionalgroup);
        }
        if let ::std::option::Option::Some(optional_nested_message) = &other.optional_nested_message {
            self.optional_nested_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(optional_nested_message);
        }
        if let ::std::option::Option::Some(optional_foreign_message) = &other.optional_foreign_message {
            self.optional_foreign_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(optional_foreign_message);
        }
        if let ::std::option::Option::Some(optional_import_message) = &other.optional_import_message {
            self.optional_import_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(optional_import_message);
        }
        self.optional_nested_enum = other.optional_nested_enum;
        self.optional_foreign_enum = other.optional_foreign_enum;
        self.optional_import_enum = other.optional_import_enum;
        self.optional_string_piece = other.optional_string_piece.clone();
        self.optional_cord = other.optional_cord.clone();
        if let ::std::option::Option::Some(optional_public_import_message) = &other.optional_public_import_message {
            self.optional_public_import_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(optional_public_import_message);
        }
        if let ::std::option::Option::Some(optional_lazy_message) = &other.optional_lazy_message {
            self.optional_lazy_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(optional_lazy_message);
        }
        self.repeated_int32.merge(&other.repeated_int32);
        self.repeated_int64.merge(&other.repeated_int64);
        self.repeated_uint32.merge(&other.repeated_uint32);
        self.repeated_uint64.merge(&other.repeated_uint64);
        self.repeated_sint32.merge(&other.repeated_sint32);
        self.repeated_sint64.merge(&other.repeated_sint64);
        self.repeated_fixed32.merge(&other.repeated_fixed32);
        self.repeated_fixed64.merge(&other.repeated_fixed64);
        self.repeated_sfixed32.merge(&other.repeated_sfixed32);
        self.repeated_sfixed64.merge(&other.repeated_sfixed64);
        self.repeated_float.merge(&other.repeated_float);
        self.repeated_double.merge(&other.repeated_double);
        self.repeated_bool.merge(&other.repeated_bool);
        self.repeated_string.merge(&other.repeated_string);
        self.repeated_bytes.merge(&other.repeated_bytes);
        self.repeatedgroup.merge(&other.repeatedgroup);
        self.repeated_nested_message.merge(&other.repeated_nested_message);
        self.repeated_foreign_message.merge(&other.repeated_foreign_message);
        self.repeated_import_message.merge(&other.repeated_import_message);
        self.repeated_nested_enum.merge(&other.repeated_nested_enum);
        self.repeated_foreign_enum.merge(&other.repeated_foreign_enum);
        self.repeated_import_enum.merge(&other.repeated_import_enum);
        self.repeated_string_piece.merge(&other.repeated_string_piece);
        self.repeated_cord.merge(&other.repeated_cord);
        self.repeated_lazy_message.merge(&other.repeated_lazy_message);
        self.default_int32 = other.default_int32;
        self.default_int64 = other.default_int64;
        self.default_uint32 = other.default_uint32;
        self.default_uint64 = other.default_uint64;
        self.default_sint32 = other.default_sint32;
        self.default_sint64 = other.default_sint64;
        self.default_fixed32 = other.default_fixed32;
        self.default_fixed64 = other.default_fixed64;
        self.default_sfixed32 = other.default_sfixed32;
        self.default_sfixed64 = other.default_sfixed64;
        self.default_float = other.default_float;
        self.default_double = other.default_double;
        self.default_bool = other.default_bool;
        self.default_string = other.default_string.clone();
        self.default_bytes = other.default_bytes.clone();
        self.default_nested_enum = other.default_nested_enum;
        self.default_foreign_enum = other.default_foreign_enum;
        self.default_import_enum = other.default_import_enum;
        self.default_string_piece = other.default_string_piece.clone();
        self.default_cord = other.default_cord.clone();
        if let self::test_all_types::OneofField::OneofUint32(oneof_field) = other.oneof_field {
            self.oneof_field = self::test_all_types::OneofField::OneofUint32(oneof_field);
        }
        if let self::test_all_types::OneofField::OneofNestedMessage(oneof_field) = &other.oneof_field {
            if let self::test_all_types::OneofField::OneofNestedMessage(existing) = &mut self.oneof_field {
                existing.merge(oneof_field);
            } else {
                self.oneof_field = self::test_all_types::OneofField::OneofNestedMessage(oneof_field.clone());
            }
        }
        if let self::test_all_types::OneofField::OneofString(oneof_field) = &other.oneof_field {
            self.oneof_field = self::test_all_types::OneofField::OneofString(oneof_field.clone());
        }
        if let self::test_all_types::OneofField::OneofBytes(oneof_field) = &other.oneof_field {
            self.oneof_field = self::test_all_types::OneofField::OneofBytes(oneof_field.clone());
        }
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestAllTypes {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[0]
    }
}
impl self::TestAllTypes {
    /// Gets the field number of the [`optional_int32`] field
    ///
    /// [`optional_int32`]: #method.optional_int32
    pub const OPTIONAL_INT32_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`optional_int32`] field
    ///
    /// [`optional_int32`]: #method.optional_int32
    pub const OPTIONAL_INT32_DEFAULT_VALUE: i32 = 0;
    /// Singular
    pub fn optional_int32(&self) -> i32 {
        self.optional_int32.unwrap_or(Self::OPTIONAL_INT32_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`optional_int32`] field
    ///
    /// [`optional_int32`]: #method.optional_int32
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn optional_int32_option(&self) -> ::std::option::Option<i32> {
        self.optional_int32
    }
    /// Returns a bool indicating the presence of the [`optional_int32`] field
    ///
    /// [`optional_int32`]: #method.optional_int32
    pub fn has_optional_int32(&self) -> bool {
        self.optional_int32.is_some()
    }
    /// Sets the value of the [`optional_int32`] field
    ///
    /// [`optional_int32`]: #method.optional_int32
    pub fn set_optional_int32(&mut self, value: i32) {
        self.optional_int32 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`optional_int32`] field
    ///
    /// [`optional_int32`]: #method.optional_int32
    pub fn clear_optional_int32(&mut self) {
        self.optional_int32 = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_int64`] field
    ///
    /// [`optional_int64`]: #method.optional_int64
    pub const OPTIONAL_INT64_FIELD_NUMBER: i32 = 2;
    /// A constant value representing the default value of the [`optional_int64`] field
    ///
    /// [`optional_int64`]: #method.optional_int64
    pub const OPTIONAL_INT64_DEFAULT_VALUE: i64 = 0;
    pub fn optional_int64(&self) -> i64 {
        self.optional_int64.unwrap_or(Self::OPTIONAL_INT64_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`optional_int64`] field
    ///
    /// [`optional_int64`]: #method.optional_int64
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn optional_int64_option(&self) -> ::std::option::Option<i64> {
        self.optional_int64
    }
    /// Returns a bool indicating the presence of the [`optional_int64`] field
    ///
    /// [`optional_int64`]: #method.optional_int64
    pub fn has_optional_int64(&self) -> bool {
        self.optional_int64.is_some()
    }
    /// Sets the value of the [`optional_int64`] field
    ///
    /// [`optional_int64`]: #method.optional_int64
    pub fn set_optional_int64(&mut self, value: i64) {
        self.optional_int64 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`optional_int64`] field
    ///
    /// [`optional_int64`]: #method.optional_int64
    pub fn clear_optional_int64(&mut self) {
        self.optional_int64 = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_uint32`] field
    ///
    /// [`optional_uint32`]: #method.optional_uint32
    pub const OPTIONAL_UINT32_FIELD_NUMBER: i32 = 3;
    /// A constant value representing the default value of the [`optional_uint32`] field
    ///
    /// [`optional_uint32`]: #method.optional_uint32
    pub const OPTIONAL_UINT32_DEFAULT_VALUE: u32 = 0;
    pub fn optional_uint32(&self) -> u32 {
        self.optional_uint32.unwrap_or(Self::OPTIONAL_UINT32_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`optional_uint32`] field
    ///
    /// [`optional_uint32`]: #method.optional_uint32
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn optional_uint32_option(&self) -> ::std::option::Option<u32> {
        self.optional_uint32
    }
    /// Returns a bool indicating the presence of the [`optional_uint32`] field
    ///
    /// [`optional_uint32`]: #method.optional_uint32
    pub fn has_optional_uint32(&self) -> bool {
        self.optional_uint32.is_some()
    }
    /// Sets the value of the [`optional_uint32`] field
    ///
    /// [`optional_uint32`]: #method.optional_uint32
    pub fn set_optional_uint32(&mut self, value: u32) {
        self.optional_uint32 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`optional_uint32`] field
    ///
    /// [`optional_uint32`]: #method.optional_uint32
    pub fn clear_optional_uint32(&mut self) {
        self.optional_uint32 = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_uint64`] field
    ///
    /// [`optional_uint64`]: #method.optional_uint64
    pub const OPTIONAL_UINT64_FIELD_NUMBER: i32 = 4;
    /// A constant value representing the default value of the [`optional_uint64`] field
    ///
    /// [`optional_uint64`]: #method.optional_uint64
    pub const OPTIONAL_UINT64_DEFAULT_VALUE: u64 = 0;
    pub fn optional_uint64(&self) -> u64 {
        self.optional_uint64.unwrap_or(Self::OPTIONAL_UINT64_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`optional_uint64`] field
    ///
    /// [`optional_uint64`]: #method.optional_uint64
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn optional_uint64_option(&self) -> ::std::option::Option<u64> {
        self.optional_uint64
    }
    /// Returns a bool indicating the presence of the [`optional_uint64`] field
    ///
    /// [`optional_uint64`]: #method.optional_uint64
    pub fn has_optional_uint64(&self) -> bool {
        self.optional_uint64.is_some()
    }
    /// Sets the value of the [`optional_uint64`] field
    ///
    /// [`optional_uint64`]: #method.optional_uint64
    pub fn set_optional_uint64(&mut self, value: u64) {
        self.optional_uint64 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`optional_uint64`] field
    ///
    /// [`optional_uint64`]: #method.optional_uint64
    pub fn clear_optional_uint64(&mut self) {
        self.optional_uint64 = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_sint32`] field
    ///
    /// [`optional_sint32`]: #method.optional_sint32
    pub const OPTIONAL_SINT32_FIELD_NUMBER: i32 = 5;
    /// A constant value representing the default value of the [`optional_sint32`] field
    ///
    /// [`optional_sint32`]: #method.optional_sint32
    pub const OPTIONAL_SINT32_DEFAULT_VALUE: i32 = 0;
    pub fn optional_sint32(&self) -> i32 {
        self.optional_sint32.unwrap_or(Self::OPTIONAL_SINT32_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`optional_sint32`] field
    ///
    /// [`optional_sint32`]: #method.optional_sint32
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn optional_sint32_option(&self) -> ::std::option::Option<i32> {
        self.optional_sint32
    }
    /// Returns a bool indicating the presence of the [`optional_sint32`] field
    ///
    /// [`optional_sint32`]: #method.optional_sint32
    pub fn has_optional_sint32(&self) -> bool {
        self.optional_sint32.is_some()
    }
    /// Sets the value of the [`optional_sint32`] field
    ///
    /// [`optional_sint32`]: #method.optional_sint32
    pub fn set_optional_sint32(&mut self, value: i32) {
        self.optional_sint32 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`optional_sint32`] field
    ///
    /// [`optional_sint32`]: #method.optional_sint32
    pub fn clear_optional_sint32(&mut self) {
        self.optional_sint32 = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_sint64`] field
    ///
    /// [`optional_sint64`]: #method.optional_sint64
    pub const OPTIONAL_SINT64_FIELD_NUMBER: i32 = 6;
    /// A constant value representing the default value of the [`optional_sint64`] field
    ///
    /// [`optional_sint64`]: #method.optional_sint64
    pub const OPTIONAL_SINT64_DEFAULT_VALUE: i64 = 0;
    pub fn optional_sint64(&self) -> i64 {
        self.optional_sint64.unwrap_or(Self::OPTIONAL_SINT64_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`optional_sint64`] field
    ///
    /// [`optional_sint64`]: #method.optional_sint64
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn optional_sint64_option(&self) -> ::std::option::Option<i64> {
        self.optional_sint64
    }
    /// Returns a bool indicating the presence of the [`optional_sint64`] field
    ///
    /// [`optional_sint64`]: #method.optional_sint64
    pub fn has_optional_sint64(&self) -> bool {
        self.optional_sint64.is_some()
    }
    /// Sets the value of the [`optional_sint64`] field
    ///
    /// [`optional_sint64`]: #method.optional_sint64
    pub fn set_optional_sint64(&mut self, value: i64) {
        self.optional_sint64 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`optional_sint64`] field
    ///
    /// [`optional_sint64`]: #method.optional_sint64
    pub fn clear_optional_sint64(&mut self) {
        self.optional_sint64 = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_fixed32`] field
    ///
    /// [`optional_fixed32`]: #method.optional_fixed32
    pub const OPTIONAL_FIXED32_FIELD_NUMBER: i32 = 7;
    /// A constant value representing the default value of the [`optional_fixed32`] field
    ///
    /// [`optional_fixed32`]: #method.optional_fixed32
    pub const OPTIONAL_FIXED32_DEFAULT_VALUE: u32 = 0;
    pub fn optional_fixed32(&self) -> u32 {
        self.optional_fixed32.unwrap_or(Self::OPTIONAL_FIXED32_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`optional_fixed32`] field
    ///
    /// [`optional_fixed32`]: #method.optional_fixed32
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn optional_fixed32_option(&self) -> ::std::option::Option<u32> {
        self.optional_fixed32
    }
    /// Returns a bool indicating the presence of the [`optional_fixed32`] field
    ///
    /// [`optional_fixed32`]: #method.optional_fixed32
    pub fn has_optional_fixed32(&self) -> bool {
        self.optional_fixed32.is_some()
    }
    /// Sets the value of the [`optional_fixed32`] field
    ///
    /// [`optional_fixed32`]: #method.optional_fixed32
    pub fn set_optional_fixed32(&mut self, value: u32) {
        self.optional_fixed32 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`optional_fixed32`] field
    ///
    /// [`optional_fixed32`]: #method.optional_fixed32
    pub fn clear_optional_fixed32(&mut self) {
        self.optional_fixed32 = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_fixed64`] field
    ///
    /// [`optional_fixed64`]: #method.optional_fixed64
    pub const OPTIONAL_FIXED64_FIELD_NUMBER: i32 = 8;
    /// A constant value representing the default value of the [`optional_fixed64`] field
    ///
    /// [`optional_fixed64`]: #method.optional_fixed64
    pub const OPTIONAL_FIXED64_DEFAULT_VALUE: u64 = 0;
    pub fn optional_fixed64(&self) -> u64 {
        self.optional_fixed64.unwrap_or(Self::OPTIONAL_FIXED64_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`optional_fixed64`] field
    ///
    /// [`optional_fixed64`]: #method.optional_fixed64
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn optional_fixed64_option(&self) -> ::std::option::Option<u64> {
        self.optional_fixed64
    }
    /// Returns a bool indicating the presence of the [`optional_fixed64`] field
    ///
    /// [`optional_fixed64`]: #method.optional_fixed64
    pub fn has_optional_fixed64(&self) -> bool {
        self.optional_fixed64.is_some()
    }
    /// Sets the value of the [`optional_fixed64`] field
    ///
    /// [`optional_fixed64`]: #method.optional_fixed64
    pub fn set_optional_fixed64(&mut self, value: u64) {
        self.optional_fixed64 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`optional_fixed64`] field
    ///
    /// [`optional_fixed64`]: #method.optional_fixed64
    pub fn clear_optional_fixed64(&mut self) {
        self.optional_fixed64 = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_sfixed32`] field
    ///
    /// [`optional_sfixed32`]: #method.optional_sfixed32
    pub const OPTIONAL_SFIXED32_FIELD_NUMBER: i32 = 9;
    /// A constant value representing the default value of the [`optional_sfixed32`] field
    ///
    /// [`optional_sfixed32`]: #method.optional_sfixed32
    pub const OPTIONAL_SFIXED32_DEFAULT_VALUE: i32 = 0;
    pub fn optional_sfixed32(&self) -> i32 {
        self.optional_sfixed32.unwrap_or(Self::OPTIONAL_SFIXED32_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`optional_sfixed32`] field
    ///
    /// [`optional_sfixed32`]: #method.optional_sfixed32
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn optional_sfixed32_option(&self) -> ::std::option::Option<i32> {
        self.optional_sfixed32
    }
    /// Returns a bool indicating the presence of the [`optional_sfixed32`] field
    ///
    /// [`optional_sfixed32`]: #method.optional_sfixed32
    pub fn has_optional_sfixed32(&self) -> bool {
        self.optional_sfixed32.is_some()
    }
    /// Sets the value of the [`optional_sfixed32`] field
    ///
    /// [`optional_sfixed32`]: #method.optional_sfixed32
    pub fn set_optional_sfixed32(&mut self, value: i32) {
        self.optional_sfixed32 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`optional_sfixed32`] field
    ///
    /// [`optional_sfixed32`]: #method.optional_sfixed32
    pub fn clear_optional_sfixed32(&mut self) {
        self.optional_sfixed32 = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_sfixed64`] field
    ///
    /// [`optional_sfixed64`]: #method.optional_sfixed64
    pub const OPTIONAL_SFIXED64_FIELD_NUMBER: i32 = 10;
    /// A constant value representing the default value of the [`optional_sfixed64`] field
    ///
    /// [`optional_sfixed64`]: #method.optional_sfixed64
    pub const OPTIONAL_SFIXED64_DEFAULT_VALUE: i64 = 0;
    pub fn optional_sfixed64(&self) -> i64 {
        self.optional_sfixed64.unwrap_or(Self::OPTIONAL_SFIXED64_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`optional_sfixed64`] field
    ///
    /// [`optional_sfixed64`]: #method.optional_sfixed64
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn optional_sfixed64_option(&self) -> ::std::option::Option<i64> {
        self.optional_sfixed64
    }
    /// Returns a bool indicating the presence of the [`optional_sfixed64`] field
    ///
    /// [`optional_sfixed64`]: #method.optional_sfixed64
    pub fn has_optional_sfixed64(&self) -> bool {
        self.optional_sfixed64.is_some()
    }
    /// Sets the value of the [`optional_sfixed64`] field
    ///
    /// [`optional_sfixed64`]: #method.optional_sfixed64
    pub fn set_optional_sfixed64(&mut self, value: i64) {
        self.optional_sfixed64 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`optional_sfixed64`] field
    ///
    /// [`optional_sfixed64`]: #method.optional_sfixed64
    pub fn clear_optional_sfixed64(&mut self) {
        self.optional_sfixed64 = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_float`] field
    ///
    /// [`optional_float`]: #method.optional_float
    pub const OPTIONAL_FLOAT_FIELD_NUMBER: i32 = 11;
    /// A constant value representing the default value of the [`optional_float`] field
    ///
    /// [`optional_float`]: #method.optional_float
    pub const OPTIONAL_FLOAT_DEFAULT_VALUE: f32 = 0.0;
    pub fn optional_float(&self) -> f32 {
        self.optional_float.unwrap_or(Self::OPTIONAL_FLOAT_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`optional_float`] field
    ///
    /// [`optional_float`]: #method.optional_float
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn optional_float_option(&self) -> ::std::option::Option<f32> {
        self.optional_float
    }
    /// Returns a bool indicating the presence of the [`optional_float`] field
    ///
    /// [`optional_float`]: #method.optional_float
    pub fn has_optional_float(&self) -> bool {
        self.optional_float.is_some()
    }
    /// Sets the value of the [`optional_float`] field
    ///
    /// [`optional_float`]: #method.optional_float
    pub fn set_optional_float(&mut self, value: f32) {
        self.optional_float = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`optional_float`] field
    ///
    /// [`optional_float`]: #method.optional_float
    pub fn clear_optional_float(&mut self) {
        self.optional_float = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_double`] field
    ///
    /// [`optional_double`]: #method.optional_double
    pub const OPTIONAL_DOUBLE_FIELD_NUMBER: i32 = 12;
    /// A constant value representing the default value of the [`optional_double`] field
    ///
    /// [`optional_double`]: #method.optional_double
    pub const OPTIONAL_DOUBLE_DEFAULT_VALUE: f64 = 0.0;
    pub fn optional_double(&self) -> f64 {
        self.optional_double.unwrap_or(Self::OPTIONAL_DOUBLE_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`optional_double`] field
    ///
    /// [`optional_double`]: #method.optional_double
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn optional_double_option(&self) -> ::std::option::Option<f64> {
        self.optional_double
    }
    /// Returns a bool indicating the presence of the [`optional_double`] field
    ///
    /// [`optional_double`]: #method.optional_double
    pub fn has_optional_double(&self) -> bool {
        self.optional_double.is_some()
    }
    /// Sets the value of the [`optional_double`] field
    ///
    /// [`optional_double`]: #method.optional_double
    pub fn set_optional_double(&mut self, value: f64) {
        self.optional_double = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`optional_double`] field
    ///
    /// [`optional_double`]: #method.optional_double
    pub fn clear_optional_double(&mut self) {
        self.optional_double = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_bool`] field
    ///
    /// [`optional_bool`]: #method.optional_bool
    pub const OPTIONAL_BOOL_FIELD_NUMBER: i32 = 13;
    /// A constant value representing the default value of the [`optional_bool`] field
    ///
    /// [`optional_bool`]: #method.optional_bool
    pub const OPTIONAL_BOOL_DEFAULT_VALUE: bool = false;
    pub fn optional_bool(&self) -> bool {
        self.optional_bool.unwrap_or(Self::OPTIONAL_BOOL_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`optional_bool`] field
    ///
    /// [`optional_bool`]: #method.optional_bool
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn optional_bool_option(&self) -> ::std::option::Option<bool> {
        self.optional_bool
    }
    /// Returns a bool indicating the presence of the [`optional_bool`] field
    ///
    /// [`optional_bool`]: #method.optional_bool
    pub fn has_optional_bool(&self) -> bool {
        self.optional_bool.is_some()
    }
    /// Sets the value of the [`optional_bool`] field
    ///
    /// [`optional_bool`]: #method.optional_bool
    pub fn set_optional_bool(&mut self, value: bool) {
        self.optional_bool = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`optional_bool`] field
    ///
    /// [`optional_bool`]: #method.optional_bool
    pub fn clear_optional_bool(&mut self) {
        self.optional_bool = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_string`] field
    ///
    /// [`optional_string`]: #method.optional_string
    pub const OPTIONAL_STRING_FIELD_NUMBER: i32 = 14;
    /// A constant value representing the default value of the [`optional_string`] field
    ///
    /// [`optional_string`]: #method.optional_string
    pub const OPTIONAL_STRING_DEFAULT_VALUE: &'static str = "";
    pub fn optional_string(&self) -> &str {
        self.optional_string.as_ref().map(|v| &**v).unwrap_or(Self::OPTIONAL_STRING_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`optional_string`] field
    ///
    /// [`optional_string`]: #method.optional_string
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn optional_string_option(&self) -> ::std::option::Option<&::std::string::String> {
        self.optional_string.as_ref()
    }
    /// Returns a unique reference to the [`optional_string`] field
    ///
    /// [`optional_string`]: #method.optional_string
    pub fn optional_string_mut(&mut self) -> &mut ::std::string::String {
        self.optional_string.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`optional_string`] field
    ///
    /// [`optional_string`]: #method.optional_string
    pub fn has_optional_string(&self) -> bool {
        self.optional_string.is_some()
    }
    /// Sets the value of the [`optional_string`] field
    ///
    /// [`optional_string`]: #method.optional_string
    pub fn set_optional_string(&mut self, value: ::std::string::String) {
        self.optional_string = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`optional_string`] field, leaving it empty
    ///
    /// [`optional_string`]: #method.optional_string
    pub fn take_optional_string(&mut self) -> ::std::option::Option<::std::string::String> {
        self.optional_string.take()
    }
    /// Clears the value of the [`optional_string`] field
    ///
    /// [`optional_string`]: #method.optional_string
    pub fn clear_optional_string(&mut self) {
        self.optional_string = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_bytes`] field
    ///
    /// [`optional_bytes`]: #method.optional_bytes
    pub const OPTIONAL_BYTES_FIELD_NUMBER: i32 = 15;
    /// A constant value representing the default value of the [`optional_bytes`] field
    ///
    /// [`optional_bytes`]: #method.optional_bytes
    pub const OPTIONAL_BYTES_DEFAULT_VALUE: &'static [u8] = &[];
    pub fn optional_bytes(&self) -> &[u8] {
        self.optional_bytes.as_ref().map(|v| &**v).unwrap_or(Self::OPTIONAL_BYTES_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`optional_bytes`] field
    ///
    /// [`optional_bytes`]: #method.optional_bytes
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn optional_bytes_option(&self) -> ::std::option::Option<&::std::vec::Vec<u8>> {
        self.optional_bytes.as_ref()
    }
    /// Returns a unique reference to the [`optional_bytes`] field
    ///
    /// [`optional_bytes`]: #method.optional_bytes
    pub fn optional_bytes_mut(&mut self) -> &mut ::std::vec::Vec<u8> {
        self.optional_bytes.get_or_insert_with(::std::vec::Vec::new)
    }
    /// Returns a bool indicating the presence of the [`optional_bytes`] field
    ///
    /// [`optional_bytes`]: #method.optional_bytes
    pub fn has_optional_bytes(&self) -> bool {
        self.optional_bytes.is_some()
    }
    /// Sets the value of the [`optional_bytes`] field
    ///
    /// [`optional_bytes`]: #method.optional_bytes
    pub fn set_optional_bytes(&mut self, value: ::std::vec::Vec<u8>) {
        self.optional_bytes = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`optional_bytes`] field, leaving it empty
    ///
    /// [`optional_bytes`]: #method.optional_bytes
    pub fn take_optional_bytes(&mut self) -> ::std::option::Option<::std::vec::Vec<u8>> {
        self.optional_bytes.take()
    }
    /// Clears the value of the [`optional_bytes`] field
    ///
    /// [`optional_bytes`]: #method.optional_bytes
    pub fn clear_optional_bytes(&mut self) {
        self.optional_bytes = ::std::option::Option::None
    }
    /// Gets the field number of the [`optionalgroup`] field
    ///
    /// [`optionalgroup`]: #method.optionalgroup
    pub const OPTIONALGROUP_FIELD_NUMBER: i32 = 16;
    pub fn optionalgroup_option(&self) -> ::std::option::Option<&self::test_all_types::OptionalGroup> {
        self.optionalgroup.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`optionalgroup`] field
    ///
    /// [`optionalgroup`]: #method.optionalgroup
    pub fn optionalgroup_mut(&mut self) -> &mut self::test_all_types::OptionalGroup {
        self.optionalgroup.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`optionalgroup`] field
    ///
    /// [`optionalgroup`]: #method.optionalgroup
    pub fn has_optionalgroup(&self) -> bool {
        self.optionalgroup.is_some()
    }
    /// Sets the value of the [`optionalgroup`] field
    ///
    /// [`optionalgroup`]: #method.optionalgroup
    pub fn set_optionalgroup(&mut self, value: self::test_all_types::OptionalGroup) {
        self.optionalgroup = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`optionalgroup`] field, leaving it empty
    ///
    /// [`optionalgroup`]: #method.optionalgroup
    pub fn take_optionalgroup(&mut self) -> ::std::option::Option<self::test_all_types::OptionalGroup> {
        self.optionalgroup.take().map(|b| *b)
    }
    /// Clears the value of the [`optionalgroup`] field
    ///
    /// [`optionalgroup`]: #method.optionalgroup
    pub fn clear_optionalgroup(&mut self) {
        self.optionalgroup = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_nested_message`] field
    ///
    /// [`optional_nested_message`]: #method.optional_nested_message
    pub const OPTIONAL_NESTED_MESSAGE_FIELD_NUMBER: i32 = 18;
    pub fn optional_nested_message_option(&self) -> ::std::option::Option<&self::test_all_types::NestedMessage> {
        self.optional_nested_message.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`optional_nested_message`] field
    ///
    /// [`optional_nested_message`]: #method.optional_nested_message
    pub fn optional_nested_message_mut(&mut self) -> &mut self::test_all_types::NestedMessage {
        self.optional_nested_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`optional_nested_message`] field
    ///
    /// [`optional_nested_message`]: #method.optional_nested_message
    pub fn has_optional_nested_message(&self) -> bool {
        self.optional_nested_message.is_some()
    }
    /// Sets the value of the [`optional_nested_message`] field
    ///
    /// [`optional_nested_message`]: #method.optional_nested_message
    pub fn set_optional_nested_message(&mut self, value: self::test_all_types::NestedMessage) {
        self.optional_nested_message = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`optional_nested_message`] field, leaving it empty
    ///
    /// [`optional_nested_message`]: #method.optional_nested_message
    pub fn take_optional_nested_message(&mut self) -> ::std::option::Option<self::test_all_types::NestedMessage> {
        self.optional_nested_message.take().map(|b| *b)
    }
    /// Clears the value of the [`optional_nested_message`] field
    ///
    /// [`optional_nested_message`]: #method.optional_nested_message
    pub fn clear_optional_nested_message(&mut self) {
        self.optional_nested_message = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_foreign_message`] field
    ///
    /// [`optional_foreign_message`]: #method.optional_foreign_message
    pub const OPTIONAL_FOREIGN_MESSAGE_FIELD_NUMBER: i32 = 19;
    pub fn optional_foreign_message_option(&self) -> ::std::option::Option<&self::ForeignMessage> {
        self.optional_foreign_message.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`optional_foreign_message`] field
    ///
    /// [`optional_foreign_message`]: #method.optional_foreign_message
    pub fn optional_foreign_message_mut(&mut self) -> &mut self::ForeignMessage {
        self.optional_foreign_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`optional_foreign_message`] field
    ///
    /// [`optional_foreign_message`]: #method.optional_foreign_message
    pub fn has_optional_foreign_message(&self) -> bool {
        self.optional_foreign_message.is_some()
    }
    /// Sets the value of the [`optional_foreign_message`] field
    ///
    /// [`optional_foreign_message`]: #method.optional_foreign_message
    pub fn set_optional_foreign_message(&mut self, value: self::ForeignMessage) {
        self.optional_foreign_message = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`optional_foreign_message`] field, leaving it empty
    ///
    /// [`optional_foreign_message`]: #method.optional_foreign_message
    pub fn take_optional_foreign_message(&mut self) -> ::std::option::Option<self::ForeignMessage> {
        self.optional_foreign_message.take().map(|b| *b)
    }
    /// Clears the value of the [`optional_foreign_message`] field
    ///
    /// [`optional_foreign_message`]: #method.optional_foreign_message
    pub fn clear_optional_foreign_message(&mut self) {
        self.optional_foreign_message = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_import_message`] field
    ///
    /// [`optional_import_message`]: #method.optional_import_message
    pub const OPTIONAL_IMPORT_MESSAGE_FIELD_NUMBER: i32 = 20;
    pub fn optional_import_message_option(&self) -> ::std::option::Option<&self::super::unittest_import_proto::ImportMessage> {
        self.optional_import_message.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`optional_import_message`] field
    ///
    /// [`optional_import_message`]: #method.optional_import_message
    pub fn optional_import_message_mut(&mut self) -> &mut self::super::unittest_import_proto::ImportMessage {
        self.optional_import_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`optional_import_message`] field
    ///
    /// [`optional_import_message`]: #method.optional_import_message
    pub fn has_optional_import_message(&self) -> bool {
        self.optional_import_message.is_some()
    }
    /// Sets the value of the [`optional_import_message`] field
    ///
    /// [`optional_import_message`]: #method.optional_import_message
    pub fn set_optional_import_message(&mut self, value: self::super::unittest_import_proto::ImportMessage) {
        self.optional_import_message = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`optional_import_message`] field, leaving it empty
    ///
    /// [`optional_import_message`]: #method.optional_import_message
    pub fn take_optional_import_message(&mut self) -> ::std::option::Option<self::super::unittest_import_proto::ImportMessage> {
        self.optional_import_message.take().map(|b| *b)
    }
    /// Clears the value of the [`optional_import_message`] field
    ///
    /// [`optional_import_message`]: #method.optional_import_message
    pub fn clear_optional_import_message(&mut self) {
        self.optional_import_message = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_nested_enum`] field
    ///
    /// [`optional_nested_enum`]: #method.optional_nested_enum
    pub const OPTIONAL_NESTED_ENUM_FIELD_NUMBER: i32 = 21;
    /// A constant value representing the default value of the [`optional_nested_enum`] field
    ///
    /// [`optional_nested_enum`]: #method.optional_nested_enum
    pub const OPTIONAL_NESTED_ENUM_DEFAULT_VALUE: ::protrust::EnumValue<self::test_all_types::NestedEnum> = ::protrust::EnumValue::Undefined(0);
    pub fn optional_nested_enum(&self) -> ::protrust::EnumValue<self::test_all_types::NestedEnum> {
        self.optional_nested_enum.unwrap_or(Self::OPTIONAL_NESTED_ENUM_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`optional_nested_enum`] field
    ///
    /// [`optional_nested_enum`]: #method.optional_nested_enum
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn optional_nested_enum_option(&self) -> ::std::option::Option<::protrust::EnumValue<self::test_all_types::NestedEnum>> {
        self.optional_nested_enum
    }
    /// Returns a bool indicating the presence of the [`optional_nested_enum`] field
    ///
    /// [`optional_nested_enum`]: #method.optional_nested_enum
    pub fn has_optional_nested_enum(&self) -> bool {
        self.optional_nested_enum.is_some()
    }
    /// Sets the value of the [`optional_nested_enum`] field
    ///
    /// [`optional_nested_enum`]: #method.optional_nested_enum
    pub fn set_optional_nested_enum(&mut self, value: ::protrust::EnumValue<self::test_all_types::NestedEnum>) {
        self.optional_nested_enum = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`optional_nested_enum`] field
    ///
    /// [`optional_nested_enum`]: #method.optional_nested_enum
    pub fn clear_optional_nested_enum(&mut self) {
        self.optional_nested_enum = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_foreign_enum`] field
    ///
    /// [`optional_foreign_enum`]: #method.optional_foreign_enum
    pub const OPTIONAL_FOREIGN_ENUM_FIELD_NUMBER: i32 = 22;
    /// A constant value representing the default value of the [`optional_foreign_enum`] field
    ///
    /// [`optional_foreign_enum`]: #method.optional_foreign_enum
    pub const OPTIONAL_FOREIGN_ENUM_DEFAULT_VALUE: ::protrust::EnumValue<self::ForeignEnum> = ::protrust::EnumValue::Undefined(0);
    pub fn optional_foreign_enum(&self) -> ::protrust::EnumValue<self::ForeignEnum> {
        self.optional_foreign_enum.unwrap_or(Self::OPTIONAL_FOREIGN_ENUM_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`optional_foreign_enum`] field
    ///
    /// [`optional_foreign_enum`]: #method.optional_foreign_enum
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn optional_foreign_enum_option(&self) -> ::std::option::Option<::protrust::EnumValue<self::ForeignEnum>> {
        self.optional_foreign_enum
    }
    /// Returns a bool indicating the presence of the [`optional_foreign_enum`] field
    ///
    /// [`optional_foreign_enum`]: #method.optional_foreign_enum
    pub fn has_optional_foreign_enum(&self) -> bool {
        self.optional_foreign_enum.is_some()
    }
    /// Sets the value of the [`optional_foreign_enum`] field
    ///
    /// [`optional_foreign_enum`]: #method.optional_foreign_enum
    pub fn set_optional_foreign_enum(&mut self, value: ::protrust::EnumValue<self::ForeignEnum>) {
        self.optional_foreign_enum = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`optional_foreign_enum`] field
    ///
    /// [`optional_foreign_enum`]: #method.optional_foreign_enum
    pub fn clear_optional_foreign_enum(&mut self) {
        self.optional_foreign_enum = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_import_enum`] field
    ///
    /// [`optional_import_enum`]: #method.optional_import_enum
    pub const OPTIONAL_IMPORT_ENUM_FIELD_NUMBER: i32 = 23;
    /// A constant value representing the default value of the [`optional_import_enum`] field
    ///
    /// [`optional_import_enum`]: #method.optional_import_enum
    pub const OPTIONAL_IMPORT_ENUM_DEFAULT_VALUE: ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum> = ::protrust::EnumValue::Undefined(0);
    pub fn optional_import_enum(&self) -> ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum> {
        self.optional_import_enum.unwrap_or(Self::OPTIONAL_IMPORT_ENUM_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`optional_import_enum`] field
    ///
    /// [`optional_import_enum`]: #method.optional_import_enum
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn optional_import_enum_option(&self) -> ::std::option::Option<::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>> {
        self.optional_import_enum
    }
    /// Returns a bool indicating the presence of the [`optional_import_enum`] field
    ///
    /// [`optional_import_enum`]: #method.optional_import_enum
    pub fn has_optional_import_enum(&self) -> bool {
        self.optional_import_enum.is_some()
    }
    /// Sets the value of the [`optional_import_enum`] field
    ///
    /// [`optional_import_enum`]: #method.optional_import_enum
    pub fn set_optional_import_enum(&mut self, value: ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>) {
        self.optional_import_enum = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`optional_import_enum`] field
    ///
    /// [`optional_import_enum`]: #method.optional_import_enum
    pub fn clear_optional_import_enum(&mut self) {
        self.optional_import_enum = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_string_piece`] field
    ///
    /// [`optional_string_piece`]: #method.optional_string_piece
    pub const OPTIONAL_STRING_PIECE_FIELD_NUMBER: i32 = 24;
    /// A constant value representing the default value of the [`optional_string_piece`] field
    ///
    /// [`optional_string_piece`]: #method.optional_string_piece
    pub const OPTIONAL_STRING_PIECE_DEFAULT_VALUE: &'static str = "";
    pub fn optional_string_piece(&self) -> &str {
        self.optional_string_piece.as_ref().map(|v| &**v).unwrap_or(Self::OPTIONAL_STRING_PIECE_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`optional_string_piece`] field
    ///
    /// [`optional_string_piece`]: #method.optional_string_piece
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn optional_string_piece_option(&self) -> ::std::option::Option<&::std::string::String> {
        self.optional_string_piece.as_ref()
    }
    /// Returns a unique reference to the [`optional_string_piece`] field
    ///
    /// [`optional_string_piece`]: #method.optional_string_piece
    pub fn optional_string_piece_mut(&mut self) -> &mut ::std::string::String {
        self.optional_string_piece.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`optional_string_piece`] field
    ///
    /// [`optional_string_piece`]: #method.optional_string_piece
    pub fn has_optional_string_piece(&self) -> bool {
        self.optional_string_piece.is_some()
    }
    /// Sets the value of the [`optional_string_piece`] field
    ///
    /// [`optional_string_piece`]: #method.optional_string_piece
    pub fn set_optional_string_piece(&mut self, value: ::std::string::String) {
        self.optional_string_piece = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`optional_string_piece`] field, leaving it empty
    ///
    /// [`optional_string_piece`]: #method.optional_string_piece
    pub fn take_optional_string_piece(&mut self) -> ::std::option::Option<::std::string::String> {
        self.optional_string_piece.take()
    }
    /// Clears the value of the [`optional_string_piece`] field
    ///
    /// [`optional_string_piece`]: #method.optional_string_piece
    pub fn clear_optional_string_piece(&mut self) {
        self.optional_string_piece = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_cord`] field
    ///
    /// [`optional_cord`]: #method.optional_cord
    pub const OPTIONAL_CORD_FIELD_NUMBER: i32 = 25;
    /// A constant value representing the default value of the [`optional_cord`] field
    ///
    /// [`optional_cord`]: #method.optional_cord
    pub const OPTIONAL_CORD_DEFAULT_VALUE: &'static str = "";
    pub fn optional_cord(&self) -> &str {
        self.optional_cord.as_ref().map(|v| &**v).unwrap_or(Self::OPTIONAL_CORD_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`optional_cord`] field
    ///
    /// [`optional_cord`]: #method.optional_cord
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn optional_cord_option(&self) -> ::std::option::Option<&::std::string::String> {
        self.optional_cord.as_ref()
    }
    /// Returns a unique reference to the [`optional_cord`] field
    ///
    /// [`optional_cord`]: #method.optional_cord
    pub fn optional_cord_mut(&mut self) -> &mut ::std::string::String {
        self.optional_cord.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`optional_cord`] field
    ///
    /// [`optional_cord`]: #method.optional_cord
    pub fn has_optional_cord(&self) -> bool {
        self.optional_cord.is_some()
    }
    /// Sets the value of the [`optional_cord`] field
    ///
    /// [`optional_cord`]: #method.optional_cord
    pub fn set_optional_cord(&mut self, value: ::std::string::String) {
        self.optional_cord = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`optional_cord`] field, leaving it empty
    ///
    /// [`optional_cord`]: #method.optional_cord
    pub fn take_optional_cord(&mut self) -> ::std::option::Option<::std::string::String> {
        self.optional_cord.take()
    }
    /// Clears the value of the [`optional_cord`] field
    ///
    /// [`optional_cord`]: #method.optional_cord
    pub fn clear_optional_cord(&mut self) {
        self.optional_cord = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_public_import_message`] field
    ///
    /// [`optional_public_import_message`]: #method.optional_public_import_message
    pub const OPTIONAL_PUBLIC_IMPORT_MESSAGE_FIELD_NUMBER: i32 = 26;
    /// Defined in unittest_import_public.proto
    pub fn optional_public_import_message_option(&self) -> ::std::option::Option<&self::super::unittest_import_public_proto::PublicImportMessage> {
        self.optional_public_import_message.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`optional_public_import_message`] field
    ///
    /// [`optional_public_import_message`]: #method.optional_public_import_message
    pub fn optional_public_import_message_mut(&mut self) -> &mut self::super::unittest_import_public_proto::PublicImportMessage {
        self.optional_public_import_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`optional_public_import_message`] field
    ///
    /// [`optional_public_import_message`]: #method.optional_public_import_message
    pub fn has_optional_public_import_message(&self) -> bool {
        self.optional_public_import_message.is_some()
    }
    /// Sets the value of the [`optional_public_import_message`] field
    ///
    /// [`optional_public_import_message`]: #method.optional_public_import_message
    pub fn set_optional_public_import_message(&mut self, value: self::super::unittest_import_public_proto::PublicImportMessage) {
        self.optional_public_import_message = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`optional_public_import_message`] field, leaving it empty
    ///
    /// [`optional_public_import_message`]: #method.optional_public_import_message
    pub fn take_optional_public_import_message(&mut self) -> ::std::option::Option<self::super::unittest_import_public_proto::PublicImportMessage> {
        self.optional_public_import_message.take().map(|b| *b)
    }
    /// Clears the value of the [`optional_public_import_message`] field
    ///
    /// [`optional_public_import_message`]: #method.optional_public_import_message
    pub fn clear_optional_public_import_message(&mut self) {
        self.optional_public_import_message = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_lazy_message`] field
    ///
    /// [`optional_lazy_message`]: #method.optional_lazy_message
    pub const OPTIONAL_LAZY_MESSAGE_FIELD_NUMBER: i32 = 27;
    pub fn optional_lazy_message_option(&self) -> ::std::option::Option<&self::test_all_types::NestedMessage> {
        self.optional_lazy_message.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`optional_lazy_message`] field
    ///
    /// [`optional_lazy_message`]: #method.optional_lazy_message
    pub fn optional_lazy_message_mut(&mut self) -> &mut self::test_all_types::NestedMessage {
        self.optional_lazy_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`optional_lazy_message`] field
    ///
    /// [`optional_lazy_message`]: #method.optional_lazy_message
    pub fn has_optional_lazy_message(&self) -> bool {
        self.optional_lazy_message.is_some()
    }
    /// Sets the value of the [`optional_lazy_message`] field
    ///
    /// [`optional_lazy_message`]: #method.optional_lazy_message
    pub fn set_optional_lazy_message(&mut self, value: self::test_all_types::NestedMessage) {
        self.optional_lazy_message = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`optional_lazy_message`] field, leaving it empty
    ///
    /// [`optional_lazy_message`]: #method.optional_lazy_message
    pub fn take_optional_lazy_message(&mut self) -> ::std::option::Option<self::test_all_types::NestedMessage> {
        self.optional_lazy_message.take().map(|b| *b)
    }
    /// Clears the value of the [`optional_lazy_message`] field
    ///
    /// [`optional_lazy_message`]: #method.optional_lazy_message
    pub fn clear_optional_lazy_message(&mut self) {
        self.optional_lazy_message = ::std::option::Option::None
    }
    /// Gets the field number of the [`repeated_int32`] field
    ///
    /// [`repeated_int32`]: #method.repeated_int32
    pub const REPEATED_INT32_FIELD_NUMBER: i32 = 31;
    /// Repeated
    pub fn repeated_int32(&self) -> &::protrust::collections::RepeatedField<i32> {
        &self.repeated_int32
    }
    /// Returns a unique reference to the [`repeated_int32`] field
    ///
    /// [`repeated_int32`]: #method.repeated_int32
    pub fn repeated_int32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
        &mut self.repeated_int32
    }
    /// Gets the field number of the [`repeated_int64`] field
    ///
    /// [`repeated_int64`]: #method.repeated_int64
    pub const REPEATED_INT64_FIELD_NUMBER: i32 = 32;
    pub fn repeated_int64(&self) -> &::protrust::collections::RepeatedField<i64> {
        &self.repeated_int64
    }
    /// Returns a unique reference to the [`repeated_int64`] field
    ///
    /// [`repeated_int64`]: #method.repeated_int64
    pub fn repeated_int64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
        &mut self.repeated_int64
    }
    /// Gets the field number of the [`repeated_uint32`] field
    ///
    /// [`repeated_uint32`]: #method.repeated_uint32
    pub const REPEATED_UINT32_FIELD_NUMBER: i32 = 33;
    pub fn repeated_uint32(&self) -> &::protrust::collections::RepeatedField<u32> {
        &self.repeated_uint32
    }
    /// Returns a unique reference to the [`repeated_uint32`] field
    ///
    /// [`repeated_uint32`]: #method.repeated_uint32
    pub fn repeated_uint32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u32> {
        &mut self.repeated_uint32
    }
    /// Gets the field number of the [`repeated_uint64`] field
    ///
    /// [`repeated_uint64`]: #method.repeated_uint64
    pub const REPEATED_UINT64_FIELD_NUMBER: i32 = 34;
    pub fn repeated_uint64(&self) -> &::protrust::collections::RepeatedField<u64> {
        &self.repeated_uint64
    }
    /// Returns a unique reference to the [`repeated_uint64`] field
    ///
    /// [`repeated_uint64`]: #method.repeated_uint64
    pub fn repeated_uint64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u64> {
        &mut self.repeated_uint64
    }
    /// Gets the field number of the [`repeated_sint32`] field
    ///
    /// [`repeated_sint32`]: #method.repeated_sint32
    pub const REPEATED_SINT32_FIELD_NUMBER: i32 = 35;
    pub fn repeated_sint32(&self) -> &::protrust::collections::RepeatedField<i32> {
        &self.repeated_sint32
    }
    /// Returns a unique reference to the [`repeated_sint32`] field
    ///
    /// [`repeated_sint32`]: #method.repeated_sint32
    pub fn repeated_sint32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
        &mut self.repeated_sint32
    }
    /// Gets the field number of the [`repeated_sint64`] field
    ///
    /// [`repeated_sint64`]: #method.repeated_sint64
    pub const REPEATED_SINT64_FIELD_NUMBER: i32 = 36;
    pub fn repeated_sint64(&self) -> &::protrust::collections::RepeatedField<i64> {
        &self.repeated_sint64
    }
    /// Returns a unique reference to the [`repeated_sint64`] field
    ///
    /// [`repeated_sint64`]: #method.repeated_sint64
    pub fn repeated_sint64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
        &mut self.repeated_sint64
    }
    /// Gets the field number of the [`repeated_fixed32`] field
    ///
    /// [`repeated_fixed32`]: #method.repeated_fixed32
    pub const REPEATED_FIXED32_FIELD_NUMBER: i32 = 37;
    pub fn repeated_fixed32(&self) -> &::protrust::collections::RepeatedField<u32> {
        &self.repeated_fixed32
    }
    /// Returns a unique reference to the [`repeated_fixed32`] field
    ///
    /// [`repeated_fixed32`]: #method.repeated_fixed32
    pub fn repeated_fixed32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u32> {
        &mut self.repeated_fixed32
    }
    /// Gets the field number of the [`repeated_fixed64`] field
    ///
    /// [`repeated_fixed64`]: #method.repeated_fixed64
    pub const REPEATED_FIXED64_FIELD_NUMBER: i32 = 38;
    pub fn repeated_fixed64(&self) -> &::protrust::collections::RepeatedField<u64> {
        &self.repeated_fixed64
    }
    /// Returns a unique reference to the [`repeated_fixed64`] field
    ///
    /// [`repeated_fixed64`]: #method.repeated_fixed64
    pub fn repeated_fixed64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u64> {
        &mut self.repeated_fixed64
    }
    /// Gets the field number of the [`repeated_sfixed32`] field
    ///
    /// [`repeated_sfixed32`]: #method.repeated_sfixed32
    pub const REPEATED_SFIXED32_FIELD_NUMBER: i32 = 39;
    pub fn repeated_sfixed32(&self) -> &::protrust::collections::RepeatedField<i32> {
        &self.repeated_sfixed32
    }
    /// Returns a unique reference to the [`repeated_sfixed32`] field
    ///
    /// [`repeated_sfixed32`]: #method.repeated_sfixed32
    pub fn repeated_sfixed32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
        &mut self.repeated_sfixed32
    }
    /// Gets the field number of the [`repeated_sfixed64`] field
    ///
    /// [`repeated_sfixed64`]: #method.repeated_sfixed64
    pub const REPEATED_SFIXED64_FIELD_NUMBER: i32 = 40;
    pub fn repeated_sfixed64(&self) -> &::protrust::collections::RepeatedField<i64> {
        &self.repeated_sfixed64
    }
    /// Returns a unique reference to the [`repeated_sfixed64`] field
    ///
    /// [`repeated_sfixed64`]: #method.repeated_sfixed64
    pub fn repeated_sfixed64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
        &mut self.repeated_sfixed64
    }
    /// Gets the field number of the [`repeated_float`] field
    ///
    /// [`repeated_float`]: #method.repeated_float
    pub const REPEATED_FLOAT_FIELD_NUMBER: i32 = 41;
    pub fn repeated_float(&self) -> &::protrust::collections::RepeatedField<f32> {
        &self.repeated_float
    }
    /// Returns a unique reference to the [`repeated_float`] field
    ///
    /// [`repeated_float`]: #method.repeated_float
    pub fn repeated_float_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<f32> {
        &mut self.repeated_float
    }
    /// Gets the field number of the [`repeated_double`] field
    ///
    /// [`repeated_double`]: #method.repeated_double
    pub const REPEATED_DOUBLE_FIELD_NUMBER: i32 = 42;
    pub fn repeated_double(&self) -> &::protrust::collections::RepeatedField<f64> {
        &self.repeated_double
    }
    /// Returns a unique reference to the [`repeated_double`] field
    ///
    /// [`repeated_double`]: #method.repeated_double
    pub fn repeated_double_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<f64> {
        &mut self.repeated_double
    }
    /// Gets the field number of the [`repeated_bool`] field
    ///
    /// [`repeated_bool`]: #method.repeated_bool
    pub const REPEATED_BOOL_FIELD_NUMBER: i32 = 43;
    pub fn repeated_bool(&self) -> &::protrust::collections::RepeatedField<bool> {
        &self.repeated_bool
    }
    /// Returns a unique reference to the [`repeated_bool`] field
    ///
    /// [`repeated_bool`]: #method.repeated_bool
    pub fn repeated_bool_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<bool> {
        &mut self.repeated_bool
    }
    /// Gets the field number of the [`repeated_string`] field
    ///
    /// [`repeated_string`]: #method.repeated_string
    pub const REPEATED_STRING_FIELD_NUMBER: i32 = 44;
    pub fn repeated_string(&self) -> &::protrust::collections::RepeatedField<::std::string::String> {
        &self.repeated_string
    }
    /// Returns a unique reference to the [`repeated_string`] field
    ///
    /// [`repeated_string`]: #method.repeated_string
    pub fn repeated_string_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<::std::string::String> {
        &mut self.repeated_string
    }
    /// Gets the field number of the [`repeated_bytes`] field
    ///
    /// [`repeated_bytes`]: #method.repeated_bytes
    pub const REPEATED_BYTES_FIELD_NUMBER: i32 = 45;
    pub fn repeated_bytes(&self) -> &::protrust::collections::RepeatedField<::std::vec::Vec<u8>> {
        &self.repeated_bytes
    }
    /// Returns a unique reference to the [`repeated_bytes`] field
    ///
    /// [`repeated_bytes`]: #method.repeated_bytes
    pub fn repeated_bytes_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.repeated_bytes
    }
    /// Gets the field number of the [`repeatedgroup`] field
    ///
    /// [`repeatedgroup`]: #method.repeatedgroup
    pub const REPEATEDGROUP_FIELD_NUMBER: i32 = 46;
    pub fn repeatedgroup(&self) -> &::protrust::collections::RepeatedField<self::test_all_types::RepeatedGroup> {
        &self.repeatedgroup
    }
    /// Returns a unique reference to the [`repeatedgroup`] field
    ///
    /// [`repeatedgroup`]: #method.repeatedgroup
    pub fn repeatedgroup_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<self::test_all_types::RepeatedGroup> {
        &mut self.repeatedgroup
    }
    /// Gets the field number of the [`repeated_nested_message`] field
    ///
    /// [`repeated_nested_message`]: #method.repeated_nested_message
    pub const REPEATED_NESTED_MESSAGE_FIELD_NUMBER: i32 = 48;
    pub fn repeated_nested_message(&self) -> &::protrust::collections::RepeatedField<self::test_all_types::NestedMessage> {
        &self.repeated_nested_message
    }
    /// Returns a unique reference to the [`repeated_nested_message`] field
    ///
    /// [`repeated_nested_message`]: #method.repeated_nested_message
    pub fn repeated_nested_message_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<self::test_all_types::NestedMessage> {
        &mut self.repeated_nested_message
    }
    /// Gets the field number of the [`repeated_foreign_message`] field
    ///
    /// [`repeated_foreign_message`]: #method.repeated_foreign_message
    pub const REPEATED_FOREIGN_MESSAGE_FIELD_NUMBER: i32 = 49;
    pub fn repeated_foreign_message(&self) -> &::protrust::collections::RepeatedField<self::ForeignMessage> {
        &self.repeated_foreign_message
    }
    /// Returns a unique reference to the [`repeated_foreign_message`] field
    ///
    /// [`repeated_foreign_message`]: #method.repeated_foreign_message
    pub fn repeated_foreign_message_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<self::ForeignMessage> {
        &mut self.repeated_foreign_message
    }
    /// Gets the field number of the [`repeated_import_message`] field
    ///
    /// [`repeated_import_message`]: #method.repeated_import_message
    pub const REPEATED_IMPORT_MESSAGE_FIELD_NUMBER: i32 = 50;
    pub fn repeated_import_message(&self) -> &::protrust::collections::RepeatedField<self::super::unittest_import_proto::ImportMessage> {
        &self.repeated_import_message
    }
    /// Returns a unique reference to the [`repeated_import_message`] field
    ///
    /// [`repeated_import_message`]: #method.repeated_import_message
    pub fn repeated_import_message_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<self::super::unittest_import_proto::ImportMessage> {
        &mut self.repeated_import_message
    }
    /// Gets the field number of the [`repeated_nested_enum`] field
    ///
    /// [`repeated_nested_enum`]: #method.repeated_nested_enum
    pub const REPEATED_NESTED_ENUM_FIELD_NUMBER: i32 = 51;
    pub fn repeated_nested_enum(&self) -> &::protrust::collections::RepeatedField<::protrust::EnumValue<self::test_all_types::NestedEnum>> {
        &self.repeated_nested_enum
    }
    /// Returns a unique reference to the [`repeated_nested_enum`] field
    ///
    /// [`repeated_nested_enum`]: #method.repeated_nested_enum
    pub fn repeated_nested_enum_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<::protrust::EnumValue<self::test_all_types::NestedEnum>> {
        &mut self.repeated_nested_enum
    }
    /// Gets the field number of the [`repeated_foreign_enum`] field
    ///
    /// [`repeated_foreign_enum`]: #method.repeated_foreign_enum
    pub const REPEATED_FOREIGN_ENUM_FIELD_NUMBER: i32 = 52;
    pub fn repeated_foreign_enum(&self) -> &::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>> {
        &self.repeated_foreign_enum
    }
    /// Returns a unique reference to the [`repeated_foreign_enum`] field
    ///
    /// [`repeated_foreign_enum`]: #method.repeated_foreign_enum
    pub fn repeated_foreign_enum_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>> {
        &mut self.repeated_foreign_enum
    }
    /// Gets the field number of the [`repeated_import_enum`] field
    ///
    /// [`repeated_import_enum`]: #method.repeated_import_enum
    pub const REPEATED_IMPORT_ENUM_FIELD_NUMBER: i32 = 53;
    pub fn repeated_import_enum(&self) -> &::protrust::collections::RepeatedField<::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>> {
        &self.repeated_import_enum
    }
    /// Returns a unique reference to the [`repeated_import_enum`] field
    ///
    /// [`repeated_import_enum`]: #method.repeated_import_enum
    pub fn repeated_import_enum_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>> {
        &mut self.repeated_import_enum
    }
    /// Gets the field number of the [`repeated_string_piece`] field
    ///
    /// [`repeated_string_piece`]: #method.repeated_string_piece
    pub const REPEATED_STRING_PIECE_FIELD_NUMBER: i32 = 54;
    pub fn repeated_string_piece(&self) -> &::protrust::collections::RepeatedField<::std::string::String> {
        &self.repeated_string_piece
    }
    /// Returns a unique reference to the [`repeated_string_piece`] field
    ///
    /// [`repeated_string_piece`]: #method.repeated_string_piece
    pub fn repeated_string_piece_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<::std::string::String> {
        &mut self.repeated_string_piece
    }
    /// Gets the field number of the [`repeated_cord`] field
    ///
    /// [`repeated_cord`]: #method.repeated_cord
    pub const REPEATED_CORD_FIELD_NUMBER: i32 = 55;
    pub fn repeated_cord(&self) -> &::protrust::collections::RepeatedField<::std::string::String> {
        &self.repeated_cord
    }
    /// Returns a unique reference to the [`repeated_cord`] field
    ///
    /// [`repeated_cord`]: #method.repeated_cord
    pub fn repeated_cord_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<::std::string::String> {
        &mut self.repeated_cord
    }
    /// Gets the field number of the [`repeated_lazy_message`] field
    ///
    /// [`repeated_lazy_message`]: #method.repeated_lazy_message
    pub const REPEATED_LAZY_MESSAGE_FIELD_NUMBER: i32 = 57;
    pub fn repeated_lazy_message(&self) -> &::protrust::collections::RepeatedField<self::test_all_types::NestedMessage> {
        &self.repeated_lazy_message
    }
    /// Returns a unique reference to the [`repeated_lazy_message`] field
    ///
    /// [`repeated_lazy_message`]: #method.repeated_lazy_message
    pub fn repeated_lazy_message_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<self::test_all_types::NestedMessage> {
        &mut self.repeated_lazy_message
    }
    /// Gets the field number of the [`default_int32`] field
    ///
    /// [`default_int32`]: #method.default_int32
    pub const DEFAULT_INT32_FIELD_NUMBER: i32 = 61;
    /// A constant value representing the default value of the [`default_int32`] field
    ///
    /// [`default_int32`]: #method.default_int32
    pub const DEFAULT_INT32_DEFAULT_VALUE: i32 = 41;
    /// Singular with defaults
    pub fn default_int32(&self) -> i32 {
        self.default_int32.unwrap_or(Self::DEFAULT_INT32_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`default_int32`] field
    ///
    /// [`default_int32`]: #method.default_int32
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn default_int32_option(&self) -> ::std::option::Option<i32> {
        self.default_int32
    }
    /// Returns a bool indicating the presence of the [`default_int32`] field
    ///
    /// [`default_int32`]: #method.default_int32
    pub fn has_default_int32(&self) -> bool {
        self.default_int32.is_some()
    }
    /// Sets the value of the [`default_int32`] field
    ///
    /// [`default_int32`]: #method.default_int32
    pub fn set_default_int32(&mut self, value: i32) {
        self.default_int32 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`default_int32`] field
    ///
    /// [`default_int32`]: #method.default_int32
    pub fn clear_default_int32(&mut self) {
        self.default_int32 = ::std::option::Option::None
    }
    /// Gets the field number of the [`default_int64`] field
    ///
    /// [`default_int64`]: #method.default_int64
    pub const DEFAULT_INT64_FIELD_NUMBER: i32 = 62;
    /// A constant value representing the default value of the [`default_int64`] field
    ///
    /// [`default_int64`]: #method.default_int64
    pub const DEFAULT_INT64_DEFAULT_VALUE: i64 = 42;
    pub fn default_int64(&self) -> i64 {
        self.default_int64.unwrap_or(Self::DEFAULT_INT64_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`default_int64`] field
    ///
    /// [`default_int64`]: #method.default_int64
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn default_int64_option(&self) -> ::std::option::Option<i64> {
        self.default_int64
    }
    /// Returns a bool indicating the presence of the [`default_int64`] field
    ///
    /// [`default_int64`]: #method.default_int64
    pub fn has_default_int64(&self) -> bool {
        self.default_int64.is_some()
    }
    /// Sets the value of the [`default_int64`] field
    ///
    /// [`default_int64`]: #method.default_int64
    pub fn set_default_int64(&mut self, value: i64) {
        self.default_int64 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`default_int64`] field
    ///
    /// [`default_int64`]: #method.default_int64
    pub fn clear_default_int64(&mut self) {
        self.default_int64 = ::std::option::Option::None
    }
    /// Gets the field number of the [`default_uint32`] field
    ///
    /// [`default_uint32`]: #method.default_uint32
    pub const DEFAULT_UINT32_FIELD_NUMBER: i32 = 63;
    /// A constant value representing the default value of the [`default_uint32`] field
    ///
    /// [`default_uint32`]: #method.default_uint32
    pub const DEFAULT_UINT32_DEFAULT_VALUE: u32 = 43;
    pub fn default_uint32(&self) -> u32 {
        self.default_uint32.unwrap_or(Self::DEFAULT_UINT32_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`default_uint32`] field
    ///
    /// [`default_uint32`]: #method.default_uint32
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn default_uint32_option(&self) -> ::std::option::Option<u32> {
        self.default_uint32
    }
    /// Returns a bool indicating the presence of the [`default_uint32`] field
    ///
    /// [`default_uint32`]: #method.default_uint32
    pub fn has_default_uint32(&self) -> bool {
        self.default_uint32.is_some()
    }
    /// Sets the value of the [`default_uint32`] field
    ///
    /// [`default_uint32`]: #method.default_uint32
    pub fn set_default_uint32(&mut self, value: u32) {
        self.default_uint32 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`default_uint32`] field
    ///
    /// [`default_uint32`]: #method.default_uint32
    pub fn clear_default_uint32(&mut self) {
        self.default_uint32 = ::std::option::Option::None
    }
    /// Gets the field number of the [`default_uint64`] field
    ///
    /// [`default_uint64`]: #method.default_uint64
    pub const DEFAULT_UINT64_FIELD_NUMBER: i32 = 64;
    /// A constant value representing the default value of the [`default_uint64`] field
    ///
    /// [`default_uint64`]: #method.default_uint64
    pub const DEFAULT_UINT64_DEFAULT_VALUE: u64 = 44;
    pub fn default_uint64(&self) -> u64 {
        self.default_uint64.unwrap_or(Self::DEFAULT_UINT64_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`default_uint64`] field
    ///
    /// [`default_uint64`]: #method.default_uint64
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn default_uint64_option(&self) -> ::std::option::Option<u64> {
        self.default_uint64
    }
    /// Returns a bool indicating the presence of the [`default_uint64`] field
    ///
    /// [`default_uint64`]: #method.default_uint64
    pub fn has_default_uint64(&self) -> bool {
        self.default_uint64.is_some()
    }
    /// Sets the value of the [`default_uint64`] field
    ///
    /// [`default_uint64`]: #method.default_uint64
    pub fn set_default_uint64(&mut self, value: u64) {
        self.default_uint64 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`default_uint64`] field
    ///
    /// [`default_uint64`]: #method.default_uint64
    pub fn clear_default_uint64(&mut self) {
        self.default_uint64 = ::std::option::Option::None
    }
    /// Gets the field number of the [`default_sint32`] field
    ///
    /// [`default_sint32`]: #method.default_sint32
    pub const DEFAULT_SINT32_FIELD_NUMBER: i32 = 65;
    /// A constant value representing the default value of the [`default_sint32`] field
    ///
    /// [`default_sint32`]: #method.default_sint32
    pub const DEFAULT_SINT32_DEFAULT_VALUE: i32 = -45;
    pub fn default_sint32(&self) -> i32 {
        self.default_sint32.unwrap_or(Self::DEFAULT_SINT32_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`default_sint32`] field
    ///
    /// [`default_sint32`]: #method.default_sint32
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn default_sint32_option(&self) -> ::std::option::Option<i32> {
        self.default_sint32
    }
    /// Returns a bool indicating the presence of the [`default_sint32`] field
    ///
    /// [`default_sint32`]: #method.default_sint32
    pub fn has_default_sint32(&self) -> bool {
        self.default_sint32.is_some()
    }
    /// Sets the value of the [`default_sint32`] field
    ///
    /// [`default_sint32`]: #method.default_sint32
    pub fn set_default_sint32(&mut self, value: i32) {
        self.default_sint32 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`default_sint32`] field
    ///
    /// [`default_sint32`]: #method.default_sint32
    pub fn clear_default_sint32(&mut self) {
        self.default_sint32 = ::std::option::Option::None
    }
    /// Gets the field number of the [`default_sint64`] field
    ///
    /// [`default_sint64`]: #method.default_sint64
    pub const DEFAULT_SINT64_FIELD_NUMBER: i32 = 66;
    /// A constant value representing the default value of the [`default_sint64`] field
    ///
    /// [`default_sint64`]: #method.default_sint64
    pub const DEFAULT_SINT64_DEFAULT_VALUE: i64 = 46;
    pub fn default_sint64(&self) -> i64 {
        self.default_sint64.unwrap_or(Self::DEFAULT_SINT64_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`default_sint64`] field
    ///
    /// [`default_sint64`]: #method.default_sint64
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn default_sint64_option(&self) -> ::std::option::Option<i64> {
        self.default_sint64
    }
    /// Returns a bool indicating the presence of the [`default_sint64`] field
    ///
    /// [`default_sint64`]: #method.default_sint64
    pub fn has_default_sint64(&self) -> bool {
        self.default_sint64.is_some()
    }
    /// Sets the value of the [`default_sint64`] field
    ///
    /// [`default_sint64`]: #method.default_sint64
    pub fn set_default_sint64(&mut self, value: i64) {
        self.default_sint64 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`default_sint64`] field
    ///
    /// [`default_sint64`]: #method.default_sint64
    pub fn clear_default_sint64(&mut self) {
        self.default_sint64 = ::std::option::Option::None
    }
    /// Gets the field number of the [`default_fixed32`] field
    ///
    /// [`default_fixed32`]: #method.default_fixed32
    pub const DEFAULT_FIXED32_FIELD_NUMBER: i32 = 67;
    /// A constant value representing the default value of the [`default_fixed32`] field
    ///
    /// [`default_fixed32`]: #method.default_fixed32
    pub const DEFAULT_FIXED32_DEFAULT_VALUE: u32 = 47;
    pub fn default_fixed32(&self) -> u32 {
        self.default_fixed32.unwrap_or(Self::DEFAULT_FIXED32_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`default_fixed32`] field
    ///
    /// [`default_fixed32`]: #method.default_fixed32
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn default_fixed32_option(&self) -> ::std::option::Option<u32> {
        self.default_fixed32
    }
    /// Returns a bool indicating the presence of the [`default_fixed32`] field
    ///
    /// [`default_fixed32`]: #method.default_fixed32
    pub fn has_default_fixed32(&self) -> bool {
        self.default_fixed32.is_some()
    }
    /// Sets the value of the [`default_fixed32`] field
    ///
    /// [`default_fixed32`]: #method.default_fixed32
    pub fn set_default_fixed32(&mut self, value: u32) {
        self.default_fixed32 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`default_fixed32`] field
    ///
    /// [`default_fixed32`]: #method.default_fixed32
    pub fn clear_default_fixed32(&mut self) {
        self.default_fixed32 = ::std::option::Option::None
    }
    /// Gets the field number of the [`default_fixed64`] field
    ///
    /// [`default_fixed64`]: #method.default_fixed64
    pub const DEFAULT_FIXED64_FIELD_NUMBER: i32 = 68;
    /// A constant value representing the default value of the [`default_fixed64`] field
    ///
    /// [`default_fixed64`]: #method.default_fixed64
    pub const DEFAULT_FIXED64_DEFAULT_VALUE: u64 = 48;
    pub fn default_fixed64(&self) -> u64 {
        self.default_fixed64.unwrap_or(Self::DEFAULT_FIXED64_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`default_fixed64`] field
    ///
    /// [`default_fixed64`]: #method.default_fixed64
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn default_fixed64_option(&self) -> ::std::option::Option<u64> {
        self.default_fixed64
    }
    /// Returns a bool indicating the presence of the [`default_fixed64`] field
    ///
    /// [`default_fixed64`]: #method.default_fixed64
    pub fn has_default_fixed64(&self) -> bool {
        self.default_fixed64.is_some()
    }
    /// Sets the value of the [`default_fixed64`] field
    ///
    /// [`default_fixed64`]: #method.default_fixed64
    pub fn set_default_fixed64(&mut self, value: u64) {
        self.default_fixed64 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`default_fixed64`] field
    ///
    /// [`default_fixed64`]: #method.default_fixed64
    pub fn clear_default_fixed64(&mut self) {
        self.default_fixed64 = ::std::option::Option::None
    }
    /// Gets the field number of the [`default_sfixed32`] field
    ///
    /// [`default_sfixed32`]: #method.default_sfixed32
    pub const DEFAULT_SFIXED32_FIELD_NUMBER: i32 = 69;
    /// A constant value representing the default value of the [`default_sfixed32`] field
    ///
    /// [`default_sfixed32`]: #method.default_sfixed32
    pub const DEFAULT_SFIXED32_DEFAULT_VALUE: i32 = 49;
    pub fn default_sfixed32(&self) -> i32 {
        self.default_sfixed32.unwrap_or(Self::DEFAULT_SFIXED32_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`default_sfixed32`] field
    ///
    /// [`default_sfixed32`]: #method.default_sfixed32
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn default_sfixed32_option(&self) -> ::std::option::Option<i32> {
        self.default_sfixed32
    }
    /// Returns a bool indicating the presence of the [`default_sfixed32`] field
    ///
    /// [`default_sfixed32`]: #method.default_sfixed32
    pub fn has_default_sfixed32(&self) -> bool {
        self.default_sfixed32.is_some()
    }
    /// Sets the value of the [`default_sfixed32`] field
    ///
    /// [`default_sfixed32`]: #method.default_sfixed32
    pub fn set_default_sfixed32(&mut self, value: i32) {
        self.default_sfixed32 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`default_sfixed32`] field
    ///
    /// [`default_sfixed32`]: #method.default_sfixed32
    pub fn clear_default_sfixed32(&mut self) {
        self.default_sfixed32 = ::std::option::Option::None
    }
    /// Gets the field number of the [`default_sfixed64`] field
    ///
    /// [`default_sfixed64`]: #method.default_sfixed64
    pub const DEFAULT_SFIXED64_FIELD_NUMBER: i32 = 70;
    /// A constant value representing the default value of the [`default_sfixed64`] field
    ///
    /// [`default_sfixed64`]: #method.default_sfixed64
    pub const DEFAULT_SFIXED64_DEFAULT_VALUE: i64 = -50;
    pub fn default_sfixed64(&self) -> i64 {
        self.default_sfixed64.unwrap_or(Self::DEFAULT_SFIXED64_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`default_sfixed64`] field
    ///
    /// [`default_sfixed64`]: #method.default_sfixed64
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn default_sfixed64_option(&self) -> ::std::option::Option<i64> {
        self.default_sfixed64
    }
    /// Returns a bool indicating the presence of the [`default_sfixed64`] field
    ///
    /// [`default_sfixed64`]: #method.default_sfixed64
    pub fn has_default_sfixed64(&self) -> bool {
        self.default_sfixed64.is_some()
    }
    /// Sets the value of the [`default_sfixed64`] field
    ///
    /// [`default_sfixed64`]: #method.default_sfixed64
    pub fn set_default_sfixed64(&mut self, value: i64) {
        self.default_sfixed64 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`default_sfixed64`] field
    ///
    /// [`default_sfixed64`]: #method.default_sfixed64
    pub fn clear_default_sfixed64(&mut self) {
        self.default_sfixed64 = ::std::option::Option::None
    }
    /// Gets the field number of the [`default_float`] field
    ///
    /// [`default_float`]: #method.default_float
    pub const DEFAULT_FLOAT_FIELD_NUMBER: i32 = 71;
    /// A constant value representing the default value of the [`default_float`] field
    ///
    /// [`default_float`]: #method.default_float
    pub const DEFAULT_FLOAT_DEFAULT_VALUE: f32 = 51.5;
    pub fn default_float(&self) -> f32 {
        self.default_float.unwrap_or(Self::DEFAULT_FLOAT_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`default_float`] field
    ///
    /// [`default_float`]: #method.default_float
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn default_float_option(&self) -> ::std::option::Option<f32> {
        self.default_float
    }
    /// Returns a bool indicating the presence of the [`default_float`] field
    ///
    /// [`default_float`]: #method.default_float
    pub fn has_default_float(&self) -> bool {
        self.default_float.is_some()
    }
    /// Sets the value of the [`default_float`] field
    ///
    /// [`default_float`]: #method.default_float
    pub fn set_default_float(&mut self, value: f32) {
        self.default_float = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`default_float`] field
    ///
    /// [`default_float`]: #method.default_float
    pub fn clear_default_float(&mut self) {
        self.default_float = ::std::option::Option::None
    }
    /// Gets the field number of the [`default_double`] field
    ///
    /// [`default_double`]: #method.default_double
    pub const DEFAULT_DOUBLE_FIELD_NUMBER: i32 = 72;
    /// A constant value representing the default value of the [`default_double`] field
    ///
    /// [`default_double`]: #method.default_double
    pub const DEFAULT_DOUBLE_DEFAULT_VALUE: f64 = 52000.0;
    pub fn default_double(&self) -> f64 {
        self.default_double.unwrap_or(Self::DEFAULT_DOUBLE_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`default_double`] field
    ///
    /// [`default_double`]: #method.default_double
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn default_double_option(&self) -> ::std::option::Option<f64> {
        self.default_double
    }
    /// Returns a bool indicating the presence of the [`default_double`] field
    ///
    /// [`default_double`]: #method.default_double
    pub fn has_default_double(&self) -> bool {
        self.default_double.is_some()
    }
    /// Sets the value of the [`default_double`] field
    ///
    /// [`default_double`]: #method.default_double
    pub fn set_default_double(&mut self, value: f64) {
        self.default_double = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`default_double`] field
    ///
    /// [`default_double`]: #method.default_double
    pub fn clear_default_double(&mut self) {
        self.default_double = ::std::option::Option::None
    }
    /// Gets the field number of the [`default_bool`] field
    ///
    /// [`default_bool`]: #method.default_bool
    pub const DEFAULT_BOOL_FIELD_NUMBER: i32 = 73;
    /// A constant value representing the default value of the [`default_bool`] field
    ///
    /// [`default_bool`]: #method.default_bool
    pub const DEFAULT_BOOL_DEFAULT_VALUE: bool = false;
    pub fn default_bool(&self) -> bool {
        self.default_bool.unwrap_or(Self::DEFAULT_BOOL_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`default_bool`] field
    ///
    /// [`default_bool`]: #method.default_bool
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn default_bool_option(&self) -> ::std::option::Option<bool> {
        self.default_bool
    }
    /// Returns a bool indicating the presence of the [`default_bool`] field
    ///
    /// [`default_bool`]: #method.default_bool
    pub fn has_default_bool(&self) -> bool {
        self.default_bool.is_some()
    }
    /// Sets the value of the [`default_bool`] field
    ///
    /// [`default_bool`]: #method.default_bool
    pub fn set_default_bool(&mut self, value: bool) {
        self.default_bool = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`default_bool`] field
    ///
    /// [`default_bool`]: #method.default_bool
    pub fn clear_default_bool(&mut self) {
        self.default_bool = ::std::option::Option::None
    }
    /// Gets the field number of the [`default_string`] field
    ///
    /// [`default_string`]: #method.default_string
    pub const DEFAULT_STRING_FIELD_NUMBER: i32 = 74;
    /// A constant value representing the default value of the [`default_string`] field
    ///
    /// [`default_string`]: #method.default_string
    pub const DEFAULT_STRING_DEFAULT_VALUE: &'static str = "hello";
    pub fn default_string(&self) -> &str {
        self.default_string.as_ref().map(|v| &**v).unwrap_or(Self::DEFAULT_STRING_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`default_string`] field
    ///
    /// [`default_string`]: #method.default_string
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn default_string_option(&self) -> ::std::option::Option<&::std::string::String> {
        self.default_string.as_ref()
    }
    /// Returns a unique reference to the [`default_string`] field
    ///
    /// [`default_string`]: #method.default_string
    pub fn default_string_mut(&mut self) -> &mut ::std::string::String {
        self.default_string.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`default_string`] field
    ///
    /// [`default_string`]: #method.default_string
    pub fn has_default_string(&self) -> bool {
        self.default_string.is_some()
    }
    /// Sets the value of the [`default_string`] field
    ///
    /// [`default_string`]: #method.default_string
    pub fn set_default_string(&mut self, value: ::std::string::String) {
        self.default_string = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`default_string`] field, leaving it empty
    ///
    /// [`default_string`]: #method.default_string
    pub fn take_default_string(&mut self) -> ::std::option::Option<::std::string::String> {
        self.default_string.take()
    }
    /// Clears the value of the [`default_string`] field
    ///
    /// [`default_string`]: #method.default_string
    pub fn clear_default_string(&mut self) {
        self.default_string = ::std::option::Option::None
    }
    /// Gets the field number of the [`default_bytes`] field
    ///
    /// [`default_bytes`]: #method.default_bytes
    pub const DEFAULT_BYTES_FIELD_NUMBER: i32 = 75;
    /// A constant value representing the default value of the [`default_bytes`] field
    ///
    /// [`default_bytes`]: #method.default_bytes
    pub const DEFAULT_BYTES_DEFAULT_VALUE: &'static [u8] = &[119, 111, 114, 108, 100];
    pub fn default_bytes(&self) -> &[u8] {
        self.default_bytes.as_ref().map(|v| &**v).unwrap_or(Self::DEFAULT_BYTES_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`default_bytes`] field
    ///
    /// [`default_bytes`]: #method.default_bytes
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn default_bytes_option(&self) -> ::std::option::Option<&::std::vec::Vec<u8>> {
        self.default_bytes.as_ref()
    }
    /// Returns a unique reference to the [`default_bytes`] field
    ///
    /// [`default_bytes`]: #method.default_bytes
    pub fn default_bytes_mut(&mut self) -> &mut ::std::vec::Vec<u8> {
        self.default_bytes.get_or_insert_with(::std::vec::Vec::new)
    }
    /// Returns a bool indicating the presence of the [`default_bytes`] field
    ///
    /// [`default_bytes`]: #method.default_bytes
    pub fn has_default_bytes(&self) -> bool {
        self.default_bytes.is_some()
    }
    /// Sets the value of the [`default_bytes`] field
    ///
    /// [`default_bytes`]: #method.default_bytes
    pub fn set_default_bytes(&mut self, value: ::std::vec::Vec<u8>) {
        self.default_bytes = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`default_bytes`] field, leaving it empty
    ///
    /// [`default_bytes`]: #method.default_bytes
    pub fn take_default_bytes(&mut self) -> ::std::option::Option<::std::vec::Vec<u8>> {
        self.default_bytes.take()
    }
    /// Clears the value of the [`default_bytes`] field
    ///
    /// [`default_bytes`]: #method.default_bytes
    pub fn clear_default_bytes(&mut self) {
        self.default_bytes = ::std::option::Option::None
    }
    /// Gets the field number of the [`default_nested_enum`] field
    ///
    /// [`default_nested_enum`]: #method.default_nested_enum
    pub const DEFAULT_NESTED_ENUM_FIELD_NUMBER: i32 = 81;
    /// A constant value representing the default value of the [`default_nested_enum`] field
    ///
    /// [`default_nested_enum`]: #method.default_nested_enum
    pub const DEFAULT_NESTED_ENUM_DEFAULT_VALUE: ::protrust::EnumValue<self::test_all_types::NestedEnum> = ::protrust::EnumValue::Defined(self::test_all_types::NestedEnum::Bar);
    pub fn default_nested_enum(&self) -> ::protrust::EnumValue<self::test_all_types::NestedEnum> {
        self.default_nested_enum.unwrap_or(Self::DEFAULT_NESTED_ENUM_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`default_nested_enum`] field
    ///
    /// [`default_nested_enum`]: #method.default_nested_enum
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn default_nested_enum_option(&self) -> ::std::option::Option<::protrust::EnumValue<self::test_all_types::NestedEnum>> {
        self.default_nested_enum
    }
    /// Returns a bool indicating the presence of the [`default_nested_enum`] field
    ///
    /// [`default_nested_enum`]: #method.default_nested_enum
    pub fn has_default_nested_enum(&self) -> bool {
        self.default_nested_enum.is_some()
    }
    /// Sets the value of the [`default_nested_enum`] field
    ///
    /// [`default_nested_enum`]: #method.default_nested_enum
    pub fn set_default_nested_enum(&mut self, value: ::protrust::EnumValue<self::test_all_types::NestedEnum>) {
        self.default_nested_enum = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`default_nested_enum`] field
    ///
    /// [`default_nested_enum`]: #method.default_nested_enum
    pub fn clear_default_nested_enum(&mut self) {
        self.default_nested_enum = ::std::option::Option::None
    }
    /// Gets the field number of the [`default_foreign_enum`] field
    ///
    /// [`default_foreign_enum`]: #method.default_foreign_enum
    pub const DEFAULT_FOREIGN_ENUM_FIELD_NUMBER: i32 = 82;
    /// A constant value representing the default value of the [`default_foreign_enum`] field
    ///
    /// [`default_foreign_enum`]: #method.default_foreign_enum
    pub const DEFAULT_FOREIGN_ENUM_DEFAULT_VALUE: ::protrust::EnumValue<self::ForeignEnum> = ::protrust::EnumValue::Defined(self::ForeignEnum::ForeignBar);
    pub fn default_foreign_enum(&self) -> ::protrust::EnumValue<self::ForeignEnum> {
        self.default_foreign_enum.unwrap_or(Self::DEFAULT_FOREIGN_ENUM_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`default_foreign_enum`] field
    ///
    /// [`default_foreign_enum`]: #method.default_foreign_enum
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn default_foreign_enum_option(&self) -> ::std::option::Option<::protrust::EnumValue<self::ForeignEnum>> {
        self.default_foreign_enum
    }
    /// Returns a bool indicating the presence of the [`default_foreign_enum`] field
    ///
    /// [`default_foreign_enum`]: #method.default_foreign_enum
    pub fn has_default_foreign_enum(&self) -> bool {
        self.default_foreign_enum.is_some()
    }
    /// Sets the value of the [`default_foreign_enum`] field
    ///
    /// [`default_foreign_enum`]: #method.default_foreign_enum
    pub fn set_default_foreign_enum(&mut self, value: ::protrust::EnumValue<self::ForeignEnum>) {
        self.default_foreign_enum = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`default_foreign_enum`] field
    ///
    /// [`default_foreign_enum`]: #method.default_foreign_enum
    pub fn clear_default_foreign_enum(&mut self) {
        self.default_foreign_enum = ::std::option::Option::None
    }
    /// Gets the field number of the [`default_import_enum`] field
    ///
    /// [`default_import_enum`]: #method.default_import_enum
    pub const DEFAULT_IMPORT_ENUM_FIELD_NUMBER: i32 = 83;
    /// A constant value representing the default value of the [`default_import_enum`] field
    ///
    /// [`default_import_enum`]: #method.default_import_enum
    pub const DEFAULT_IMPORT_ENUM_DEFAULT_VALUE: ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum> = ::protrust::EnumValue::Defined(self::super::unittest_import_proto::ImportEnum::ImportBar);
    pub fn default_import_enum(&self) -> ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum> {
        self.default_import_enum.unwrap_or(Self::DEFAULT_IMPORT_ENUM_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`default_import_enum`] field
    ///
    /// [`default_import_enum`]: #method.default_import_enum
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn default_import_enum_option(&self) -> ::std::option::Option<::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>> {
        self.default_import_enum
    }
    /// Returns a bool indicating the presence of the [`default_import_enum`] field
    ///
    /// [`default_import_enum`]: #method.default_import_enum
    pub fn has_default_import_enum(&self) -> bool {
        self.default_import_enum.is_some()
    }
    /// Sets the value of the [`default_import_enum`] field
    ///
    /// [`default_import_enum`]: #method.default_import_enum
    pub fn set_default_import_enum(&mut self, value: ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>) {
        self.default_import_enum = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`default_import_enum`] field
    ///
    /// [`default_import_enum`]: #method.default_import_enum
    pub fn clear_default_import_enum(&mut self) {
        self.default_import_enum = ::std::option::Option::None
    }
    /// Gets the field number of the [`default_string_piece`] field
    ///
    /// [`default_string_piece`]: #method.default_string_piece
    pub const DEFAULT_STRING_PIECE_FIELD_NUMBER: i32 = 84;
    /// A constant value representing the default value of the [`default_string_piece`] field
    ///
    /// [`default_string_piece`]: #method.default_string_piece
    pub const DEFAULT_STRING_PIECE_DEFAULT_VALUE: &'static str = "abc";
    pub fn default_string_piece(&self) -> &str {
        self.default_string_piece.as_ref().map(|v| &**v).unwrap_or(Self::DEFAULT_STRING_PIECE_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`default_string_piece`] field
    ///
    /// [`default_string_piece`]: #method.default_string_piece
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn default_string_piece_option(&self) -> ::std::option::Option<&::std::string::String> {
        self.default_string_piece.as_ref()
    }
    /// Returns a unique reference to the [`default_string_piece`] field
    ///
    /// [`default_string_piece`]: #method.default_string_piece
    pub fn default_string_piece_mut(&mut self) -> &mut ::std::string::String {
        self.default_string_piece.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`default_string_piece`] field
    ///
    /// [`default_string_piece`]: #method.default_string_piece
    pub fn has_default_string_piece(&self) -> bool {
        self.default_string_piece.is_some()
    }
    /// Sets the value of the [`default_string_piece`] field
    ///
    /// [`default_string_piece`]: #method.default_string_piece
    pub fn set_default_string_piece(&mut self, value: ::std::string::String) {
        self.default_string_piece = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`default_string_piece`] field, leaving it empty
    ///
    /// [`default_string_piece`]: #method.default_string_piece
    pub fn take_default_string_piece(&mut self) -> ::std::option::Option<::std::string::String> {
        self.default_string_piece.take()
    }
    /// Clears the value of the [`default_string_piece`] field
    ///
    /// [`default_string_piece`]: #method.default_string_piece
    pub fn clear_default_string_piece(&mut self) {
        self.default_string_piece = ::std::option::Option::None
    }
    /// Gets the field number of the [`default_cord`] field
    ///
    /// [`default_cord`]: #method.default_cord
    pub const DEFAULT_CORD_FIELD_NUMBER: i32 = 85;
    /// A constant value representing the default value of the [`default_cord`] field
    ///
    /// [`default_cord`]: #method.default_cord
    pub const DEFAULT_CORD_DEFAULT_VALUE: &'static str = "123";
    pub fn default_cord(&self) -> &str {
        self.default_cord.as_ref().map(|v| &**v).unwrap_or(Self::DEFAULT_CORD_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`default_cord`] field
    ///
    /// [`default_cord`]: #method.default_cord
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn default_cord_option(&self) -> ::std::option::Option<&::std::string::String> {
        self.default_cord.as_ref()
    }
    /// Returns a unique reference to the [`default_cord`] field
    ///
    /// [`default_cord`]: #method.default_cord
    pub fn default_cord_mut(&mut self) -> &mut ::std::string::String {
        self.default_cord.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`default_cord`] field
    ///
    /// [`default_cord`]: #method.default_cord
    pub fn has_default_cord(&self) -> bool {
        self.default_cord.is_some()
    }
    /// Sets the value of the [`default_cord`] field
    ///
    /// [`default_cord`]: #method.default_cord
    pub fn set_default_cord(&mut self, value: ::std::string::String) {
        self.default_cord = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`default_cord`] field, leaving it empty
    ///
    /// [`default_cord`]: #method.default_cord
    pub fn take_default_cord(&mut self) -> ::std::option::Option<::std::string::String> {
        self.default_cord.take()
    }
    /// Clears the value of the [`default_cord`] field
    ///
    /// [`default_cord`]: #method.default_cord
    pub fn clear_default_cord(&mut self) {
        self.default_cord = ::std::option::Option::None
    }
    /// Gets a shared reference to the [`oneof_field`] oneof field
    ///
    /// [`oneof_field`]: enum.OneofField.html
    pub fn oneof_field(&self) -> &self::test_all_types::OneofField {
        &self.oneof_field
    }
    /// Gets a unique reference to the [`oneof_field`] oneof field
    ///
    /// [`oneof_field`]: enum.OneofField.html
    pub fn oneof_field_mut(&mut self) -> &mut self::test_all_types::OneofField {
        &mut self.oneof_field
    }
}
/// This proto includes every type of field in both singular and repeated
/// forms.
pub mod test_all_types {
    #[derive(Clone, Debug, PartialEq)]
    pub struct NestedMessage {
        bb: ::std::option::Option<i32>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::NestedMessage {
        fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.bb = ::std::option::Option::Some(input.read_int32()?),
                    _ => self.unknown_fields.merge_from(tag, input)?
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            let bb = self.bb;
            if let ::std::option::Option::Some(bb) = bb {
                size += 1;
                size += ::protrust::io::sizes::int32(bb);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
            let bb = self.bb;
            if let ::std::option::Option::Some(bb) = bb {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(bb)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
    }
    impl ::protrust::LiteMessage for self::NestedMessage {
        fn new() -> Self {
            Self {
                bb: ::std::option::Option::None,
                unknown_fields: ::protrust::UnknownFieldSet::new(),
            }
        }
        fn merge(&mut self, other: &Self) {
            self.bb = other.bb;
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::NestedMessage {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
            &self::super::file().messages()[0].messages()[0]
        }
    }
    impl self::NestedMessage {
        /// Gets the field number of the [`bb`] field
        ///
        /// [`bb`]: #method.bb
        pub const BB_FIELD_NUMBER: i32 = 1;
        /// A constant value representing the default value of the [`bb`] field
        ///
        /// [`bb`]: #method.bb
        pub const BB_DEFAULT_VALUE: i32 = 0;
        /// The field name "b" fails to compile in proto1 because it conflicts with
        /// a local variable named "b" in one of the generated methods.  Doh.
        /// This file needs to compile in proto1 to test backwards-compatibility.
        pub fn bb(&self) -> i32 {
            self.bb.unwrap_or(Self::BB_DEFAULT_VALUE)
        }
        /// Returns an [`Option`] representing the presence of the [`bb`] field
        ///
        /// [`bb`]: #method.bb
        /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
        pub fn bb_option(&self) -> ::std::option::Option<i32> {
            self.bb
        }
        /// Returns a bool indicating the presence of the [`bb`] field
        ///
        /// [`bb`]: #method.bb
        pub fn has_bb(&self) -> bool {
            self.bb.is_some()
        }
        /// Sets the value of the [`bb`] field
        ///
        /// [`bb`]: #method.bb
        pub fn set_bb(&mut self, value: i32) {
            self.bb = ::std::option::Option::Some(value)
        }
        /// Clears the value of the [`bb`] field
        ///
        /// [`bb`]: #method.bb
        pub fn clear_bb(&mut self) {
            self.bb = ::std::option::Option::None
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    pub struct OptionalGroup {
        a: ::std::option::Option<i32>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::OptionalGroup {
        fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    136 | 138 => self.a = ::std::option::Option::Some(input.read_int32()?),
                    132 => break,
                    _ => self.unknown_fields.merge_from(tag, input)?
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            let a = self.a;
            if let ::std::option::Option::Some(a) = a {
                size += 2;
                size += ::protrust::io::sizes::int32(a);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
            let a = self.a;
            if let ::std::option::Option::Some(a) = a {
                output.write_raw_tag_bytes(&[136, 1])?;
                output.write_int32(a)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
    }
    impl ::protrust::LiteMessage for self::OptionalGroup {
        fn new() -> Self {
            Self {
                a: ::std::option::Option::None,
                unknown_fields: ::protrust::UnknownFieldSet::new(),
            }
        }
        fn merge(&mut self, other: &Self) {
            self.a = other.a;
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::OptionalGroup {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
            &self::super::file().messages()[0].messages()[1]
        }
    }
    impl self::OptionalGroup {
        /// Gets the field number of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub const A_FIELD_NUMBER: i32 = 17;
        /// A constant value representing the default value of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub const A_DEFAULT_VALUE: i32 = 0;
        pub fn a(&self) -> i32 {
            self.a.unwrap_or(Self::A_DEFAULT_VALUE)
        }
        /// Returns an [`Option`] representing the presence of the [`a`] field
        ///
        /// [`a`]: #method.a
        /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
        pub fn a_option(&self) -> ::std::option::Option<i32> {
            self.a
        }
        /// Returns a bool indicating the presence of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub fn has_a(&self) -> bool {
            self.a.is_some()
        }
        /// Sets the value of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub fn set_a(&mut self, value: i32) {
            self.a = ::std::option::Option::Some(value)
        }
        /// Clears the value of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub fn clear_a(&mut self) {
            self.a = ::std::option::Option::None
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    pub struct RepeatedGroup {
        a: ::std::option::Option<i32>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::RepeatedGroup {
        fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    376 | 378 => self.a = ::std::option::Option::Some(input.read_int32()?),
                    372 => break,
                    _ => self.unknown_fields.merge_from(tag, input)?
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            let a = self.a;
            if let ::std::option::Option::Some(a) = a {
                size += 2;
                size += ::protrust::io::sizes::int32(a);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
            let a = self.a;
            if let ::std::option::Option::Some(a) = a {
                output.write_raw_tag_bytes(&[248, 2])?;
                output.write_int32(a)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
    }
    impl ::protrust::LiteMessage for self::RepeatedGroup {
        fn new() -> Self {
            Self {
                a: ::std::option::Option::None,
                unknown_fields: ::protrust::UnknownFieldSet::new(),
            }
        }
        fn merge(&mut self, other: &Self) {
            self.a = other.a;
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::RepeatedGroup {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
            &self::super::file().messages()[0].messages()[2]
        }
    }
    impl self::RepeatedGroup {
        /// Gets the field number of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub const A_FIELD_NUMBER: i32 = 47;
        /// A constant value representing the default value of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub const A_DEFAULT_VALUE: i32 = 0;
        pub fn a(&self) -> i32 {
            self.a.unwrap_or(Self::A_DEFAULT_VALUE)
        }
        /// Returns an [`Option`] representing the presence of the [`a`] field
        ///
        /// [`a`]: #method.a
        /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
        pub fn a_option(&self) -> ::std::option::Option<i32> {
            self.a
        }
        /// Returns a bool indicating the presence of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub fn has_a(&self) -> bool {
            self.a.is_some()
        }
        /// Sets the value of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub fn set_a(&mut self, value: i32) {
            self.a = ::std::option::Option::Some(value)
        }
        /// Clears the value of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub fn clear_a(&mut self) {
            self.a = ::std::option::Option::None
        }
    }
    #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
    pub enum NestedEnum {
        Foo,
        Bar,
        Baz,
        /// Intentionally negative.
        Neg,
    }
    unsafe impl ::protrust::Enum for self::NestedEnum { }
    impl ::std::convert::TryFrom<i32> for self::NestedEnum {
        type Error = ::protrust::VariantUndefinedError;
        fn try_from(value: i32) -> ::std::result::Result<Self, ::protrust::VariantUndefinedError> {
            #[allow(unreachable_patterns)]
            match value {
                1 => ::std::result::Result::Ok(self::NestedEnum::Foo),
                2 => ::std::result::Result::Ok(self::NestedEnum::Bar),
                3 => ::std::result::Result::Ok(self::NestedEnum::Baz),
                -1 => ::std::result::Result::Ok(self::NestedEnum::Neg),
                _ => ::std::result::Result::Err(::protrust::VariantUndefinedError)
            }
        }
    }
    impl ::std::convert::From<self::NestedEnum> for i32 {
        fn from(value: self::NestedEnum) -> i32 {
            match value {
                NestedEnum::Foo => 1,
                NestedEnum::Bar => 2,
                NestedEnum::Baz => 3,
                NestedEnum::Neg => -1,
            }
        }
    }
    /// For oneof test
    #[derive(Clone, Debug, PartialEq)]
    pub enum OneofField {
        /// No value
        None,
        OneofUint32(u32),
        OneofNestedMessage(::std::boxed::Box<self::super::test_all_types::NestedMessage>),
        OneofString(::std::string::String),
        OneofBytes(::std::vec::Vec<u8>),
    }
}
/// This proto includes a recusively nested message.
#[derive(Clone, Debug, PartialEq)]
pub struct NestedTestAllTypes {
    child: ::std::option::Option<::std::boxed::Box<self::NestedTestAllTypes>>,
    payload: ::std::option::Option<::std::boxed::Box<self::TestAllTypes>>,
    repeated_child: ::protrust::collections::RepeatedField<self::NestedTestAllTypes>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
static NESTED_TEST_ALL_TYPES_REPEATED_CHILD_CODEC: ::protrust::Codec<self::NestedTestAllTypes> = ::protrust::Codec::message(26);
impl ::protrust::CodedMessage for self::NestedTestAllTypes {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => input.read_message(&mut **self.child.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                18 => input.read_message(&mut **self.payload.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                26 => self.repeated_child.add_entries(input, &NESTED_TEST_ALL_TYPES_REPEATED_CHILD_CODEC)?,
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let child = &self.child;
        if let ::std::option::Option::Some(child) = child {
            size += 1;
            size += ::protrust::io::sizes::message(&**child);
        }
        let payload = &self.payload;
        if let ::std::option::Option::Some(payload) = payload {
            size += 1;
            size += ::protrust::io::sizes::message(&**payload);
        }
        size += self.repeated_child.calculate_size(&NESTED_TEST_ALL_TYPES_REPEATED_CHILD_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let child = &self.child;
        if let ::std::option::Option::Some(child) = child {
            output.write_raw_tag_bytes(&[10])?;
            output.write_message(&**child)?;
        }
        let payload = &self.payload;
        if let ::std::option::Option::Some(payload) = payload {
            output.write_raw_tag_bytes(&[18])?;
            output.write_message(&**payload)?;
        }
        self.repeated_child.write_to(output, &NESTED_TEST_ALL_TYPES_REPEATED_CHILD_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        if let Some(child) = &self.child {
            if !::protrust::CodedMessage::is_initialized(&**child) {
                return false;
            }
        }
        if let Some(payload) = &self.payload {
            if !::protrust::CodedMessage::is_initialized(&**payload) {
                return false;
            }
        }
        if !self.repeated_child.is_initialized() {
            return false;
        }
        true
    }
}
impl ::protrust::LiteMessage for self::NestedTestAllTypes {
    fn new() -> Self {
        Self {
            child: ::std::option::Option::None,
            payload: ::std::option::Option::None,
            repeated_child: ::protrust::collections::RepeatedField::new(),
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        if let ::std::option::Option::Some(child) = &other.child {
            self.child.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(child);
        }
        if let ::std::option::Option::Some(payload) = &other.payload {
            self.payload.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(payload);
        }
        self.repeated_child.merge(&other.repeated_child);
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::NestedTestAllTypes {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[1]
    }
}
impl self::NestedTestAllTypes {
    /// Gets the field number of the [`child`] field
    ///
    /// [`child`]: #method.child
    pub const CHILD_FIELD_NUMBER: i32 = 1;
    pub fn child_option(&self) -> ::std::option::Option<&self::NestedTestAllTypes> {
        self.child.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`child`] field
    ///
    /// [`child`]: #method.child
    pub fn child_mut(&mut self) -> &mut self::NestedTestAllTypes {
        self.child.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`child`] field
    ///
    /// [`child`]: #method.child
    pub fn has_child(&self) -> bool {
        self.child.is_some()
    }
    /// Sets the value of the [`child`] field
    ///
    /// [`child`]: #method.child
    pub fn set_child(&mut self, value: self::NestedTestAllTypes) {
        self.child = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`child`] field, leaving it empty
    ///
    /// [`child`]: #method.child
    pub fn take_child(&mut self) -> ::std::option::Option<self::NestedTestAllTypes> {
        self.child.take().map(|b| *b)
    }
    /// Clears the value of the [`child`] field
    ///
    /// [`child`]: #method.child
    pub fn clear_child(&mut self) {
        self.child = ::std::option::Option::None
    }
    /// Gets the field number of the [`payload`] field
    ///
    /// [`payload`]: #method.payload
    pub const PAYLOAD_FIELD_NUMBER: i32 = 2;
    pub fn payload_option(&self) -> ::std::option::Option<&self::TestAllTypes> {
        self.payload.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`payload`] field
    ///
    /// [`payload`]: #method.payload
    pub fn payload_mut(&mut self) -> &mut self::TestAllTypes {
        self.payload.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`payload`] field
    ///
    /// [`payload`]: #method.payload
    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }
    /// Sets the value of the [`payload`] field
    ///
    /// [`payload`]: #method.payload
    pub fn set_payload(&mut self, value: self::TestAllTypes) {
        self.payload = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`payload`] field, leaving it empty
    ///
    /// [`payload`]: #method.payload
    pub fn take_payload(&mut self) -> ::std::option::Option<self::TestAllTypes> {
        self.payload.take().map(|b| *b)
    }
    /// Clears the value of the [`payload`] field
    ///
    /// [`payload`]: #method.payload
    pub fn clear_payload(&mut self) {
        self.payload = ::std::option::Option::None
    }
    /// Gets the field number of the [`repeated_child`] field
    ///
    /// [`repeated_child`]: #method.repeated_child
    pub const REPEATED_CHILD_FIELD_NUMBER: i32 = 3;
    pub fn repeated_child(&self) -> &::protrust::collections::RepeatedField<self::NestedTestAllTypes> {
        &self.repeated_child
    }
    /// Returns a unique reference to the [`repeated_child`] field
    ///
    /// [`repeated_child`]: #method.repeated_child
    pub fn repeated_child_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<self::NestedTestAllTypes> {
        &mut self.repeated_child
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct TestDeprecatedFields {
    deprecated_int32: ::std::option::Option<i32>,
    oneof_fields: self::test_deprecated_fields::OneofFields,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::TestDeprecatedFields {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 | 10 => self.deprecated_int32 = ::std::option::Option::Some(input.read_int32()?),
                16 | 18 => self.oneof_fields = self::test_deprecated_fields::OneofFields::DeprecatedInt32InOneof(input.read_int32()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let deprecated_int32 = self.deprecated_int32;
        if let ::std::option::Option::Some(deprecated_int32) = deprecated_int32 {
            size += 1;
            size += ::protrust::io::sizes::int32(deprecated_int32);
        }
        if let self::test_deprecated_fields::OneofFields::DeprecatedInt32InOneof(oneof_fields) = self.oneof_fields {
            size += 1;
            size += ::protrust::io::sizes::int32(oneof_fields);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let deprecated_int32 = self.deprecated_int32;
        if let ::std::option::Option::Some(deprecated_int32) = deprecated_int32 {
            output.write_raw_tag_bytes(&[8])?;
            output.write_int32(deprecated_int32)?;
        }
        if let self::test_deprecated_fields::OneofFields::DeprecatedInt32InOneof(oneof_fields) = self.oneof_fields {
            output.write_raw_tag_bytes(&[16])?;
            output.write_int32(oneof_fields)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::TestDeprecatedFields {
    fn new() -> Self {
        Self {
            deprecated_int32: ::std::option::Option::None,
            oneof_fields: self::test_deprecated_fields::OneofFields::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.deprecated_int32 = other.deprecated_int32;
        if let self::test_deprecated_fields::OneofFields::DeprecatedInt32InOneof(oneof_fields) = other.oneof_fields {
            self.oneof_fields = self::test_deprecated_fields::OneofFields::DeprecatedInt32InOneof(oneof_fields);
        }
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestDeprecatedFields {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[2]
    }
}
impl self::TestDeprecatedFields {
    /// Gets the field number of the [`deprecated_int32`] field
    ///
    /// [`deprecated_int32`]: #method.deprecated_int32
    pub const DEPRECATED_INT32_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`deprecated_int32`] field
    ///
    /// [`deprecated_int32`]: #method.deprecated_int32
    pub const DEPRECATED_INT32_DEFAULT_VALUE: i32 = 0;
    pub fn deprecated_int32(&self) -> i32 {
        self.deprecated_int32.unwrap_or(Self::DEPRECATED_INT32_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`deprecated_int32`] field
    ///
    /// [`deprecated_int32`]: #method.deprecated_int32
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn deprecated_int32_option(&self) -> ::std::option::Option<i32> {
        self.deprecated_int32
    }
    /// Returns a bool indicating the presence of the [`deprecated_int32`] field
    ///
    /// [`deprecated_int32`]: #method.deprecated_int32
    pub fn has_deprecated_int32(&self) -> bool {
        self.deprecated_int32.is_some()
    }
    /// Sets the value of the [`deprecated_int32`] field
    ///
    /// [`deprecated_int32`]: #method.deprecated_int32
    pub fn set_deprecated_int32(&mut self, value: i32) {
        self.deprecated_int32 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`deprecated_int32`] field
    ///
    /// [`deprecated_int32`]: #method.deprecated_int32
    pub fn clear_deprecated_int32(&mut self) {
        self.deprecated_int32 = ::std::option::Option::None
    }
    /// Gets a shared reference to the [`oneof_fields`] oneof field
    ///
    /// [`oneof_fields`]: enum.OneofFields.html
    pub fn oneof_fields(&self) -> &self::test_deprecated_fields::OneofFields {
        &self.oneof_fields
    }
    /// Gets a unique reference to the [`oneof_fields`] oneof field
    ///
    /// [`oneof_fields`]: enum.OneofFields.html
    pub fn oneof_fields_mut(&mut self) -> &mut self::test_deprecated_fields::OneofFields {
        &mut self.oneof_fields
    }
}
pub mod test_deprecated_fields {
    #[derive(Clone, Debug, PartialEq)]
    pub enum OneofFields {
        /// No value
        None,
        DeprecatedInt32InOneof(i32),
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct TestDeprecatedMessage {
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::TestDeprecatedMessage {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::TestDeprecatedMessage {
    fn new() -> Self {
        Self {
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestDeprecatedMessage {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[3]
    }
}
impl self::TestDeprecatedMessage {
}
/// Define these after TestAllTypes to make sure the compiler can handle
/// that.
#[derive(Clone, Debug, PartialEq)]
pub struct ForeignMessage {
    c: ::std::option::Option<i32>,
    d: ::std::option::Option<i32>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::ForeignMessage {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 | 10 => self.c = ::std::option::Option::Some(input.read_int32()?),
                16 | 18 => self.d = ::std::option::Option::Some(input.read_int32()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let c = self.c;
        if let ::std::option::Option::Some(c) = c {
            size += 1;
            size += ::protrust::io::sizes::int32(c);
        }
        let d = self.d;
        if let ::std::option::Option::Some(d) = d {
            size += 1;
            size += ::protrust::io::sizes::int32(d);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let c = self.c;
        if let ::std::option::Option::Some(c) = c {
            output.write_raw_tag_bytes(&[8])?;
            output.write_int32(c)?;
        }
        let d = self.d;
        if let ::std::option::Option::Some(d) = d {
            output.write_raw_tag_bytes(&[16])?;
            output.write_int32(d)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::ForeignMessage {
    fn new() -> Self {
        Self {
            c: ::std::option::Option::None,
            d: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.c = other.c;
        self.d = other.d;
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::ForeignMessage {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[4]
    }
}
impl self::ForeignMessage {
    /// Gets the field number of the [`c`] field
    ///
    /// [`c`]: #method.c
    pub const C_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`c`] field
    ///
    /// [`c`]: #method.c
    pub const C_DEFAULT_VALUE: i32 = 0;
    pub fn c(&self) -> i32 {
        self.c.unwrap_or(Self::C_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`c`] field
    ///
    /// [`c`]: #method.c
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn c_option(&self) -> ::std::option::Option<i32> {
        self.c
    }
    /// Returns a bool indicating the presence of the [`c`] field
    ///
    /// [`c`]: #method.c
    pub fn has_c(&self) -> bool {
        self.c.is_some()
    }
    /// Sets the value of the [`c`] field
    ///
    /// [`c`]: #method.c
    pub fn set_c(&mut self, value: i32) {
        self.c = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`c`] field
    ///
    /// [`c`]: #method.c
    pub fn clear_c(&mut self) {
        self.c = ::std::option::Option::None
    }
    /// Gets the field number of the [`d`] field
    ///
    /// [`d`]: #method.d
    pub const D_FIELD_NUMBER: i32 = 2;
    /// A constant value representing the default value of the [`d`] field
    ///
    /// [`d`]: #method.d
    pub const D_DEFAULT_VALUE: i32 = 0;
    pub fn d(&self) -> i32 {
        self.d.unwrap_or(Self::D_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`d`] field
    ///
    /// [`d`]: #method.d
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn d_option(&self) -> ::std::option::Option<i32> {
        self.d
    }
    /// Returns a bool indicating the presence of the [`d`] field
    ///
    /// [`d`]: #method.d
    pub fn has_d(&self) -> bool {
        self.d.is_some()
    }
    /// Sets the value of the [`d`] field
    ///
    /// [`d`]: #method.d
    pub fn set_d(&mut self, value: i32) {
        self.d = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`d`] field
    ///
    /// [`d`]: #method.d
    pub fn clear_d(&mut self) {
        self.d = ::std::option::Option::None
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct TestReservedFields {
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::TestReservedFields {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::TestReservedFields {
    fn new() -> Self {
        Self {
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestReservedFields {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[5]
    }
}
impl self::TestReservedFields {
}
#[derive(Clone, Debug, PartialEq)]
pub struct TestAllExtensions {
    unknown_fields: ::protrust::UnknownFieldSet,
    extensions: ::protrust::ExtensionSet<Self>,
}
impl ::protrust::CodedMessage for self::TestAllExtensions {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        self.unknown_fields.write_to(output)?;
        self.extensions.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::TestAllExtensions {
    fn new() -> Self {
        Self {
            unknown_fields: ::protrust::UnknownFieldSet::new(),
            extensions: ::protrust::ExtensionSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.unknown_fields.merge(&other.unknown_fields);
        self.extensions.merge(&other.extensions);
    }
}
impl ::protrust::ExtensionMessage for self::TestAllExtensions {
    fn registry(&self) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> { self.extensions.registry() }
    fn replace_registry(&mut self, extensions: ::std::option::Option<&'static ::protrust::ExtensionRegistry>) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> { self.extensions.replace_registry(extensions) }
    fn field<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::cmp::PartialEq<D> + ::std::fmt::Debug + ::std::marker::Sync, D: ::std::fmt::Debug + ::std::marker::Sync>(&self, extension: &'static ::protrust::Extension<Self, V, D>) -> ::std::option::Option<&::protrust::ExtensionField<V, D>> { self.extensions.field(extension) }
    fn field_mut<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::cmp::PartialEq<D> + ::std::fmt::Debug + ::std::marker::Sync, D: ::std::fmt::Debug + ::std::marker::Sync>(&mut self, extension: &'static ::protrust::Extension<Self, V, D>) -> ::std::option::Option<&mut ::protrust::ExtensionField<V, D>> { self.extensions.field_mut(extension) }
    fn repeated_field<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::fmt::Debug + ::std::marker::Sync + 'static>(&self, extension: &'static ::protrust::RepeatedExtension<Self, V>) -> ::std::option::Option<&::protrust::collections::RepeatedField<V>> { self.extensions.repeated_field(extension) }
    fn repeated_field_mut<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::fmt::Debug + ::std::marker::Sync + 'static>(&mut self, extension: &'static ::protrust::RepeatedExtension<Self, V>) -> ::std::option::Option<&mut ::protrust::collections::RepeatedField<V>> { self.extensions.repeated_field_mut(extension) }
}
impl ::protrust::Message for self::TestAllExtensions {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[6]
    }
}
impl self::TestAllExtensions {
}
#[derive(Clone, Debug, PartialEq)]
pub struct OptionalGroup_extension {
    a: ::std::option::Option<i32>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::OptionalGroup_extension {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                136 | 138 => self.a = ::std::option::Option::Some(input.read_int32()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let a = self.a;
        if let ::std::option::Option::Some(a) = a {
            size += 2;
            size += ::protrust::io::sizes::int32(a);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let a = self.a;
        if let ::std::option::Option::Some(a) = a {
            output.write_raw_tag_bytes(&[136, 1])?;
            output.write_int32(a)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::OptionalGroup_extension {
    fn new() -> Self {
        Self {
            a: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.a = other.a;
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::OptionalGroup_extension {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[7]
    }
}
impl self::OptionalGroup_extension {
    /// Gets the field number of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub const A_FIELD_NUMBER: i32 = 17;
    /// A constant value representing the default value of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub const A_DEFAULT_VALUE: i32 = 0;
    pub fn a(&self) -> i32 {
        self.a.unwrap_or(Self::A_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`a`] field
    ///
    /// [`a`]: #method.a
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn a_option(&self) -> ::std::option::Option<i32> {
        self.a
    }
    /// Returns a bool indicating the presence of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub fn has_a(&self) -> bool {
        self.a.is_some()
    }
    /// Sets the value of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub fn set_a(&mut self, value: i32) {
        self.a = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub fn clear_a(&mut self) {
        self.a = ::std::option::Option::None
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct RepeatedGroup_extension {
    a: ::std::option::Option<i32>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::RepeatedGroup_extension {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                376 | 378 => self.a = ::std::option::Option::Some(input.read_int32()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let a = self.a;
        if let ::std::option::Option::Some(a) = a {
            size += 2;
            size += ::protrust::io::sizes::int32(a);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let a = self.a;
        if let ::std::option::Option::Some(a) = a {
            output.write_raw_tag_bytes(&[248, 2])?;
            output.write_int32(a)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::RepeatedGroup_extension {
    fn new() -> Self {
        Self {
            a: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.a = other.a;
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::RepeatedGroup_extension {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[8]
    }
}
impl self::RepeatedGroup_extension {
    /// Gets the field number of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub const A_FIELD_NUMBER: i32 = 47;
    /// A constant value representing the default value of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub const A_DEFAULT_VALUE: i32 = 0;
    pub fn a(&self) -> i32 {
        self.a.unwrap_or(Self::A_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`a`] field
    ///
    /// [`a`]: #method.a
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn a_option(&self) -> ::std::option::Option<i32> {
        self.a
    }
    /// Returns a bool indicating the presence of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub fn has_a(&self) -> bool {
        self.a.is_some()
    }
    /// Sets the value of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub fn set_a(&mut self, value: i32) {
        self.a = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub fn clear_a(&mut self) {
        self.a = ::std::option::Option::None
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct TestGroup {
    optionalgroup: ::std::option::Option<::std::boxed::Box<self::test_group::OptionalGroup>>,
    optional_foreign_enum: ::std::option::Option<::protrust::EnumValue<self::ForeignEnum>>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::TestGroup {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                131 => input.read_group(&mut **self.optionalgroup.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                176 | 178 => self.optional_foreign_enum = ::std::option::Option::Some(input.read_enum_value()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let optionalgroup = &self.optionalgroup;
        if let ::std::option::Option::Some(optionalgroup) = optionalgroup {
            size += 2;
            size += ::protrust::io::sizes::group(&**optionalgroup);
            size += 2;
        }
        let optional_foreign_enum = self.optional_foreign_enum;
        if let ::std::option::Option::Some(optional_foreign_enum) = optional_foreign_enum {
            size += 2;
            size += ::protrust::io::sizes::enum_value(optional_foreign_enum);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let optionalgroup = &self.optionalgroup;
        if let ::std::option::Option::Some(optionalgroup) = optionalgroup {
            output.write_raw_tag_bytes(&[131, 1])?;
            output.write_group(&**optionalgroup)?;
            output.write_raw_tag_bytes(&[132, 1])?;
        }
        let optional_foreign_enum = self.optional_foreign_enum;
        if let ::std::option::Option::Some(optional_foreign_enum) = optional_foreign_enum {
            output.write_raw_tag_bytes(&[176, 1])?;
            output.write_enum_value(optional_foreign_enum)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        if let Some(optionalgroup) = &self.optionalgroup {
            if !::protrust::CodedMessage::is_initialized(&**optionalgroup) {
                return false;
            }
        }
        true
    }
}
impl ::protrust::LiteMessage for self::TestGroup {
    fn new() -> Self {
        Self {
            optionalgroup: ::std::option::Option::None,
            optional_foreign_enum: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        if let ::std::option::Option::Some(optionalgroup) = &other.optionalgroup {
            self.optionalgroup.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(optionalgroup);
        }
        self.optional_foreign_enum = other.optional_foreign_enum;
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestGroup {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[9]
    }
}
impl self::TestGroup {
    /// Gets the field number of the [`optionalgroup`] field
    ///
    /// [`optionalgroup`]: #method.optionalgroup
    pub const OPTIONALGROUP_FIELD_NUMBER: i32 = 16;
    pub fn optionalgroup_option(&self) -> ::std::option::Option<&self::test_group::OptionalGroup> {
        self.optionalgroup.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`optionalgroup`] field
    ///
    /// [`optionalgroup`]: #method.optionalgroup
    pub fn optionalgroup_mut(&mut self) -> &mut self::test_group::OptionalGroup {
        self.optionalgroup.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`optionalgroup`] field
    ///
    /// [`optionalgroup`]: #method.optionalgroup
    pub fn has_optionalgroup(&self) -> bool {
        self.optionalgroup.is_some()
    }
    /// Sets the value of the [`optionalgroup`] field
    ///
    /// [`optionalgroup`]: #method.optionalgroup
    pub fn set_optionalgroup(&mut self, value: self::test_group::OptionalGroup) {
        self.optionalgroup = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`optionalgroup`] field, leaving it empty
    ///
    /// [`optionalgroup`]: #method.optionalgroup
    pub fn take_optionalgroup(&mut self) -> ::std::option::Option<self::test_group::OptionalGroup> {
        self.optionalgroup.take().map(|b| *b)
    }
    /// Clears the value of the [`optionalgroup`] field
    ///
    /// [`optionalgroup`]: #method.optionalgroup
    pub fn clear_optionalgroup(&mut self) {
        self.optionalgroup = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_foreign_enum`] field
    ///
    /// [`optional_foreign_enum`]: #method.optional_foreign_enum
    pub const OPTIONAL_FOREIGN_ENUM_FIELD_NUMBER: i32 = 22;
    /// A constant value representing the default value of the [`optional_foreign_enum`] field
    ///
    /// [`optional_foreign_enum`]: #method.optional_foreign_enum
    pub const OPTIONAL_FOREIGN_ENUM_DEFAULT_VALUE: ::protrust::EnumValue<self::ForeignEnum> = ::protrust::EnumValue::Undefined(0);
    pub fn optional_foreign_enum(&self) -> ::protrust::EnumValue<self::ForeignEnum> {
        self.optional_foreign_enum.unwrap_or(Self::OPTIONAL_FOREIGN_ENUM_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`optional_foreign_enum`] field
    ///
    /// [`optional_foreign_enum`]: #method.optional_foreign_enum
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn optional_foreign_enum_option(&self) -> ::std::option::Option<::protrust::EnumValue<self::ForeignEnum>> {
        self.optional_foreign_enum
    }
    /// Returns a bool indicating the presence of the [`optional_foreign_enum`] field
    ///
    /// [`optional_foreign_enum`]: #method.optional_foreign_enum
    pub fn has_optional_foreign_enum(&self) -> bool {
        self.optional_foreign_enum.is_some()
    }
    /// Sets the value of the [`optional_foreign_enum`] field
    ///
    /// [`optional_foreign_enum`]: #method.optional_foreign_enum
    pub fn set_optional_foreign_enum(&mut self, value: ::protrust::EnumValue<self::ForeignEnum>) {
        self.optional_foreign_enum = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`optional_foreign_enum`] field
    ///
    /// [`optional_foreign_enum`]: #method.optional_foreign_enum
    pub fn clear_optional_foreign_enum(&mut self) {
        self.optional_foreign_enum = ::std::option::Option::None
    }
}
pub mod test_group {
    #[derive(Clone, Debug, PartialEq)]
    pub struct OptionalGroup {
        a: ::std::option::Option<i32>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::OptionalGroup {
        fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    136 | 138 => self.a = ::std::option::Option::Some(input.read_int32()?),
                    132 => break,
                    _ => self.unknown_fields.merge_from(tag, input)?
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            let a = self.a;
            if let ::std::option::Option::Some(a) = a {
                size += 2;
                size += ::protrust::io::sizes::int32(a);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
            let a = self.a;
            if let ::std::option::Option::Some(a) = a {
                output.write_raw_tag_bytes(&[136, 1])?;
                output.write_int32(a)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
    }
    impl ::protrust::LiteMessage for self::OptionalGroup {
        fn new() -> Self {
            Self {
                a: ::std::option::Option::None,
                unknown_fields: ::protrust::UnknownFieldSet::new(),
            }
        }
        fn merge(&mut self, other: &Self) {
            self.a = other.a;
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::OptionalGroup {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
            &self::super::file().messages()[9].messages()[0]
        }
    }
    impl self::OptionalGroup {
        /// Gets the field number of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub const A_FIELD_NUMBER: i32 = 17;
        /// A constant value representing the default value of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub const A_DEFAULT_VALUE: i32 = 0;
        pub fn a(&self) -> i32 {
            self.a.unwrap_or(Self::A_DEFAULT_VALUE)
        }
        /// Returns an [`Option`] representing the presence of the [`a`] field
        ///
        /// [`a`]: #method.a
        /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
        pub fn a_option(&self) -> ::std::option::Option<i32> {
            self.a
        }
        /// Returns a bool indicating the presence of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub fn has_a(&self) -> bool {
            self.a.is_some()
        }
        /// Sets the value of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub fn set_a(&mut self, value: i32) {
            self.a = ::std::option::Option::Some(value)
        }
        /// Clears the value of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub fn clear_a(&mut self) {
            self.a = ::std::option::Option::None
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct TestGroupExtension {
    unknown_fields: ::protrust::UnknownFieldSet,
    extensions: ::protrust::ExtensionSet<Self>,
}
impl ::protrust::CodedMessage for self::TestGroupExtension {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        self.unknown_fields.write_to(output)?;
        self.extensions.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::TestGroupExtension {
    fn new() -> Self {
        Self {
            unknown_fields: ::protrust::UnknownFieldSet::new(),
            extensions: ::protrust::ExtensionSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.unknown_fields.merge(&other.unknown_fields);
        self.extensions.merge(&other.extensions);
    }
}
impl ::protrust::ExtensionMessage for self::TestGroupExtension {
    fn registry(&self) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> { self.extensions.registry() }
    fn replace_registry(&mut self, extensions: ::std::option::Option<&'static ::protrust::ExtensionRegistry>) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> { self.extensions.replace_registry(extensions) }
    fn field<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::cmp::PartialEq<D> + ::std::fmt::Debug + ::std::marker::Sync, D: ::std::fmt::Debug + ::std::marker::Sync>(&self, extension: &'static ::protrust::Extension<Self, V, D>) -> ::std::option::Option<&::protrust::ExtensionField<V, D>> { self.extensions.field(extension) }
    fn field_mut<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::cmp::PartialEq<D> + ::std::fmt::Debug + ::std::marker::Sync, D: ::std::fmt::Debug + ::std::marker::Sync>(&mut self, extension: &'static ::protrust::Extension<Self, V, D>) -> ::std::option::Option<&mut ::protrust::ExtensionField<V, D>> { self.extensions.field_mut(extension) }
    fn repeated_field<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::fmt::Debug + ::std::marker::Sync + 'static>(&self, extension: &'static ::protrust::RepeatedExtension<Self, V>) -> ::std::option::Option<&::protrust::collections::RepeatedField<V>> { self.extensions.repeated_field(extension) }
    fn repeated_field_mut<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::fmt::Debug + ::std::marker::Sync + 'static>(&mut self, extension: &'static ::protrust::RepeatedExtension<Self, V>) -> ::std::option::Option<&mut ::protrust::collections::RepeatedField<V>> { self.extensions.repeated_field_mut(extension) }
}
impl ::protrust::Message for self::TestGroupExtension {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[10]
    }
}
impl self::TestGroupExtension {
}
#[derive(Clone, Debug, PartialEq)]
pub struct TestNestedExtension {
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::TestNestedExtension {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::TestNestedExtension {
    fn new() -> Self {
        Self {
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestNestedExtension {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[11]
    }
}
impl self::TestNestedExtension {
}
pub mod test_nested_extension {
    #[derive(Clone, Debug, PartialEq)]
    pub struct OptionalGroup_extension {
        a: ::std::option::Option<i32>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::OptionalGroup_extension {
        fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    136 | 138 => self.a = ::std::option::Option::Some(input.read_int32()?),
                    _ => self.unknown_fields.merge_from(tag, input)?
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            let a = self.a;
            if let ::std::option::Option::Some(a) = a {
                size += 2;
                size += ::protrust::io::sizes::int32(a);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
            let a = self.a;
            if let ::std::option::Option::Some(a) = a {
                output.write_raw_tag_bytes(&[136, 1])?;
                output.write_int32(a)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
    }
    impl ::protrust::LiteMessage for self::OptionalGroup_extension {
        fn new() -> Self {
            Self {
                a: ::std::option::Option::None,
                unknown_fields: ::protrust::UnknownFieldSet::new(),
            }
        }
        fn merge(&mut self, other: &Self) {
            self.a = other.a;
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::OptionalGroup_extension {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
            &self::super::file().messages()[11].messages()[0]
        }
    }
    impl self::OptionalGroup_extension {
        /// Gets the field number of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub const A_FIELD_NUMBER: i32 = 17;
        /// A constant value representing the default value of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub const A_DEFAULT_VALUE: i32 = 0;
        pub fn a(&self) -> i32 {
            self.a.unwrap_or(Self::A_DEFAULT_VALUE)
        }
        /// Returns an [`Option`] representing the presence of the [`a`] field
        ///
        /// [`a`]: #method.a
        /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
        pub fn a_option(&self) -> ::std::option::Option<i32> {
            self.a
        }
        /// Returns a bool indicating the presence of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub fn has_a(&self) -> bool {
            self.a.is_some()
        }
        /// Sets the value of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub fn set_a(&mut self, value: i32) {
            self.a = ::std::option::Option::Some(value)
        }
        /// Clears the value of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub fn clear_a(&mut self) {
            self.a = ::std::option::Option::None
        }
    }
    /// Check for bug where string extensions declared in tested scope did not
    /// compile.
    pub static TEST: ::protrust::Extension<self::super::TestAllExtensions, ::std::string::String, &'static str> = ::protrust::Extension::string(8018, "test");
    /// Used to test if generated extension name is correct when there are
    /// underscores.
    pub static NESTED_STRING_EXTENSION: ::protrust::Extension<self::super::TestAllExtensions, ::std::string::String, &'static str> = ::protrust::Extension::string(8026, "");
    pub static OPTIONALGROUP_EXTENSION: ::protrust::Extension<self::super::TestGroupExtension, self::super::test_nested_extension::OptionalGroup_extension, self::super::test_nested_extension::OptionalGroup_extension> = ::protrust::Extension::group(131, 132);
    pub static OPTIONAL_FOREIGN_ENUM_EXTENSION: ::protrust::Extension<self::super::TestGroupExtension, ::protrust::EnumValue<self::super::ForeignEnum>, ::protrust::EnumValue<self::super::ForeignEnum>> = ::protrust::Extension::enum_value(176, ::protrust::EnumValue::Undefined(0));
}
/// We have separate messages for testing required fields because it's
/// annoying to have to fill in required fields in TestProto in order to
/// do anything with it.  Note that we don't need to test every type of
/// required filed because the code output is basically identical to
/// optional fields for all types.
#[derive(Clone, Debug, PartialEq)]
pub struct TestRequired {
    a: ::std::option::Option<i32>,
    dummy2: ::std::option::Option<i32>,
    b: ::std::option::Option<i32>,
    dummy4: ::std::option::Option<i32>,
    dummy5: ::std::option::Option<i32>,
    dummy6: ::std::option::Option<i32>,
    dummy7: ::std::option::Option<i32>,
    dummy8: ::std::option::Option<i32>,
    dummy9: ::std::option::Option<i32>,
    dummy10: ::std::option::Option<i32>,
    dummy11: ::std::option::Option<i32>,
    dummy12: ::std::option::Option<i32>,
    dummy13: ::std::option::Option<i32>,
    dummy14: ::std::option::Option<i32>,
    dummy15: ::std::option::Option<i32>,
    dummy16: ::std::option::Option<i32>,
    dummy17: ::std::option::Option<i32>,
    dummy18: ::std::option::Option<i32>,
    dummy19: ::std::option::Option<i32>,
    dummy20: ::std::option::Option<i32>,
    dummy21: ::std::option::Option<i32>,
    dummy22: ::std::option::Option<i32>,
    dummy23: ::std::option::Option<i32>,
    dummy24: ::std::option::Option<i32>,
    dummy25: ::std::option::Option<i32>,
    dummy26: ::std::option::Option<i32>,
    dummy27: ::std::option::Option<i32>,
    dummy28: ::std::option::Option<i32>,
    dummy29: ::std::option::Option<i32>,
    dummy30: ::std::option::Option<i32>,
    dummy31: ::std::option::Option<i32>,
    dummy32: ::std::option::Option<i32>,
    c: ::std::option::Option<i32>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::TestRequired {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 | 10 => self.a = ::std::option::Option::Some(input.read_int32()?),
                16 | 18 => self.dummy2 = ::std::option::Option::Some(input.read_int32()?),
                24 | 26 => self.b = ::std::option::Option::Some(input.read_int32()?),
                32 | 34 => self.dummy4 = ::std::option::Option::Some(input.read_int32()?),
                40 | 42 => self.dummy5 = ::std::option::Option::Some(input.read_int32()?),
                48 | 50 => self.dummy6 = ::std::option::Option::Some(input.read_int32()?),
                56 | 58 => self.dummy7 = ::std::option::Option::Some(input.read_int32()?),
                64 | 66 => self.dummy8 = ::std::option::Option::Some(input.read_int32()?),
                72 | 74 => self.dummy9 = ::std::option::Option::Some(input.read_int32()?),
                80 | 82 => self.dummy10 = ::std::option::Option::Some(input.read_int32()?),
                88 | 90 => self.dummy11 = ::std::option::Option::Some(input.read_int32()?),
                96 | 98 => self.dummy12 = ::std::option::Option::Some(input.read_int32()?),
                104 | 106 => self.dummy13 = ::std::option::Option::Some(input.read_int32()?),
                112 | 114 => self.dummy14 = ::std::option::Option::Some(input.read_int32()?),
                120 | 122 => self.dummy15 = ::std::option::Option::Some(input.read_int32()?),
                128 | 130 => self.dummy16 = ::std::option::Option::Some(input.read_int32()?),
                136 | 138 => self.dummy17 = ::std::option::Option::Some(input.read_int32()?),
                144 | 146 => self.dummy18 = ::std::option::Option::Some(input.read_int32()?),
                152 | 154 => self.dummy19 = ::std::option::Option::Some(input.read_int32()?),
                160 | 162 => self.dummy20 = ::std::option::Option::Some(input.read_int32()?),
                168 | 170 => self.dummy21 = ::std::option::Option::Some(input.read_int32()?),
                176 | 178 => self.dummy22 = ::std::option::Option::Some(input.read_int32()?),
                184 | 186 => self.dummy23 = ::std::option::Option::Some(input.read_int32()?),
                192 | 194 => self.dummy24 = ::std::option::Option::Some(input.read_int32()?),
                200 | 202 => self.dummy25 = ::std::option::Option::Some(input.read_int32()?),
                208 | 210 => self.dummy26 = ::std::option::Option::Some(input.read_int32()?),
                216 | 218 => self.dummy27 = ::std::option::Option::Some(input.read_int32()?),
                224 | 226 => self.dummy28 = ::std::option::Option::Some(input.read_int32()?),
                232 | 234 => self.dummy29 = ::std::option::Option::Some(input.read_int32()?),
                240 | 242 => self.dummy30 = ::std::option::Option::Some(input.read_int32()?),
                248 | 250 => self.dummy31 = ::std::option::Option::Some(input.read_int32()?),
                256 | 258 => self.dummy32 = ::std::option::Option::Some(input.read_int32()?),
                264 | 266 => self.c = ::std::option::Option::Some(input.read_int32()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let a = self.a;
        if let ::std::option::Option::Some(a) = a {
            size += 1;
            size += ::protrust::io::sizes::int32(a);
        }
        let dummy2 = self.dummy2;
        if let ::std::option::Option::Some(dummy2) = dummy2 {
            size += 1;
            size += ::protrust::io::sizes::int32(dummy2);
        }
        let b = self.b;
        if let ::std::option::Option::Some(b) = b {
            size += 1;
            size += ::protrust::io::sizes::int32(b);
        }
        let dummy4 = self.dummy4;
        if let ::std::option::Option::Some(dummy4) = dummy4 {
            size += 1;
            size += ::protrust::io::sizes::int32(dummy4);
        }
        let dummy5 = self.dummy5;
        if let ::std::option::Option::Some(dummy5) = dummy5 {
            size += 1;
            size += ::protrust::io::sizes::int32(dummy5);
        }
        let dummy6 = self.dummy6;
        if let ::std::option::Option::Some(dummy6) = dummy6 {
            size += 1;
            size += ::protrust::io::sizes::int32(dummy6);
        }
        let dummy7 = self.dummy7;
        if let ::std::option::Option::Some(dummy7) = dummy7 {
            size += 1;
            size += ::protrust::io::sizes::int32(dummy7);
        }
        let dummy8 = self.dummy8;
        if let ::std::option::Option::Some(dummy8) = dummy8 {
            size += 1;
            size += ::protrust::io::sizes::int32(dummy8);
        }
        let dummy9 = self.dummy9;
        if let ::std::option::Option::Some(dummy9) = dummy9 {
            size += 1;
            size += ::protrust::io::sizes::int32(dummy9);
        }
        let dummy10 = self.dummy10;
        if let ::std::option::Option::Some(dummy10) = dummy10 {
            size += 1;
            size += ::protrust::io::sizes::int32(dummy10);
        }
        let dummy11 = self.dummy11;
        if let ::std::option::Option::Some(dummy11) = dummy11 {
            size += 1;
            size += ::protrust::io::sizes::int32(dummy11);
        }
        let dummy12 = self.dummy12;
        if let ::std::option::Option::Some(dummy12) = dummy12 {
            size += 1;
            size += ::protrust::io::sizes::int32(dummy12);
        }
        let dummy13 = self.dummy13;
        if let ::std::option::Option::Some(dummy13) = dummy13 {
            size += 1;
            size += ::protrust::io::sizes::int32(dummy13);
        }
        let dummy14 = self.dummy14;
        if let ::std::option::Option::Some(dummy14) = dummy14 {
            size += 1;
            size += ::protrust::io::sizes::int32(dummy14);
        }
        let dummy15 = self.dummy15;
        if let ::std::option::Option::Some(dummy15) = dummy15 {
            size += 1;
            size += ::protrust::io::sizes::int32(dummy15);
        }
        let dummy16 = self.dummy16;
        if let ::std::option::Option::Some(dummy16) = dummy16 {
            size += 2;
            size += ::protrust::io::sizes::int32(dummy16);
        }
        let dummy17 = self.dummy17;
        if let ::std::option::Option::Some(dummy17) = dummy17 {
            size += 2;
            size += ::protrust::io::sizes::int32(dummy17);
        }
        let dummy18 = self.dummy18;
        if let ::std::option::Option::Some(dummy18) = dummy18 {
            size += 2;
            size += ::protrust::io::sizes::int32(dummy18);
        }
        let dummy19 = self.dummy19;
        if let ::std::option::Option::Some(dummy19) = dummy19 {
            size += 2;
            size += ::protrust::io::sizes::int32(dummy19);
        }
        let dummy20 = self.dummy20;
        if let ::std::option::Option::Some(dummy20) = dummy20 {
            size += 2;
            size += ::protrust::io::sizes::int32(dummy20);
        }
        let dummy21 = self.dummy21;
        if let ::std::option::Option::Some(dummy21) = dummy21 {
            size += 2;
            size += ::protrust::io::sizes::int32(dummy21);
        }
        let dummy22 = self.dummy22;
        if let ::std::option::Option::Some(dummy22) = dummy22 {
            size += 2;
            size += ::protrust::io::sizes::int32(dummy22);
        }
        let dummy23 = self.dummy23;
        if let ::std::option::Option::Some(dummy23) = dummy23 {
            size += 2;
            size += ::protrust::io::sizes::int32(dummy23);
        }
        let dummy24 = self.dummy24;
        if let ::std::option::Option::Some(dummy24) = dummy24 {
            size += 2;
            size += ::protrust::io::sizes::int32(dummy24);
        }
        let dummy25 = self.dummy25;
        if let ::std::option::Option::Some(dummy25) = dummy25 {
            size += 2;
            size += ::protrust::io::sizes::int32(dummy25);
        }
        let dummy26 = self.dummy26;
        if let ::std::option::Option::Some(dummy26) = dummy26 {
            size += 2;
            size += ::protrust::io::sizes::int32(dummy26);
        }
        let dummy27 = self.dummy27;
        if let ::std::option::Option::Some(dummy27) = dummy27 {
            size += 2;
            size += ::protrust::io::sizes::int32(dummy27);
        }
        let dummy28 = self.dummy28;
        if let ::std::option::Option::Some(dummy28) = dummy28 {
            size += 2;
            size += ::protrust::io::sizes::int32(dummy28);
        }
        let dummy29 = self.dummy29;
        if let ::std::option::Option::Some(dummy29) = dummy29 {
            size += 2;
            size += ::protrust::io::sizes::int32(dummy29);
        }
        let dummy30 = self.dummy30;
        if let ::std::option::Option::Some(dummy30) = dummy30 {
            size += 2;
            size += ::protrust::io::sizes::int32(dummy30);
        }
        let dummy31 = self.dummy31;
        if let ::std::option::Option::Some(dummy31) = dummy31 {
            size += 2;
            size += ::protrust::io::sizes::int32(dummy31);
        }
        let dummy32 = self.dummy32;
        if let ::std::option::Option::Some(dummy32) = dummy32 {
            size += 2;
            size += ::protrust::io::sizes::int32(dummy32);
        }
        let c = self.c;
        if let ::std::option::Option::Some(c) = c {
            size += 2;
            size += ::protrust::io::sizes::int32(c);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let a = self.a;
        if let ::std::option::Option::Some(a) = a {
            output.write_raw_tag_bytes(&[8])?;
            output.write_int32(a)?;
        }
        let dummy2 = self.dummy2;
        if let ::std::option::Option::Some(dummy2) = dummy2 {
            output.write_raw_tag_bytes(&[16])?;
            output.write_int32(dummy2)?;
        }
        let b = self.b;
        if let ::std::option::Option::Some(b) = b {
            output.write_raw_tag_bytes(&[24])?;
            output.write_int32(b)?;
        }
        let dummy4 = self.dummy4;
        if let ::std::option::Option::Some(dummy4) = dummy4 {
            output.write_raw_tag_bytes(&[32])?;
            output.write_int32(dummy4)?;
        }
        let dummy5 = self.dummy5;
        if let ::std::option::Option::Some(dummy5) = dummy5 {
            output.write_raw_tag_bytes(&[40])?;
            output.write_int32(dummy5)?;
        }
        let dummy6 = self.dummy6;
        if let ::std::option::Option::Some(dummy6) = dummy6 {
            output.write_raw_tag_bytes(&[48])?;
            output.write_int32(dummy6)?;
        }
        let dummy7 = self.dummy7;
        if let ::std::option::Option::Some(dummy7) = dummy7 {
            output.write_raw_tag_bytes(&[56])?;
            output.write_int32(dummy7)?;
        }
        let dummy8 = self.dummy8;
        if let ::std::option::Option::Some(dummy8) = dummy8 {
            output.write_raw_tag_bytes(&[64])?;
            output.write_int32(dummy8)?;
        }
        let dummy9 = self.dummy9;
        if let ::std::option::Option::Some(dummy9) = dummy9 {
            output.write_raw_tag_bytes(&[72])?;
            output.write_int32(dummy9)?;
        }
        let dummy10 = self.dummy10;
        if let ::std::option::Option::Some(dummy10) = dummy10 {
            output.write_raw_tag_bytes(&[80])?;
            output.write_int32(dummy10)?;
        }
        let dummy11 = self.dummy11;
        if let ::std::option::Option::Some(dummy11) = dummy11 {
            output.write_raw_tag_bytes(&[88])?;
            output.write_int32(dummy11)?;
        }
        let dummy12 = self.dummy12;
        if let ::std::option::Option::Some(dummy12) = dummy12 {
            output.write_raw_tag_bytes(&[96])?;
            output.write_int32(dummy12)?;
        }
        let dummy13 = self.dummy13;
        if let ::std::option::Option::Some(dummy13) = dummy13 {
            output.write_raw_tag_bytes(&[104])?;
            output.write_int32(dummy13)?;
        }
        let dummy14 = self.dummy14;
        if let ::std::option::Option::Some(dummy14) = dummy14 {
            output.write_raw_tag_bytes(&[112])?;
            output.write_int32(dummy14)?;
        }
        let dummy15 = self.dummy15;
        if let ::std::option::Option::Some(dummy15) = dummy15 {
            output.write_raw_tag_bytes(&[120])?;
            output.write_int32(dummy15)?;
        }
        let dummy16 = self.dummy16;
        if let ::std::option::Option::Some(dummy16) = dummy16 {
            output.write_raw_tag_bytes(&[128, 1])?;
            output.write_int32(dummy16)?;
        }
        let dummy17 = self.dummy17;
        if let ::std::option::Option::Some(dummy17) = dummy17 {
            output.write_raw_tag_bytes(&[136, 1])?;
            output.write_int32(dummy17)?;
        }
        let dummy18 = self.dummy18;
        if let ::std::option::Option::Some(dummy18) = dummy18 {
            output.write_raw_tag_bytes(&[144, 1])?;
            output.write_int32(dummy18)?;
        }
        let dummy19 = self.dummy19;
        if let ::std::option::Option::Some(dummy19) = dummy19 {
            output.write_raw_tag_bytes(&[152, 1])?;
            output.write_int32(dummy19)?;
        }
        let dummy20 = self.dummy20;
        if let ::std::option::Option::Some(dummy20) = dummy20 {
            output.write_raw_tag_bytes(&[160, 1])?;
            output.write_int32(dummy20)?;
        }
        let dummy21 = self.dummy21;
        if let ::std::option::Option::Some(dummy21) = dummy21 {
            output.write_raw_tag_bytes(&[168, 1])?;
            output.write_int32(dummy21)?;
        }
        let dummy22 = self.dummy22;
        if let ::std::option::Option::Some(dummy22) = dummy22 {
            output.write_raw_tag_bytes(&[176, 1])?;
            output.write_int32(dummy22)?;
        }
        let dummy23 = self.dummy23;
        if let ::std::option::Option::Some(dummy23) = dummy23 {
            output.write_raw_tag_bytes(&[184, 1])?;
            output.write_int32(dummy23)?;
        }
        let dummy24 = self.dummy24;
        if let ::std::option::Option::Some(dummy24) = dummy24 {
            output.write_raw_tag_bytes(&[192, 1])?;
            output.write_int32(dummy24)?;
        }
        let dummy25 = self.dummy25;
        if let ::std::option::Option::Some(dummy25) = dummy25 {
            output.write_raw_tag_bytes(&[200, 1])?;
            output.write_int32(dummy25)?;
        }
        let dummy26 = self.dummy26;
        if let ::std::option::Option::Some(dummy26) = dummy26 {
            output.write_raw_tag_bytes(&[208, 1])?;
            output.write_int32(dummy26)?;
        }
        let dummy27 = self.dummy27;
        if let ::std::option::Option::Some(dummy27) = dummy27 {
            output.write_raw_tag_bytes(&[216, 1])?;
            output.write_int32(dummy27)?;
        }
        let dummy28 = self.dummy28;
        if let ::std::option::Option::Some(dummy28) = dummy28 {
            output.write_raw_tag_bytes(&[224, 1])?;
            output.write_int32(dummy28)?;
        }
        let dummy29 = self.dummy29;
        if let ::std::option::Option::Some(dummy29) = dummy29 {
            output.write_raw_tag_bytes(&[232, 1])?;
            output.write_int32(dummy29)?;
        }
        let dummy30 = self.dummy30;
        if let ::std::option::Option::Some(dummy30) = dummy30 {
            output.write_raw_tag_bytes(&[240, 1])?;
            output.write_int32(dummy30)?;
        }
        let dummy31 = self.dummy31;
        if let ::std::option::Option::Some(dummy31) = dummy31 {
            output.write_raw_tag_bytes(&[248, 1])?;
            output.write_int32(dummy31)?;
        }
        let dummy32 = self.dummy32;
        if let ::std::option::Option::Some(dummy32) = dummy32 {
            output.write_raw_tag_bytes(&[128, 2])?;
            output.write_int32(dummy32)?;
        }
        let c = self.c;
        if let ::std::option::Option::Some(c) = c {
            output.write_raw_tag_bytes(&[136, 2])?;
            output.write_int32(c)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        if self.a.is_none() {
            return false;
        }
        if self.b.is_none() {
            return false;
        }
        if self.c.is_none() {
            return false;
        }
        true
    }
}
impl ::protrust::LiteMessage for self::TestRequired {
    fn new() -> Self {
        Self {
            a: ::std::option::Option::None,
            dummy2: ::std::option::Option::None,
            b: ::std::option::Option::None,
            dummy4: ::std::option::Option::None,
            dummy5: ::std::option::Option::None,
            dummy6: ::std::option::Option::None,
            dummy7: ::std::option::Option::None,
            dummy8: ::std::option::Option::None,
            dummy9: ::std::option::Option::None,
            dummy10: ::std::option::Option::None,
            dummy11: ::std::option::Option::None,
            dummy12: ::std::option::Option::None,
            dummy13: ::std::option::Option::None,
            dummy14: ::std::option::Option::None,
            dummy15: ::std::option::Option::None,
            dummy16: ::std::option::Option::None,
            dummy17: ::std::option::Option::None,
            dummy18: ::std::option::Option::None,
            dummy19: ::std::option::Option::None,
            dummy20: ::std::option::Option::None,
            dummy21: ::std::option::Option::None,
            dummy22: ::std::option::Option::None,
            dummy23: ::std::option::Option::None,
            dummy24: ::std::option::Option::None,
            dummy25: ::std::option::Option::None,
            dummy26: ::std::option::Option::None,
            dummy27: ::std::option::Option::None,
            dummy28: ::std::option::Option::None,
            dummy29: ::std::option::Option::None,
            dummy30: ::std::option::Option::None,
            dummy31: ::std::option::Option::None,
            dummy32: ::std::option::Option::None,
            c: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.a = other.a;
        self.dummy2 = other.dummy2;
        self.b = other.b;
        self.dummy4 = other.dummy4;
        self.dummy5 = other.dummy5;
        self.dummy6 = other.dummy6;
        self.dummy7 = other.dummy7;
        self.dummy8 = other.dummy8;
        self.dummy9 = other.dummy9;
        self.dummy10 = other.dummy10;
        self.dummy11 = other.dummy11;
        self.dummy12 = other.dummy12;
        self.dummy13 = other.dummy13;
        self.dummy14 = other.dummy14;
        self.dummy15 = other.dummy15;
        self.dummy16 = other.dummy16;
        self.dummy17 = other.dummy17;
        self.dummy18 = other.dummy18;
        self.dummy19 = other.dummy19;
        self.dummy20 = other.dummy20;
        self.dummy21 = other.dummy21;
        self.dummy22 = other.dummy22;
        self.dummy23 = other.dummy23;
        self.dummy24 = other.dummy24;
        self.dummy25 = other.dummy25;
        self.dummy26 = other.dummy26;
        self.dummy27 = other.dummy27;
        self.dummy28 = other.dummy28;
        self.dummy29 = other.dummy29;
        self.dummy30 = other.dummy30;
        self.dummy31 = other.dummy31;
        self.dummy32 = other.dummy32;
        self.c = other.c;
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestRequired {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[12]
    }
}
impl self::TestRequired {
    /// Gets the field number of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub const A_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub const A_DEFAULT_VALUE: i32 = 0;
    pub fn a(&self) -> i32 {
        self.a.unwrap_or(Self::A_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`a`] field
    ///
    /// [`a`]: #method.a
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn a_option(&self) -> ::std::option::Option<i32> {
        self.a
    }
    /// Returns a bool indicating the presence of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub fn has_a(&self) -> bool {
        self.a.is_some()
    }
    /// Sets the value of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub fn set_a(&mut self, value: i32) {
        self.a = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub fn clear_a(&mut self) {
        self.a = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy2`] field
    ///
    /// [`dummy2`]: #method.dummy2
    pub const DUMMY2_FIELD_NUMBER: i32 = 2;
    /// A constant value representing the default value of the [`dummy2`] field
    ///
    /// [`dummy2`]: #method.dummy2
    pub const DUMMY2_DEFAULT_VALUE: i32 = 0;
    pub fn dummy2(&self) -> i32 {
        self.dummy2.unwrap_or(Self::DUMMY2_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy2`] field
    ///
    /// [`dummy2`]: #method.dummy2
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy2_option(&self) -> ::std::option::Option<i32> {
        self.dummy2
    }
    /// Returns a bool indicating the presence of the [`dummy2`] field
    ///
    /// [`dummy2`]: #method.dummy2
    pub fn has_dummy2(&self) -> bool {
        self.dummy2.is_some()
    }
    /// Sets the value of the [`dummy2`] field
    ///
    /// [`dummy2`]: #method.dummy2
    pub fn set_dummy2(&mut self, value: i32) {
        self.dummy2 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy2`] field
    ///
    /// [`dummy2`]: #method.dummy2
    pub fn clear_dummy2(&mut self) {
        self.dummy2 = ::std::option::Option::None
    }
    /// Gets the field number of the [`b`] field
    ///
    /// [`b`]: #method.b
    pub const B_FIELD_NUMBER: i32 = 3;
    /// A constant value representing the default value of the [`b`] field
    ///
    /// [`b`]: #method.b
    pub const B_DEFAULT_VALUE: i32 = 0;
    pub fn b(&self) -> i32 {
        self.b.unwrap_or(Self::B_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`b`] field
    ///
    /// [`b`]: #method.b
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn b_option(&self) -> ::std::option::Option<i32> {
        self.b
    }
    /// Returns a bool indicating the presence of the [`b`] field
    ///
    /// [`b`]: #method.b
    pub fn has_b(&self) -> bool {
        self.b.is_some()
    }
    /// Sets the value of the [`b`] field
    ///
    /// [`b`]: #method.b
    pub fn set_b(&mut self, value: i32) {
        self.b = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`b`] field
    ///
    /// [`b`]: #method.b
    pub fn clear_b(&mut self) {
        self.b = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy4`] field
    ///
    /// [`dummy4`]: #method.dummy4
    pub const DUMMY4_FIELD_NUMBER: i32 = 4;
    /// A constant value representing the default value of the [`dummy4`] field
    ///
    /// [`dummy4`]: #method.dummy4
    pub const DUMMY4_DEFAULT_VALUE: i32 = 0;
    /// Pad the field count to 32 so that we can test that IsInitialized()
    /// properly checks multiple elements of has_bits_.
    pub fn dummy4(&self) -> i32 {
        self.dummy4.unwrap_or(Self::DUMMY4_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy4`] field
    ///
    /// [`dummy4`]: #method.dummy4
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy4_option(&self) -> ::std::option::Option<i32> {
        self.dummy4
    }
    /// Returns a bool indicating the presence of the [`dummy4`] field
    ///
    /// [`dummy4`]: #method.dummy4
    pub fn has_dummy4(&self) -> bool {
        self.dummy4.is_some()
    }
    /// Sets the value of the [`dummy4`] field
    ///
    /// [`dummy4`]: #method.dummy4
    pub fn set_dummy4(&mut self, value: i32) {
        self.dummy4 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy4`] field
    ///
    /// [`dummy4`]: #method.dummy4
    pub fn clear_dummy4(&mut self) {
        self.dummy4 = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy5`] field
    ///
    /// [`dummy5`]: #method.dummy5
    pub const DUMMY5_FIELD_NUMBER: i32 = 5;
    /// A constant value representing the default value of the [`dummy5`] field
    ///
    /// [`dummy5`]: #method.dummy5
    pub const DUMMY5_DEFAULT_VALUE: i32 = 0;
    pub fn dummy5(&self) -> i32 {
        self.dummy5.unwrap_or(Self::DUMMY5_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy5`] field
    ///
    /// [`dummy5`]: #method.dummy5
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy5_option(&self) -> ::std::option::Option<i32> {
        self.dummy5
    }
    /// Returns a bool indicating the presence of the [`dummy5`] field
    ///
    /// [`dummy5`]: #method.dummy5
    pub fn has_dummy5(&self) -> bool {
        self.dummy5.is_some()
    }
    /// Sets the value of the [`dummy5`] field
    ///
    /// [`dummy5`]: #method.dummy5
    pub fn set_dummy5(&mut self, value: i32) {
        self.dummy5 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy5`] field
    ///
    /// [`dummy5`]: #method.dummy5
    pub fn clear_dummy5(&mut self) {
        self.dummy5 = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy6`] field
    ///
    /// [`dummy6`]: #method.dummy6
    pub const DUMMY6_FIELD_NUMBER: i32 = 6;
    /// A constant value representing the default value of the [`dummy6`] field
    ///
    /// [`dummy6`]: #method.dummy6
    pub const DUMMY6_DEFAULT_VALUE: i32 = 0;
    pub fn dummy6(&self) -> i32 {
        self.dummy6.unwrap_or(Self::DUMMY6_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy6`] field
    ///
    /// [`dummy6`]: #method.dummy6
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy6_option(&self) -> ::std::option::Option<i32> {
        self.dummy6
    }
    /// Returns a bool indicating the presence of the [`dummy6`] field
    ///
    /// [`dummy6`]: #method.dummy6
    pub fn has_dummy6(&self) -> bool {
        self.dummy6.is_some()
    }
    /// Sets the value of the [`dummy6`] field
    ///
    /// [`dummy6`]: #method.dummy6
    pub fn set_dummy6(&mut self, value: i32) {
        self.dummy6 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy6`] field
    ///
    /// [`dummy6`]: #method.dummy6
    pub fn clear_dummy6(&mut self) {
        self.dummy6 = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy7`] field
    ///
    /// [`dummy7`]: #method.dummy7
    pub const DUMMY7_FIELD_NUMBER: i32 = 7;
    /// A constant value representing the default value of the [`dummy7`] field
    ///
    /// [`dummy7`]: #method.dummy7
    pub const DUMMY7_DEFAULT_VALUE: i32 = 0;
    pub fn dummy7(&self) -> i32 {
        self.dummy7.unwrap_or(Self::DUMMY7_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy7`] field
    ///
    /// [`dummy7`]: #method.dummy7
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy7_option(&self) -> ::std::option::Option<i32> {
        self.dummy7
    }
    /// Returns a bool indicating the presence of the [`dummy7`] field
    ///
    /// [`dummy7`]: #method.dummy7
    pub fn has_dummy7(&self) -> bool {
        self.dummy7.is_some()
    }
    /// Sets the value of the [`dummy7`] field
    ///
    /// [`dummy7`]: #method.dummy7
    pub fn set_dummy7(&mut self, value: i32) {
        self.dummy7 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy7`] field
    ///
    /// [`dummy7`]: #method.dummy7
    pub fn clear_dummy7(&mut self) {
        self.dummy7 = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy8`] field
    ///
    /// [`dummy8`]: #method.dummy8
    pub const DUMMY8_FIELD_NUMBER: i32 = 8;
    /// A constant value representing the default value of the [`dummy8`] field
    ///
    /// [`dummy8`]: #method.dummy8
    pub const DUMMY8_DEFAULT_VALUE: i32 = 0;
    pub fn dummy8(&self) -> i32 {
        self.dummy8.unwrap_or(Self::DUMMY8_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy8`] field
    ///
    /// [`dummy8`]: #method.dummy8
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy8_option(&self) -> ::std::option::Option<i32> {
        self.dummy8
    }
    /// Returns a bool indicating the presence of the [`dummy8`] field
    ///
    /// [`dummy8`]: #method.dummy8
    pub fn has_dummy8(&self) -> bool {
        self.dummy8.is_some()
    }
    /// Sets the value of the [`dummy8`] field
    ///
    /// [`dummy8`]: #method.dummy8
    pub fn set_dummy8(&mut self, value: i32) {
        self.dummy8 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy8`] field
    ///
    /// [`dummy8`]: #method.dummy8
    pub fn clear_dummy8(&mut self) {
        self.dummy8 = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy9`] field
    ///
    /// [`dummy9`]: #method.dummy9
    pub const DUMMY9_FIELD_NUMBER: i32 = 9;
    /// A constant value representing the default value of the [`dummy9`] field
    ///
    /// [`dummy9`]: #method.dummy9
    pub const DUMMY9_DEFAULT_VALUE: i32 = 0;
    pub fn dummy9(&self) -> i32 {
        self.dummy9.unwrap_or(Self::DUMMY9_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy9`] field
    ///
    /// [`dummy9`]: #method.dummy9
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy9_option(&self) -> ::std::option::Option<i32> {
        self.dummy9
    }
    /// Returns a bool indicating the presence of the [`dummy9`] field
    ///
    /// [`dummy9`]: #method.dummy9
    pub fn has_dummy9(&self) -> bool {
        self.dummy9.is_some()
    }
    /// Sets the value of the [`dummy9`] field
    ///
    /// [`dummy9`]: #method.dummy9
    pub fn set_dummy9(&mut self, value: i32) {
        self.dummy9 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy9`] field
    ///
    /// [`dummy9`]: #method.dummy9
    pub fn clear_dummy9(&mut self) {
        self.dummy9 = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy10`] field
    ///
    /// [`dummy10`]: #method.dummy10
    pub const DUMMY10_FIELD_NUMBER: i32 = 10;
    /// A constant value representing the default value of the [`dummy10`] field
    ///
    /// [`dummy10`]: #method.dummy10
    pub const DUMMY10_DEFAULT_VALUE: i32 = 0;
    pub fn dummy10(&self) -> i32 {
        self.dummy10.unwrap_or(Self::DUMMY10_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy10`] field
    ///
    /// [`dummy10`]: #method.dummy10
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy10_option(&self) -> ::std::option::Option<i32> {
        self.dummy10
    }
    /// Returns a bool indicating the presence of the [`dummy10`] field
    ///
    /// [`dummy10`]: #method.dummy10
    pub fn has_dummy10(&self) -> bool {
        self.dummy10.is_some()
    }
    /// Sets the value of the [`dummy10`] field
    ///
    /// [`dummy10`]: #method.dummy10
    pub fn set_dummy10(&mut self, value: i32) {
        self.dummy10 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy10`] field
    ///
    /// [`dummy10`]: #method.dummy10
    pub fn clear_dummy10(&mut self) {
        self.dummy10 = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy11`] field
    ///
    /// [`dummy11`]: #method.dummy11
    pub const DUMMY11_FIELD_NUMBER: i32 = 11;
    /// A constant value representing the default value of the [`dummy11`] field
    ///
    /// [`dummy11`]: #method.dummy11
    pub const DUMMY11_DEFAULT_VALUE: i32 = 0;
    pub fn dummy11(&self) -> i32 {
        self.dummy11.unwrap_or(Self::DUMMY11_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy11`] field
    ///
    /// [`dummy11`]: #method.dummy11
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy11_option(&self) -> ::std::option::Option<i32> {
        self.dummy11
    }
    /// Returns a bool indicating the presence of the [`dummy11`] field
    ///
    /// [`dummy11`]: #method.dummy11
    pub fn has_dummy11(&self) -> bool {
        self.dummy11.is_some()
    }
    /// Sets the value of the [`dummy11`] field
    ///
    /// [`dummy11`]: #method.dummy11
    pub fn set_dummy11(&mut self, value: i32) {
        self.dummy11 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy11`] field
    ///
    /// [`dummy11`]: #method.dummy11
    pub fn clear_dummy11(&mut self) {
        self.dummy11 = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy12`] field
    ///
    /// [`dummy12`]: #method.dummy12
    pub const DUMMY12_FIELD_NUMBER: i32 = 12;
    /// A constant value representing the default value of the [`dummy12`] field
    ///
    /// [`dummy12`]: #method.dummy12
    pub const DUMMY12_DEFAULT_VALUE: i32 = 0;
    pub fn dummy12(&self) -> i32 {
        self.dummy12.unwrap_or(Self::DUMMY12_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy12`] field
    ///
    /// [`dummy12`]: #method.dummy12
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy12_option(&self) -> ::std::option::Option<i32> {
        self.dummy12
    }
    /// Returns a bool indicating the presence of the [`dummy12`] field
    ///
    /// [`dummy12`]: #method.dummy12
    pub fn has_dummy12(&self) -> bool {
        self.dummy12.is_some()
    }
    /// Sets the value of the [`dummy12`] field
    ///
    /// [`dummy12`]: #method.dummy12
    pub fn set_dummy12(&mut self, value: i32) {
        self.dummy12 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy12`] field
    ///
    /// [`dummy12`]: #method.dummy12
    pub fn clear_dummy12(&mut self) {
        self.dummy12 = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy13`] field
    ///
    /// [`dummy13`]: #method.dummy13
    pub const DUMMY13_FIELD_NUMBER: i32 = 13;
    /// A constant value representing the default value of the [`dummy13`] field
    ///
    /// [`dummy13`]: #method.dummy13
    pub const DUMMY13_DEFAULT_VALUE: i32 = 0;
    pub fn dummy13(&self) -> i32 {
        self.dummy13.unwrap_or(Self::DUMMY13_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy13`] field
    ///
    /// [`dummy13`]: #method.dummy13
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy13_option(&self) -> ::std::option::Option<i32> {
        self.dummy13
    }
    /// Returns a bool indicating the presence of the [`dummy13`] field
    ///
    /// [`dummy13`]: #method.dummy13
    pub fn has_dummy13(&self) -> bool {
        self.dummy13.is_some()
    }
    /// Sets the value of the [`dummy13`] field
    ///
    /// [`dummy13`]: #method.dummy13
    pub fn set_dummy13(&mut self, value: i32) {
        self.dummy13 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy13`] field
    ///
    /// [`dummy13`]: #method.dummy13
    pub fn clear_dummy13(&mut self) {
        self.dummy13 = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy14`] field
    ///
    /// [`dummy14`]: #method.dummy14
    pub const DUMMY14_FIELD_NUMBER: i32 = 14;
    /// A constant value representing the default value of the [`dummy14`] field
    ///
    /// [`dummy14`]: #method.dummy14
    pub const DUMMY14_DEFAULT_VALUE: i32 = 0;
    pub fn dummy14(&self) -> i32 {
        self.dummy14.unwrap_or(Self::DUMMY14_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy14`] field
    ///
    /// [`dummy14`]: #method.dummy14
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy14_option(&self) -> ::std::option::Option<i32> {
        self.dummy14
    }
    /// Returns a bool indicating the presence of the [`dummy14`] field
    ///
    /// [`dummy14`]: #method.dummy14
    pub fn has_dummy14(&self) -> bool {
        self.dummy14.is_some()
    }
    /// Sets the value of the [`dummy14`] field
    ///
    /// [`dummy14`]: #method.dummy14
    pub fn set_dummy14(&mut self, value: i32) {
        self.dummy14 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy14`] field
    ///
    /// [`dummy14`]: #method.dummy14
    pub fn clear_dummy14(&mut self) {
        self.dummy14 = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy15`] field
    ///
    /// [`dummy15`]: #method.dummy15
    pub const DUMMY15_FIELD_NUMBER: i32 = 15;
    /// A constant value representing the default value of the [`dummy15`] field
    ///
    /// [`dummy15`]: #method.dummy15
    pub const DUMMY15_DEFAULT_VALUE: i32 = 0;
    pub fn dummy15(&self) -> i32 {
        self.dummy15.unwrap_or(Self::DUMMY15_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy15`] field
    ///
    /// [`dummy15`]: #method.dummy15
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy15_option(&self) -> ::std::option::Option<i32> {
        self.dummy15
    }
    /// Returns a bool indicating the presence of the [`dummy15`] field
    ///
    /// [`dummy15`]: #method.dummy15
    pub fn has_dummy15(&self) -> bool {
        self.dummy15.is_some()
    }
    /// Sets the value of the [`dummy15`] field
    ///
    /// [`dummy15`]: #method.dummy15
    pub fn set_dummy15(&mut self, value: i32) {
        self.dummy15 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy15`] field
    ///
    /// [`dummy15`]: #method.dummy15
    pub fn clear_dummy15(&mut self) {
        self.dummy15 = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy16`] field
    ///
    /// [`dummy16`]: #method.dummy16
    pub const DUMMY16_FIELD_NUMBER: i32 = 16;
    /// A constant value representing the default value of the [`dummy16`] field
    ///
    /// [`dummy16`]: #method.dummy16
    pub const DUMMY16_DEFAULT_VALUE: i32 = 0;
    pub fn dummy16(&self) -> i32 {
        self.dummy16.unwrap_or(Self::DUMMY16_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy16`] field
    ///
    /// [`dummy16`]: #method.dummy16
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy16_option(&self) -> ::std::option::Option<i32> {
        self.dummy16
    }
    /// Returns a bool indicating the presence of the [`dummy16`] field
    ///
    /// [`dummy16`]: #method.dummy16
    pub fn has_dummy16(&self) -> bool {
        self.dummy16.is_some()
    }
    /// Sets the value of the [`dummy16`] field
    ///
    /// [`dummy16`]: #method.dummy16
    pub fn set_dummy16(&mut self, value: i32) {
        self.dummy16 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy16`] field
    ///
    /// [`dummy16`]: #method.dummy16
    pub fn clear_dummy16(&mut self) {
        self.dummy16 = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy17`] field
    ///
    /// [`dummy17`]: #method.dummy17
    pub const DUMMY17_FIELD_NUMBER: i32 = 17;
    /// A constant value representing the default value of the [`dummy17`] field
    ///
    /// [`dummy17`]: #method.dummy17
    pub const DUMMY17_DEFAULT_VALUE: i32 = 0;
    pub fn dummy17(&self) -> i32 {
        self.dummy17.unwrap_or(Self::DUMMY17_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy17`] field
    ///
    /// [`dummy17`]: #method.dummy17
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy17_option(&self) -> ::std::option::Option<i32> {
        self.dummy17
    }
    /// Returns a bool indicating the presence of the [`dummy17`] field
    ///
    /// [`dummy17`]: #method.dummy17
    pub fn has_dummy17(&self) -> bool {
        self.dummy17.is_some()
    }
    /// Sets the value of the [`dummy17`] field
    ///
    /// [`dummy17`]: #method.dummy17
    pub fn set_dummy17(&mut self, value: i32) {
        self.dummy17 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy17`] field
    ///
    /// [`dummy17`]: #method.dummy17
    pub fn clear_dummy17(&mut self) {
        self.dummy17 = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy18`] field
    ///
    /// [`dummy18`]: #method.dummy18
    pub const DUMMY18_FIELD_NUMBER: i32 = 18;
    /// A constant value representing the default value of the [`dummy18`] field
    ///
    /// [`dummy18`]: #method.dummy18
    pub const DUMMY18_DEFAULT_VALUE: i32 = 0;
    pub fn dummy18(&self) -> i32 {
        self.dummy18.unwrap_or(Self::DUMMY18_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy18`] field
    ///
    /// [`dummy18`]: #method.dummy18
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy18_option(&self) -> ::std::option::Option<i32> {
        self.dummy18
    }
    /// Returns a bool indicating the presence of the [`dummy18`] field
    ///
    /// [`dummy18`]: #method.dummy18
    pub fn has_dummy18(&self) -> bool {
        self.dummy18.is_some()
    }
    /// Sets the value of the [`dummy18`] field
    ///
    /// [`dummy18`]: #method.dummy18
    pub fn set_dummy18(&mut self, value: i32) {
        self.dummy18 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy18`] field
    ///
    /// [`dummy18`]: #method.dummy18
    pub fn clear_dummy18(&mut self) {
        self.dummy18 = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy19`] field
    ///
    /// [`dummy19`]: #method.dummy19
    pub const DUMMY19_FIELD_NUMBER: i32 = 19;
    /// A constant value representing the default value of the [`dummy19`] field
    ///
    /// [`dummy19`]: #method.dummy19
    pub const DUMMY19_DEFAULT_VALUE: i32 = 0;
    pub fn dummy19(&self) -> i32 {
        self.dummy19.unwrap_or(Self::DUMMY19_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy19`] field
    ///
    /// [`dummy19`]: #method.dummy19
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy19_option(&self) -> ::std::option::Option<i32> {
        self.dummy19
    }
    /// Returns a bool indicating the presence of the [`dummy19`] field
    ///
    /// [`dummy19`]: #method.dummy19
    pub fn has_dummy19(&self) -> bool {
        self.dummy19.is_some()
    }
    /// Sets the value of the [`dummy19`] field
    ///
    /// [`dummy19`]: #method.dummy19
    pub fn set_dummy19(&mut self, value: i32) {
        self.dummy19 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy19`] field
    ///
    /// [`dummy19`]: #method.dummy19
    pub fn clear_dummy19(&mut self) {
        self.dummy19 = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy20`] field
    ///
    /// [`dummy20`]: #method.dummy20
    pub const DUMMY20_FIELD_NUMBER: i32 = 20;
    /// A constant value representing the default value of the [`dummy20`] field
    ///
    /// [`dummy20`]: #method.dummy20
    pub const DUMMY20_DEFAULT_VALUE: i32 = 0;
    pub fn dummy20(&self) -> i32 {
        self.dummy20.unwrap_or(Self::DUMMY20_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy20`] field
    ///
    /// [`dummy20`]: #method.dummy20
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy20_option(&self) -> ::std::option::Option<i32> {
        self.dummy20
    }
    /// Returns a bool indicating the presence of the [`dummy20`] field
    ///
    /// [`dummy20`]: #method.dummy20
    pub fn has_dummy20(&self) -> bool {
        self.dummy20.is_some()
    }
    /// Sets the value of the [`dummy20`] field
    ///
    /// [`dummy20`]: #method.dummy20
    pub fn set_dummy20(&mut self, value: i32) {
        self.dummy20 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy20`] field
    ///
    /// [`dummy20`]: #method.dummy20
    pub fn clear_dummy20(&mut self) {
        self.dummy20 = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy21`] field
    ///
    /// [`dummy21`]: #method.dummy21
    pub const DUMMY21_FIELD_NUMBER: i32 = 21;
    /// A constant value representing the default value of the [`dummy21`] field
    ///
    /// [`dummy21`]: #method.dummy21
    pub const DUMMY21_DEFAULT_VALUE: i32 = 0;
    pub fn dummy21(&self) -> i32 {
        self.dummy21.unwrap_or(Self::DUMMY21_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy21`] field
    ///
    /// [`dummy21`]: #method.dummy21
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy21_option(&self) -> ::std::option::Option<i32> {
        self.dummy21
    }
    /// Returns a bool indicating the presence of the [`dummy21`] field
    ///
    /// [`dummy21`]: #method.dummy21
    pub fn has_dummy21(&self) -> bool {
        self.dummy21.is_some()
    }
    /// Sets the value of the [`dummy21`] field
    ///
    /// [`dummy21`]: #method.dummy21
    pub fn set_dummy21(&mut self, value: i32) {
        self.dummy21 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy21`] field
    ///
    /// [`dummy21`]: #method.dummy21
    pub fn clear_dummy21(&mut self) {
        self.dummy21 = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy22`] field
    ///
    /// [`dummy22`]: #method.dummy22
    pub const DUMMY22_FIELD_NUMBER: i32 = 22;
    /// A constant value representing the default value of the [`dummy22`] field
    ///
    /// [`dummy22`]: #method.dummy22
    pub const DUMMY22_DEFAULT_VALUE: i32 = 0;
    pub fn dummy22(&self) -> i32 {
        self.dummy22.unwrap_or(Self::DUMMY22_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy22`] field
    ///
    /// [`dummy22`]: #method.dummy22
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy22_option(&self) -> ::std::option::Option<i32> {
        self.dummy22
    }
    /// Returns a bool indicating the presence of the [`dummy22`] field
    ///
    /// [`dummy22`]: #method.dummy22
    pub fn has_dummy22(&self) -> bool {
        self.dummy22.is_some()
    }
    /// Sets the value of the [`dummy22`] field
    ///
    /// [`dummy22`]: #method.dummy22
    pub fn set_dummy22(&mut self, value: i32) {
        self.dummy22 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy22`] field
    ///
    /// [`dummy22`]: #method.dummy22
    pub fn clear_dummy22(&mut self) {
        self.dummy22 = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy23`] field
    ///
    /// [`dummy23`]: #method.dummy23
    pub const DUMMY23_FIELD_NUMBER: i32 = 23;
    /// A constant value representing the default value of the [`dummy23`] field
    ///
    /// [`dummy23`]: #method.dummy23
    pub const DUMMY23_DEFAULT_VALUE: i32 = 0;
    pub fn dummy23(&self) -> i32 {
        self.dummy23.unwrap_or(Self::DUMMY23_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy23`] field
    ///
    /// [`dummy23`]: #method.dummy23
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy23_option(&self) -> ::std::option::Option<i32> {
        self.dummy23
    }
    /// Returns a bool indicating the presence of the [`dummy23`] field
    ///
    /// [`dummy23`]: #method.dummy23
    pub fn has_dummy23(&self) -> bool {
        self.dummy23.is_some()
    }
    /// Sets the value of the [`dummy23`] field
    ///
    /// [`dummy23`]: #method.dummy23
    pub fn set_dummy23(&mut self, value: i32) {
        self.dummy23 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy23`] field
    ///
    /// [`dummy23`]: #method.dummy23
    pub fn clear_dummy23(&mut self) {
        self.dummy23 = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy24`] field
    ///
    /// [`dummy24`]: #method.dummy24
    pub const DUMMY24_FIELD_NUMBER: i32 = 24;
    /// A constant value representing the default value of the [`dummy24`] field
    ///
    /// [`dummy24`]: #method.dummy24
    pub const DUMMY24_DEFAULT_VALUE: i32 = 0;
    pub fn dummy24(&self) -> i32 {
        self.dummy24.unwrap_or(Self::DUMMY24_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy24`] field
    ///
    /// [`dummy24`]: #method.dummy24
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy24_option(&self) -> ::std::option::Option<i32> {
        self.dummy24
    }
    /// Returns a bool indicating the presence of the [`dummy24`] field
    ///
    /// [`dummy24`]: #method.dummy24
    pub fn has_dummy24(&self) -> bool {
        self.dummy24.is_some()
    }
    /// Sets the value of the [`dummy24`] field
    ///
    /// [`dummy24`]: #method.dummy24
    pub fn set_dummy24(&mut self, value: i32) {
        self.dummy24 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy24`] field
    ///
    /// [`dummy24`]: #method.dummy24
    pub fn clear_dummy24(&mut self) {
        self.dummy24 = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy25`] field
    ///
    /// [`dummy25`]: #method.dummy25
    pub const DUMMY25_FIELD_NUMBER: i32 = 25;
    /// A constant value representing the default value of the [`dummy25`] field
    ///
    /// [`dummy25`]: #method.dummy25
    pub const DUMMY25_DEFAULT_VALUE: i32 = 0;
    pub fn dummy25(&self) -> i32 {
        self.dummy25.unwrap_or(Self::DUMMY25_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy25`] field
    ///
    /// [`dummy25`]: #method.dummy25
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy25_option(&self) -> ::std::option::Option<i32> {
        self.dummy25
    }
    /// Returns a bool indicating the presence of the [`dummy25`] field
    ///
    /// [`dummy25`]: #method.dummy25
    pub fn has_dummy25(&self) -> bool {
        self.dummy25.is_some()
    }
    /// Sets the value of the [`dummy25`] field
    ///
    /// [`dummy25`]: #method.dummy25
    pub fn set_dummy25(&mut self, value: i32) {
        self.dummy25 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy25`] field
    ///
    /// [`dummy25`]: #method.dummy25
    pub fn clear_dummy25(&mut self) {
        self.dummy25 = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy26`] field
    ///
    /// [`dummy26`]: #method.dummy26
    pub const DUMMY26_FIELD_NUMBER: i32 = 26;
    /// A constant value representing the default value of the [`dummy26`] field
    ///
    /// [`dummy26`]: #method.dummy26
    pub const DUMMY26_DEFAULT_VALUE: i32 = 0;
    pub fn dummy26(&self) -> i32 {
        self.dummy26.unwrap_or(Self::DUMMY26_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy26`] field
    ///
    /// [`dummy26`]: #method.dummy26
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy26_option(&self) -> ::std::option::Option<i32> {
        self.dummy26
    }
    /// Returns a bool indicating the presence of the [`dummy26`] field
    ///
    /// [`dummy26`]: #method.dummy26
    pub fn has_dummy26(&self) -> bool {
        self.dummy26.is_some()
    }
    /// Sets the value of the [`dummy26`] field
    ///
    /// [`dummy26`]: #method.dummy26
    pub fn set_dummy26(&mut self, value: i32) {
        self.dummy26 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy26`] field
    ///
    /// [`dummy26`]: #method.dummy26
    pub fn clear_dummy26(&mut self) {
        self.dummy26 = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy27`] field
    ///
    /// [`dummy27`]: #method.dummy27
    pub const DUMMY27_FIELD_NUMBER: i32 = 27;
    /// A constant value representing the default value of the [`dummy27`] field
    ///
    /// [`dummy27`]: #method.dummy27
    pub const DUMMY27_DEFAULT_VALUE: i32 = 0;
    pub fn dummy27(&self) -> i32 {
        self.dummy27.unwrap_or(Self::DUMMY27_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy27`] field
    ///
    /// [`dummy27`]: #method.dummy27
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy27_option(&self) -> ::std::option::Option<i32> {
        self.dummy27
    }
    /// Returns a bool indicating the presence of the [`dummy27`] field
    ///
    /// [`dummy27`]: #method.dummy27
    pub fn has_dummy27(&self) -> bool {
        self.dummy27.is_some()
    }
    /// Sets the value of the [`dummy27`] field
    ///
    /// [`dummy27`]: #method.dummy27
    pub fn set_dummy27(&mut self, value: i32) {
        self.dummy27 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy27`] field
    ///
    /// [`dummy27`]: #method.dummy27
    pub fn clear_dummy27(&mut self) {
        self.dummy27 = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy28`] field
    ///
    /// [`dummy28`]: #method.dummy28
    pub const DUMMY28_FIELD_NUMBER: i32 = 28;
    /// A constant value representing the default value of the [`dummy28`] field
    ///
    /// [`dummy28`]: #method.dummy28
    pub const DUMMY28_DEFAULT_VALUE: i32 = 0;
    pub fn dummy28(&self) -> i32 {
        self.dummy28.unwrap_or(Self::DUMMY28_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy28`] field
    ///
    /// [`dummy28`]: #method.dummy28
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy28_option(&self) -> ::std::option::Option<i32> {
        self.dummy28
    }
    /// Returns a bool indicating the presence of the [`dummy28`] field
    ///
    /// [`dummy28`]: #method.dummy28
    pub fn has_dummy28(&self) -> bool {
        self.dummy28.is_some()
    }
    /// Sets the value of the [`dummy28`] field
    ///
    /// [`dummy28`]: #method.dummy28
    pub fn set_dummy28(&mut self, value: i32) {
        self.dummy28 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy28`] field
    ///
    /// [`dummy28`]: #method.dummy28
    pub fn clear_dummy28(&mut self) {
        self.dummy28 = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy29`] field
    ///
    /// [`dummy29`]: #method.dummy29
    pub const DUMMY29_FIELD_NUMBER: i32 = 29;
    /// A constant value representing the default value of the [`dummy29`] field
    ///
    /// [`dummy29`]: #method.dummy29
    pub const DUMMY29_DEFAULT_VALUE: i32 = 0;
    pub fn dummy29(&self) -> i32 {
        self.dummy29.unwrap_or(Self::DUMMY29_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy29`] field
    ///
    /// [`dummy29`]: #method.dummy29
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy29_option(&self) -> ::std::option::Option<i32> {
        self.dummy29
    }
    /// Returns a bool indicating the presence of the [`dummy29`] field
    ///
    /// [`dummy29`]: #method.dummy29
    pub fn has_dummy29(&self) -> bool {
        self.dummy29.is_some()
    }
    /// Sets the value of the [`dummy29`] field
    ///
    /// [`dummy29`]: #method.dummy29
    pub fn set_dummy29(&mut self, value: i32) {
        self.dummy29 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy29`] field
    ///
    /// [`dummy29`]: #method.dummy29
    pub fn clear_dummy29(&mut self) {
        self.dummy29 = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy30`] field
    ///
    /// [`dummy30`]: #method.dummy30
    pub const DUMMY30_FIELD_NUMBER: i32 = 30;
    /// A constant value representing the default value of the [`dummy30`] field
    ///
    /// [`dummy30`]: #method.dummy30
    pub const DUMMY30_DEFAULT_VALUE: i32 = 0;
    pub fn dummy30(&self) -> i32 {
        self.dummy30.unwrap_or(Self::DUMMY30_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy30`] field
    ///
    /// [`dummy30`]: #method.dummy30
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy30_option(&self) -> ::std::option::Option<i32> {
        self.dummy30
    }
    /// Returns a bool indicating the presence of the [`dummy30`] field
    ///
    /// [`dummy30`]: #method.dummy30
    pub fn has_dummy30(&self) -> bool {
        self.dummy30.is_some()
    }
    /// Sets the value of the [`dummy30`] field
    ///
    /// [`dummy30`]: #method.dummy30
    pub fn set_dummy30(&mut self, value: i32) {
        self.dummy30 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy30`] field
    ///
    /// [`dummy30`]: #method.dummy30
    pub fn clear_dummy30(&mut self) {
        self.dummy30 = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy31`] field
    ///
    /// [`dummy31`]: #method.dummy31
    pub const DUMMY31_FIELD_NUMBER: i32 = 31;
    /// A constant value representing the default value of the [`dummy31`] field
    ///
    /// [`dummy31`]: #method.dummy31
    pub const DUMMY31_DEFAULT_VALUE: i32 = 0;
    pub fn dummy31(&self) -> i32 {
        self.dummy31.unwrap_or(Self::DUMMY31_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy31`] field
    ///
    /// [`dummy31`]: #method.dummy31
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy31_option(&self) -> ::std::option::Option<i32> {
        self.dummy31
    }
    /// Returns a bool indicating the presence of the [`dummy31`] field
    ///
    /// [`dummy31`]: #method.dummy31
    pub fn has_dummy31(&self) -> bool {
        self.dummy31.is_some()
    }
    /// Sets the value of the [`dummy31`] field
    ///
    /// [`dummy31`]: #method.dummy31
    pub fn set_dummy31(&mut self, value: i32) {
        self.dummy31 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy31`] field
    ///
    /// [`dummy31`]: #method.dummy31
    pub fn clear_dummy31(&mut self) {
        self.dummy31 = ::std::option::Option::None
    }
    /// Gets the field number of the [`dummy32`] field
    ///
    /// [`dummy32`]: #method.dummy32
    pub const DUMMY32_FIELD_NUMBER: i32 = 32;
    /// A constant value representing the default value of the [`dummy32`] field
    ///
    /// [`dummy32`]: #method.dummy32
    pub const DUMMY32_DEFAULT_VALUE: i32 = 0;
    pub fn dummy32(&self) -> i32 {
        self.dummy32.unwrap_or(Self::DUMMY32_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy32`] field
    ///
    /// [`dummy32`]: #method.dummy32
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy32_option(&self) -> ::std::option::Option<i32> {
        self.dummy32
    }
    /// Returns a bool indicating the presence of the [`dummy32`] field
    ///
    /// [`dummy32`]: #method.dummy32
    pub fn has_dummy32(&self) -> bool {
        self.dummy32.is_some()
    }
    /// Sets the value of the [`dummy32`] field
    ///
    /// [`dummy32`]: #method.dummy32
    pub fn set_dummy32(&mut self, value: i32) {
        self.dummy32 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy32`] field
    ///
    /// [`dummy32`]: #method.dummy32
    pub fn clear_dummy32(&mut self) {
        self.dummy32 = ::std::option::Option::None
    }
    /// Gets the field number of the [`c`] field
    ///
    /// [`c`]: #method.c
    pub const C_FIELD_NUMBER: i32 = 33;
    /// A constant value representing the default value of the [`c`] field
    ///
    /// [`c`]: #method.c
    pub const C_DEFAULT_VALUE: i32 = 0;
    pub fn c(&self) -> i32 {
        self.c.unwrap_or(Self::C_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`c`] field
    ///
    /// [`c`]: #method.c
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn c_option(&self) -> ::std::option::Option<i32> {
        self.c
    }
    /// Returns a bool indicating the presence of the [`c`] field
    ///
    /// [`c`]: #method.c
    pub fn has_c(&self) -> bool {
        self.c.is_some()
    }
    /// Sets the value of the [`c`] field
    ///
    /// [`c`]: #method.c
    pub fn set_c(&mut self, value: i32) {
        self.c = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`c`] field
    ///
    /// [`c`]: #method.c
    pub fn clear_c(&mut self) {
        self.c = ::std::option::Option::None
    }
}
/// We have separate messages for testing required fields because it's
/// annoying to have to fill in required fields in TestProto in order to
/// do anything with it.  Note that we don't need to test every type of
/// required filed because the code output is basically identical to
/// optional fields for all types.
pub mod test_required {
    pub static SINGLE: ::protrust::Extension<self::super::TestAllExtensions, self::super::TestRequired, self::super::TestRequired> = ::protrust::Extension::message(8002);
    pub static MULTI: ::protrust::RepeatedExtension<self::super::TestAllExtensions, self::super::TestRequired> = ::protrust::RepeatedExtension::message(8010);
}
#[derive(Clone, Debug, PartialEq)]
pub struct TestRequiredForeign {
    optional_message: ::std::option::Option<::std::boxed::Box<self::TestRequired>>,
    repeated_message: ::protrust::collections::RepeatedField<self::TestRequired>,
    dummy: ::std::option::Option<i32>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
static TEST_REQUIRED_FOREIGN_REPEATED_MESSAGE_CODEC: ::protrust::Codec<self::TestRequired> = ::protrust::Codec::message(18);
impl ::protrust::CodedMessage for self::TestRequiredForeign {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => input.read_message(&mut **self.optional_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                18 => self.repeated_message.add_entries(input, &TEST_REQUIRED_FOREIGN_REPEATED_MESSAGE_CODEC)?,
                24 | 26 => self.dummy = ::std::option::Option::Some(input.read_int32()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let optional_message = &self.optional_message;
        if let ::std::option::Option::Some(optional_message) = optional_message {
            size += 1;
            size += ::protrust::io::sizes::message(&**optional_message);
        }
        size += self.repeated_message.calculate_size(&TEST_REQUIRED_FOREIGN_REPEATED_MESSAGE_CODEC);
        let dummy = self.dummy;
        if let ::std::option::Option::Some(dummy) = dummy {
            size += 1;
            size += ::protrust::io::sizes::int32(dummy);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let optional_message = &self.optional_message;
        if let ::std::option::Option::Some(optional_message) = optional_message {
            output.write_raw_tag_bytes(&[10])?;
            output.write_message(&**optional_message)?;
        }
        self.repeated_message.write_to(output, &TEST_REQUIRED_FOREIGN_REPEATED_MESSAGE_CODEC)?;
        let dummy = self.dummy;
        if let ::std::option::Option::Some(dummy) = dummy {
            output.write_raw_tag_bytes(&[24])?;
            output.write_int32(dummy)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        if let Some(optional_message) = &self.optional_message {
            if !::protrust::CodedMessage::is_initialized(&**optional_message) {
                return false;
            }
        }
        if !self.repeated_message.is_initialized() {
            return false;
        }
        true
    }
}
impl ::protrust::LiteMessage for self::TestRequiredForeign {
    fn new() -> Self {
        Self {
            optional_message: ::std::option::Option::None,
            repeated_message: ::protrust::collections::RepeatedField::new(),
            dummy: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        if let ::std::option::Option::Some(optional_message) = &other.optional_message {
            self.optional_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(optional_message);
        }
        self.repeated_message.merge(&other.repeated_message);
        self.dummy = other.dummy;
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestRequiredForeign {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[13]
    }
}
impl self::TestRequiredForeign {
    /// Gets the field number of the [`optional_message`] field
    ///
    /// [`optional_message`]: #method.optional_message
    pub const OPTIONAL_MESSAGE_FIELD_NUMBER: i32 = 1;
    pub fn optional_message_option(&self) -> ::std::option::Option<&self::TestRequired> {
        self.optional_message.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`optional_message`] field
    ///
    /// [`optional_message`]: #method.optional_message
    pub fn optional_message_mut(&mut self) -> &mut self::TestRequired {
        self.optional_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`optional_message`] field
    ///
    /// [`optional_message`]: #method.optional_message
    pub fn has_optional_message(&self) -> bool {
        self.optional_message.is_some()
    }
    /// Sets the value of the [`optional_message`] field
    ///
    /// [`optional_message`]: #method.optional_message
    pub fn set_optional_message(&mut self, value: self::TestRequired) {
        self.optional_message = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`optional_message`] field, leaving it empty
    ///
    /// [`optional_message`]: #method.optional_message
    pub fn take_optional_message(&mut self) -> ::std::option::Option<self::TestRequired> {
        self.optional_message.take().map(|b| *b)
    }
    /// Clears the value of the [`optional_message`] field
    ///
    /// [`optional_message`]: #method.optional_message
    pub fn clear_optional_message(&mut self) {
        self.optional_message = ::std::option::Option::None
    }
    /// Gets the field number of the [`repeated_message`] field
    ///
    /// [`repeated_message`]: #method.repeated_message
    pub const REPEATED_MESSAGE_FIELD_NUMBER: i32 = 2;
    pub fn repeated_message(&self) -> &::protrust::collections::RepeatedField<self::TestRequired> {
        &self.repeated_message
    }
    /// Returns a unique reference to the [`repeated_message`] field
    ///
    /// [`repeated_message`]: #method.repeated_message
    pub fn repeated_message_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<self::TestRequired> {
        &mut self.repeated_message
    }
    /// Gets the field number of the [`dummy`] field
    ///
    /// [`dummy`]: #method.dummy
    pub const DUMMY_FIELD_NUMBER: i32 = 3;
    /// A constant value representing the default value of the [`dummy`] field
    ///
    /// [`dummy`]: #method.dummy
    pub const DUMMY_DEFAULT_VALUE: i32 = 0;
    pub fn dummy(&self) -> i32 {
        self.dummy.unwrap_or(Self::DUMMY_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dummy`] field
    ///
    /// [`dummy`]: #method.dummy
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dummy_option(&self) -> ::std::option::Option<i32> {
        self.dummy
    }
    /// Returns a bool indicating the presence of the [`dummy`] field
    ///
    /// [`dummy`]: #method.dummy
    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }
    /// Sets the value of the [`dummy`] field
    ///
    /// [`dummy`]: #method.dummy
    pub fn set_dummy(&mut self, value: i32) {
        self.dummy = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dummy`] field
    ///
    /// [`dummy`]: #method.dummy
    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct TestRequiredMessage {
    optional_message: ::std::option::Option<::std::boxed::Box<self::TestRequired>>,
    repeated_message: ::protrust::collections::RepeatedField<self::TestRequired>,
    required_message: ::std::option::Option<::std::boxed::Box<self::TestRequired>>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
static TEST_REQUIRED_MESSAGE_REPEATED_MESSAGE_CODEC: ::protrust::Codec<self::TestRequired> = ::protrust::Codec::message(18);
impl ::protrust::CodedMessage for self::TestRequiredMessage {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => input.read_message(&mut **self.optional_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                18 => self.repeated_message.add_entries(input, &TEST_REQUIRED_MESSAGE_REPEATED_MESSAGE_CODEC)?,
                26 => input.read_message(&mut **self.required_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let optional_message = &self.optional_message;
        if let ::std::option::Option::Some(optional_message) = optional_message {
            size += 1;
            size += ::protrust::io::sizes::message(&**optional_message);
        }
        size += self.repeated_message.calculate_size(&TEST_REQUIRED_MESSAGE_REPEATED_MESSAGE_CODEC);
        let required_message = &self.required_message;
        if let ::std::option::Option::Some(required_message) = required_message {
            size += 1;
            size += ::protrust::io::sizes::message(&**required_message);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let optional_message = &self.optional_message;
        if let ::std::option::Option::Some(optional_message) = optional_message {
            output.write_raw_tag_bytes(&[10])?;
            output.write_message(&**optional_message)?;
        }
        self.repeated_message.write_to(output, &TEST_REQUIRED_MESSAGE_REPEATED_MESSAGE_CODEC)?;
        let required_message = &self.required_message;
        if let ::std::option::Option::Some(required_message) = required_message {
            output.write_raw_tag_bytes(&[26])?;
            output.write_message(&**required_message)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        if let Some(optional_message) = &self.optional_message {
            if !::protrust::CodedMessage::is_initialized(&**optional_message) {
                return false;
            }
        }
        if !self.repeated_message.is_initialized() {
            return false;
        }
        if let Some(required_message) = &self.required_message {
            if !::protrust::CodedMessage::is_initialized(&**required_message) {
                return false;
            }
        }
        true
    }
}
impl ::protrust::LiteMessage for self::TestRequiredMessage {
    fn new() -> Self {
        Self {
            optional_message: ::std::option::Option::None,
            repeated_message: ::protrust::collections::RepeatedField::new(),
            required_message: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        if let ::std::option::Option::Some(optional_message) = &other.optional_message {
            self.optional_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(optional_message);
        }
        self.repeated_message.merge(&other.repeated_message);
        if let ::std::option::Option::Some(required_message) = &other.required_message {
            self.required_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(required_message);
        }
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestRequiredMessage {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[14]
    }
}
impl self::TestRequiredMessage {
    /// Gets the field number of the [`optional_message`] field
    ///
    /// [`optional_message`]: #method.optional_message
    pub const OPTIONAL_MESSAGE_FIELD_NUMBER: i32 = 1;
    pub fn optional_message_option(&self) -> ::std::option::Option<&self::TestRequired> {
        self.optional_message.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`optional_message`] field
    ///
    /// [`optional_message`]: #method.optional_message
    pub fn optional_message_mut(&mut self) -> &mut self::TestRequired {
        self.optional_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`optional_message`] field
    ///
    /// [`optional_message`]: #method.optional_message
    pub fn has_optional_message(&self) -> bool {
        self.optional_message.is_some()
    }
    /// Sets the value of the [`optional_message`] field
    ///
    /// [`optional_message`]: #method.optional_message
    pub fn set_optional_message(&mut self, value: self::TestRequired) {
        self.optional_message = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`optional_message`] field, leaving it empty
    ///
    /// [`optional_message`]: #method.optional_message
    pub fn take_optional_message(&mut self) -> ::std::option::Option<self::TestRequired> {
        self.optional_message.take().map(|b| *b)
    }
    /// Clears the value of the [`optional_message`] field
    ///
    /// [`optional_message`]: #method.optional_message
    pub fn clear_optional_message(&mut self) {
        self.optional_message = ::std::option::Option::None
    }
    /// Gets the field number of the [`repeated_message`] field
    ///
    /// [`repeated_message`]: #method.repeated_message
    pub const REPEATED_MESSAGE_FIELD_NUMBER: i32 = 2;
    pub fn repeated_message(&self) -> &::protrust::collections::RepeatedField<self::TestRequired> {
        &self.repeated_message
    }
    /// Returns a unique reference to the [`repeated_message`] field
    ///
    /// [`repeated_message`]: #method.repeated_message
    pub fn repeated_message_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<self::TestRequired> {
        &mut self.repeated_message
    }
    /// Gets the field number of the [`required_message`] field
    ///
    /// [`required_message`]: #method.required_message
    pub const REQUIRED_MESSAGE_FIELD_NUMBER: i32 = 3;
    pub fn required_message_option(&self) -> ::std::option::Option<&self::TestRequired> {
        self.required_message.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`required_message`] field
    ///
    /// [`required_message`]: #method.required_message
    pub fn required_message_mut(&mut self) -> &mut self::TestRequired {
        self.required_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`required_message`] field
    ///
    /// [`required_message`]: #method.required_message
    pub fn has_required_message(&self) -> bool {
        self.required_message.is_some()
    }
    /// Sets the value of the [`required_message`] field
    ///
    /// [`required_message`]: #method.required_message
    pub fn set_required_message(&mut self, value: self::TestRequired) {
        self.required_message = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`required_message`] field, leaving it empty
    ///
    /// [`required_message`]: #method.required_message
    pub fn take_required_message(&mut self) -> ::std::option::Option<self::TestRequired> {
        self.required_message.take().map(|b| *b)
    }
    /// Clears the value of the [`required_message`] field
    ///
    /// [`required_message`]: #method.required_message
    pub fn clear_required_message(&mut self) {
        self.required_message = ::std::option::Option::None
    }
}
/// Test that we can use NestedMessage from outside TestAllTypes.
#[derive(Clone, Debug, PartialEq)]
pub struct TestForeignNested {
    foreign_nested: ::std::option::Option<::std::boxed::Box<self::test_all_types::NestedMessage>>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::TestForeignNested {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => input.read_message(&mut **self.foreign_nested.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let foreign_nested = &self.foreign_nested;
        if let ::std::option::Option::Some(foreign_nested) = foreign_nested {
            size += 1;
            size += ::protrust::io::sizes::message(&**foreign_nested);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let foreign_nested = &self.foreign_nested;
        if let ::std::option::Option::Some(foreign_nested) = foreign_nested {
            output.write_raw_tag_bytes(&[10])?;
            output.write_message(&**foreign_nested)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        if let Some(foreign_nested) = &self.foreign_nested {
            if !::protrust::CodedMessage::is_initialized(&**foreign_nested) {
                return false;
            }
        }
        true
    }
}
impl ::protrust::LiteMessage for self::TestForeignNested {
    fn new() -> Self {
        Self {
            foreign_nested: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        if let ::std::option::Option::Some(foreign_nested) = &other.foreign_nested {
            self.foreign_nested.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(foreign_nested);
        }
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestForeignNested {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[15]
    }
}
impl self::TestForeignNested {
    /// Gets the field number of the [`foreign_nested`] field
    ///
    /// [`foreign_nested`]: #method.foreign_nested
    pub const FOREIGN_NESTED_FIELD_NUMBER: i32 = 1;
    pub fn foreign_nested_option(&self) -> ::std::option::Option<&self::test_all_types::NestedMessage> {
        self.foreign_nested.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`foreign_nested`] field
    ///
    /// [`foreign_nested`]: #method.foreign_nested
    pub fn foreign_nested_mut(&mut self) -> &mut self::test_all_types::NestedMessage {
        self.foreign_nested.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`foreign_nested`] field
    ///
    /// [`foreign_nested`]: #method.foreign_nested
    pub fn has_foreign_nested(&self) -> bool {
        self.foreign_nested.is_some()
    }
    /// Sets the value of the [`foreign_nested`] field
    ///
    /// [`foreign_nested`]: #method.foreign_nested
    pub fn set_foreign_nested(&mut self, value: self::test_all_types::NestedMessage) {
        self.foreign_nested = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`foreign_nested`] field, leaving it empty
    ///
    /// [`foreign_nested`]: #method.foreign_nested
    pub fn take_foreign_nested(&mut self) -> ::std::option::Option<self::test_all_types::NestedMessage> {
        self.foreign_nested.take().map(|b| *b)
    }
    /// Clears the value of the [`foreign_nested`] field
    ///
    /// [`foreign_nested`]: #method.foreign_nested
    pub fn clear_foreign_nested(&mut self) {
        self.foreign_nested = ::std::option::Option::None
    }
}
/// TestEmptyMessage is used to test unknown field support.
#[derive(Clone, Debug, PartialEq)]
pub struct TestEmptyMessage {
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::TestEmptyMessage {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::TestEmptyMessage {
    fn new() -> Self {
        Self {
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestEmptyMessage {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[16]
    }
}
impl self::TestEmptyMessage {
}
/// Like above, but declare all field numbers as potential extensions.  No
/// actual extensions should ever be defined for this type.
#[derive(Clone, Debug, PartialEq)]
pub struct TestEmptyMessageWithExtensions {
    unknown_fields: ::protrust::UnknownFieldSet,
    extensions: ::protrust::ExtensionSet<Self>,
}
impl ::protrust::CodedMessage for self::TestEmptyMessageWithExtensions {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        self.unknown_fields.write_to(output)?;
        self.extensions.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::TestEmptyMessageWithExtensions {
    fn new() -> Self {
        Self {
            unknown_fields: ::protrust::UnknownFieldSet::new(),
            extensions: ::protrust::ExtensionSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.unknown_fields.merge(&other.unknown_fields);
        self.extensions.merge(&other.extensions);
    }
}
impl ::protrust::ExtensionMessage for self::TestEmptyMessageWithExtensions {
    fn registry(&self) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> { self.extensions.registry() }
    fn replace_registry(&mut self, extensions: ::std::option::Option<&'static ::protrust::ExtensionRegistry>) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> { self.extensions.replace_registry(extensions) }
    fn field<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::cmp::PartialEq<D> + ::std::fmt::Debug + ::std::marker::Sync, D: ::std::fmt::Debug + ::std::marker::Sync>(&self, extension: &'static ::protrust::Extension<Self, V, D>) -> ::std::option::Option<&::protrust::ExtensionField<V, D>> { self.extensions.field(extension) }
    fn field_mut<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::cmp::PartialEq<D> + ::std::fmt::Debug + ::std::marker::Sync, D: ::std::fmt::Debug + ::std::marker::Sync>(&mut self, extension: &'static ::protrust::Extension<Self, V, D>) -> ::std::option::Option<&mut ::protrust::ExtensionField<V, D>> { self.extensions.field_mut(extension) }
    fn repeated_field<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::fmt::Debug + ::std::marker::Sync + 'static>(&self, extension: &'static ::protrust::RepeatedExtension<Self, V>) -> ::std::option::Option<&::protrust::collections::RepeatedField<V>> { self.extensions.repeated_field(extension) }
    fn repeated_field_mut<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::fmt::Debug + ::std::marker::Sync + 'static>(&mut self, extension: &'static ::protrust::RepeatedExtension<Self, V>) -> ::std::option::Option<&mut ::protrust::collections::RepeatedField<V>> { self.extensions.repeated_field_mut(extension) }
}
impl ::protrust::Message for self::TestEmptyMessageWithExtensions {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[17]
    }
}
impl self::TestEmptyMessageWithExtensions {
}
#[derive(Clone, Debug, PartialEq)]
pub struct TestMultipleExtensionRanges {
    unknown_fields: ::protrust::UnknownFieldSet,
    extensions: ::protrust::ExtensionSet<Self>,
}
impl ::protrust::CodedMessage for self::TestMultipleExtensionRanges {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        self.unknown_fields.write_to(output)?;
        self.extensions.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::TestMultipleExtensionRanges {
    fn new() -> Self {
        Self {
            unknown_fields: ::protrust::UnknownFieldSet::new(),
            extensions: ::protrust::ExtensionSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.unknown_fields.merge(&other.unknown_fields);
        self.extensions.merge(&other.extensions);
    }
}
impl ::protrust::ExtensionMessage for self::TestMultipleExtensionRanges {
    fn registry(&self) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> { self.extensions.registry() }
    fn replace_registry(&mut self, extensions: ::std::option::Option<&'static ::protrust::ExtensionRegistry>) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> { self.extensions.replace_registry(extensions) }
    fn field<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::cmp::PartialEq<D> + ::std::fmt::Debug + ::std::marker::Sync, D: ::std::fmt::Debug + ::std::marker::Sync>(&self, extension: &'static ::protrust::Extension<Self, V, D>) -> ::std::option::Option<&::protrust::ExtensionField<V, D>> { self.extensions.field(extension) }
    fn field_mut<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::cmp::PartialEq<D> + ::std::fmt::Debug + ::std::marker::Sync, D: ::std::fmt::Debug + ::std::marker::Sync>(&mut self, extension: &'static ::protrust::Extension<Self, V, D>) -> ::std::option::Option<&mut ::protrust::ExtensionField<V, D>> { self.extensions.field_mut(extension) }
    fn repeated_field<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::fmt::Debug + ::std::marker::Sync + 'static>(&self, extension: &'static ::protrust::RepeatedExtension<Self, V>) -> ::std::option::Option<&::protrust::collections::RepeatedField<V>> { self.extensions.repeated_field(extension) }
    fn repeated_field_mut<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::fmt::Debug + ::std::marker::Sync + 'static>(&mut self, extension: &'static ::protrust::RepeatedExtension<Self, V>) -> ::std::option::Option<&mut ::protrust::collections::RepeatedField<V>> { self.extensions.repeated_field_mut(extension) }
}
impl ::protrust::Message for self::TestMultipleExtensionRanges {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[18]
    }
}
impl self::TestMultipleExtensionRanges {
}
/// Test that really large tag numbers don't break anything.
#[derive(Clone, Debug, PartialEq)]
pub struct TestReallyLargeTagNumber {
    a: ::std::option::Option<i32>,
    bb: ::std::option::Option<i32>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::TestReallyLargeTagNumber {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 | 10 => self.a = ::std::option::Option::Some(input.read_int32()?),
                2147483640 | 2147483642 => self.bb = ::std::option::Option::Some(input.read_int32()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let a = self.a;
        if let ::std::option::Option::Some(a) = a {
            size += 1;
            size += ::protrust::io::sizes::int32(a);
        }
        let bb = self.bb;
        if let ::std::option::Option::Some(bb) = bb {
            size += 5;
            size += ::protrust::io::sizes::int32(bb);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let a = self.a;
        if let ::std::option::Option::Some(a) = a {
            output.write_raw_tag_bytes(&[8])?;
            output.write_int32(a)?;
        }
        let bb = self.bb;
        if let ::std::option::Option::Some(bb) = bb {
            output.write_raw_tag_bytes(&[248, 255, 255, 255, 7])?;
            output.write_int32(bb)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::TestReallyLargeTagNumber {
    fn new() -> Self {
        Self {
            a: ::std::option::Option::None,
            bb: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.a = other.a;
        self.bb = other.bb;
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestReallyLargeTagNumber {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[19]
    }
}
impl self::TestReallyLargeTagNumber {
    /// Gets the field number of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub const A_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub const A_DEFAULT_VALUE: i32 = 0;
    /// The largest possible tag number is 2^28 - 1, since the wire format uses
    /// three bits to communicate wire type.
    pub fn a(&self) -> i32 {
        self.a.unwrap_or(Self::A_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`a`] field
    ///
    /// [`a`]: #method.a
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn a_option(&self) -> ::std::option::Option<i32> {
        self.a
    }
    /// Returns a bool indicating the presence of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub fn has_a(&self) -> bool {
        self.a.is_some()
    }
    /// Sets the value of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub fn set_a(&mut self, value: i32) {
        self.a = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub fn clear_a(&mut self) {
        self.a = ::std::option::Option::None
    }
    /// Gets the field number of the [`bb`] field
    ///
    /// [`bb`]: #method.bb
    pub const BB_FIELD_NUMBER: i32 = 268435455;
    /// A constant value representing the default value of the [`bb`] field
    ///
    /// [`bb`]: #method.bb
    pub const BB_DEFAULT_VALUE: i32 = 0;
    pub fn bb(&self) -> i32 {
        self.bb.unwrap_or(Self::BB_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`bb`] field
    ///
    /// [`bb`]: #method.bb
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn bb_option(&self) -> ::std::option::Option<i32> {
        self.bb
    }
    /// Returns a bool indicating the presence of the [`bb`] field
    ///
    /// [`bb`]: #method.bb
    pub fn has_bb(&self) -> bool {
        self.bb.is_some()
    }
    /// Sets the value of the [`bb`] field
    ///
    /// [`bb`]: #method.bb
    pub fn set_bb(&mut self, value: i32) {
        self.bb = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`bb`] field
    ///
    /// [`bb`]: #method.bb
    pub fn clear_bb(&mut self) {
        self.bb = ::std::option::Option::None
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct TestRecursiveMessage {
    a: ::std::option::Option<::std::boxed::Box<self::TestRecursiveMessage>>,
    i: ::std::option::Option<i32>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::TestRecursiveMessage {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => input.read_message(&mut **self.a.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                16 | 18 => self.i = ::std::option::Option::Some(input.read_int32()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let a = &self.a;
        if let ::std::option::Option::Some(a) = a {
            size += 1;
            size += ::protrust::io::sizes::message(&**a);
        }
        let i = self.i;
        if let ::std::option::Option::Some(i) = i {
            size += 1;
            size += ::protrust::io::sizes::int32(i);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let a = &self.a;
        if let ::std::option::Option::Some(a) = a {
            output.write_raw_tag_bytes(&[10])?;
            output.write_message(&**a)?;
        }
        let i = self.i;
        if let ::std::option::Option::Some(i) = i {
            output.write_raw_tag_bytes(&[16])?;
            output.write_int32(i)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        if let Some(a) = &self.a {
            if !::protrust::CodedMessage::is_initialized(&**a) {
                return false;
            }
        }
        true
    }
}
impl ::protrust::LiteMessage for self::TestRecursiveMessage {
    fn new() -> Self {
        Self {
            a: ::std::option::Option::None,
            i: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        if let ::std::option::Option::Some(a) = &other.a {
            self.a.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(a);
        }
        self.i = other.i;
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestRecursiveMessage {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[20]
    }
}
impl self::TestRecursiveMessage {
    /// Gets the field number of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub const A_FIELD_NUMBER: i32 = 1;
    pub fn a_option(&self) -> ::std::option::Option<&self::TestRecursiveMessage> {
        self.a.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`a`] field
    ///
    /// [`a`]: #method.a
    pub fn a_mut(&mut self) -> &mut self::TestRecursiveMessage {
        self.a.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub fn has_a(&self) -> bool {
        self.a.is_some()
    }
    /// Sets the value of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub fn set_a(&mut self, value: self::TestRecursiveMessage) {
        self.a = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`a`] field, leaving it empty
    ///
    /// [`a`]: #method.a
    pub fn take_a(&mut self) -> ::std::option::Option<self::TestRecursiveMessage> {
        self.a.take().map(|b| *b)
    }
    /// Clears the value of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub fn clear_a(&mut self) {
        self.a = ::std::option::Option::None
    }
    /// Gets the field number of the [`i`] field
    ///
    /// [`i`]: #method.i
    pub const I_FIELD_NUMBER: i32 = 2;
    /// A constant value representing the default value of the [`i`] field
    ///
    /// [`i`]: #method.i
    pub const I_DEFAULT_VALUE: i32 = 0;
    pub fn i(&self) -> i32 {
        self.i.unwrap_or(Self::I_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`i`] field
    ///
    /// [`i`]: #method.i
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn i_option(&self) -> ::std::option::Option<i32> {
        self.i
    }
    /// Returns a bool indicating the presence of the [`i`] field
    ///
    /// [`i`]: #method.i
    pub fn has_i(&self) -> bool {
        self.i.is_some()
    }
    /// Sets the value of the [`i`] field
    ///
    /// [`i`]: #method.i
    pub fn set_i(&mut self, value: i32) {
        self.i = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`i`] field
    ///
    /// [`i`]: #method.i
    pub fn clear_i(&mut self) {
        self.i = ::std::option::Option::None
    }
}
/// Test that mutual recursion works.
#[derive(Clone, Debug, PartialEq)]
pub struct TestMutualRecursionA {
    bb: ::std::option::Option<::std::boxed::Box<self::TestMutualRecursionB>>,
    subgroup: ::std::option::Option<::std::boxed::Box<self::test_mutual_recursion_a::SubGroup>>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::TestMutualRecursionA {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => input.read_message(&mut **self.bb.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                19 => input.read_group(&mut **self.subgroup.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let bb = &self.bb;
        if let ::std::option::Option::Some(bb) = bb {
            size += 1;
            size += ::protrust::io::sizes::message(&**bb);
        }
        let subgroup = &self.subgroup;
        if let ::std::option::Option::Some(subgroup) = subgroup {
            size += 1;
            size += ::protrust::io::sizes::group(&**subgroup);
            size += 1;
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let bb = &self.bb;
        if let ::std::option::Option::Some(bb) = bb {
            output.write_raw_tag_bytes(&[10])?;
            output.write_message(&**bb)?;
        }
        let subgroup = &self.subgroup;
        if let ::std::option::Option::Some(subgroup) = subgroup {
            output.write_raw_tag_bytes(&[19])?;
            output.write_group(&**subgroup)?;
            output.write_raw_tag_bytes(&[20])?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        if let Some(bb) = &self.bb {
            if !::protrust::CodedMessage::is_initialized(&**bb) {
                return false;
            }
        }
        if let Some(subgroup) = &self.subgroup {
            if !::protrust::CodedMessage::is_initialized(&**subgroup) {
                return false;
            }
        }
        true
    }
}
impl ::protrust::LiteMessage for self::TestMutualRecursionA {
    fn new() -> Self {
        Self {
            bb: ::std::option::Option::None,
            subgroup: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        if let ::std::option::Option::Some(bb) = &other.bb {
            self.bb.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(bb);
        }
        if let ::std::option::Option::Some(subgroup) = &other.subgroup {
            self.subgroup.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(subgroup);
        }
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestMutualRecursionA {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[21]
    }
}
impl self::TestMutualRecursionA {
    /// Gets the field number of the [`bb`] field
    ///
    /// [`bb`]: #method.bb
    pub const BB_FIELD_NUMBER: i32 = 1;
    pub fn bb_option(&self) -> ::std::option::Option<&self::TestMutualRecursionB> {
        self.bb.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`bb`] field
    ///
    /// [`bb`]: #method.bb
    pub fn bb_mut(&mut self) -> &mut self::TestMutualRecursionB {
        self.bb.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`bb`] field
    ///
    /// [`bb`]: #method.bb
    pub fn has_bb(&self) -> bool {
        self.bb.is_some()
    }
    /// Sets the value of the [`bb`] field
    ///
    /// [`bb`]: #method.bb
    pub fn set_bb(&mut self, value: self::TestMutualRecursionB) {
        self.bb = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`bb`] field, leaving it empty
    ///
    /// [`bb`]: #method.bb
    pub fn take_bb(&mut self) -> ::std::option::Option<self::TestMutualRecursionB> {
        self.bb.take().map(|b| *b)
    }
    /// Clears the value of the [`bb`] field
    ///
    /// [`bb`]: #method.bb
    pub fn clear_bb(&mut self) {
        self.bb = ::std::option::Option::None
    }
    /// Gets the field number of the [`subgroup`] field
    ///
    /// [`subgroup`]: #method.subgroup
    pub const SUBGROUP_FIELD_NUMBER: i32 = 2;
    pub fn subgroup_option(&self) -> ::std::option::Option<&self::test_mutual_recursion_a::SubGroup> {
        self.subgroup.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`subgroup`] field
    ///
    /// [`subgroup`]: #method.subgroup
    pub fn subgroup_mut(&mut self) -> &mut self::test_mutual_recursion_a::SubGroup {
        self.subgroup.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`subgroup`] field
    ///
    /// [`subgroup`]: #method.subgroup
    pub fn has_subgroup(&self) -> bool {
        self.subgroup.is_some()
    }
    /// Sets the value of the [`subgroup`] field
    ///
    /// [`subgroup`]: #method.subgroup
    pub fn set_subgroup(&mut self, value: self::test_mutual_recursion_a::SubGroup) {
        self.subgroup = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`subgroup`] field, leaving it empty
    ///
    /// [`subgroup`]: #method.subgroup
    pub fn take_subgroup(&mut self) -> ::std::option::Option<self::test_mutual_recursion_a::SubGroup> {
        self.subgroup.take().map(|b| *b)
    }
    /// Clears the value of the [`subgroup`] field
    ///
    /// [`subgroup`]: #method.subgroup
    pub fn clear_subgroup(&mut self) {
        self.subgroup = ::std::option::Option::None
    }
}
/// Test that mutual recursion works.
pub mod test_mutual_recursion_a {
    #[derive(Clone, Debug, PartialEq)]
    pub struct SubMessage {
        b: ::std::option::Option<::std::boxed::Box<self::super::TestMutualRecursionB>>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::SubMessage {
        fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => input.read_message(&mut **self.b.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                    _ => self.unknown_fields.merge_from(tag, input)?
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            let b = &self.b;
            if let ::std::option::Option::Some(b) = b {
                size += 1;
                size += ::protrust::io::sizes::message(&**b);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
            let b = &self.b;
            if let ::std::option::Option::Some(b) = b {
                output.write_raw_tag_bytes(&[10])?;
                output.write_message(&**b)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let Some(b) = &self.b {
                if !::protrust::CodedMessage::is_initialized(&**b) {
                    return false;
                }
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::SubMessage {
        fn new() -> Self {
            Self {
                b: ::std::option::Option::None,
                unknown_fields: ::protrust::UnknownFieldSet::new(),
            }
        }
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(b) = &other.b {
                self.b.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(b);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::SubMessage {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
            &self::super::file().messages()[21].messages()[0]
        }
    }
    impl self::SubMessage {
        /// Gets the field number of the [`b`] field
        ///
        /// [`b`]: #method.b
        pub const B_FIELD_NUMBER: i32 = 1;
        pub fn b_option(&self) -> ::std::option::Option<&self::super::TestMutualRecursionB> {
            self.b.as_ref().map(|b| &**b)
        }
        /// Returns a unique reference to the [`b`] field
        ///
        /// [`b`]: #method.b
        pub fn b_mut(&mut self) -> &mut self::super::TestMutualRecursionB {
            self.b.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
        }
        /// Returns a bool indicating the presence of the [`b`] field
        ///
        /// [`b`]: #method.b
        pub fn has_b(&self) -> bool {
            self.b.is_some()
        }
        /// Sets the value of the [`b`] field
        ///
        /// [`b`]: #method.b
        pub fn set_b(&mut self, value: self::super::TestMutualRecursionB) {
            self.b = ::std::option::Option::Some(::std::boxed::Box::new(value))
        }
        /// Takes the value of the [`b`] field, leaving it empty
        ///
        /// [`b`]: #method.b
        pub fn take_b(&mut self) -> ::std::option::Option<self::super::TestMutualRecursionB> {
            self.b.take().map(|b| *b)
        }
        /// Clears the value of the [`b`] field
        ///
        /// [`b`]: #method.b
        pub fn clear_b(&mut self) {
            self.b = ::std::option::Option::None
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    pub struct SubGroup {
        sub_message: ::std::option::Option<::std::boxed::Box<self::SubMessage>>,
        not_in_this_scc: ::std::option::Option<::std::boxed::Box<self::super::TestAllTypes>>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::SubGroup {
        fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    26 => input.read_message(&mut **self.sub_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                    34 => input.read_message(&mut **self.not_in_this_scc.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                    20 => break,
                    _ => self.unknown_fields.merge_from(tag, input)?
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            let sub_message = &self.sub_message;
            if let ::std::option::Option::Some(sub_message) = sub_message {
                size += 1;
                size += ::protrust::io::sizes::message(&**sub_message);
            }
            let not_in_this_scc = &self.not_in_this_scc;
            if let ::std::option::Option::Some(not_in_this_scc) = not_in_this_scc {
                size += 1;
                size += ::protrust::io::sizes::message(&**not_in_this_scc);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
            let sub_message = &self.sub_message;
            if let ::std::option::Option::Some(sub_message) = sub_message {
                output.write_raw_tag_bytes(&[26])?;
                output.write_message(&**sub_message)?;
            }
            let not_in_this_scc = &self.not_in_this_scc;
            if let ::std::option::Option::Some(not_in_this_scc) = not_in_this_scc {
                output.write_raw_tag_bytes(&[34])?;
                output.write_message(&**not_in_this_scc)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let Some(sub_message) = &self.sub_message {
                if !::protrust::CodedMessage::is_initialized(&**sub_message) {
                    return false;
                }
            }
            if let Some(not_in_this_scc) = &self.not_in_this_scc {
                if !::protrust::CodedMessage::is_initialized(&**not_in_this_scc) {
                    return false;
                }
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::SubGroup {
        fn new() -> Self {
            Self {
                sub_message: ::std::option::Option::None,
                not_in_this_scc: ::std::option::Option::None,
                unknown_fields: ::protrust::UnknownFieldSet::new(),
            }
        }
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(sub_message) = &other.sub_message {
                self.sub_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(sub_message);
            }
            if let ::std::option::Option::Some(not_in_this_scc) = &other.not_in_this_scc {
                self.not_in_this_scc.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(not_in_this_scc);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::SubGroup {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
            &self::super::file().messages()[21].messages()[1]
        }
    }
    impl self::SubGroup {
        /// Gets the field number of the [`sub_message`] field
        ///
        /// [`sub_message`]: #method.sub_message
        pub const SUB_MESSAGE_FIELD_NUMBER: i32 = 3;
        /// Needed because of bug in javatest
        pub fn sub_message_option(&self) -> ::std::option::Option<&self::SubMessage> {
            self.sub_message.as_ref().map(|b| &**b)
        }
        /// Returns a unique reference to the [`sub_message`] field
        ///
        /// [`sub_message`]: #method.sub_message
        pub fn sub_message_mut(&mut self) -> &mut self::SubMessage {
            self.sub_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
        }
        /// Returns a bool indicating the presence of the [`sub_message`] field
        ///
        /// [`sub_message`]: #method.sub_message
        pub fn has_sub_message(&self) -> bool {
            self.sub_message.is_some()
        }
        /// Sets the value of the [`sub_message`] field
        ///
        /// [`sub_message`]: #method.sub_message
        pub fn set_sub_message(&mut self, value: self::SubMessage) {
            self.sub_message = ::std::option::Option::Some(::std::boxed::Box::new(value))
        }
        /// Takes the value of the [`sub_message`] field, leaving it empty
        ///
        /// [`sub_message`]: #method.sub_message
        pub fn take_sub_message(&mut self) -> ::std::option::Option<self::SubMessage> {
            self.sub_message.take().map(|b| *b)
        }
        /// Clears the value of the [`sub_message`] field
        ///
        /// [`sub_message`]: #method.sub_message
        pub fn clear_sub_message(&mut self) {
            self.sub_message = ::std::option::Option::None
        }
        /// Gets the field number of the [`not_in_this_scc`] field
        ///
        /// [`not_in_this_scc`]: #method.not_in_this_scc
        pub const NOT_IN_THIS_SCC_FIELD_NUMBER: i32 = 4;
        pub fn not_in_this_scc_option(&self) -> ::std::option::Option<&self::super::TestAllTypes> {
            self.not_in_this_scc.as_ref().map(|b| &**b)
        }
        /// Returns a unique reference to the [`not_in_this_scc`] field
        ///
        /// [`not_in_this_scc`]: #method.not_in_this_scc
        pub fn not_in_this_scc_mut(&mut self) -> &mut self::super::TestAllTypes {
            self.not_in_this_scc.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
        }
        /// Returns a bool indicating the presence of the [`not_in_this_scc`] field
        ///
        /// [`not_in_this_scc`]: #method.not_in_this_scc
        pub fn has_not_in_this_scc(&self) -> bool {
            self.not_in_this_scc.is_some()
        }
        /// Sets the value of the [`not_in_this_scc`] field
        ///
        /// [`not_in_this_scc`]: #method.not_in_this_scc
        pub fn set_not_in_this_scc(&mut self, value: self::super::TestAllTypes) {
            self.not_in_this_scc = ::std::option::Option::Some(::std::boxed::Box::new(value))
        }
        /// Takes the value of the [`not_in_this_scc`] field, leaving it empty
        ///
        /// [`not_in_this_scc`]: #method.not_in_this_scc
        pub fn take_not_in_this_scc(&mut self) -> ::std::option::Option<self::super::TestAllTypes> {
            self.not_in_this_scc.take().map(|b| *b)
        }
        /// Clears the value of the [`not_in_this_scc`] field
        ///
        /// [`not_in_this_scc`]: #method.not_in_this_scc
        pub fn clear_not_in_this_scc(&mut self) {
            self.not_in_this_scc = ::std::option::Option::None
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct TestMutualRecursionB {
    a: ::std::option::Option<::std::boxed::Box<self::TestMutualRecursionA>>,
    optional_int32: ::std::option::Option<i32>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::TestMutualRecursionB {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => input.read_message(&mut **self.a.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                16 | 18 => self.optional_int32 = ::std::option::Option::Some(input.read_int32()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let a = &self.a;
        if let ::std::option::Option::Some(a) = a {
            size += 1;
            size += ::protrust::io::sizes::message(&**a);
        }
        let optional_int32 = self.optional_int32;
        if let ::std::option::Option::Some(optional_int32) = optional_int32 {
            size += 1;
            size += ::protrust::io::sizes::int32(optional_int32);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let a = &self.a;
        if let ::std::option::Option::Some(a) = a {
            output.write_raw_tag_bytes(&[10])?;
            output.write_message(&**a)?;
        }
        let optional_int32 = self.optional_int32;
        if let ::std::option::Option::Some(optional_int32) = optional_int32 {
            output.write_raw_tag_bytes(&[16])?;
            output.write_int32(optional_int32)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        if let Some(a) = &self.a {
            if !::protrust::CodedMessage::is_initialized(&**a) {
                return false;
            }
        }
        true
    }
}
impl ::protrust::LiteMessage for self::TestMutualRecursionB {
    fn new() -> Self {
        Self {
            a: ::std::option::Option::None,
            optional_int32: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        if let ::std::option::Option::Some(a) = &other.a {
            self.a.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(a);
        }
        self.optional_int32 = other.optional_int32;
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestMutualRecursionB {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[22]
    }
}
impl self::TestMutualRecursionB {
    /// Gets the field number of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub const A_FIELD_NUMBER: i32 = 1;
    pub fn a_option(&self) -> ::std::option::Option<&self::TestMutualRecursionA> {
        self.a.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`a`] field
    ///
    /// [`a`]: #method.a
    pub fn a_mut(&mut self) -> &mut self::TestMutualRecursionA {
        self.a.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub fn has_a(&self) -> bool {
        self.a.is_some()
    }
    /// Sets the value of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub fn set_a(&mut self, value: self::TestMutualRecursionA) {
        self.a = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`a`] field, leaving it empty
    ///
    /// [`a`]: #method.a
    pub fn take_a(&mut self) -> ::std::option::Option<self::TestMutualRecursionA> {
        self.a.take().map(|b| *b)
    }
    /// Clears the value of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub fn clear_a(&mut self) {
        self.a = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_int32`] field
    ///
    /// [`optional_int32`]: #method.optional_int32
    pub const OPTIONAL_INT32_FIELD_NUMBER: i32 = 2;
    /// A constant value representing the default value of the [`optional_int32`] field
    ///
    /// [`optional_int32`]: #method.optional_int32
    pub const OPTIONAL_INT32_DEFAULT_VALUE: i32 = 0;
    pub fn optional_int32(&self) -> i32 {
        self.optional_int32.unwrap_or(Self::OPTIONAL_INT32_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`optional_int32`] field
    ///
    /// [`optional_int32`]: #method.optional_int32
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn optional_int32_option(&self) -> ::std::option::Option<i32> {
        self.optional_int32
    }
    /// Returns a bool indicating the presence of the [`optional_int32`] field
    ///
    /// [`optional_int32`]: #method.optional_int32
    pub fn has_optional_int32(&self) -> bool {
        self.optional_int32.is_some()
    }
    /// Sets the value of the [`optional_int32`] field
    ///
    /// [`optional_int32`]: #method.optional_int32
    pub fn set_optional_int32(&mut self, value: i32) {
        self.optional_int32 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`optional_int32`] field
    ///
    /// [`optional_int32`]: #method.optional_int32
    pub fn clear_optional_int32(&mut self) {
        self.optional_int32 = ::std::option::Option::None
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct TestIsInitialized {
    sub_message: ::std::option::Option<::std::boxed::Box<self::test_is_initialized::SubMessage>>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::TestIsInitialized {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => input.read_message(&mut **self.sub_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let sub_message = &self.sub_message;
        if let ::std::option::Option::Some(sub_message) = sub_message {
            size += 1;
            size += ::protrust::io::sizes::message(&**sub_message);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let sub_message = &self.sub_message;
        if let ::std::option::Option::Some(sub_message) = sub_message {
            output.write_raw_tag_bytes(&[10])?;
            output.write_message(&**sub_message)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        if let Some(sub_message) = &self.sub_message {
            if !::protrust::CodedMessage::is_initialized(&**sub_message) {
                return false;
            }
        }
        true
    }
}
impl ::protrust::LiteMessage for self::TestIsInitialized {
    fn new() -> Self {
        Self {
            sub_message: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        if let ::std::option::Option::Some(sub_message) = &other.sub_message {
            self.sub_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(sub_message);
        }
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestIsInitialized {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[23]
    }
}
impl self::TestIsInitialized {
    /// Gets the field number of the [`sub_message`] field
    ///
    /// [`sub_message`]: #method.sub_message
    pub const SUB_MESSAGE_FIELD_NUMBER: i32 = 1;
    pub fn sub_message_option(&self) -> ::std::option::Option<&self::test_is_initialized::SubMessage> {
        self.sub_message.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`sub_message`] field
    ///
    /// [`sub_message`]: #method.sub_message
    pub fn sub_message_mut(&mut self) -> &mut self::test_is_initialized::SubMessage {
        self.sub_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`sub_message`] field
    ///
    /// [`sub_message`]: #method.sub_message
    pub fn has_sub_message(&self) -> bool {
        self.sub_message.is_some()
    }
    /// Sets the value of the [`sub_message`] field
    ///
    /// [`sub_message`]: #method.sub_message
    pub fn set_sub_message(&mut self, value: self::test_is_initialized::SubMessage) {
        self.sub_message = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`sub_message`] field, leaving it empty
    ///
    /// [`sub_message`]: #method.sub_message
    pub fn take_sub_message(&mut self) -> ::std::option::Option<self::test_is_initialized::SubMessage> {
        self.sub_message.take().map(|b| *b)
    }
    /// Clears the value of the [`sub_message`] field
    ///
    /// [`sub_message`]: #method.sub_message
    pub fn clear_sub_message(&mut self) {
        self.sub_message = ::std::option::Option::None
    }
}
pub mod test_is_initialized {
    #[derive(Clone, Debug, PartialEq)]
    pub struct SubMessage {
        subgroup: ::std::option::Option<::std::boxed::Box<self::sub_message::SubGroup>>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::SubMessage {
        fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    11 => input.read_group(&mut **self.subgroup.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                    _ => self.unknown_fields.merge_from(tag, input)?
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            let subgroup = &self.subgroup;
            if let ::std::option::Option::Some(subgroup) = subgroup {
                size += 1;
                size += ::protrust::io::sizes::group(&**subgroup);
                size += 1;
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
            let subgroup = &self.subgroup;
            if let ::std::option::Option::Some(subgroup) = subgroup {
                output.write_raw_tag_bytes(&[11])?;
                output.write_group(&**subgroup)?;
                output.write_raw_tag_bytes(&[12])?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let Some(subgroup) = &self.subgroup {
                if !::protrust::CodedMessage::is_initialized(&**subgroup) {
                    return false;
                }
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::SubMessage {
        fn new() -> Self {
            Self {
                subgroup: ::std::option::Option::None,
                unknown_fields: ::protrust::UnknownFieldSet::new(),
            }
        }
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(subgroup) = &other.subgroup {
                self.subgroup.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(subgroup);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::SubMessage {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
            &self::super::file().messages()[23].messages()[0]
        }
    }
    impl self::SubMessage {
        /// Gets the field number of the [`subgroup`] field
        ///
        /// [`subgroup`]: #method.subgroup
        pub const SUBGROUP_FIELD_NUMBER: i32 = 1;
        pub fn subgroup_option(&self) -> ::std::option::Option<&self::sub_message::SubGroup> {
            self.subgroup.as_ref().map(|b| &**b)
        }
        /// Returns a unique reference to the [`subgroup`] field
        ///
        /// [`subgroup`]: #method.subgroup
        pub fn subgroup_mut(&mut self) -> &mut self::sub_message::SubGroup {
            self.subgroup.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
        }
        /// Returns a bool indicating the presence of the [`subgroup`] field
        ///
        /// [`subgroup`]: #method.subgroup
        pub fn has_subgroup(&self) -> bool {
            self.subgroup.is_some()
        }
        /// Sets the value of the [`subgroup`] field
        ///
        /// [`subgroup`]: #method.subgroup
        pub fn set_subgroup(&mut self, value: self::sub_message::SubGroup) {
            self.subgroup = ::std::option::Option::Some(::std::boxed::Box::new(value))
        }
        /// Takes the value of the [`subgroup`] field, leaving it empty
        ///
        /// [`subgroup`]: #method.subgroup
        pub fn take_subgroup(&mut self) -> ::std::option::Option<self::sub_message::SubGroup> {
            self.subgroup.take().map(|b| *b)
        }
        /// Clears the value of the [`subgroup`] field
        ///
        /// [`subgroup`]: #method.subgroup
        pub fn clear_subgroup(&mut self) {
            self.subgroup = ::std::option::Option::None
        }
    }
    pub mod sub_message {
        #[derive(Clone, Debug, PartialEq)]
        pub struct SubGroup {
            i: ::std::option::Option<i32>,
            unknown_fields: ::protrust::UnknownFieldSet,
        }
        impl ::protrust::CodedMessage for self::SubGroup {
            fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        16 | 18 => self.i = ::std::option::Option::Some(input.read_int32()?),
                        12 => break,
                        _ => self.unknown_fields.merge_from(tag, input)?
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> i32 {
                let mut size = 0i32;
                let i = self.i;
                if let ::std::option::Option::Some(i) = i {
                    size += 1;
                    size += ::protrust::io::sizes::int32(i);
                }
                size += self.unknown_fields.calculate_size();
                size
            }
            fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
                let i = self.i;
                if let ::std::option::Option::Some(i) = i {
                    output.write_raw_tag_bytes(&[16])?;
                    output.write_int32(i)?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                if self.i.is_none() {
                    return false;
                }
                true
            }
        }
        impl ::protrust::LiteMessage for self::SubGroup {
            fn new() -> Self {
                Self {
                    i: ::std::option::Option::None,
                    unknown_fields: ::protrust::UnknownFieldSet::new(),
                }
            }
            fn merge(&mut self, other: &Self) {
                self.i = other.i;
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl ::protrust::Message for self::SubGroup {
            fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
                &self::super::super::file().messages()[23].messages()[0].messages()[0]
            }
        }
        impl self::SubGroup {
            /// Gets the field number of the [`i`] field
            ///
            /// [`i`]: #method.i
            pub const I_FIELD_NUMBER: i32 = 2;
            /// A constant value representing the default value of the [`i`] field
            ///
            /// [`i`]: #method.i
            pub const I_DEFAULT_VALUE: i32 = 0;
            pub fn i(&self) -> i32 {
                self.i.unwrap_or(Self::I_DEFAULT_VALUE)
            }
            /// Returns an [`Option`] representing the presence of the [`i`] field
            ///
            /// [`i`]: #method.i
            /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
            pub fn i_option(&self) -> ::std::option::Option<i32> {
                self.i
            }
            /// Returns a bool indicating the presence of the [`i`] field
            ///
            /// [`i`]: #method.i
            pub fn has_i(&self) -> bool {
                self.i.is_some()
            }
            /// Sets the value of the [`i`] field
            ///
            /// [`i`]: #method.i
            pub fn set_i(&mut self, value: i32) {
                self.i = ::std::option::Option::Some(value)
            }
            /// Clears the value of the [`i`] field
            ///
            /// [`i`]: #method.i
            pub fn clear_i(&mut self) {
                self.i = ::std::option::Option::None
            }
        }
    }
}
/// Test that groups have disjoint field numbers from their siblings and
/// parents.  This is NOT possible in proto1; only google.protobuf.  When attempting
/// to compile with proto1, this will emit an error; so we only include it
/// in protobuf_unittest_proto.
#[derive(Clone, Debug, PartialEq)]
pub struct TestDupFieldNumber {
    a: ::std::option::Option<i32>,
    foo: ::std::option::Option<::std::boxed::Box<self::test_dup_field_number::Foo>>,
    bar: ::std::option::Option<::std::boxed::Box<self::test_dup_field_number::Bar>>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::TestDupFieldNumber {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 | 10 => self.a = ::std::option::Option::Some(input.read_int32()?),
                19 => input.read_group(&mut **self.foo.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                27 => input.read_group(&mut **self.bar.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let a = self.a;
        if let ::std::option::Option::Some(a) = a {
            size += 1;
            size += ::protrust::io::sizes::int32(a);
        }
        let foo = &self.foo;
        if let ::std::option::Option::Some(foo) = foo {
            size += 1;
            size += ::protrust::io::sizes::group(&**foo);
            size += 1;
        }
        let bar = &self.bar;
        if let ::std::option::Option::Some(bar) = bar {
            size += 1;
            size += ::protrust::io::sizes::group(&**bar);
            size += 1;
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let a = self.a;
        if let ::std::option::Option::Some(a) = a {
            output.write_raw_tag_bytes(&[8])?;
            output.write_int32(a)?;
        }
        let foo = &self.foo;
        if let ::std::option::Option::Some(foo) = foo {
            output.write_raw_tag_bytes(&[19])?;
            output.write_group(&**foo)?;
            output.write_raw_tag_bytes(&[20])?;
        }
        let bar = &self.bar;
        if let ::std::option::Option::Some(bar) = bar {
            output.write_raw_tag_bytes(&[27])?;
            output.write_group(&**bar)?;
            output.write_raw_tag_bytes(&[28])?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        if let Some(foo) = &self.foo {
            if !::protrust::CodedMessage::is_initialized(&**foo) {
                return false;
            }
        }
        if let Some(bar) = &self.bar {
            if !::protrust::CodedMessage::is_initialized(&**bar) {
                return false;
            }
        }
        true
    }
}
impl ::protrust::LiteMessage for self::TestDupFieldNumber {
    fn new() -> Self {
        Self {
            a: ::std::option::Option::None,
            foo: ::std::option::Option::None,
            bar: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.a = other.a;
        if let ::std::option::Option::Some(foo) = &other.foo {
            self.foo.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(foo);
        }
        if let ::std::option::Option::Some(bar) = &other.bar {
            self.bar.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(bar);
        }
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestDupFieldNumber {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[24]
    }
}
impl self::TestDupFieldNumber {
    /// Gets the field number of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub const A_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub const A_DEFAULT_VALUE: i32 = 0;
    /// NO_PROTO1
    pub fn a(&self) -> i32 {
        self.a.unwrap_or(Self::A_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`a`] field
    ///
    /// [`a`]: #method.a
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn a_option(&self) -> ::std::option::Option<i32> {
        self.a
    }
    /// Returns a bool indicating the presence of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub fn has_a(&self) -> bool {
        self.a.is_some()
    }
    /// Sets the value of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub fn set_a(&mut self, value: i32) {
        self.a = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub fn clear_a(&mut self) {
        self.a = ::std::option::Option::None
    }
    /// Gets the field number of the [`foo`] field
    ///
    /// [`foo`]: #method.foo
    pub const FOO_FIELD_NUMBER: i32 = 2;
    pub fn foo_option(&self) -> ::std::option::Option<&self::test_dup_field_number::Foo> {
        self.foo.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`foo`] field
    ///
    /// [`foo`]: #method.foo
    pub fn foo_mut(&mut self) -> &mut self::test_dup_field_number::Foo {
        self.foo.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`foo`] field
    ///
    /// [`foo`]: #method.foo
    pub fn has_foo(&self) -> bool {
        self.foo.is_some()
    }
    /// Sets the value of the [`foo`] field
    ///
    /// [`foo`]: #method.foo
    pub fn set_foo(&mut self, value: self::test_dup_field_number::Foo) {
        self.foo = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`foo`] field, leaving it empty
    ///
    /// [`foo`]: #method.foo
    pub fn take_foo(&mut self) -> ::std::option::Option<self::test_dup_field_number::Foo> {
        self.foo.take().map(|b| *b)
    }
    /// Clears the value of the [`foo`] field
    ///
    /// [`foo`]: #method.foo
    pub fn clear_foo(&mut self) {
        self.foo = ::std::option::Option::None
    }
    /// Gets the field number of the [`bar`] field
    ///
    /// [`bar`]: #method.bar
    pub const BAR_FIELD_NUMBER: i32 = 3;
    pub fn bar_option(&self) -> ::std::option::Option<&self::test_dup_field_number::Bar> {
        self.bar.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`bar`] field
    ///
    /// [`bar`]: #method.bar
    pub fn bar_mut(&mut self) -> &mut self::test_dup_field_number::Bar {
        self.bar.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`bar`] field
    ///
    /// [`bar`]: #method.bar
    pub fn has_bar(&self) -> bool {
        self.bar.is_some()
    }
    /// Sets the value of the [`bar`] field
    ///
    /// [`bar`]: #method.bar
    pub fn set_bar(&mut self, value: self::test_dup_field_number::Bar) {
        self.bar = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`bar`] field, leaving it empty
    ///
    /// [`bar`]: #method.bar
    pub fn take_bar(&mut self) -> ::std::option::Option<self::test_dup_field_number::Bar> {
        self.bar.take().map(|b| *b)
    }
    /// Clears the value of the [`bar`] field
    ///
    /// [`bar`]: #method.bar
    pub fn clear_bar(&mut self) {
        self.bar = ::std::option::Option::None
    }
}
/// Test that groups have disjoint field numbers from their siblings and
/// parents.  This is NOT possible in proto1; only google.protobuf.  When attempting
/// to compile with proto1, this will emit an error; so we only include it
/// in protobuf_unittest_proto.
pub mod test_dup_field_number {
    #[derive(Clone, Debug, PartialEq)]
    pub struct Foo {
        a: ::std::option::Option<i32>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::Foo {
        fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.a = ::std::option::Option::Some(input.read_int32()?),
                    20 => break,
                    _ => self.unknown_fields.merge_from(tag, input)?
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            let a = self.a;
            if let ::std::option::Option::Some(a) = a {
                size += 1;
                size += ::protrust::io::sizes::int32(a);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
            let a = self.a;
            if let ::std::option::Option::Some(a) = a {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(a)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
    }
    impl ::protrust::LiteMessage for self::Foo {
        fn new() -> Self {
            Self {
                a: ::std::option::Option::None,
                unknown_fields: ::protrust::UnknownFieldSet::new(),
            }
        }
        fn merge(&mut self, other: &Self) {
            self.a = other.a;
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::Foo {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
            &self::super::file().messages()[24].messages()[0]
        }
    }
    impl self::Foo {
        /// Gets the field number of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub const A_FIELD_NUMBER: i32 = 1;
        /// A constant value representing the default value of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub const A_DEFAULT_VALUE: i32 = 0;
        pub fn a(&self) -> i32 {
            self.a.unwrap_or(Self::A_DEFAULT_VALUE)
        }
        /// Returns an [`Option`] representing the presence of the [`a`] field
        ///
        /// [`a`]: #method.a
        /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
        pub fn a_option(&self) -> ::std::option::Option<i32> {
            self.a
        }
        /// Returns a bool indicating the presence of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub fn has_a(&self) -> bool {
            self.a.is_some()
        }
        /// Sets the value of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub fn set_a(&mut self, value: i32) {
            self.a = ::std::option::Option::Some(value)
        }
        /// Clears the value of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub fn clear_a(&mut self) {
            self.a = ::std::option::Option::None
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    pub struct Bar {
        a: ::std::option::Option<i32>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::Bar {
        fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.a = ::std::option::Option::Some(input.read_int32()?),
                    28 => break,
                    _ => self.unknown_fields.merge_from(tag, input)?
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            let a = self.a;
            if let ::std::option::Option::Some(a) = a {
                size += 1;
                size += ::protrust::io::sizes::int32(a);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
            let a = self.a;
            if let ::std::option::Option::Some(a) = a {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(a)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
    }
    impl ::protrust::LiteMessage for self::Bar {
        fn new() -> Self {
            Self {
                a: ::std::option::Option::None,
                unknown_fields: ::protrust::UnknownFieldSet::new(),
            }
        }
        fn merge(&mut self, other: &Self) {
            self.a = other.a;
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::Bar {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
            &self::super::file().messages()[24].messages()[1]
        }
    }
    impl self::Bar {
        /// Gets the field number of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub const A_FIELD_NUMBER: i32 = 1;
        /// A constant value representing the default value of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub const A_DEFAULT_VALUE: i32 = 0;
        pub fn a(&self) -> i32 {
            self.a.unwrap_or(Self::A_DEFAULT_VALUE)
        }
        /// Returns an [`Option`] representing the presence of the [`a`] field
        ///
        /// [`a`]: #method.a
        /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
        pub fn a_option(&self) -> ::std::option::Option<i32> {
            self.a
        }
        /// Returns a bool indicating the presence of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub fn has_a(&self) -> bool {
            self.a.is_some()
        }
        /// Sets the value of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub fn set_a(&mut self, value: i32) {
            self.a = ::std::option::Option::Some(value)
        }
        /// Clears the value of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub fn clear_a(&mut self) {
            self.a = ::std::option::Option::None
        }
    }
}
/// Additional messages for testing lazy fields.
#[derive(Clone, Debug, PartialEq)]
pub struct TestEagerMessage {
    sub_message: ::std::option::Option<::std::boxed::Box<self::TestAllTypes>>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::TestEagerMessage {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => input.read_message(&mut **self.sub_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let sub_message = &self.sub_message;
        if let ::std::option::Option::Some(sub_message) = sub_message {
            size += 1;
            size += ::protrust::io::sizes::message(&**sub_message);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let sub_message = &self.sub_message;
        if let ::std::option::Option::Some(sub_message) = sub_message {
            output.write_raw_tag_bytes(&[10])?;
            output.write_message(&**sub_message)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        if let Some(sub_message) = &self.sub_message {
            if !::protrust::CodedMessage::is_initialized(&**sub_message) {
                return false;
            }
        }
        true
    }
}
impl ::protrust::LiteMessage for self::TestEagerMessage {
    fn new() -> Self {
        Self {
            sub_message: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        if let ::std::option::Option::Some(sub_message) = &other.sub_message {
            self.sub_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(sub_message);
        }
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestEagerMessage {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[25]
    }
}
impl self::TestEagerMessage {
    /// Gets the field number of the [`sub_message`] field
    ///
    /// [`sub_message`]: #method.sub_message
    pub const SUB_MESSAGE_FIELD_NUMBER: i32 = 1;
    pub fn sub_message_option(&self) -> ::std::option::Option<&self::TestAllTypes> {
        self.sub_message.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`sub_message`] field
    ///
    /// [`sub_message`]: #method.sub_message
    pub fn sub_message_mut(&mut self) -> &mut self::TestAllTypes {
        self.sub_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`sub_message`] field
    ///
    /// [`sub_message`]: #method.sub_message
    pub fn has_sub_message(&self) -> bool {
        self.sub_message.is_some()
    }
    /// Sets the value of the [`sub_message`] field
    ///
    /// [`sub_message`]: #method.sub_message
    pub fn set_sub_message(&mut self, value: self::TestAllTypes) {
        self.sub_message = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`sub_message`] field, leaving it empty
    ///
    /// [`sub_message`]: #method.sub_message
    pub fn take_sub_message(&mut self) -> ::std::option::Option<self::TestAllTypes> {
        self.sub_message.take().map(|b| *b)
    }
    /// Clears the value of the [`sub_message`] field
    ///
    /// [`sub_message`]: #method.sub_message
    pub fn clear_sub_message(&mut self) {
        self.sub_message = ::std::option::Option::None
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct TestLazyMessage {
    sub_message: ::std::option::Option<::std::boxed::Box<self::TestAllTypes>>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::TestLazyMessage {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => input.read_message(&mut **self.sub_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let sub_message = &self.sub_message;
        if let ::std::option::Option::Some(sub_message) = sub_message {
            size += 1;
            size += ::protrust::io::sizes::message(&**sub_message);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let sub_message = &self.sub_message;
        if let ::std::option::Option::Some(sub_message) = sub_message {
            output.write_raw_tag_bytes(&[10])?;
            output.write_message(&**sub_message)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        if let Some(sub_message) = &self.sub_message {
            if !::protrust::CodedMessage::is_initialized(&**sub_message) {
                return false;
            }
        }
        true
    }
}
impl ::protrust::LiteMessage for self::TestLazyMessage {
    fn new() -> Self {
        Self {
            sub_message: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        if let ::std::option::Option::Some(sub_message) = &other.sub_message {
            self.sub_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(sub_message);
        }
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestLazyMessage {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[26]
    }
}
impl self::TestLazyMessage {
    /// Gets the field number of the [`sub_message`] field
    ///
    /// [`sub_message`]: #method.sub_message
    pub const SUB_MESSAGE_FIELD_NUMBER: i32 = 1;
    pub fn sub_message_option(&self) -> ::std::option::Option<&self::TestAllTypes> {
        self.sub_message.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`sub_message`] field
    ///
    /// [`sub_message`]: #method.sub_message
    pub fn sub_message_mut(&mut self) -> &mut self::TestAllTypes {
        self.sub_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`sub_message`] field
    ///
    /// [`sub_message`]: #method.sub_message
    pub fn has_sub_message(&self) -> bool {
        self.sub_message.is_some()
    }
    /// Sets the value of the [`sub_message`] field
    ///
    /// [`sub_message`]: #method.sub_message
    pub fn set_sub_message(&mut self, value: self::TestAllTypes) {
        self.sub_message = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`sub_message`] field, leaving it empty
    ///
    /// [`sub_message`]: #method.sub_message
    pub fn take_sub_message(&mut self) -> ::std::option::Option<self::TestAllTypes> {
        self.sub_message.take().map(|b| *b)
    }
    /// Clears the value of the [`sub_message`] field
    ///
    /// [`sub_message`]: #method.sub_message
    pub fn clear_sub_message(&mut self) {
        self.sub_message = ::std::option::Option::None
    }
}
/// Needed for a Python test.
#[derive(Clone, Debug, PartialEq)]
pub struct TestNestedMessageHasBits {
    optional_nested_message: ::std::option::Option<::std::boxed::Box<self::test_nested_message_has_bits::NestedMessage>>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::TestNestedMessageHasBits {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => input.read_message(&mut **self.optional_nested_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let optional_nested_message = &self.optional_nested_message;
        if let ::std::option::Option::Some(optional_nested_message) = optional_nested_message {
            size += 1;
            size += ::protrust::io::sizes::message(&**optional_nested_message);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let optional_nested_message = &self.optional_nested_message;
        if let ::std::option::Option::Some(optional_nested_message) = optional_nested_message {
            output.write_raw_tag_bytes(&[10])?;
            output.write_message(&**optional_nested_message)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        if let Some(optional_nested_message) = &self.optional_nested_message {
            if !::protrust::CodedMessage::is_initialized(&**optional_nested_message) {
                return false;
            }
        }
        true
    }
}
impl ::protrust::LiteMessage for self::TestNestedMessageHasBits {
    fn new() -> Self {
        Self {
            optional_nested_message: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        if let ::std::option::Option::Some(optional_nested_message) = &other.optional_nested_message {
            self.optional_nested_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(optional_nested_message);
        }
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestNestedMessageHasBits {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[27]
    }
}
impl self::TestNestedMessageHasBits {
    /// Gets the field number of the [`optional_nested_message`] field
    ///
    /// [`optional_nested_message`]: #method.optional_nested_message
    pub const OPTIONAL_NESTED_MESSAGE_FIELD_NUMBER: i32 = 1;
    pub fn optional_nested_message_option(&self) -> ::std::option::Option<&self::test_nested_message_has_bits::NestedMessage> {
        self.optional_nested_message.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`optional_nested_message`] field
    ///
    /// [`optional_nested_message`]: #method.optional_nested_message
    pub fn optional_nested_message_mut(&mut self) -> &mut self::test_nested_message_has_bits::NestedMessage {
        self.optional_nested_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`optional_nested_message`] field
    ///
    /// [`optional_nested_message`]: #method.optional_nested_message
    pub fn has_optional_nested_message(&self) -> bool {
        self.optional_nested_message.is_some()
    }
    /// Sets the value of the [`optional_nested_message`] field
    ///
    /// [`optional_nested_message`]: #method.optional_nested_message
    pub fn set_optional_nested_message(&mut self, value: self::test_nested_message_has_bits::NestedMessage) {
        self.optional_nested_message = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`optional_nested_message`] field, leaving it empty
    ///
    /// [`optional_nested_message`]: #method.optional_nested_message
    pub fn take_optional_nested_message(&mut self) -> ::std::option::Option<self::test_nested_message_has_bits::NestedMessage> {
        self.optional_nested_message.take().map(|b| *b)
    }
    /// Clears the value of the [`optional_nested_message`] field
    ///
    /// [`optional_nested_message`]: #method.optional_nested_message
    pub fn clear_optional_nested_message(&mut self) {
        self.optional_nested_message = ::std::option::Option::None
    }
}
/// Needed for a Python test.
pub mod test_nested_message_has_bits {
    #[derive(Clone, Debug, PartialEq)]
    pub struct NestedMessage {
        nestedmessage_repeated_int32: ::protrust::collections::RepeatedField<i32>,
        nestedmessage_repeated_foreignmessage: ::protrust::collections::RepeatedField<self::super::ForeignMessage>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    static NESTED_MESSAGE_NESTEDMESSAGE_REPEATED_INT32_CODEC: ::protrust::Codec<i32> = ::protrust::Codec::int32(8);
    static NESTED_MESSAGE_NESTEDMESSAGE_REPEATED_FOREIGNMESSAGE_CODEC: ::protrust::Codec<self::super::ForeignMessage> = ::protrust::Codec::message(18);
    impl ::protrust::CodedMessage for self::NestedMessage {
        fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.nestedmessage_repeated_int32.add_entries(input, &NESTED_MESSAGE_NESTEDMESSAGE_REPEATED_INT32_CODEC)?,
                    18 => self.nestedmessage_repeated_foreignmessage.add_entries(input, &NESTED_MESSAGE_NESTEDMESSAGE_REPEATED_FOREIGNMESSAGE_CODEC)?,
                    _ => self.unknown_fields.merge_from(tag, input)?
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            size += self.nestedmessage_repeated_int32.calculate_size(&NESTED_MESSAGE_NESTEDMESSAGE_REPEATED_INT32_CODEC);
            size += self.nestedmessage_repeated_foreignmessage.calculate_size(&NESTED_MESSAGE_NESTEDMESSAGE_REPEATED_FOREIGNMESSAGE_CODEC);
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
            self.nestedmessage_repeated_int32.write_to(output, &NESTED_MESSAGE_NESTEDMESSAGE_REPEATED_INT32_CODEC)?;
            self.nestedmessage_repeated_foreignmessage.write_to(output, &NESTED_MESSAGE_NESTEDMESSAGE_REPEATED_FOREIGNMESSAGE_CODEC)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.nestedmessage_repeated_foreignmessage.is_initialized() {
                return false;
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::NestedMessage {
        fn new() -> Self {
            Self {
                nestedmessage_repeated_int32: ::protrust::collections::RepeatedField::new(),
                nestedmessage_repeated_foreignmessage: ::protrust::collections::RepeatedField::new(),
                unknown_fields: ::protrust::UnknownFieldSet::new(),
            }
        }
        fn merge(&mut self, other: &Self) {
            self.nestedmessage_repeated_int32.merge(&other.nestedmessage_repeated_int32);
            self.nestedmessage_repeated_foreignmessage.merge(&other.nestedmessage_repeated_foreignmessage);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::NestedMessage {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
            &self::super::file().messages()[27].messages()[0]
        }
    }
    impl self::NestedMessage {
        /// Gets the field number of the [`nestedmessage_repeated_int32`] field
        ///
        /// [`nestedmessage_repeated_int32`]: #method.nestedmessage_repeated_int32
        pub const NESTEDMESSAGE_REPEATED_INT32_FIELD_NUMBER: i32 = 1;
        pub fn nestedmessage_repeated_int32(&self) -> &::protrust::collections::RepeatedField<i32> {
            &self.nestedmessage_repeated_int32
        }
        /// Returns a unique reference to the [`nestedmessage_repeated_int32`] field
        ///
        /// [`nestedmessage_repeated_int32`]: #method.nestedmessage_repeated_int32
        pub fn nestedmessage_repeated_int32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
            &mut self.nestedmessage_repeated_int32
        }
        /// Gets the field number of the [`nestedmessage_repeated_foreignmessage`] field
        ///
        /// [`nestedmessage_repeated_foreignmessage`]: #method.nestedmessage_repeated_foreignmessage
        pub const NESTEDMESSAGE_REPEATED_FOREIGNMESSAGE_FIELD_NUMBER: i32 = 2;
        pub fn nestedmessage_repeated_foreignmessage(&self) -> &::protrust::collections::RepeatedField<self::super::ForeignMessage> {
            &self.nestedmessage_repeated_foreignmessage
        }
        /// Returns a unique reference to the [`nestedmessage_repeated_foreignmessage`] field
        ///
        /// [`nestedmessage_repeated_foreignmessage`]: #method.nestedmessage_repeated_foreignmessage
        pub fn nestedmessage_repeated_foreignmessage_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<self::super::ForeignMessage> {
            &mut self.nestedmessage_repeated_foreignmessage
        }
    }
}
/// Test message with CamelCase field names.  This violates Protocol Buffer
/// standard style.
#[derive(Clone, Debug, PartialEq)]
pub struct TestCamelCaseFieldNames {
    PrimitiveField: ::std::option::Option<i32>,
    StringField: ::std::option::Option<::std::string::String>,
    EnumField: ::std::option::Option<::protrust::EnumValue<self::ForeignEnum>>,
    MessageField: ::std::option::Option<::std::boxed::Box<self::ForeignMessage>>,
    StringPieceField: ::std::option::Option<::std::string::String>,
    CordField: ::std::option::Option<::std::string::String>,
    RepeatedPrimitiveField: ::protrust::collections::RepeatedField<i32>,
    RepeatedStringField: ::protrust::collections::RepeatedField<::std::string::String>,
    RepeatedEnumField: ::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>>,
    RepeatedMessageField: ::protrust::collections::RepeatedField<self::ForeignMessage>,
    RepeatedStringPieceField: ::protrust::collections::RepeatedField<::std::string::String>,
    RepeatedCordField: ::protrust::collections::RepeatedField<::std::string::String>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
static TEST_CAMEL_CASE_FIELD_NAMES_REPEATEDPRIMITIVEFIELD_CODEC: ::protrust::Codec<i32> = ::protrust::Codec::int32(56);
static TEST_CAMEL_CASE_FIELD_NAMES_REPEATEDSTRINGFIELD_CODEC: ::protrust::Codec<::std::string::String> = ::protrust::Codec::string(66);
static TEST_CAMEL_CASE_FIELD_NAMES_REPEATEDENUMFIELD_CODEC: ::protrust::Codec<::protrust::EnumValue<self::ForeignEnum>> = ::protrust::Codec::enum_value(72);
static TEST_CAMEL_CASE_FIELD_NAMES_REPEATEDMESSAGEFIELD_CODEC: ::protrust::Codec<self::ForeignMessage> = ::protrust::Codec::message(82);
static TEST_CAMEL_CASE_FIELD_NAMES_REPEATEDSTRINGPIECEFIELD_CODEC: ::protrust::Codec<::std::string::String> = ::protrust::Codec::string(90);
static TEST_CAMEL_CASE_FIELD_NAMES_REPEATEDCORDFIELD_CODEC: ::protrust::Codec<::std::string::String> = ::protrust::Codec::string(98);
impl ::protrust::CodedMessage for self::TestCamelCaseFieldNames {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 | 10 => self.PrimitiveField = ::std::option::Option::Some(input.read_int32()?),
                18 => self.StringField = ::std::option::Option::Some(input.read_string()?),
                24 | 26 => self.EnumField = ::std::option::Option::Some(input.read_enum_value()?),
                34 => input.read_message(&mut **self.MessageField.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                42 => self.StringPieceField = ::std::option::Option::Some(input.read_string()?),
                50 => self.CordField = ::std::option::Option::Some(input.read_string()?),
                56 | 58 => self.RepeatedPrimitiveField.add_entries(input, &TEST_CAMEL_CASE_FIELD_NAMES_REPEATEDPRIMITIVEFIELD_CODEC)?,
                66 => self.RepeatedStringField.add_entries(input, &TEST_CAMEL_CASE_FIELD_NAMES_REPEATEDSTRINGFIELD_CODEC)?,
                72 | 74 => self.RepeatedEnumField.add_entries(input, &TEST_CAMEL_CASE_FIELD_NAMES_REPEATEDENUMFIELD_CODEC)?,
                82 => self.RepeatedMessageField.add_entries(input, &TEST_CAMEL_CASE_FIELD_NAMES_REPEATEDMESSAGEFIELD_CODEC)?,
                90 => self.RepeatedStringPieceField.add_entries(input, &TEST_CAMEL_CASE_FIELD_NAMES_REPEATEDSTRINGPIECEFIELD_CODEC)?,
                98 => self.RepeatedCordField.add_entries(input, &TEST_CAMEL_CASE_FIELD_NAMES_REPEATEDCORDFIELD_CODEC)?,
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let PrimitiveField = self.PrimitiveField;
        if let ::std::option::Option::Some(PrimitiveField) = PrimitiveField {
            size += 1;
            size += ::protrust::io::sizes::int32(PrimitiveField);
        }
        let StringField = &self.StringField;
        if let ::std::option::Option::Some(StringField) = StringField {
            size += 1;
            size += ::protrust::io::sizes::string(StringField);
        }
        let EnumField = self.EnumField;
        if let ::std::option::Option::Some(EnumField) = EnumField {
            size += 1;
            size += ::protrust::io::sizes::enum_value(EnumField);
        }
        let MessageField = &self.MessageField;
        if let ::std::option::Option::Some(MessageField) = MessageField {
            size += 1;
            size += ::protrust::io::sizes::message(&**MessageField);
        }
        let StringPieceField = &self.StringPieceField;
        if let ::std::option::Option::Some(StringPieceField) = StringPieceField {
            size += 1;
            size += ::protrust::io::sizes::string(StringPieceField);
        }
        let CordField = &self.CordField;
        if let ::std::option::Option::Some(CordField) = CordField {
            size += 1;
            size += ::protrust::io::sizes::string(CordField);
        }
        size += self.RepeatedPrimitiveField.calculate_size(&TEST_CAMEL_CASE_FIELD_NAMES_REPEATEDPRIMITIVEFIELD_CODEC);
        size += self.RepeatedStringField.calculate_size(&TEST_CAMEL_CASE_FIELD_NAMES_REPEATEDSTRINGFIELD_CODEC);
        size += self.RepeatedEnumField.calculate_size(&TEST_CAMEL_CASE_FIELD_NAMES_REPEATEDENUMFIELD_CODEC);
        size += self.RepeatedMessageField.calculate_size(&TEST_CAMEL_CASE_FIELD_NAMES_REPEATEDMESSAGEFIELD_CODEC);
        size += self.RepeatedStringPieceField.calculate_size(&TEST_CAMEL_CASE_FIELD_NAMES_REPEATEDSTRINGPIECEFIELD_CODEC);
        size += self.RepeatedCordField.calculate_size(&TEST_CAMEL_CASE_FIELD_NAMES_REPEATEDCORDFIELD_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let PrimitiveField = self.PrimitiveField;
        if let ::std::option::Option::Some(PrimitiveField) = PrimitiveField {
            output.write_raw_tag_bytes(&[8])?;
            output.write_int32(PrimitiveField)?;
        }
        let StringField = &self.StringField;
        if let ::std::option::Option::Some(StringField) = StringField {
            output.write_raw_tag_bytes(&[18])?;
            output.write_string(StringField)?;
        }
        let EnumField = self.EnumField;
        if let ::std::option::Option::Some(EnumField) = EnumField {
            output.write_raw_tag_bytes(&[24])?;
            output.write_enum_value(EnumField)?;
        }
        let MessageField = &self.MessageField;
        if let ::std::option::Option::Some(MessageField) = MessageField {
            output.write_raw_tag_bytes(&[34])?;
            output.write_message(&**MessageField)?;
        }
        let StringPieceField = &self.StringPieceField;
        if let ::std::option::Option::Some(StringPieceField) = StringPieceField {
            output.write_raw_tag_bytes(&[42])?;
            output.write_string(StringPieceField)?;
        }
        let CordField = &self.CordField;
        if let ::std::option::Option::Some(CordField) = CordField {
            output.write_raw_tag_bytes(&[50])?;
            output.write_string(CordField)?;
        }
        self.RepeatedPrimitiveField.write_to(output, &TEST_CAMEL_CASE_FIELD_NAMES_REPEATEDPRIMITIVEFIELD_CODEC)?;
        self.RepeatedStringField.write_to(output, &TEST_CAMEL_CASE_FIELD_NAMES_REPEATEDSTRINGFIELD_CODEC)?;
        self.RepeatedEnumField.write_to(output, &TEST_CAMEL_CASE_FIELD_NAMES_REPEATEDENUMFIELD_CODEC)?;
        self.RepeatedMessageField.write_to(output, &TEST_CAMEL_CASE_FIELD_NAMES_REPEATEDMESSAGEFIELD_CODEC)?;
        self.RepeatedStringPieceField.write_to(output, &TEST_CAMEL_CASE_FIELD_NAMES_REPEATEDSTRINGPIECEFIELD_CODEC)?;
        self.RepeatedCordField.write_to(output, &TEST_CAMEL_CASE_FIELD_NAMES_REPEATEDCORDFIELD_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        if let Some(MessageField) = &self.MessageField {
            if !::protrust::CodedMessage::is_initialized(&**MessageField) {
                return false;
            }
        }
        if !self.RepeatedMessageField.is_initialized() {
            return false;
        }
        true
    }
}
impl ::protrust::LiteMessage for self::TestCamelCaseFieldNames {
    fn new() -> Self {
        Self {
            PrimitiveField: ::std::option::Option::None,
            StringField: ::std::option::Option::None,
            EnumField: ::std::option::Option::None,
            MessageField: ::std::option::Option::None,
            StringPieceField: ::std::option::Option::None,
            CordField: ::std::option::Option::None,
            RepeatedPrimitiveField: ::protrust::collections::RepeatedField::new(),
            RepeatedStringField: ::protrust::collections::RepeatedField::new(),
            RepeatedEnumField: ::protrust::collections::RepeatedField::new(),
            RepeatedMessageField: ::protrust::collections::RepeatedField::new(),
            RepeatedStringPieceField: ::protrust::collections::RepeatedField::new(),
            RepeatedCordField: ::protrust::collections::RepeatedField::new(),
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.PrimitiveField = other.PrimitiveField;
        self.StringField = other.StringField.clone();
        self.EnumField = other.EnumField;
        if let ::std::option::Option::Some(MessageField) = &other.MessageField {
            self.MessageField.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(MessageField);
        }
        self.StringPieceField = other.StringPieceField.clone();
        self.CordField = other.CordField.clone();
        self.RepeatedPrimitiveField.merge(&other.RepeatedPrimitiveField);
        self.RepeatedStringField.merge(&other.RepeatedStringField);
        self.RepeatedEnumField.merge(&other.RepeatedEnumField);
        self.RepeatedMessageField.merge(&other.RepeatedMessageField);
        self.RepeatedStringPieceField.merge(&other.RepeatedStringPieceField);
        self.RepeatedCordField.merge(&other.RepeatedCordField);
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestCamelCaseFieldNames {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[28]
    }
}
impl self::TestCamelCaseFieldNames {
    /// Gets the field number of the [`PrimitiveField`] field
    ///
    /// [`PrimitiveField`]: #method.PrimitiveField
    pub const PRIMITIVEFIELD_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`PrimitiveField`] field
    ///
    /// [`PrimitiveField`]: #method.PrimitiveField
    pub const PRIMITIVEFIELD_DEFAULT_VALUE: i32 = 0;
    pub fn PrimitiveField(&self) -> i32 {
        self.PrimitiveField.unwrap_or(Self::PRIMITIVEFIELD_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`PrimitiveField`] field
    ///
    /// [`PrimitiveField`]: #method.PrimitiveField
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn PrimitiveField_option(&self) -> ::std::option::Option<i32> {
        self.PrimitiveField
    }
    /// Returns a bool indicating the presence of the [`PrimitiveField`] field
    ///
    /// [`PrimitiveField`]: #method.PrimitiveField
    pub fn has_PrimitiveField(&self) -> bool {
        self.PrimitiveField.is_some()
    }
    /// Sets the value of the [`PrimitiveField`] field
    ///
    /// [`PrimitiveField`]: #method.PrimitiveField
    pub fn set_PrimitiveField(&mut self, value: i32) {
        self.PrimitiveField = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`PrimitiveField`] field
    ///
    /// [`PrimitiveField`]: #method.PrimitiveField
    pub fn clear_PrimitiveField(&mut self) {
        self.PrimitiveField = ::std::option::Option::None
    }
    /// Gets the field number of the [`StringField`] field
    ///
    /// [`StringField`]: #method.StringField
    pub const STRINGFIELD_FIELD_NUMBER: i32 = 2;
    /// A constant value representing the default value of the [`StringField`] field
    ///
    /// [`StringField`]: #method.StringField
    pub const STRINGFIELD_DEFAULT_VALUE: &'static str = "";
    pub fn StringField(&self) -> &str {
        self.StringField.as_ref().map(|v| &**v).unwrap_or(Self::STRINGFIELD_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`StringField`] field
    ///
    /// [`StringField`]: #method.StringField
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn StringField_option(&self) -> ::std::option::Option<&::std::string::String> {
        self.StringField.as_ref()
    }
    /// Returns a unique reference to the [`StringField`] field
    ///
    /// [`StringField`]: #method.StringField
    pub fn StringField_mut(&mut self) -> &mut ::std::string::String {
        self.StringField.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`StringField`] field
    ///
    /// [`StringField`]: #method.StringField
    pub fn has_StringField(&self) -> bool {
        self.StringField.is_some()
    }
    /// Sets the value of the [`StringField`] field
    ///
    /// [`StringField`]: #method.StringField
    pub fn set_StringField(&mut self, value: ::std::string::String) {
        self.StringField = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`StringField`] field, leaving it empty
    ///
    /// [`StringField`]: #method.StringField
    pub fn take_StringField(&mut self) -> ::std::option::Option<::std::string::String> {
        self.StringField.take()
    }
    /// Clears the value of the [`StringField`] field
    ///
    /// [`StringField`]: #method.StringField
    pub fn clear_StringField(&mut self) {
        self.StringField = ::std::option::Option::None
    }
    /// Gets the field number of the [`EnumField`] field
    ///
    /// [`EnumField`]: #method.EnumField
    pub const ENUMFIELD_FIELD_NUMBER: i32 = 3;
    /// A constant value representing the default value of the [`EnumField`] field
    ///
    /// [`EnumField`]: #method.EnumField
    pub const ENUMFIELD_DEFAULT_VALUE: ::protrust::EnumValue<self::ForeignEnum> = ::protrust::EnumValue::Undefined(0);
    pub fn EnumField(&self) -> ::protrust::EnumValue<self::ForeignEnum> {
        self.EnumField.unwrap_or(Self::ENUMFIELD_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`EnumField`] field
    ///
    /// [`EnumField`]: #method.EnumField
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn EnumField_option(&self) -> ::std::option::Option<::protrust::EnumValue<self::ForeignEnum>> {
        self.EnumField
    }
    /// Returns a bool indicating the presence of the [`EnumField`] field
    ///
    /// [`EnumField`]: #method.EnumField
    pub fn has_EnumField(&self) -> bool {
        self.EnumField.is_some()
    }
    /// Sets the value of the [`EnumField`] field
    ///
    /// [`EnumField`]: #method.EnumField
    pub fn set_EnumField(&mut self, value: ::protrust::EnumValue<self::ForeignEnum>) {
        self.EnumField = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`EnumField`] field
    ///
    /// [`EnumField`]: #method.EnumField
    pub fn clear_EnumField(&mut self) {
        self.EnumField = ::std::option::Option::None
    }
    /// Gets the field number of the [`MessageField`] field
    ///
    /// [`MessageField`]: #method.MessageField
    pub const MESSAGEFIELD_FIELD_NUMBER: i32 = 4;
    pub fn MessageField_option(&self) -> ::std::option::Option<&self::ForeignMessage> {
        self.MessageField.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`MessageField`] field
    ///
    /// [`MessageField`]: #method.MessageField
    pub fn MessageField_mut(&mut self) -> &mut self::ForeignMessage {
        self.MessageField.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`MessageField`] field
    ///
    /// [`MessageField`]: #method.MessageField
    pub fn has_MessageField(&self) -> bool {
        self.MessageField.is_some()
    }
    /// Sets the value of the [`MessageField`] field
    ///
    /// [`MessageField`]: #method.MessageField
    pub fn set_MessageField(&mut self, value: self::ForeignMessage) {
        self.MessageField = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`MessageField`] field, leaving it empty
    ///
    /// [`MessageField`]: #method.MessageField
    pub fn take_MessageField(&mut self) -> ::std::option::Option<self::ForeignMessage> {
        self.MessageField.take().map(|b| *b)
    }
    /// Clears the value of the [`MessageField`] field
    ///
    /// [`MessageField`]: #method.MessageField
    pub fn clear_MessageField(&mut self) {
        self.MessageField = ::std::option::Option::None
    }
    /// Gets the field number of the [`StringPieceField`] field
    ///
    /// [`StringPieceField`]: #method.StringPieceField
    pub const STRINGPIECEFIELD_FIELD_NUMBER: i32 = 5;
    /// A constant value representing the default value of the [`StringPieceField`] field
    ///
    /// [`StringPieceField`]: #method.StringPieceField
    pub const STRINGPIECEFIELD_DEFAULT_VALUE: &'static str = "";
    pub fn StringPieceField(&self) -> &str {
        self.StringPieceField.as_ref().map(|v| &**v).unwrap_or(Self::STRINGPIECEFIELD_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`StringPieceField`] field
    ///
    /// [`StringPieceField`]: #method.StringPieceField
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn StringPieceField_option(&self) -> ::std::option::Option<&::std::string::String> {
        self.StringPieceField.as_ref()
    }
    /// Returns a unique reference to the [`StringPieceField`] field
    ///
    /// [`StringPieceField`]: #method.StringPieceField
    pub fn StringPieceField_mut(&mut self) -> &mut ::std::string::String {
        self.StringPieceField.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`StringPieceField`] field
    ///
    /// [`StringPieceField`]: #method.StringPieceField
    pub fn has_StringPieceField(&self) -> bool {
        self.StringPieceField.is_some()
    }
    /// Sets the value of the [`StringPieceField`] field
    ///
    /// [`StringPieceField`]: #method.StringPieceField
    pub fn set_StringPieceField(&mut self, value: ::std::string::String) {
        self.StringPieceField = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`StringPieceField`] field, leaving it empty
    ///
    /// [`StringPieceField`]: #method.StringPieceField
    pub fn take_StringPieceField(&mut self) -> ::std::option::Option<::std::string::String> {
        self.StringPieceField.take()
    }
    /// Clears the value of the [`StringPieceField`] field
    ///
    /// [`StringPieceField`]: #method.StringPieceField
    pub fn clear_StringPieceField(&mut self) {
        self.StringPieceField = ::std::option::Option::None
    }
    /// Gets the field number of the [`CordField`] field
    ///
    /// [`CordField`]: #method.CordField
    pub const CORDFIELD_FIELD_NUMBER: i32 = 6;
    /// A constant value representing the default value of the [`CordField`] field
    ///
    /// [`CordField`]: #method.CordField
    pub const CORDFIELD_DEFAULT_VALUE: &'static str = "";
    pub fn CordField(&self) -> &str {
        self.CordField.as_ref().map(|v| &**v).unwrap_or(Self::CORDFIELD_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`CordField`] field
    ///
    /// [`CordField`]: #method.CordField
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn CordField_option(&self) -> ::std::option::Option<&::std::string::String> {
        self.CordField.as_ref()
    }
    /// Returns a unique reference to the [`CordField`] field
    ///
    /// [`CordField`]: #method.CordField
    pub fn CordField_mut(&mut self) -> &mut ::std::string::String {
        self.CordField.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`CordField`] field
    ///
    /// [`CordField`]: #method.CordField
    pub fn has_CordField(&self) -> bool {
        self.CordField.is_some()
    }
    /// Sets the value of the [`CordField`] field
    ///
    /// [`CordField`]: #method.CordField
    pub fn set_CordField(&mut self, value: ::std::string::String) {
        self.CordField = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`CordField`] field, leaving it empty
    ///
    /// [`CordField`]: #method.CordField
    pub fn take_CordField(&mut self) -> ::std::option::Option<::std::string::String> {
        self.CordField.take()
    }
    /// Clears the value of the [`CordField`] field
    ///
    /// [`CordField`]: #method.CordField
    pub fn clear_CordField(&mut self) {
        self.CordField = ::std::option::Option::None
    }
    /// Gets the field number of the [`RepeatedPrimitiveField`] field
    ///
    /// [`RepeatedPrimitiveField`]: #method.RepeatedPrimitiveField
    pub const REPEATEDPRIMITIVEFIELD_FIELD_NUMBER: i32 = 7;
    pub fn RepeatedPrimitiveField(&self) -> &::protrust::collections::RepeatedField<i32> {
        &self.RepeatedPrimitiveField
    }
    /// Returns a unique reference to the [`RepeatedPrimitiveField`] field
    ///
    /// [`RepeatedPrimitiveField`]: #method.RepeatedPrimitiveField
    pub fn RepeatedPrimitiveField_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
        &mut self.RepeatedPrimitiveField
    }
    /// Gets the field number of the [`RepeatedStringField`] field
    ///
    /// [`RepeatedStringField`]: #method.RepeatedStringField
    pub const REPEATEDSTRINGFIELD_FIELD_NUMBER: i32 = 8;
    pub fn RepeatedStringField(&self) -> &::protrust::collections::RepeatedField<::std::string::String> {
        &self.RepeatedStringField
    }
    /// Returns a unique reference to the [`RepeatedStringField`] field
    ///
    /// [`RepeatedStringField`]: #method.RepeatedStringField
    pub fn RepeatedStringField_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<::std::string::String> {
        &mut self.RepeatedStringField
    }
    /// Gets the field number of the [`RepeatedEnumField`] field
    ///
    /// [`RepeatedEnumField`]: #method.RepeatedEnumField
    pub const REPEATEDENUMFIELD_FIELD_NUMBER: i32 = 9;
    pub fn RepeatedEnumField(&self) -> &::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>> {
        &self.RepeatedEnumField
    }
    /// Returns a unique reference to the [`RepeatedEnumField`] field
    ///
    /// [`RepeatedEnumField`]: #method.RepeatedEnumField
    pub fn RepeatedEnumField_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>> {
        &mut self.RepeatedEnumField
    }
    /// Gets the field number of the [`RepeatedMessageField`] field
    ///
    /// [`RepeatedMessageField`]: #method.RepeatedMessageField
    pub const REPEATEDMESSAGEFIELD_FIELD_NUMBER: i32 = 10;
    pub fn RepeatedMessageField(&self) -> &::protrust::collections::RepeatedField<self::ForeignMessage> {
        &self.RepeatedMessageField
    }
    /// Returns a unique reference to the [`RepeatedMessageField`] field
    ///
    /// [`RepeatedMessageField`]: #method.RepeatedMessageField
    pub fn RepeatedMessageField_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<self::ForeignMessage> {
        &mut self.RepeatedMessageField
    }
    /// Gets the field number of the [`RepeatedStringPieceField`] field
    ///
    /// [`RepeatedStringPieceField`]: #method.RepeatedStringPieceField
    pub const REPEATEDSTRINGPIECEFIELD_FIELD_NUMBER: i32 = 11;
    pub fn RepeatedStringPieceField(&self) -> &::protrust::collections::RepeatedField<::std::string::String> {
        &self.RepeatedStringPieceField
    }
    /// Returns a unique reference to the [`RepeatedStringPieceField`] field
    ///
    /// [`RepeatedStringPieceField`]: #method.RepeatedStringPieceField
    pub fn RepeatedStringPieceField_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<::std::string::String> {
        &mut self.RepeatedStringPieceField
    }
    /// Gets the field number of the [`RepeatedCordField`] field
    ///
    /// [`RepeatedCordField`]: #method.RepeatedCordField
    pub const REPEATEDCORDFIELD_FIELD_NUMBER: i32 = 12;
    pub fn RepeatedCordField(&self) -> &::protrust::collections::RepeatedField<::std::string::String> {
        &self.RepeatedCordField
    }
    /// Returns a unique reference to the [`RepeatedCordField`] field
    ///
    /// [`RepeatedCordField`]: #method.RepeatedCordField
    pub fn RepeatedCordField_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<::std::string::String> {
        &mut self.RepeatedCordField
    }
}
/// We list fields out of order, to ensure that we're using field number and not
/// field index to determine serialization order.
#[derive(Clone, Debug, PartialEq)]
pub struct TestFieldOrderings {
    my_string: ::std::option::Option<::std::string::String>,
    my_int: ::std::option::Option<i64>,
    my_float: ::std::option::Option<f32>,
    optional_nested_message: ::std::option::Option<::std::boxed::Box<self::test_field_orderings::NestedMessage>>,
    unknown_fields: ::protrust::UnknownFieldSet,
    extensions: ::protrust::ExtensionSet<Self>,
}
impl ::protrust::CodedMessage for self::TestFieldOrderings {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                90 => self.my_string = ::std::option::Option::Some(input.read_string()?),
                8 | 10 => self.my_int = ::std::option::Option::Some(input.read_int64()?),
                813 | 810 => self.my_float = ::std::option::Option::Some(input.read_float()?),
                1602 => input.read_message(&mut **self.optional_nested_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let my_string = &self.my_string;
        if let ::std::option::Option::Some(my_string) = my_string {
            size += 1;
            size += ::protrust::io::sizes::string(my_string);
        }
        let my_int = self.my_int;
        if let ::std::option::Option::Some(my_int) = my_int {
            size += 1;
            size += ::protrust::io::sizes::int64(my_int);
        }
        let my_float = self.my_float;
        if let ::std::option::Option::Some(my_float) = my_float {
            size += 2;
            size += ::protrust::io::sizes::float(my_float);
        }
        let optional_nested_message = &self.optional_nested_message;
        if let ::std::option::Option::Some(optional_nested_message) = optional_nested_message {
            size += 2;
            size += ::protrust::io::sizes::message(&**optional_nested_message);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let my_string = &self.my_string;
        if let ::std::option::Option::Some(my_string) = my_string {
            output.write_raw_tag_bytes(&[90])?;
            output.write_string(my_string)?;
        }
        let my_int = self.my_int;
        if let ::std::option::Option::Some(my_int) = my_int {
            output.write_raw_tag_bytes(&[8])?;
            output.write_int64(my_int)?;
        }
        let my_float = self.my_float;
        if let ::std::option::Option::Some(my_float) = my_float {
            output.write_raw_tag_bytes(&[173, 6])?;
            output.write_float(my_float)?;
        }
        let optional_nested_message = &self.optional_nested_message;
        if let ::std::option::Option::Some(optional_nested_message) = optional_nested_message {
            output.write_raw_tag_bytes(&[194, 12])?;
            output.write_message(&**optional_nested_message)?;
        }
        self.unknown_fields.write_to(output)?;
        self.extensions.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        if let Some(optional_nested_message) = &self.optional_nested_message {
            if !::protrust::CodedMessage::is_initialized(&**optional_nested_message) {
                return false;
            }
        }
        true
    }
}
impl ::protrust::LiteMessage for self::TestFieldOrderings {
    fn new() -> Self {
        Self {
            my_string: ::std::option::Option::None,
            my_int: ::std::option::Option::None,
            my_float: ::std::option::Option::None,
            optional_nested_message: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
            extensions: ::protrust::ExtensionSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.my_string = other.my_string.clone();
        self.my_int = other.my_int;
        self.my_float = other.my_float;
        if let ::std::option::Option::Some(optional_nested_message) = &other.optional_nested_message {
            self.optional_nested_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(optional_nested_message);
        }
        self.unknown_fields.merge(&other.unknown_fields);
        self.extensions.merge(&other.extensions);
    }
}
impl ::protrust::ExtensionMessage for self::TestFieldOrderings {
    fn registry(&self) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> { self.extensions.registry() }
    fn replace_registry(&mut self, extensions: ::std::option::Option<&'static ::protrust::ExtensionRegistry>) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> { self.extensions.replace_registry(extensions) }
    fn field<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::cmp::PartialEq<D> + ::std::fmt::Debug + ::std::marker::Sync, D: ::std::fmt::Debug + ::std::marker::Sync>(&self, extension: &'static ::protrust::Extension<Self, V, D>) -> ::std::option::Option<&::protrust::ExtensionField<V, D>> { self.extensions.field(extension) }
    fn field_mut<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::cmp::PartialEq<D> + ::std::fmt::Debug + ::std::marker::Sync, D: ::std::fmt::Debug + ::std::marker::Sync>(&mut self, extension: &'static ::protrust::Extension<Self, V, D>) -> ::std::option::Option<&mut ::protrust::ExtensionField<V, D>> { self.extensions.field_mut(extension) }
    fn repeated_field<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::fmt::Debug + ::std::marker::Sync + 'static>(&self, extension: &'static ::protrust::RepeatedExtension<Self, V>) -> ::std::option::Option<&::protrust::collections::RepeatedField<V>> { self.extensions.repeated_field(extension) }
    fn repeated_field_mut<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::fmt::Debug + ::std::marker::Sync + 'static>(&mut self, extension: &'static ::protrust::RepeatedExtension<Self, V>) -> ::std::option::Option<&mut ::protrust::collections::RepeatedField<V>> { self.extensions.repeated_field_mut(extension) }
}
impl ::protrust::Message for self::TestFieldOrderings {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[29]
    }
}
impl self::TestFieldOrderings {
    /// Gets the field number of the [`my_string`] field
    ///
    /// [`my_string`]: #method.my_string
    pub const MY_STRING_FIELD_NUMBER: i32 = 11;
    /// A constant value representing the default value of the [`my_string`] field
    ///
    /// [`my_string`]: #method.my_string
    pub const MY_STRING_DEFAULT_VALUE: &'static str = "";
    pub fn my_string(&self) -> &str {
        self.my_string.as_ref().map(|v| &**v).unwrap_or(Self::MY_STRING_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`my_string`] field
    ///
    /// [`my_string`]: #method.my_string
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn my_string_option(&self) -> ::std::option::Option<&::std::string::String> {
        self.my_string.as_ref()
    }
    /// Returns a unique reference to the [`my_string`] field
    ///
    /// [`my_string`]: #method.my_string
    pub fn my_string_mut(&mut self) -> &mut ::std::string::String {
        self.my_string.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`my_string`] field
    ///
    /// [`my_string`]: #method.my_string
    pub fn has_my_string(&self) -> bool {
        self.my_string.is_some()
    }
    /// Sets the value of the [`my_string`] field
    ///
    /// [`my_string`]: #method.my_string
    pub fn set_my_string(&mut self, value: ::std::string::String) {
        self.my_string = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`my_string`] field, leaving it empty
    ///
    /// [`my_string`]: #method.my_string
    pub fn take_my_string(&mut self) -> ::std::option::Option<::std::string::String> {
        self.my_string.take()
    }
    /// Clears the value of the [`my_string`] field
    ///
    /// [`my_string`]: #method.my_string
    pub fn clear_my_string(&mut self) {
        self.my_string = ::std::option::Option::None
    }
    /// Gets the field number of the [`my_int`] field
    ///
    /// [`my_int`]: #method.my_int
    pub const MY_INT_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`my_int`] field
    ///
    /// [`my_int`]: #method.my_int
    pub const MY_INT_DEFAULT_VALUE: i64 = 0;
    pub fn my_int(&self) -> i64 {
        self.my_int.unwrap_or(Self::MY_INT_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`my_int`] field
    ///
    /// [`my_int`]: #method.my_int
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn my_int_option(&self) -> ::std::option::Option<i64> {
        self.my_int
    }
    /// Returns a bool indicating the presence of the [`my_int`] field
    ///
    /// [`my_int`]: #method.my_int
    pub fn has_my_int(&self) -> bool {
        self.my_int.is_some()
    }
    /// Sets the value of the [`my_int`] field
    ///
    /// [`my_int`]: #method.my_int
    pub fn set_my_int(&mut self, value: i64) {
        self.my_int = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`my_int`] field
    ///
    /// [`my_int`]: #method.my_int
    pub fn clear_my_int(&mut self) {
        self.my_int = ::std::option::Option::None
    }
    /// Gets the field number of the [`my_float`] field
    ///
    /// [`my_float`]: #method.my_float
    pub const MY_FLOAT_FIELD_NUMBER: i32 = 101;
    /// A constant value representing the default value of the [`my_float`] field
    ///
    /// [`my_float`]: #method.my_float
    pub const MY_FLOAT_DEFAULT_VALUE: f32 = 0.0;
    pub fn my_float(&self) -> f32 {
        self.my_float.unwrap_or(Self::MY_FLOAT_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`my_float`] field
    ///
    /// [`my_float`]: #method.my_float
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn my_float_option(&self) -> ::std::option::Option<f32> {
        self.my_float
    }
    /// Returns a bool indicating the presence of the [`my_float`] field
    ///
    /// [`my_float`]: #method.my_float
    pub fn has_my_float(&self) -> bool {
        self.my_float.is_some()
    }
    /// Sets the value of the [`my_float`] field
    ///
    /// [`my_float`]: #method.my_float
    pub fn set_my_float(&mut self, value: f32) {
        self.my_float = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`my_float`] field
    ///
    /// [`my_float`]: #method.my_float
    pub fn clear_my_float(&mut self) {
        self.my_float = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_nested_message`] field
    ///
    /// [`optional_nested_message`]: #method.optional_nested_message
    pub const OPTIONAL_NESTED_MESSAGE_FIELD_NUMBER: i32 = 200;
    pub fn optional_nested_message_option(&self) -> ::std::option::Option<&self::test_field_orderings::NestedMessage> {
        self.optional_nested_message.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`optional_nested_message`] field
    ///
    /// [`optional_nested_message`]: #method.optional_nested_message
    pub fn optional_nested_message_mut(&mut self) -> &mut self::test_field_orderings::NestedMessage {
        self.optional_nested_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`optional_nested_message`] field
    ///
    /// [`optional_nested_message`]: #method.optional_nested_message
    pub fn has_optional_nested_message(&self) -> bool {
        self.optional_nested_message.is_some()
    }
    /// Sets the value of the [`optional_nested_message`] field
    ///
    /// [`optional_nested_message`]: #method.optional_nested_message
    pub fn set_optional_nested_message(&mut self, value: self::test_field_orderings::NestedMessage) {
        self.optional_nested_message = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`optional_nested_message`] field, leaving it empty
    ///
    /// [`optional_nested_message`]: #method.optional_nested_message
    pub fn take_optional_nested_message(&mut self) -> ::std::option::Option<self::test_field_orderings::NestedMessage> {
        self.optional_nested_message.take().map(|b| *b)
    }
    /// Clears the value of the [`optional_nested_message`] field
    ///
    /// [`optional_nested_message`]: #method.optional_nested_message
    pub fn clear_optional_nested_message(&mut self) {
        self.optional_nested_message = ::std::option::Option::None
    }
}
/// We list fields out of order, to ensure that we're using field number and not
/// field index to determine serialization order.
pub mod test_field_orderings {
    #[derive(Clone, Debug, PartialEq)]
    pub struct NestedMessage {
        oo: ::std::option::Option<i64>,
        bb: ::std::option::Option<i32>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::NestedMessage {
        fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    16 | 18 => self.oo = ::std::option::Option::Some(input.read_int64()?),
                    8 | 10 => self.bb = ::std::option::Option::Some(input.read_int32()?),
                    _ => self.unknown_fields.merge_from(tag, input)?
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            let oo = self.oo;
            if let ::std::option::Option::Some(oo) = oo {
                size += 1;
                size += ::protrust::io::sizes::int64(oo);
            }
            let bb = self.bb;
            if let ::std::option::Option::Some(bb) = bb {
                size += 1;
                size += ::protrust::io::sizes::int32(bb);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
            let oo = self.oo;
            if let ::std::option::Option::Some(oo) = oo {
                output.write_raw_tag_bytes(&[16])?;
                output.write_int64(oo)?;
            }
            let bb = self.bb;
            if let ::std::option::Option::Some(bb) = bb {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(bb)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
    }
    impl ::protrust::LiteMessage for self::NestedMessage {
        fn new() -> Self {
            Self {
                oo: ::std::option::Option::None,
                bb: ::std::option::Option::None,
                unknown_fields: ::protrust::UnknownFieldSet::new(),
            }
        }
        fn merge(&mut self, other: &Self) {
            self.oo = other.oo;
            self.bb = other.bb;
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::NestedMessage {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
            &self::super::file().messages()[29].messages()[0]
        }
    }
    impl self::NestedMessage {
        /// Gets the field number of the [`oo`] field
        ///
        /// [`oo`]: #method.oo
        pub const OO_FIELD_NUMBER: i32 = 2;
        /// A constant value representing the default value of the [`oo`] field
        ///
        /// [`oo`]: #method.oo
        pub const OO_DEFAULT_VALUE: i64 = 0;
        pub fn oo(&self) -> i64 {
            self.oo.unwrap_or(Self::OO_DEFAULT_VALUE)
        }
        /// Returns an [`Option`] representing the presence of the [`oo`] field
        ///
        /// [`oo`]: #method.oo
        /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
        pub fn oo_option(&self) -> ::std::option::Option<i64> {
            self.oo
        }
        /// Returns a bool indicating the presence of the [`oo`] field
        ///
        /// [`oo`]: #method.oo
        pub fn has_oo(&self) -> bool {
            self.oo.is_some()
        }
        /// Sets the value of the [`oo`] field
        ///
        /// [`oo`]: #method.oo
        pub fn set_oo(&mut self, value: i64) {
            self.oo = ::std::option::Option::Some(value)
        }
        /// Clears the value of the [`oo`] field
        ///
        /// [`oo`]: #method.oo
        pub fn clear_oo(&mut self) {
            self.oo = ::std::option::Option::None
        }
        /// Gets the field number of the [`bb`] field
        ///
        /// [`bb`]: #method.bb
        pub const BB_FIELD_NUMBER: i32 = 1;
        /// A constant value representing the default value of the [`bb`] field
        ///
        /// [`bb`]: #method.bb
        pub const BB_DEFAULT_VALUE: i32 = 0;
        /// The field name "b" fails to compile in proto1 because it conflicts with
        /// a local variable named "b" in one of the generated methods.  Doh.
        /// This file needs to compile in proto1 to test backwards-compatibility.
        pub fn bb(&self) -> i32 {
            self.bb.unwrap_or(Self::BB_DEFAULT_VALUE)
        }
        /// Returns an [`Option`] representing the presence of the [`bb`] field
        ///
        /// [`bb`]: #method.bb
        /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
        pub fn bb_option(&self) -> ::std::option::Option<i32> {
            self.bb
        }
        /// Returns a bool indicating the presence of the [`bb`] field
        ///
        /// [`bb`]: #method.bb
        pub fn has_bb(&self) -> bool {
            self.bb.is_some()
        }
        /// Sets the value of the [`bb`] field
        ///
        /// [`bb`]: #method.bb
        pub fn set_bb(&mut self, value: i32) {
            self.bb = ::std::option::Option::Some(value)
        }
        /// Clears the value of the [`bb`] field
        ///
        /// [`bb`]: #method.bb
        pub fn clear_bb(&mut self) {
            self.bb = ::std::option::Option::None
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct TestExtensionOrderings1 {
    my_string: ::std::option::Option<::std::string::String>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::TestExtensionOrderings1 {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.my_string = ::std::option::Option::Some(input.read_string()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let my_string = &self.my_string;
        if let ::std::option::Option::Some(my_string) = my_string {
            size += 1;
            size += ::protrust::io::sizes::string(my_string);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let my_string = &self.my_string;
        if let ::std::option::Option::Some(my_string) = my_string {
            output.write_raw_tag_bytes(&[10])?;
            output.write_string(my_string)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::TestExtensionOrderings1 {
    fn new() -> Self {
        Self {
            my_string: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.my_string = other.my_string.clone();
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestExtensionOrderings1 {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[30]
    }
}
impl self::TestExtensionOrderings1 {
    /// Gets the field number of the [`my_string`] field
    ///
    /// [`my_string`]: #method.my_string
    pub const MY_STRING_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`my_string`] field
    ///
    /// [`my_string`]: #method.my_string
    pub const MY_STRING_DEFAULT_VALUE: &'static str = "";
    pub fn my_string(&self) -> &str {
        self.my_string.as_ref().map(|v| &**v).unwrap_or(Self::MY_STRING_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`my_string`] field
    ///
    /// [`my_string`]: #method.my_string
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn my_string_option(&self) -> ::std::option::Option<&::std::string::String> {
        self.my_string.as_ref()
    }
    /// Returns a unique reference to the [`my_string`] field
    ///
    /// [`my_string`]: #method.my_string
    pub fn my_string_mut(&mut self) -> &mut ::std::string::String {
        self.my_string.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`my_string`] field
    ///
    /// [`my_string`]: #method.my_string
    pub fn has_my_string(&self) -> bool {
        self.my_string.is_some()
    }
    /// Sets the value of the [`my_string`] field
    ///
    /// [`my_string`]: #method.my_string
    pub fn set_my_string(&mut self, value: ::std::string::String) {
        self.my_string = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`my_string`] field, leaving it empty
    ///
    /// [`my_string`]: #method.my_string
    pub fn take_my_string(&mut self) -> ::std::option::Option<::std::string::String> {
        self.my_string.take()
    }
    /// Clears the value of the [`my_string`] field
    ///
    /// [`my_string`]: #method.my_string
    pub fn clear_my_string(&mut self) {
        self.my_string = ::std::option::Option::None
    }
}
pub mod test_extension_orderings1 {
    pub static TEST_EXT_ORDERINGS1: ::protrust::Extension<self::super::TestFieldOrderings, self::super::TestExtensionOrderings1, self::super::TestExtensionOrderings1> = ::protrust::Extension::message(106);
}
#[derive(Clone, Debug, PartialEq)]
pub struct TestExtensionOrderings2 {
    my_string: ::std::option::Option<::std::string::String>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::TestExtensionOrderings2 {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.my_string = ::std::option::Option::Some(input.read_string()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let my_string = &self.my_string;
        if let ::std::option::Option::Some(my_string) = my_string {
            size += 1;
            size += ::protrust::io::sizes::string(my_string);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let my_string = &self.my_string;
        if let ::std::option::Option::Some(my_string) = my_string {
            output.write_raw_tag_bytes(&[10])?;
            output.write_string(my_string)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::TestExtensionOrderings2 {
    fn new() -> Self {
        Self {
            my_string: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.my_string = other.my_string.clone();
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestExtensionOrderings2 {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[31]
    }
}
impl self::TestExtensionOrderings2 {
    /// Gets the field number of the [`my_string`] field
    ///
    /// [`my_string`]: #method.my_string
    pub const MY_STRING_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`my_string`] field
    ///
    /// [`my_string`]: #method.my_string
    pub const MY_STRING_DEFAULT_VALUE: &'static str = "";
    pub fn my_string(&self) -> &str {
        self.my_string.as_ref().map(|v| &**v).unwrap_or(Self::MY_STRING_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`my_string`] field
    ///
    /// [`my_string`]: #method.my_string
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn my_string_option(&self) -> ::std::option::Option<&::std::string::String> {
        self.my_string.as_ref()
    }
    /// Returns a unique reference to the [`my_string`] field
    ///
    /// [`my_string`]: #method.my_string
    pub fn my_string_mut(&mut self) -> &mut ::std::string::String {
        self.my_string.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`my_string`] field
    ///
    /// [`my_string`]: #method.my_string
    pub fn has_my_string(&self) -> bool {
        self.my_string.is_some()
    }
    /// Sets the value of the [`my_string`] field
    ///
    /// [`my_string`]: #method.my_string
    pub fn set_my_string(&mut self, value: ::std::string::String) {
        self.my_string = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`my_string`] field, leaving it empty
    ///
    /// [`my_string`]: #method.my_string
    pub fn take_my_string(&mut self) -> ::std::option::Option<::std::string::String> {
        self.my_string.take()
    }
    /// Clears the value of the [`my_string`] field
    ///
    /// [`my_string`]: #method.my_string
    pub fn clear_my_string(&mut self) {
        self.my_string = ::std::option::Option::None
    }
}
pub mod test_extension_orderings2 {
    #[derive(Clone, Debug, PartialEq)]
    pub struct TestExtensionOrderings3 {
        my_string: ::std::option::Option<::std::string::String>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestExtensionOrderings3 {
        fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => self.my_string = ::std::option::Option::Some(input.read_string()?),
                    _ => self.unknown_fields.merge_from(tag, input)?
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            let my_string = &self.my_string;
            if let ::std::option::Option::Some(my_string) = my_string {
                size += 1;
                size += ::protrust::io::sizes::string(my_string);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
            let my_string = &self.my_string;
            if let ::std::option::Option::Some(my_string) = my_string {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(my_string)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
    }
    impl ::protrust::LiteMessage for self::TestExtensionOrderings3 {
        fn new() -> Self {
            Self {
                my_string: ::std::option::Option::None,
                unknown_fields: ::protrust::UnknownFieldSet::new(),
            }
        }
        fn merge(&mut self, other: &Self) {
            self.my_string = other.my_string.clone();
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestExtensionOrderings3 {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
            &self::super::file().messages()[31].messages()[0]
        }
    }
    impl self::TestExtensionOrderings3 {
        /// Gets the field number of the [`my_string`] field
        ///
        /// [`my_string`]: #method.my_string
        pub const MY_STRING_FIELD_NUMBER: i32 = 1;
        /// A constant value representing the default value of the [`my_string`] field
        ///
        /// [`my_string`]: #method.my_string
        pub const MY_STRING_DEFAULT_VALUE: &'static str = "";
        pub fn my_string(&self) -> &str {
            self.my_string.as_ref().map(|v| &**v).unwrap_or(Self::MY_STRING_DEFAULT_VALUE)
        }
        /// Returns an [`Option`] representing the presence of the [`my_string`] field
        ///
        /// [`my_string`]: #method.my_string
        /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
        pub fn my_string_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.my_string.as_ref()
        }
        /// Returns a unique reference to the [`my_string`] field
        ///
        /// [`my_string`]: #method.my_string
        pub fn my_string_mut(&mut self) -> &mut ::std::string::String {
            self.my_string.get_or_insert_with(::std::string::String::new)
        }
        /// Returns a bool indicating the presence of the [`my_string`] field
        ///
        /// [`my_string`]: #method.my_string
        pub fn has_my_string(&self) -> bool {
            self.my_string.is_some()
        }
        /// Sets the value of the [`my_string`] field
        ///
        /// [`my_string`]: #method.my_string
        pub fn set_my_string(&mut self, value: ::std::string::String) {
            self.my_string = ::std::option::Option::Some(value)
        }
        /// Takes the value of the [`my_string`] field, leaving it empty
        ///
        /// [`my_string`]: #method.my_string
        pub fn take_my_string(&mut self) -> ::std::option::Option<::std::string::String> {
            self.my_string.take()
        }
        /// Clears the value of the [`my_string`] field
        ///
        /// [`my_string`]: #method.my_string
        pub fn clear_my_string(&mut self) {
            self.my_string = ::std::option::Option::None
        }
    }
    pub mod test_extension_orderings3 {
        pub static TEST_EXT_ORDERINGS3: ::protrust::Extension<self::super::super::TestFieldOrderings, self::super::TestExtensionOrderings3, self::super::TestExtensionOrderings3> = ::protrust::Extension::message(114);
    }
    pub static TEST_EXT_ORDERINGS2: ::protrust::Extension<self::super::TestFieldOrderings, self::super::TestExtensionOrderings2, self::super::TestExtensionOrderings2> = ::protrust::Extension::message(98);
}
#[derive(Clone, Debug, PartialEq)]
pub struct TestExtremeDefaultValues {
    escaped_bytes: ::std::option::Option<::std::vec::Vec<u8>>,
    large_uint32: ::std::option::Option<u32>,
    large_uint64: ::std::option::Option<u64>,
    small_int32: ::std::option::Option<i32>,
    small_int64: ::std::option::Option<i64>,
    really_small_int32: ::std::option::Option<i32>,
    really_small_int64: ::std::option::Option<i64>,
    utf8_string: ::std::option::Option<::std::string::String>,
    zero_float: ::std::option::Option<f32>,
    one_float: ::std::option::Option<f32>,
    small_float: ::std::option::Option<f32>,
    negative_one_float: ::std::option::Option<f32>,
    negative_float: ::std::option::Option<f32>,
    large_float: ::std::option::Option<f32>,
    small_negative_float: ::std::option::Option<f32>,
    inf_double: ::std::option::Option<f64>,
    neg_inf_double: ::std::option::Option<f64>,
    nan_double: ::std::option::Option<f64>,
    inf_float: ::std::option::Option<f32>,
    neg_inf_float: ::std::option::Option<f32>,
    nan_float: ::std::option::Option<f32>,
    cpp_trigraph: ::std::option::Option<::std::string::String>,
    string_with_zero: ::std::option::Option<::std::string::String>,
    bytes_with_zero: ::std::option::Option<::std::vec::Vec<u8>>,
    string_piece_with_zero: ::std::option::Option<::std::string::String>,
    cord_with_zero: ::std::option::Option<::std::string::String>,
    replacement_string: ::std::option::Option<::std::string::String>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::TestExtremeDefaultValues {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.escaped_bytes = ::std::option::Option::Some(input.read_bytes()?),
                16 | 18 => self.large_uint32 = ::std::option::Option::Some(input.read_uint32()?),
                24 | 26 => self.large_uint64 = ::std::option::Option::Some(input.read_uint64()?),
                32 | 34 => self.small_int32 = ::std::option::Option::Some(input.read_int32()?),
                40 | 42 => self.small_int64 = ::std::option::Option::Some(input.read_int64()?),
                168 | 170 => self.really_small_int32 = ::std::option::Option::Some(input.read_int32()?),
                176 | 178 => self.really_small_int64 = ::std::option::Option::Some(input.read_int64()?),
                50 => self.utf8_string = ::std::option::Option::Some(input.read_string()?),
                61 | 58 => self.zero_float = ::std::option::Option::Some(input.read_float()?),
                69 | 66 => self.one_float = ::std::option::Option::Some(input.read_float()?),
                77 | 74 => self.small_float = ::std::option::Option::Some(input.read_float()?),
                85 | 82 => self.negative_one_float = ::std::option::Option::Some(input.read_float()?),
                93 | 90 => self.negative_float = ::std::option::Option::Some(input.read_float()?),
                101 | 98 => self.large_float = ::std::option::Option::Some(input.read_float()?),
                109 | 106 => self.small_negative_float = ::std::option::Option::Some(input.read_float()?),
                113 | 114 => self.inf_double = ::std::option::Option::Some(input.read_double()?),
                121 | 122 => self.neg_inf_double = ::std::option::Option::Some(input.read_double()?),
                129 | 130 => self.nan_double = ::std::option::Option::Some(input.read_double()?),
                141 | 138 => self.inf_float = ::std::option::Option::Some(input.read_float()?),
                149 | 146 => self.neg_inf_float = ::std::option::Option::Some(input.read_float()?),
                157 | 154 => self.nan_float = ::std::option::Option::Some(input.read_float()?),
                162 => self.cpp_trigraph = ::std::option::Option::Some(input.read_string()?),
                186 => self.string_with_zero = ::std::option::Option::Some(input.read_string()?),
                194 => self.bytes_with_zero = ::std::option::Option::Some(input.read_bytes()?),
                202 => self.string_piece_with_zero = ::std::option::Option::Some(input.read_string()?),
                210 => self.cord_with_zero = ::std::option::Option::Some(input.read_string()?),
                218 => self.replacement_string = ::std::option::Option::Some(input.read_string()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let escaped_bytes = &self.escaped_bytes;
        if let ::std::option::Option::Some(escaped_bytes) = escaped_bytes {
            size += 1;
            size += ::protrust::io::sizes::bytes(escaped_bytes);
        }
        let large_uint32 = self.large_uint32;
        if let ::std::option::Option::Some(large_uint32) = large_uint32 {
            size += 1;
            size += ::protrust::io::sizes::uint32(large_uint32);
        }
        let large_uint64 = self.large_uint64;
        if let ::std::option::Option::Some(large_uint64) = large_uint64 {
            size += 1;
            size += ::protrust::io::sizes::uint64(large_uint64);
        }
        let small_int32 = self.small_int32;
        if let ::std::option::Option::Some(small_int32) = small_int32 {
            size += 1;
            size += ::protrust::io::sizes::int32(small_int32);
        }
        let small_int64 = self.small_int64;
        if let ::std::option::Option::Some(small_int64) = small_int64 {
            size += 1;
            size += ::protrust::io::sizes::int64(small_int64);
        }
        let really_small_int32 = self.really_small_int32;
        if let ::std::option::Option::Some(really_small_int32) = really_small_int32 {
            size += 2;
            size += ::protrust::io::sizes::int32(really_small_int32);
        }
        let really_small_int64 = self.really_small_int64;
        if let ::std::option::Option::Some(really_small_int64) = really_small_int64 {
            size += 2;
            size += ::protrust::io::sizes::int64(really_small_int64);
        }
        let utf8_string = &self.utf8_string;
        if let ::std::option::Option::Some(utf8_string) = utf8_string {
            size += 1;
            size += ::protrust::io::sizes::string(utf8_string);
        }
        let zero_float = self.zero_float;
        if let ::std::option::Option::Some(zero_float) = zero_float {
            size += 1;
            size += ::protrust::io::sizes::float(zero_float);
        }
        let one_float = self.one_float;
        if let ::std::option::Option::Some(one_float) = one_float {
            size += 1;
            size += ::protrust::io::sizes::float(one_float);
        }
        let small_float = self.small_float;
        if let ::std::option::Option::Some(small_float) = small_float {
            size += 1;
            size += ::protrust::io::sizes::float(small_float);
        }
        let negative_one_float = self.negative_one_float;
        if let ::std::option::Option::Some(negative_one_float) = negative_one_float {
            size += 1;
            size += ::protrust::io::sizes::float(negative_one_float);
        }
        let negative_float = self.negative_float;
        if let ::std::option::Option::Some(negative_float) = negative_float {
            size += 1;
            size += ::protrust::io::sizes::float(negative_float);
        }
        let large_float = self.large_float;
        if let ::std::option::Option::Some(large_float) = large_float {
            size += 1;
            size += ::protrust::io::sizes::float(large_float);
        }
        let small_negative_float = self.small_negative_float;
        if let ::std::option::Option::Some(small_negative_float) = small_negative_float {
            size += 1;
            size += ::protrust::io::sizes::float(small_negative_float);
        }
        let inf_double = self.inf_double;
        if let ::std::option::Option::Some(inf_double) = inf_double {
            size += 1;
            size += ::protrust::io::sizes::double(inf_double);
        }
        let neg_inf_double = self.neg_inf_double;
        if let ::std::option::Option::Some(neg_inf_double) = neg_inf_double {
            size += 1;
            size += ::protrust::io::sizes::double(neg_inf_double);
        }
        let nan_double = self.nan_double;
        if let ::std::option::Option::Some(nan_double) = nan_double {
            size += 2;
            size += ::protrust::io::sizes::double(nan_double);
        }
        let inf_float = self.inf_float;
        if let ::std::option::Option::Some(inf_float) = inf_float {
            size += 2;
            size += ::protrust::io::sizes::float(inf_float);
        }
        let neg_inf_float = self.neg_inf_float;
        if let ::std::option::Option::Some(neg_inf_float) = neg_inf_float {
            size += 2;
            size += ::protrust::io::sizes::float(neg_inf_float);
        }
        let nan_float = self.nan_float;
        if let ::std::option::Option::Some(nan_float) = nan_float {
            size += 2;
            size += ::protrust::io::sizes::float(nan_float);
        }
        let cpp_trigraph = &self.cpp_trigraph;
        if let ::std::option::Option::Some(cpp_trigraph) = cpp_trigraph {
            size += 2;
            size += ::protrust::io::sizes::string(cpp_trigraph);
        }
        let string_with_zero = &self.string_with_zero;
        if let ::std::option::Option::Some(string_with_zero) = string_with_zero {
            size += 2;
            size += ::protrust::io::sizes::string(string_with_zero);
        }
        let bytes_with_zero = &self.bytes_with_zero;
        if let ::std::option::Option::Some(bytes_with_zero) = bytes_with_zero {
            size += 2;
            size += ::protrust::io::sizes::bytes(bytes_with_zero);
        }
        let string_piece_with_zero = &self.string_piece_with_zero;
        if let ::std::option::Option::Some(string_piece_with_zero) = string_piece_with_zero {
            size += 2;
            size += ::protrust::io::sizes::string(string_piece_with_zero);
        }
        let cord_with_zero = &self.cord_with_zero;
        if let ::std::option::Option::Some(cord_with_zero) = cord_with_zero {
            size += 2;
            size += ::protrust::io::sizes::string(cord_with_zero);
        }
        let replacement_string = &self.replacement_string;
        if let ::std::option::Option::Some(replacement_string) = replacement_string {
            size += 2;
            size += ::protrust::io::sizes::string(replacement_string);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let escaped_bytes = &self.escaped_bytes;
        if let ::std::option::Option::Some(escaped_bytes) = escaped_bytes {
            output.write_raw_tag_bytes(&[10])?;
            output.write_bytes(escaped_bytes)?;
        }
        let large_uint32 = self.large_uint32;
        if let ::std::option::Option::Some(large_uint32) = large_uint32 {
            output.write_raw_tag_bytes(&[16])?;
            output.write_uint32(large_uint32)?;
        }
        let large_uint64 = self.large_uint64;
        if let ::std::option::Option::Some(large_uint64) = large_uint64 {
            output.write_raw_tag_bytes(&[24])?;
            output.write_uint64(large_uint64)?;
        }
        let small_int32 = self.small_int32;
        if let ::std::option::Option::Some(small_int32) = small_int32 {
            output.write_raw_tag_bytes(&[32])?;
            output.write_int32(small_int32)?;
        }
        let small_int64 = self.small_int64;
        if let ::std::option::Option::Some(small_int64) = small_int64 {
            output.write_raw_tag_bytes(&[40])?;
            output.write_int64(small_int64)?;
        }
        let really_small_int32 = self.really_small_int32;
        if let ::std::option::Option::Some(really_small_int32) = really_small_int32 {
            output.write_raw_tag_bytes(&[168, 1])?;
            output.write_int32(really_small_int32)?;
        }
        let really_small_int64 = self.really_small_int64;
        if let ::std::option::Option::Some(really_small_int64) = really_small_int64 {
            output.write_raw_tag_bytes(&[176, 1])?;
            output.write_int64(really_small_int64)?;
        }
        let utf8_string = &self.utf8_string;
        if let ::std::option::Option::Some(utf8_string) = utf8_string {
            output.write_raw_tag_bytes(&[50])?;
            output.write_string(utf8_string)?;
        }
        let zero_float = self.zero_float;
        if let ::std::option::Option::Some(zero_float) = zero_float {
            output.write_raw_tag_bytes(&[61])?;
            output.write_float(zero_float)?;
        }
        let one_float = self.one_float;
        if let ::std::option::Option::Some(one_float) = one_float {
            output.write_raw_tag_bytes(&[69])?;
            output.write_float(one_float)?;
        }
        let small_float = self.small_float;
        if let ::std::option::Option::Some(small_float) = small_float {
            output.write_raw_tag_bytes(&[77])?;
            output.write_float(small_float)?;
        }
        let negative_one_float = self.negative_one_float;
        if let ::std::option::Option::Some(negative_one_float) = negative_one_float {
            output.write_raw_tag_bytes(&[85])?;
            output.write_float(negative_one_float)?;
        }
        let negative_float = self.negative_float;
        if let ::std::option::Option::Some(negative_float) = negative_float {
            output.write_raw_tag_bytes(&[93])?;
            output.write_float(negative_float)?;
        }
        let large_float = self.large_float;
        if let ::std::option::Option::Some(large_float) = large_float {
            output.write_raw_tag_bytes(&[101])?;
            output.write_float(large_float)?;
        }
        let small_negative_float = self.small_negative_float;
        if let ::std::option::Option::Some(small_negative_float) = small_negative_float {
            output.write_raw_tag_bytes(&[109])?;
            output.write_float(small_negative_float)?;
        }
        let inf_double = self.inf_double;
        if let ::std::option::Option::Some(inf_double) = inf_double {
            output.write_raw_tag_bytes(&[113])?;
            output.write_double(inf_double)?;
        }
        let neg_inf_double = self.neg_inf_double;
        if let ::std::option::Option::Some(neg_inf_double) = neg_inf_double {
            output.write_raw_tag_bytes(&[121])?;
            output.write_double(neg_inf_double)?;
        }
        let nan_double = self.nan_double;
        if let ::std::option::Option::Some(nan_double) = nan_double {
            output.write_raw_tag_bytes(&[129, 1])?;
            output.write_double(nan_double)?;
        }
        let inf_float = self.inf_float;
        if let ::std::option::Option::Some(inf_float) = inf_float {
            output.write_raw_tag_bytes(&[141, 1])?;
            output.write_float(inf_float)?;
        }
        let neg_inf_float = self.neg_inf_float;
        if let ::std::option::Option::Some(neg_inf_float) = neg_inf_float {
            output.write_raw_tag_bytes(&[149, 1])?;
            output.write_float(neg_inf_float)?;
        }
        let nan_float = self.nan_float;
        if let ::std::option::Option::Some(nan_float) = nan_float {
            output.write_raw_tag_bytes(&[157, 1])?;
            output.write_float(nan_float)?;
        }
        let cpp_trigraph = &self.cpp_trigraph;
        if let ::std::option::Option::Some(cpp_trigraph) = cpp_trigraph {
            output.write_raw_tag_bytes(&[162, 1])?;
            output.write_string(cpp_trigraph)?;
        }
        let string_with_zero = &self.string_with_zero;
        if let ::std::option::Option::Some(string_with_zero) = string_with_zero {
            output.write_raw_tag_bytes(&[186, 1])?;
            output.write_string(string_with_zero)?;
        }
        let bytes_with_zero = &self.bytes_with_zero;
        if let ::std::option::Option::Some(bytes_with_zero) = bytes_with_zero {
            output.write_raw_tag_bytes(&[194, 1])?;
            output.write_bytes(bytes_with_zero)?;
        }
        let string_piece_with_zero = &self.string_piece_with_zero;
        if let ::std::option::Option::Some(string_piece_with_zero) = string_piece_with_zero {
            output.write_raw_tag_bytes(&[202, 1])?;
            output.write_string(string_piece_with_zero)?;
        }
        let cord_with_zero = &self.cord_with_zero;
        if let ::std::option::Option::Some(cord_with_zero) = cord_with_zero {
            output.write_raw_tag_bytes(&[210, 1])?;
            output.write_string(cord_with_zero)?;
        }
        let replacement_string = &self.replacement_string;
        if let ::std::option::Option::Some(replacement_string) = replacement_string {
            output.write_raw_tag_bytes(&[218, 1])?;
            output.write_string(replacement_string)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::TestExtremeDefaultValues {
    fn new() -> Self {
        Self {
            escaped_bytes: ::std::option::Option::None,
            large_uint32: ::std::option::Option::None,
            large_uint64: ::std::option::Option::None,
            small_int32: ::std::option::Option::None,
            small_int64: ::std::option::Option::None,
            really_small_int32: ::std::option::Option::None,
            really_small_int64: ::std::option::Option::None,
            utf8_string: ::std::option::Option::None,
            zero_float: ::std::option::Option::None,
            one_float: ::std::option::Option::None,
            small_float: ::std::option::Option::None,
            negative_one_float: ::std::option::Option::None,
            negative_float: ::std::option::Option::None,
            large_float: ::std::option::Option::None,
            small_negative_float: ::std::option::Option::None,
            inf_double: ::std::option::Option::None,
            neg_inf_double: ::std::option::Option::None,
            nan_double: ::std::option::Option::None,
            inf_float: ::std::option::Option::None,
            neg_inf_float: ::std::option::Option::None,
            nan_float: ::std::option::Option::None,
            cpp_trigraph: ::std::option::Option::None,
            string_with_zero: ::std::option::Option::None,
            bytes_with_zero: ::std::option::Option::None,
            string_piece_with_zero: ::std::option::Option::None,
            cord_with_zero: ::std::option::Option::None,
            replacement_string: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.escaped_bytes = other.escaped_bytes.clone();
        self.large_uint32 = other.large_uint32;
        self.large_uint64 = other.large_uint64;
        self.small_int32 = other.small_int32;
        self.small_int64 = other.small_int64;
        self.really_small_int32 = other.really_small_int32;
        self.really_small_int64 = other.really_small_int64;
        self.utf8_string = other.utf8_string.clone();
        self.zero_float = other.zero_float;
        self.one_float = other.one_float;
        self.small_float = other.small_float;
        self.negative_one_float = other.negative_one_float;
        self.negative_float = other.negative_float;
        self.large_float = other.large_float;
        self.small_negative_float = other.small_negative_float;
        self.inf_double = other.inf_double;
        self.neg_inf_double = other.neg_inf_double;
        self.nan_double = other.nan_double;
        self.inf_float = other.inf_float;
        self.neg_inf_float = other.neg_inf_float;
        self.nan_float = other.nan_float;
        self.cpp_trigraph = other.cpp_trigraph.clone();
        self.string_with_zero = other.string_with_zero.clone();
        self.bytes_with_zero = other.bytes_with_zero.clone();
        self.string_piece_with_zero = other.string_piece_with_zero.clone();
        self.cord_with_zero = other.cord_with_zero.clone();
        self.replacement_string = other.replacement_string.clone();
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestExtremeDefaultValues {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[32]
    }
}
impl self::TestExtremeDefaultValues {
    /// Gets the field number of the [`escaped_bytes`] field
    ///
    /// [`escaped_bytes`]: #method.escaped_bytes
    pub const ESCAPED_BYTES_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`escaped_bytes`] field
    ///
    /// [`escaped_bytes`]: #method.escaped_bytes
    pub const ESCAPED_BYTES_DEFAULT_VALUE: &'static [u8] = &[0, 48, 48, 48, 1, 48, 48, 49, 7, 48, 48, 55, 8, 48, 49, 48, 12, 48, 49, 52, 10, 110, 13, 114, 9, 116, 11, 48, 49, 51, 92, 92, 39, 39, 34, 34, 254, 51, 55, 54];
    pub fn escaped_bytes(&self) -> &[u8] {
        self.escaped_bytes.as_ref().map(|v| &**v).unwrap_or(Self::ESCAPED_BYTES_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`escaped_bytes`] field
    ///
    /// [`escaped_bytes`]: #method.escaped_bytes
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn escaped_bytes_option(&self) -> ::std::option::Option<&::std::vec::Vec<u8>> {
        self.escaped_bytes.as_ref()
    }
    /// Returns a unique reference to the [`escaped_bytes`] field
    ///
    /// [`escaped_bytes`]: #method.escaped_bytes
    pub fn escaped_bytes_mut(&mut self) -> &mut ::std::vec::Vec<u8> {
        self.escaped_bytes.get_or_insert_with(::std::vec::Vec::new)
    }
    /// Returns a bool indicating the presence of the [`escaped_bytes`] field
    ///
    /// [`escaped_bytes`]: #method.escaped_bytes
    pub fn has_escaped_bytes(&self) -> bool {
        self.escaped_bytes.is_some()
    }
    /// Sets the value of the [`escaped_bytes`] field
    ///
    /// [`escaped_bytes`]: #method.escaped_bytes
    pub fn set_escaped_bytes(&mut self, value: ::std::vec::Vec<u8>) {
        self.escaped_bytes = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`escaped_bytes`] field, leaving it empty
    ///
    /// [`escaped_bytes`]: #method.escaped_bytes
    pub fn take_escaped_bytes(&mut self) -> ::std::option::Option<::std::vec::Vec<u8>> {
        self.escaped_bytes.take()
    }
    /// Clears the value of the [`escaped_bytes`] field
    ///
    /// [`escaped_bytes`]: #method.escaped_bytes
    pub fn clear_escaped_bytes(&mut self) {
        self.escaped_bytes = ::std::option::Option::None
    }
    /// Gets the field number of the [`large_uint32`] field
    ///
    /// [`large_uint32`]: #method.large_uint32
    pub const LARGE_UINT32_FIELD_NUMBER: i32 = 2;
    /// A constant value representing the default value of the [`large_uint32`] field
    ///
    /// [`large_uint32`]: #method.large_uint32
    pub const LARGE_UINT32_DEFAULT_VALUE: u32 = 4294967295;
    pub fn large_uint32(&self) -> u32 {
        self.large_uint32.unwrap_or(Self::LARGE_UINT32_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`large_uint32`] field
    ///
    /// [`large_uint32`]: #method.large_uint32
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn large_uint32_option(&self) -> ::std::option::Option<u32> {
        self.large_uint32
    }
    /// Returns a bool indicating the presence of the [`large_uint32`] field
    ///
    /// [`large_uint32`]: #method.large_uint32
    pub fn has_large_uint32(&self) -> bool {
        self.large_uint32.is_some()
    }
    /// Sets the value of the [`large_uint32`] field
    ///
    /// [`large_uint32`]: #method.large_uint32
    pub fn set_large_uint32(&mut self, value: u32) {
        self.large_uint32 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`large_uint32`] field
    ///
    /// [`large_uint32`]: #method.large_uint32
    pub fn clear_large_uint32(&mut self) {
        self.large_uint32 = ::std::option::Option::None
    }
    /// Gets the field number of the [`large_uint64`] field
    ///
    /// [`large_uint64`]: #method.large_uint64
    pub const LARGE_UINT64_FIELD_NUMBER: i32 = 3;
    /// A constant value representing the default value of the [`large_uint64`] field
    ///
    /// [`large_uint64`]: #method.large_uint64
    pub const LARGE_UINT64_DEFAULT_VALUE: u64 = 18446744073709551615;
    pub fn large_uint64(&self) -> u64 {
        self.large_uint64.unwrap_or(Self::LARGE_UINT64_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`large_uint64`] field
    ///
    /// [`large_uint64`]: #method.large_uint64
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn large_uint64_option(&self) -> ::std::option::Option<u64> {
        self.large_uint64
    }
    /// Returns a bool indicating the presence of the [`large_uint64`] field
    ///
    /// [`large_uint64`]: #method.large_uint64
    pub fn has_large_uint64(&self) -> bool {
        self.large_uint64.is_some()
    }
    /// Sets the value of the [`large_uint64`] field
    ///
    /// [`large_uint64`]: #method.large_uint64
    pub fn set_large_uint64(&mut self, value: u64) {
        self.large_uint64 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`large_uint64`] field
    ///
    /// [`large_uint64`]: #method.large_uint64
    pub fn clear_large_uint64(&mut self) {
        self.large_uint64 = ::std::option::Option::None
    }
    /// Gets the field number of the [`small_int32`] field
    ///
    /// [`small_int32`]: #method.small_int32
    pub const SMALL_INT32_FIELD_NUMBER: i32 = 4;
    /// A constant value representing the default value of the [`small_int32`] field
    ///
    /// [`small_int32`]: #method.small_int32
    pub const SMALL_INT32_DEFAULT_VALUE: i32 = -2147483647;
    pub fn small_int32(&self) -> i32 {
        self.small_int32.unwrap_or(Self::SMALL_INT32_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`small_int32`] field
    ///
    /// [`small_int32`]: #method.small_int32
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn small_int32_option(&self) -> ::std::option::Option<i32> {
        self.small_int32
    }
    /// Returns a bool indicating the presence of the [`small_int32`] field
    ///
    /// [`small_int32`]: #method.small_int32
    pub fn has_small_int32(&self) -> bool {
        self.small_int32.is_some()
    }
    /// Sets the value of the [`small_int32`] field
    ///
    /// [`small_int32`]: #method.small_int32
    pub fn set_small_int32(&mut self, value: i32) {
        self.small_int32 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`small_int32`] field
    ///
    /// [`small_int32`]: #method.small_int32
    pub fn clear_small_int32(&mut self) {
        self.small_int32 = ::std::option::Option::None
    }
    /// Gets the field number of the [`small_int64`] field
    ///
    /// [`small_int64`]: #method.small_int64
    pub const SMALL_INT64_FIELD_NUMBER: i32 = 5;
    /// A constant value representing the default value of the [`small_int64`] field
    ///
    /// [`small_int64`]: #method.small_int64
    pub const SMALL_INT64_DEFAULT_VALUE: i64 = -9223372036854775807;
    pub fn small_int64(&self) -> i64 {
        self.small_int64.unwrap_or(Self::SMALL_INT64_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`small_int64`] field
    ///
    /// [`small_int64`]: #method.small_int64
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn small_int64_option(&self) -> ::std::option::Option<i64> {
        self.small_int64
    }
    /// Returns a bool indicating the presence of the [`small_int64`] field
    ///
    /// [`small_int64`]: #method.small_int64
    pub fn has_small_int64(&self) -> bool {
        self.small_int64.is_some()
    }
    /// Sets the value of the [`small_int64`] field
    ///
    /// [`small_int64`]: #method.small_int64
    pub fn set_small_int64(&mut self, value: i64) {
        self.small_int64 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`small_int64`] field
    ///
    /// [`small_int64`]: #method.small_int64
    pub fn clear_small_int64(&mut self) {
        self.small_int64 = ::std::option::Option::None
    }
    /// Gets the field number of the [`really_small_int32`] field
    ///
    /// [`really_small_int32`]: #method.really_small_int32
    pub const REALLY_SMALL_INT32_FIELD_NUMBER: i32 = 21;
    /// A constant value representing the default value of the [`really_small_int32`] field
    ///
    /// [`really_small_int32`]: #method.really_small_int32
    pub const REALLY_SMALL_INT32_DEFAULT_VALUE: i32 = -2147483648;
    pub fn really_small_int32(&self) -> i32 {
        self.really_small_int32.unwrap_or(Self::REALLY_SMALL_INT32_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`really_small_int32`] field
    ///
    /// [`really_small_int32`]: #method.really_small_int32
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn really_small_int32_option(&self) -> ::std::option::Option<i32> {
        self.really_small_int32
    }
    /// Returns a bool indicating the presence of the [`really_small_int32`] field
    ///
    /// [`really_small_int32`]: #method.really_small_int32
    pub fn has_really_small_int32(&self) -> bool {
        self.really_small_int32.is_some()
    }
    /// Sets the value of the [`really_small_int32`] field
    ///
    /// [`really_small_int32`]: #method.really_small_int32
    pub fn set_really_small_int32(&mut self, value: i32) {
        self.really_small_int32 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`really_small_int32`] field
    ///
    /// [`really_small_int32`]: #method.really_small_int32
    pub fn clear_really_small_int32(&mut self) {
        self.really_small_int32 = ::std::option::Option::None
    }
    /// Gets the field number of the [`really_small_int64`] field
    ///
    /// [`really_small_int64`]: #method.really_small_int64
    pub const REALLY_SMALL_INT64_FIELD_NUMBER: i32 = 22;
    /// A constant value representing the default value of the [`really_small_int64`] field
    ///
    /// [`really_small_int64`]: #method.really_small_int64
    pub const REALLY_SMALL_INT64_DEFAULT_VALUE: i64 = -9223372036854775808;
    pub fn really_small_int64(&self) -> i64 {
        self.really_small_int64.unwrap_or(Self::REALLY_SMALL_INT64_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`really_small_int64`] field
    ///
    /// [`really_small_int64`]: #method.really_small_int64
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn really_small_int64_option(&self) -> ::std::option::Option<i64> {
        self.really_small_int64
    }
    /// Returns a bool indicating the presence of the [`really_small_int64`] field
    ///
    /// [`really_small_int64`]: #method.really_small_int64
    pub fn has_really_small_int64(&self) -> bool {
        self.really_small_int64.is_some()
    }
    /// Sets the value of the [`really_small_int64`] field
    ///
    /// [`really_small_int64`]: #method.really_small_int64
    pub fn set_really_small_int64(&mut self, value: i64) {
        self.really_small_int64 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`really_small_int64`] field
    ///
    /// [`really_small_int64`]: #method.really_small_int64
    pub fn clear_really_small_int64(&mut self) {
        self.really_small_int64 = ::std::option::Option::None
    }
    /// Gets the field number of the [`utf8_string`] field
    ///
    /// [`utf8_string`]: #method.utf8_string
    pub const UTF8_STRING_FIELD_NUMBER: i32 = 6;
    /// A constant value representing the default value of the [`utf8_string`] field
    ///
    /// [`utf8_string`]: #method.utf8_string
    pub const UTF8_STRING_DEFAULT_VALUE: &'static str = "\u{1234}";
    /// The default value here is UTF-8 for "\u1234".  (We could also just type
    /// the UTF-8 text directly into this text file rather than escape it, but
    /// lots of people use editors that would be confused by this.)
    pub fn utf8_string(&self) -> &str {
        self.utf8_string.as_ref().map(|v| &**v).unwrap_or(Self::UTF8_STRING_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`utf8_string`] field
    ///
    /// [`utf8_string`]: #method.utf8_string
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn utf8_string_option(&self) -> ::std::option::Option<&::std::string::String> {
        self.utf8_string.as_ref()
    }
    /// Returns a unique reference to the [`utf8_string`] field
    ///
    /// [`utf8_string`]: #method.utf8_string
    pub fn utf8_string_mut(&mut self) -> &mut ::std::string::String {
        self.utf8_string.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`utf8_string`] field
    ///
    /// [`utf8_string`]: #method.utf8_string
    pub fn has_utf8_string(&self) -> bool {
        self.utf8_string.is_some()
    }
    /// Sets the value of the [`utf8_string`] field
    ///
    /// [`utf8_string`]: #method.utf8_string
    pub fn set_utf8_string(&mut self, value: ::std::string::String) {
        self.utf8_string = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`utf8_string`] field, leaving it empty
    ///
    /// [`utf8_string`]: #method.utf8_string
    pub fn take_utf8_string(&mut self) -> ::std::option::Option<::std::string::String> {
        self.utf8_string.take()
    }
    /// Clears the value of the [`utf8_string`] field
    ///
    /// [`utf8_string`]: #method.utf8_string
    pub fn clear_utf8_string(&mut self) {
        self.utf8_string = ::std::option::Option::None
    }
    /// Gets the field number of the [`zero_float`] field
    ///
    /// [`zero_float`]: #method.zero_float
    pub const ZERO_FLOAT_FIELD_NUMBER: i32 = 7;
    /// A constant value representing the default value of the [`zero_float`] field
    ///
    /// [`zero_float`]: #method.zero_float
    pub const ZERO_FLOAT_DEFAULT_VALUE: f32 = 0.0;
    /// Tests for single-precision floating-point values.
    pub fn zero_float(&self) -> f32 {
        self.zero_float.unwrap_or(Self::ZERO_FLOAT_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`zero_float`] field
    ///
    /// [`zero_float`]: #method.zero_float
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn zero_float_option(&self) -> ::std::option::Option<f32> {
        self.zero_float
    }
    /// Returns a bool indicating the presence of the [`zero_float`] field
    ///
    /// [`zero_float`]: #method.zero_float
    pub fn has_zero_float(&self) -> bool {
        self.zero_float.is_some()
    }
    /// Sets the value of the [`zero_float`] field
    ///
    /// [`zero_float`]: #method.zero_float
    pub fn set_zero_float(&mut self, value: f32) {
        self.zero_float = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`zero_float`] field
    ///
    /// [`zero_float`]: #method.zero_float
    pub fn clear_zero_float(&mut self) {
        self.zero_float = ::std::option::Option::None
    }
    /// Gets the field number of the [`one_float`] field
    ///
    /// [`one_float`]: #method.one_float
    pub const ONE_FLOAT_FIELD_NUMBER: i32 = 8;
    /// A constant value representing the default value of the [`one_float`] field
    ///
    /// [`one_float`]: #method.one_float
    pub const ONE_FLOAT_DEFAULT_VALUE: f32 = 1.0;
    pub fn one_float(&self) -> f32 {
        self.one_float.unwrap_or(Self::ONE_FLOAT_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`one_float`] field
    ///
    /// [`one_float`]: #method.one_float
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn one_float_option(&self) -> ::std::option::Option<f32> {
        self.one_float
    }
    /// Returns a bool indicating the presence of the [`one_float`] field
    ///
    /// [`one_float`]: #method.one_float
    pub fn has_one_float(&self) -> bool {
        self.one_float.is_some()
    }
    /// Sets the value of the [`one_float`] field
    ///
    /// [`one_float`]: #method.one_float
    pub fn set_one_float(&mut self, value: f32) {
        self.one_float = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`one_float`] field
    ///
    /// [`one_float`]: #method.one_float
    pub fn clear_one_float(&mut self) {
        self.one_float = ::std::option::Option::None
    }
    /// Gets the field number of the [`small_float`] field
    ///
    /// [`small_float`]: #method.small_float
    pub const SMALL_FLOAT_FIELD_NUMBER: i32 = 9;
    /// A constant value representing the default value of the [`small_float`] field
    ///
    /// [`small_float`]: #method.small_float
    pub const SMALL_FLOAT_DEFAULT_VALUE: f32 = 1.5;
    pub fn small_float(&self) -> f32 {
        self.small_float.unwrap_or(Self::SMALL_FLOAT_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`small_float`] field
    ///
    /// [`small_float`]: #method.small_float
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn small_float_option(&self) -> ::std::option::Option<f32> {
        self.small_float
    }
    /// Returns a bool indicating the presence of the [`small_float`] field
    ///
    /// [`small_float`]: #method.small_float
    pub fn has_small_float(&self) -> bool {
        self.small_float.is_some()
    }
    /// Sets the value of the [`small_float`] field
    ///
    /// [`small_float`]: #method.small_float
    pub fn set_small_float(&mut self, value: f32) {
        self.small_float = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`small_float`] field
    ///
    /// [`small_float`]: #method.small_float
    pub fn clear_small_float(&mut self) {
        self.small_float = ::std::option::Option::None
    }
    /// Gets the field number of the [`negative_one_float`] field
    ///
    /// [`negative_one_float`]: #method.negative_one_float
    pub const NEGATIVE_ONE_FLOAT_FIELD_NUMBER: i32 = 10;
    /// A constant value representing the default value of the [`negative_one_float`] field
    ///
    /// [`negative_one_float`]: #method.negative_one_float
    pub const NEGATIVE_ONE_FLOAT_DEFAULT_VALUE: f32 = -1.0;
    pub fn negative_one_float(&self) -> f32 {
        self.negative_one_float.unwrap_or(Self::NEGATIVE_ONE_FLOAT_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`negative_one_float`] field
    ///
    /// [`negative_one_float`]: #method.negative_one_float
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn negative_one_float_option(&self) -> ::std::option::Option<f32> {
        self.negative_one_float
    }
    /// Returns a bool indicating the presence of the [`negative_one_float`] field
    ///
    /// [`negative_one_float`]: #method.negative_one_float
    pub fn has_negative_one_float(&self) -> bool {
        self.negative_one_float.is_some()
    }
    /// Sets the value of the [`negative_one_float`] field
    ///
    /// [`negative_one_float`]: #method.negative_one_float
    pub fn set_negative_one_float(&mut self, value: f32) {
        self.negative_one_float = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`negative_one_float`] field
    ///
    /// [`negative_one_float`]: #method.negative_one_float
    pub fn clear_negative_one_float(&mut self) {
        self.negative_one_float = ::std::option::Option::None
    }
    /// Gets the field number of the [`negative_float`] field
    ///
    /// [`negative_float`]: #method.negative_float
    pub const NEGATIVE_FLOAT_FIELD_NUMBER: i32 = 11;
    /// A constant value representing the default value of the [`negative_float`] field
    ///
    /// [`negative_float`]: #method.negative_float
    pub const NEGATIVE_FLOAT_DEFAULT_VALUE: f32 = -1.5;
    pub fn negative_float(&self) -> f32 {
        self.negative_float.unwrap_or(Self::NEGATIVE_FLOAT_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`negative_float`] field
    ///
    /// [`negative_float`]: #method.negative_float
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn negative_float_option(&self) -> ::std::option::Option<f32> {
        self.negative_float
    }
    /// Returns a bool indicating the presence of the [`negative_float`] field
    ///
    /// [`negative_float`]: #method.negative_float
    pub fn has_negative_float(&self) -> bool {
        self.negative_float.is_some()
    }
    /// Sets the value of the [`negative_float`] field
    ///
    /// [`negative_float`]: #method.negative_float
    pub fn set_negative_float(&mut self, value: f32) {
        self.negative_float = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`negative_float`] field
    ///
    /// [`negative_float`]: #method.negative_float
    pub fn clear_negative_float(&mut self) {
        self.negative_float = ::std::option::Option::None
    }
    /// Gets the field number of the [`large_float`] field
    ///
    /// [`large_float`]: #method.large_float
    pub const LARGE_FLOAT_FIELD_NUMBER: i32 = 12;
    /// A constant value representing the default value of the [`large_float`] field
    ///
    /// [`large_float`]: #method.large_float
    pub const LARGE_FLOAT_DEFAULT_VALUE: f32 = 200000000.0;
    /// Using exponents
    pub fn large_float(&self) -> f32 {
        self.large_float.unwrap_or(Self::LARGE_FLOAT_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`large_float`] field
    ///
    /// [`large_float`]: #method.large_float
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn large_float_option(&self) -> ::std::option::Option<f32> {
        self.large_float
    }
    /// Returns a bool indicating the presence of the [`large_float`] field
    ///
    /// [`large_float`]: #method.large_float
    pub fn has_large_float(&self) -> bool {
        self.large_float.is_some()
    }
    /// Sets the value of the [`large_float`] field
    ///
    /// [`large_float`]: #method.large_float
    pub fn set_large_float(&mut self, value: f32) {
        self.large_float = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`large_float`] field
    ///
    /// [`large_float`]: #method.large_float
    pub fn clear_large_float(&mut self) {
        self.large_float = ::std::option::Option::None
    }
    /// Gets the field number of the [`small_negative_float`] field
    ///
    /// [`small_negative_float`]: #method.small_negative_float
    pub const SMALL_NEGATIVE_FLOAT_FIELD_NUMBER: i32 = 13;
    /// A constant value representing the default value of the [`small_negative_float`] field
    ///
    /// [`small_negative_float`]: #method.small_negative_float
    pub const SMALL_NEGATIVE_FLOAT_DEFAULT_VALUE: f32 = -0.0000000000000000000000000008;
    pub fn small_negative_float(&self) -> f32 {
        self.small_negative_float.unwrap_or(Self::SMALL_NEGATIVE_FLOAT_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`small_negative_float`] field
    ///
    /// [`small_negative_float`]: #method.small_negative_float
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn small_negative_float_option(&self) -> ::std::option::Option<f32> {
        self.small_negative_float
    }
    /// Returns a bool indicating the presence of the [`small_negative_float`] field
    ///
    /// [`small_negative_float`]: #method.small_negative_float
    pub fn has_small_negative_float(&self) -> bool {
        self.small_negative_float.is_some()
    }
    /// Sets the value of the [`small_negative_float`] field
    ///
    /// [`small_negative_float`]: #method.small_negative_float
    pub fn set_small_negative_float(&mut self, value: f32) {
        self.small_negative_float = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`small_negative_float`] field
    ///
    /// [`small_negative_float`]: #method.small_negative_float
    pub fn clear_small_negative_float(&mut self) {
        self.small_negative_float = ::std::option::Option::None
    }
    /// Gets the field number of the [`inf_double`] field
    ///
    /// [`inf_double`]: #method.inf_double
    pub const INF_DOUBLE_FIELD_NUMBER: i32 = 14;
    /// A constant value representing the default value of the [`inf_double`] field
    ///
    /// [`inf_double`]: #method.inf_double
    pub const INF_DOUBLE_DEFAULT_VALUE: f64 = ::std::f64::INFINITY;
    /// Text for nonfinite floating-point values.
    pub fn inf_double(&self) -> f64 {
        self.inf_double.unwrap_or(Self::INF_DOUBLE_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`inf_double`] field
    ///
    /// [`inf_double`]: #method.inf_double
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn inf_double_option(&self) -> ::std::option::Option<f64> {
        self.inf_double
    }
    /// Returns a bool indicating the presence of the [`inf_double`] field
    ///
    /// [`inf_double`]: #method.inf_double
    pub fn has_inf_double(&self) -> bool {
        self.inf_double.is_some()
    }
    /// Sets the value of the [`inf_double`] field
    ///
    /// [`inf_double`]: #method.inf_double
    pub fn set_inf_double(&mut self, value: f64) {
        self.inf_double = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`inf_double`] field
    ///
    /// [`inf_double`]: #method.inf_double
    pub fn clear_inf_double(&mut self) {
        self.inf_double = ::std::option::Option::None
    }
    /// Gets the field number of the [`neg_inf_double`] field
    ///
    /// [`neg_inf_double`]: #method.neg_inf_double
    pub const NEG_INF_DOUBLE_FIELD_NUMBER: i32 = 15;
    /// A constant value representing the default value of the [`neg_inf_double`] field
    ///
    /// [`neg_inf_double`]: #method.neg_inf_double
    pub const NEG_INF_DOUBLE_DEFAULT_VALUE: f64 = ::std::f64::INFINITY;
    pub fn neg_inf_double(&self) -> f64 {
        self.neg_inf_double.unwrap_or(Self::NEG_INF_DOUBLE_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`neg_inf_double`] field
    ///
    /// [`neg_inf_double`]: #method.neg_inf_double
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn neg_inf_double_option(&self) -> ::std::option::Option<f64> {
        self.neg_inf_double
    }
    /// Returns a bool indicating the presence of the [`neg_inf_double`] field
    ///
    /// [`neg_inf_double`]: #method.neg_inf_double
    pub fn has_neg_inf_double(&self) -> bool {
        self.neg_inf_double.is_some()
    }
    /// Sets the value of the [`neg_inf_double`] field
    ///
    /// [`neg_inf_double`]: #method.neg_inf_double
    pub fn set_neg_inf_double(&mut self, value: f64) {
        self.neg_inf_double = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`neg_inf_double`] field
    ///
    /// [`neg_inf_double`]: #method.neg_inf_double
    pub fn clear_neg_inf_double(&mut self) {
        self.neg_inf_double = ::std::option::Option::None
    }
    /// Gets the field number of the [`nan_double`] field
    ///
    /// [`nan_double`]: #method.nan_double
    pub const NAN_DOUBLE_FIELD_NUMBER: i32 = 16;
    /// A constant value representing the default value of the [`nan_double`] field
    ///
    /// [`nan_double`]: #method.nan_double
    pub const NAN_DOUBLE_DEFAULT_VALUE: f64 = 0.0;
    pub fn nan_double(&self) -> f64 {
        self.nan_double.unwrap_or(Self::NAN_DOUBLE_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`nan_double`] field
    ///
    /// [`nan_double`]: #method.nan_double
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn nan_double_option(&self) -> ::std::option::Option<f64> {
        self.nan_double
    }
    /// Returns a bool indicating the presence of the [`nan_double`] field
    ///
    /// [`nan_double`]: #method.nan_double
    pub fn has_nan_double(&self) -> bool {
        self.nan_double.is_some()
    }
    /// Sets the value of the [`nan_double`] field
    ///
    /// [`nan_double`]: #method.nan_double
    pub fn set_nan_double(&mut self, value: f64) {
        self.nan_double = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`nan_double`] field
    ///
    /// [`nan_double`]: #method.nan_double
    pub fn clear_nan_double(&mut self) {
        self.nan_double = ::std::option::Option::None
    }
    /// Gets the field number of the [`inf_float`] field
    ///
    /// [`inf_float`]: #method.inf_float
    pub const INF_FLOAT_FIELD_NUMBER: i32 = 17;
    /// A constant value representing the default value of the [`inf_float`] field
    ///
    /// [`inf_float`]: #method.inf_float
    pub const INF_FLOAT_DEFAULT_VALUE: f32 = ::std::f32::INFINITY;
    pub fn inf_float(&self) -> f32 {
        self.inf_float.unwrap_or(Self::INF_FLOAT_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`inf_float`] field
    ///
    /// [`inf_float`]: #method.inf_float
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn inf_float_option(&self) -> ::std::option::Option<f32> {
        self.inf_float
    }
    /// Returns a bool indicating the presence of the [`inf_float`] field
    ///
    /// [`inf_float`]: #method.inf_float
    pub fn has_inf_float(&self) -> bool {
        self.inf_float.is_some()
    }
    /// Sets the value of the [`inf_float`] field
    ///
    /// [`inf_float`]: #method.inf_float
    pub fn set_inf_float(&mut self, value: f32) {
        self.inf_float = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`inf_float`] field
    ///
    /// [`inf_float`]: #method.inf_float
    pub fn clear_inf_float(&mut self) {
        self.inf_float = ::std::option::Option::None
    }
    /// Gets the field number of the [`neg_inf_float`] field
    ///
    /// [`neg_inf_float`]: #method.neg_inf_float
    pub const NEG_INF_FLOAT_FIELD_NUMBER: i32 = 18;
    /// A constant value representing the default value of the [`neg_inf_float`] field
    ///
    /// [`neg_inf_float`]: #method.neg_inf_float
    pub const NEG_INF_FLOAT_DEFAULT_VALUE: f32 = ::std::f32::INFINITY;
    pub fn neg_inf_float(&self) -> f32 {
        self.neg_inf_float.unwrap_or(Self::NEG_INF_FLOAT_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`neg_inf_float`] field
    ///
    /// [`neg_inf_float`]: #method.neg_inf_float
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn neg_inf_float_option(&self) -> ::std::option::Option<f32> {
        self.neg_inf_float
    }
    /// Returns a bool indicating the presence of the [`neg_inf_float`] field
    ///
    /// [`neg_inf_float`]: #method.neg_inf_float
    pub fn has_neg_inf_float(&self) -> bool {
        self.neg_inf_float.is_some()
    }
    /// Sets the value of the [`neg_inf_float`] field
    ///
    /// [`neg_inf_float`]: #method.neg_inf_float
    pub fn set_neg_inf_float(&mut self, value: f32) {
        self.neg_inf_float = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`neg_inf_float`] field
    ///
    /// [`neg_inf_float`]: #method.neg_inf_float
    pub fn clear_neg_inf_float(&mut self) {
        self.neg_inf_float = ::std::option::Option::None
    }
    /// Gets the field number of the [`nan_float`] field
    ///
    /// [`nan_float`]: #method.nan_float
    pub const NAN_FLOAT_FIELD_NUMBER: i32 = 19;
    /// A constant value representing the default value of the [`nan_float`] field
    ///
    /// [`nan_float`]: #method.nan_float
    pub const NAN_FLOAT_DEFAULT_VALUE: f32 = 0.0;
    pub fn nan_float(&self) -> f32 {
        self.nan_float.unwrap_or(Self::NAN_FLOAT_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`nan_float`] field
    ///
    /// [`nan_float`]: #method.nan_float
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn nan_float_option(&self) -> ::std::option::Option<f32> {
        self.nan_float
    }
    /// Returns a bool indicating the presence of the [`nan_float`] field
    ///
    /// [`nan_float`]: #method.nan_float
    pub fn has_nan_float(&self) -> bool {
        self.nan_float.is_some()
    }
    /// Sets the value of the [`nan_float`] field
    ///
    /// [`nan_float`]: #method.nan_float
    pub fn set_nan_float(&mut self, value: f32) {
        self.nan_float = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`nan_float`] field
    ///
    /// [`nan_float`]: #method.nan_float
    pub fn clear_nan_float(&mut self) {
        self.nan_float = ::std::option::Option::None
    }
    /// Gets the field number of the [`cpp_trigraph`] field
    ///
    /// [`cpp_trigraph`]: #method.cpp_trigraph
    pub const CPP_TRIGRAPH_FIELD_NUMBER: i32 = 20;
    /// A constant value representing the default value of the [`cpp_trigraph`] field
    ///
    /// [`cpp_trigraph`]: #method.cpp_trigraph
    pub const CPP_TRIGRAPH_DEFAULT_VALUE: &'static str = "? ? ?? ?? ??? ??/ ??-";
    /// Tests for C++ trigraphs.
    /// Trigraphs should be escaped in C++ generated files, but they should not be
    /// escaped for other languages.
    /// Note that in .proto file, "?" is a valid way to escape ? in string
    /// literals.
    pub fn cpp_trigraph(&self) -> &str {
        self.cpp_trigraph.as_ref().map(|v| &**v).unwrap_or(Self::CPP_TRIGRAPH_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`cpp_trigraph`] field
    ///
    /// [`cpp_trigraph`]: #method.cpp_trigraph
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn cpp_trigraph_option(&self) -> ::std::option::Option<&::std::string::String> {
        self.cpp_trigraph.as_ref()
    }
    /// Returns a unique reference to the [`cpp_trigraph`] field
    ///
    /// [`cpp_trigraph`]: #method.cpp_trigraph
    pub fn cpp_trigraph_mut(&mut self) -> &mut ::std::string::String {
        self.cpp_trigraph.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`cpp_trigraph`] field
    ///
    /// [`cpp_trigraph`]: #method.cpp_trigraph
    pub fn has_cpp_trigraph(&self) -> bool {
        self.cpp_trigraph.is_some()
    }
    /// Sets the value of the [`cpp_trigraph`] field
    ///
    /// [`cpp_trigraph`]: #method.cpp_trigraph
    pub fn set_cpp_trigraph(&mut self, value: ::std::string::String) {
        self.cpp_trigraph = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`cpp_trigraph`] field, leaving it empty
    ///
    /// [`cpp_trigraph`]: #method.cpp_trigraph
    pub fn take_cpp_trigraph(&mut self) -> ::std::option::Option<::std::string::String> {
        self.cpp_trigraph.take()
    }
    /// Clears the value of the [`cpp_trigraph`] field
    ///
    /// [`cpp_trigraph`]: #method.cpp_trigraph
    pub fn clear_cpp_trigraph(&mut self) {
        self.cpp_trigraph = ::std::option::Option::None
    }
    /// Gets the field number of the [`string_with_zero`] field
    ///
    /// [`string_with_zero`]: #method.string_with_zero
    pub const STRING_WITH_ZERO_FIELD_NUMBER: i32 = 23;
    /// A constant value representing the default value of the [`string_with_zero`] field
    ///
    /// [`string_with_zero`]: #method.string_with_zero
    pub const STRING_WITH_ZERO_DEFAULT_VALUE: &'static str = "hel\u{0}lo";
    /// String defaults containing the character '\000'
    pub fn string_with_zero(&self) -> &str {
        self.string_with_zero.as_ref().map(|v| &**v).unwrap_or(Self::STRING_WITH_ZERO_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`string_with_zero`] field
    ///
    /// [`string_with_zero`]: #method.string_with_zero
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn string_with_zero_option(&self) -> ::std::option::Option<&::std::string::String> {
        self.string_with_zero.as_ref()
    }
    /// Returns a unique reference to the [`string_with_zero`] field
    ///
    /// [`string_with_zero`]: #method.string_with_zero
    pub fn string_with_zero_mut(&mut self) -> &mut ::std::string::String {
        self.string_with_zero.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`string_with_zero`] field
    ///
    /// [`string_with_zero`]: #method.string_with_zero
    pub fn has_string_with_zero(&self) -> bool {
        self.string_with_zero.is_some()
    }
    /// Sets the value of the [`string_with_zero`] field
    ///
    /// [`string_with_zero`]: #method.string_with_zero
    pub fn set_string_with_zero(&mut self, value: ::std::string::String) {
        self.string_with_zero = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`string_with_zero`] field, leaving it empty
    ///
    /// [`string_with_zero`]: #method.string_with_zero
    pub fn take_string_with_zero(&mut self) -> ::std::option::Option<::std::string::String> {
        self.string_with_zero.take()
    }
    /// Clears the value of the [`string_with_zero`] field
    ///
    /// [`string_with_zero`]: #method.string_with_zero
    pub fn clear_string_with_zero(&mut self) {
        self.string_with_zero = ::std::option::Option::None
    }
    /// Gets the field number of the [`bytes_with_zero`] field
    ///
    /// [`bytes_with_zero`]: #method.bytes_with_zero
    pub const BYTES_WITH_ZERO_FIELD_NUMBER: i32 = 24;
    /// A constant value representing the default value of the [`bytes_with_zero`] field
    ///
    /// [`bytes_with_zero`]: #method.bytes_with_zero
    pub const BYTES_WITH_ZERO_DEFAULT_VALUE: &'static [u8] = &[119, 111, 114, 0, 48, 48, 48, 108, 100];
    pub fn bytes_with_zero(&self) -> &[u8] {
        self.bytes_with_zero.as_ref().map(|v| &**v).unwrap_or(Self::BYTES_WITH_ZERO_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`bytes_with_zero`] field
    ///
    /// [`bytes_with_zero`]: #method.bytes_with_zero
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn bytes_with_zero_option(&self) -> ::std::option::Option<&::std::vec::Vec<u8>> {
        self.bytes_with_zero.as_ref()
    }
    /// Returns a unique reference to the [`bytes_with_zero`] field
    ///
    /// [`bytes_with_zero`]: #method.bytes_with_zero
    pub fn bytes_with_zero_mut(&mut self) -> &mut ::std::vec::Vec<u8> {
        self.bytes_with_zero.get_or_insert_with(::std::vec::Vec::new)
    }
    /// Returns a bool indicating the presence of the [`bytes_with_zero`] field
    ///
    /// [`bytes_with_zero`]: #method.bytes_with_zero
    pub fn has_bytes_with_zero(&self) -> bool {
        self.bytes_with_zero.is_some()
    }
    /// Sets the value of the [`bytes_with_zero`] field
    ///
    /// [`bytes_with_zero`]: #method.bytes_with_zero
    pub fn set_bytes_with_zero(&mut self, value: ::std::vec::Vec<u8>) {
        self.bytes_with_zero = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`bytes_with_zero`] field, leaving it empty
    ///
    /// [`bytes_with_zero`]: #method.bytes_with_zero
    pub fn take_bytes_with_zero(&mut self) -> ::std::option::Option<::std::vec::Vec<u8>> {
        self.bytes_with_zero.take()
    }
    /// Clears the value of the [`bytes_with_zero`] field
    ///
    /// [`bytes_with_zero`]: #method.bytes_with_zero
    pub fn clear_bytes_with_zero(&mut self) {
        self.bytes_with_zero = ::std::option::Option::None
    }
    /// Gets the field number of the [`string_piece_with_zero`] field
    ///
    /// [`string_piece_with_zero`]: #method.string_piece_with_zero
    pub const STRING_PIECE_WITH_ZERO_FIELD_NUMBER: i32 = 25;
    /// A constant value representing the default value of the [`string_piece_with_zero`] field
    ///
    /// [`string_piece_with_zero`]: #method.string_piece_with_zero
    pub const STRING_PIECE_WITH_ZERO_DEFAULT_VALUE: &'static str = "ab\u{0}c";
    pub fn string_piece_with_zero(&self) -> &str {
        self.string_piece_with_zero.as_ref().map(|v| &**v).unwrap_or(Self::STRING_PIECE_WITH_ZERO_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`string_piece_with_zero`] field
    ///
    /// [`string_piece_with_zero`]: #method.string_piece_with_zero
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn string_piece_with_zero_option(&self) -> ::std::option::Option<&::std::string::String> {
        self.string_piece_with_zero.as_ref()
    }
    /// Returns a unique reference to the [`string_piece_with_zero`] field
    ///
    /// [`string_piece_with_zero`]: #method.string_piece_with_zero
    pub fn string_piece_with_zero_mut(&mut self) -> &mut ::std::string::String {
        self.string_piece_with_zero.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`string_piece_with_zero`] field
    ///
    /// [`string_piece_with_zero`]: #method.string_piece_with_zero
    pub fn has_string_piece_with_zero(&self) -> bool {
        self.string_piece_with_zero.is_some()
    }
    /// Sets the value of the [`string_piece_with_zero`] field
    ///
    /// [`string_piece_with_zero`]: #method.string_piece_with_zero
    pub fn set_string_piece_with_zero(&mut self, value: ::std::string::String) {
        self.string_piece_with_zero = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`string_piece_with_zero`] field, leaving it empty
    ///
    /// [`string_piece_with_zero`]: #method.string_piece_with_zero
    pub fn take_string_piece_with_zero(&mut self) -> ::std::option::Option<::std::string::String> {
        self.string_piece_with_zero.take()
    }
    /// Clears the value of the [`string_piece_with_zero`] field
    ///
    /// [`string_piece_with_zero`]: #method.string_piece_with_zero
    pub fn clear_string_piece_with_zero(&mut self) {
        self.string_piece_with_zero = ::std::option::Option::None
    }
    /// Gets the field number of the [`cord_with_zero`] field
    ///
    /// [`cord_with_zero`]: #method.cord_with_zero
    pub const CORD_WITH_ZERO_FIELD_NUMBER: i32 = 26;
    /// A constant value representing the default value of the [`cord_with_zero`] field
    ///
    /// [`cord_with_zero`]: #method.cord_with_zero
    pub const CORD_WITH_ZERO_DEFAULT_VALUE: &'static str = "12\u{0}3";
    pub fn cord_with_zero(&self) -> &str {
        self.cord_with_zero.as_ref().map(|v| &**v).unwrap_or(Self::CORD_WITH_ZERO_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`cord_with_zero`] field
    ///
    /// [`cord_with_zero`]: #method.cord_with_zero
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn cord_with_zero_option(&self) -> ::std::option::Option<&::std::string::String> {
        self.cord_with_zero.as_ref()
    }
    /// Returns a unique reference to the [`cord_with_zero`] field
    ///
    /// [`cord_with_zero`]: #method.cord_with_zero
    pub fn cord_with_zero_mut(&mut self) -> &mut ::std::string::String {
        self.cord_with_zero.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`cord_with_zero`] field
    ///
    /// [`cord_with_zero`]: #method.cord_with_zero
    pub fn has_cord_with_zero(&self) -> bool {
        self.cord_with_zero.is_some()
    }
    /// Sets the value of the [`cord_with_zero`] field
    ///
    /// [`cord_with_zero`]: #method.cord_with_zero
    pub fn set_cord_with_zero(&mut self, value: ::std::string::String) {
        self.cord_with_zero = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`cord_with_zero`] field, leaving it empty
    ///
    /// [`cord_with_zero`]: #method.cord_with_zero
    pub fn take_cord_with_zero(&mut self) -> ::std::option::Option<::std::string::String> {
        self.cord_with_zero.take()
    }
    /// Clears the value of the [`cord_with_zero`] field
    ///
    /// [`cord_with_zero`]: #method.cord_with_zero
    pub fn clear_cord_with_zero(&mut self) {
        self.cord_with_zero = ::std::option::Option::None
    }
    /// Gets the field number of the [`replacement_string`] field
    ///
    /// [`replacement_string`]: #method.replacement_string
    pub const REPLACEMENT_STRING_FIELD_NUMBER: i32 = 27;
    /// A constant value representing the default value of the [`replacement_string`] field
    ///
    /// [`replacement_string`]: #method.replacement_string
    pub const REPLACEMENT_STRING_DEFAULT_VALUE: &'static str = "${unknown}";
    pub fn replacement_string(&self) -> &str {
        self.replacement_string.as_ref().map(|v| &**v).unwrap_or(Self::REPLACEMENT_STRING_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`replacement_string`] field
    ///
    /// [`replacement_string`]: #method.replacement_string
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn replacement_string_option(&self) -> ::std::option::Option<&::std::string::String> {
        self.replacement_string.as_ref()
    }
    /// Returns a unique reference to the [`replacement_string`] field
    ///
    /// [`replacement_string`]: #method.replacement_string
    pub fn replacement_string_mut(&mut self) -> &mut ::std::string::String {
        self.replacement_string.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`replacement_string`] field
    ///
    /// [`replacement_string`]: #method.replacement_string
    pub fn has_replacement_string(&self) -> bool {
        self.replacement_string.is_some()
    }
    /// Sets the value of the [`replacement_string`] field
    ///
    /// [`replacement_string`]: #method.replacement_string
    pub fn set_replacement_string(&mut self, value: ::std::string::String) {
        self.replacement_string = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`replacement_string`] field, leaving it empty
    ///
    /// [`replacement_string`]: #method.replacement_string
    pub fn take_replacement_string(&mut self) -> ::std::option::Option<::std::string::String> {
        self.replacement_string.take()
    }
    /// Clears the value of the [`replacement_string`] field
    ///
    /// [`replacement_string`]: #method.replacement_string
    pub fn clear_replacement_string(&mut self) {
        self.replacement_string = ::std::option::Option::None
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct SparseEnumMessage {
    sparse_enum: ::std::option::Option<::protrust::EnumValue<self::TestSparseEnum>>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::SparseEnumMessage {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 | 10 => self.sparse_enum = ::std::option::Option::Some(input.read_enum_value()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let sparse_enum = self.sparse_enum;
        if let ::std::option::Option::Some(sparse_enum) = sparse_enum {
            size += 1;
            size += ::protrust::io::sizes::enum_value(sparse_enum);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let sparse_enum = self.sparse_enum;
        if let ::std::option::Option::Some(sparse_enum) = sparse_enum {
            output.write_raw_tag_bytes(&[8])?;
            output.write_enum_value(sparse_enum)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::SparseEnumMessage {
    fn new() -> Self {
        Self {
            sparse_enum: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.sparse_enum = other.sparse_enum;
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::SparseEnumMessage {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[33]
    }
}
impl self::SparseEnumMessage {
    /// Gets the field number of the [`sparse_enum`] field
    ///
    /// [`sparse_enum`]: #method.sparse_enum
    pub const SPARSE_ENUM_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`sparse_enum`] field
    ///
    /// [`sparse_enum`]: #method.sparse_enum
    pub const SPARSE_ENUM_DEFAULT_VALUE: ::protrust::EnumValue<self::TestSparseEnum> = ::protrust::EnumValue::Defined(self::TestSparseEnum::SparseF);
    pub fn sparse_enum(&self) -> ::protrust::EnumValue<self::TestSparseEnum> {
        self.sparse_enum.unwrap_or(Self::SPARSE_ENUM_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`sparse_enum`] field
    ///
    /// [`sparse_enum`]: #method.sparse_enum
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn sparse_enum_option(&self) -> ::std::option::Option<::protrust::EnumValue<self::TestSparseEnum>> {
        self.sparse_enum
    }
    /// Returns a bool indicating the presence of the [`sparse_enum`] field
    ///
    /// [`sparse_enum`]: #method.sparse_enum
    pub fn has_sparse_enum(&self) -> bool {
        self.sparse_enum.is_some()
    }
    /// Sets the value of the [`sparse_enum`] field
    ///
    /// [`sparse_enum`]: #method.sparse_enum
    pub fn set_sparse_enum(&mut self, value: ::protrust::EnumValue<self::TestSparseEnum>) {
        self.sparse_enum = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`sparse_enum`] field
    ///
    /// [`sparse_enum`]: #method.sparse_enum
    pub fn clear_sparse_enum(&mut self) {
        self.sparse_enum = ::std::option::Option::None
    }
}
/// Test String and Bytes: string is for valid UTF-8 strings
#[derive(Clone, Debug, PartialEq)]
pub struct OneString {
    data: ::std::option::Option<::std::string::String>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::OneString {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.data = ::std::option::Option::Some(input.read_string()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let data = &self.data;
        if let ::std::option::Option::Some(data) = data {
            size += 1;
            size += ::protrust::io::sizes::string(data);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let data = &self.data;
        if let ::std::option::Option::Some(data) = data {
            output.write_raw_tag_bytes(&[10])?;
            output.write_string(data)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::OneString {
    fn new() -> Self {
        Self {
            data: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.data = other.data.clone();
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::OneString {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[34]
    }
}
impl self::OneString {
    /// Gets the field number of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub const DATA_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub const DATA_DEFAULT_VALUE: &'static str = "";
    pub fn data(&self) -> &str {
        self.data.as_ref().map(|v| &**v).unwrap_or(Self::DATA_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`data`] field
    ///
    /// [`data`]: #method.data
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn data_option(&self) -> ::std::option::Option<&::std::string::String> {
        self.data.as_ref()
    }
    /// Returns a unique reference to the [`data`] field
    ///
    /// [`data`]: #method.data
    pub fn data_mut(&mut self) -> &mut ::std::string::String {
        self.data.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }
    /// Sets the value of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub fn set_data(&mut self, value: ::std::string::String) {
        self.data = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`data`] field, leaving it empty
    ///
    /// [`data`]: #method.data
    pub fn take_data(&mut self) -> ::std::option::Option<::std::string::String> {
        self.data.take()
    }
    /// Clears the value of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct MoreString {
    data: ::protrust::collections::RepeatedField<::std::string::String>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
static MORE_STRING_DATA_CODEC: ::protrust::Codec<::std::string::String> = ::protrust::Codec::string(10);
impl ::protrust::CodedMessage for self::MoreString {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.data.add_entries(input, &MORE_STRING_DATA_CODEC)?,
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.data.calculate_size(&MORE_STRING_DATA_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        self.data.write_to(output, &MORE_STRING_DATA_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        true
    }
}
impl ::protrust::LiteMessage for self::MoreString {
    fn new() -> Self {
        Self {
            data: ::protrust::collections::RepeatedField::new(),
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.data.merge(&other.data);
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::MoreString {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[35]
    }
}
impl self::MoreString {
    /// Gets the field number of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub const DATA_FIELD_NUMBER: i32 = 1;
    pub fn data(&self) -> &::protrust::collections::RepeatedField<::std::string::String> {
        &self.data
    }
    /// Returns a unique reference to the [`data`] field
    ///
    /// [`data`]: #method.data
    pub fn data_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<::std::string::String> {
        &mut self.data
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct OneBytes {
    data: ::std::option::Option<::std::vec::Vec<u8>>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::OneBytes {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.data = ::std::option::Option::Some(input.read_bytes()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let data = &self.data;
        if let ::std::option::Option::Some(data) = data {
            size += 1;
            size += ::protrust::io::sizes::bytes(data);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let data = &self.data;
        if let ::std::option::Option::Some(data) = data {
            output.write_raw_tag_bytes(&[10])?;
            output.write_bytes(data)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::OneBytes {
    fn new() -> Self {
        Self {
            data: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.data = other.data.clone();
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::OneBytes {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[36]
    }
}
impl self::OneBytes {
    /// Gets the field number of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub const DATA_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub const DATA_DEFAULT_VALUE: &'static [u8] = &[];
    pub fn data(&self) -> &[u8] {
        self.data.as_ref().map(|v| &**v).unwrap_or(Self::DATA_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`data`] field
    ///
    /// [`data`]: #method.data
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn data_option(&self) -> ::std::option::Option<&::std::vec::Vec<u8>> {
        self.data.as_ref()
    }
    /// Returns a unique reference to the [`data`] field
    ///
    /// [`data`]: #method.data
    pub fn data_mut(&mut self) -> &mut ::std::vec::Vec<u8> {
        self.data.get_or_insert_with(::std::vec::Vec::new)
    }
    /// Returns a bool indicating the presence of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }
    /// Sets the value of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub fn set_data(&mut self, value: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`data`] field, leaving it empty
    ///
    /// [`data`]: #method.data
    pub fn take_data(&mut self) -> ::std::option::Option<::std::vec::Vec<u8>> {
        self.data.take()
    }
    /// Clears the value of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct MoreBytes {
    data: ::protrust::collections::RepeatedField<::std::vec::Vec<u8>>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
static MORE_BYTES_DATA_CODEC: ::protrust::Codec<::std::vec::Vec<u8>> = ::protrust::Codec::bytes(10);
impl ::protrust::CodedMessage for self::MoreBytes {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.data.add_entries(input, &MORE_BYTES_DATA_CODEC)?,
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.data.calculate_size(&MORE_BYTES_DATA_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        self.data.write_to(output, &MORE_BYTES_DATA_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        true
    }
}
impl ::protrust::LiteMessage for self::MoreBytes {
    fn new() -> Self {
        Self {
            data: ::protrust::collections::RepeatedField::new(),
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.data.merge(&other.data);
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::MoreBytes {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[37]
    }
}
impl self::MoreBytes {
    /// Gets the field number of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub const DATA_FIELD_NUMBER: i32 = 1;
    pub fn data(&self) -> &::protrust::collections::RepeatedField<::std::vec::Vec<u8>> {
        &self.data
    }
    /// Returns a unique reference to the [`data`] field
    ///
    /// [`data`]: #method.data
    pub fn data_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.data
    }
}
/// Test int32, uint32, int64, uint64, and bool are all compatible
#[derive(Clone, Debug, PartialEq)]
pub struct Int32Message {
    data: ::std::option::Option<i32>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::Int32Message {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 | 10 => self.data = ::std::option::Option::Some(input.read_int32()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let data = self.data;
        if let ::std::option::Option::Some(data) = data {
            size += 1;
            size += ::protrust::io::sizes::int32(data);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let data = self.data;
        if let ::std::option::Option::Some(data) = data {
            output.write_raw_tag_bytes(&[8])?;
            output.write_int32(data)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::Int32Message {
    fn new() -> Self {
        Self {
            data: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.data = other.data;
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::Int32Message {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[38]
    }
}
impl self::Int32Message {
    /// Gets the field number of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub const DATA_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub const DATA_DEFAULT_VALUE: i32 = 0;
    pub fn data(&self) -> i32 {
        self.data.unwrap_or(Self::DATA_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`data`] field
    ///
    /// [`data`]: #method.data
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn data_option(&self) -> ::std::option::Option<i32> {
        self.data
    }
    /// Returns a bool indicating the presence of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }
    /// Sets the value of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub fn set_data(&mut self, value: i32) {
        self.data = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct Uint32Message {
    data: ::std::option::Option<u32>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::Uint32Message {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 | 10 => self.data = ::std::option::Option::Some(input.read_uint32()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let data = self.data;
        if let ::std::option::Option::Some(data) = data {
            size += 1;
            size += ::protrust::io::sizes::uint32(data);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let data = self.data;
        if let ::std::option::Option::Some(data) = data {
            output.write_raw_tag_bytes(&[8])?;
            output.write_uint32(data)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::Uint32Message {
    fn new() -> Self {
        Self {
            data: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.data = other.data;
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::Uint32Message {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[39]
    }
}
impl self::Uint32Message {
    /// Gets the field number of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub const DATA_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub const DATA_DEFAULT_VALUE: u32 = 0;
    pub fn data(&self) -> u32 {
        self.data.unwrap_or(Self::DATA_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`data`] field
    ///
    /// [`data`]: #method.data
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn data_option(&self) -> ::std::option::Option<u32> {
        self.data
    }
    /// Returns a bool indicating the presence of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }
    /// Sets the value of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub fn set_data(&mut self, value: u32) {
        self.data = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct Int64Message {
    data: ::std::option::Option<i64>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::Int64Message {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 | 10 => self.data = ::std::option::Option::Some(input.read_int64()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let data = self.data;
        if let ::std::option::Option::Some(data) = data {
            size += 1;
            size += ::protrust::io::sizes::int64(data);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let data = self.data;
        if let ::std::option::Option::Some(data) = data {
            output.write_raw_tag_bytes(&[8])?;
            output.write_int64(data)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::Int64Message {
    fn new() -> Self {
        Self {
            data: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.data = other.data;
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::Int64Message {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[40]
    }
}
impl self::Int64Message {
    /// Gets the field number of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub const DATA_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub const DATA_DEFAULT_VALUE: i64 = 0;
    pub fn data(&self) -> i64 {
        self.data.unwrap_or(Self::DATA_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`data`] field
    ///
    /// [`data`]: #method.data
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn data_option(&self) -> ::std::option::Option<i64> {
        self.data
    }
    /// Returns a bool indicating the presence of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }
    /// Sets the value of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub fn set_data(&mut self, value: i64) {
        self.data = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct Uint64Message {
    data: ::std::option::Option<u64>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::Uint64Message {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 | 10 => self.data = ::std::option::Option::Some(input.read_uint64()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let data = self.data;
        if let ::std::option::Option::Some(data) = data {
            size += 1;
            size += ::protrust::io::sizes::uint64(data);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let data = self.data;
        if let ::std::option::Option::Some(data) = data {
            output.write_raw_tag_bytes(&[8])?;
            output.write_uint64(data)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::Uint64Message {
    fn new() -> Self {
        Self {
            data: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.data = other.data;
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::Uint64Message {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[41]
    }
}
impl self::Uint64Message {
    /// Gets the field number of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub const DATA_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub const DATA_DEFAULT_VALUE: u64 = 0;
    pub fn data(&self) -> u64 {
        self.data.unwrap_or(Self::DATA_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`data`] field
    ///
    /// [`data`]: #method.data
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn data_option(&self) -> ::std::option::Option<u64> {
        self.data
    }
    /// Returns a bool indicating the presence of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }
    /// Sets the value of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub fn set_data(&mut self, value: u64) {
        self.data = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct BoolMessage {
    data: ::std::option::Option<bool>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::BoolMessage {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 | 10 => self.data = ::std::option::Option::Some(input.read_bool()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let data = self.data;
        if let ::std::option::Option::Some(data) = data {
            size += 1;
            size += ::protrust::io::sizes::bool(data);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let data = self.data;
        if let ::std::option::Option::Some(data) = data {
            output.write_raw_tag_bytes(&[8])?;
            output.write_bool(data)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::BoolMessage {
    fn new() -> Self {
        Self {
            data: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.data = other.data;
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::BoolMessage {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[42]
    }
}
impl self::BoolMessage {
    /// Gets the field number of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub const DATA_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub const DATA_DEFAULT_VALUE: bool = false;
    pub fn data(&self) -> bool {
        self.data.unwrap_or(Self::DATA_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`data`] field
    ///
    /// [`data`]: #method.data
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn data_option(&self) -> ::std::option::Option<bool> {
        self.data
    }
    /// Returns a bool indicating the presence of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }
    /// Sets the value of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub fn set_data(&mut self, value: bool) {
        self.data = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`data`] field
    ///
    /// [`data`]: #method.data
    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None
    }
}
/// Test oneofs.
#[derive(Clone, Debug, PartialEq)]
pub struct TestOneof {
    foo: self::test_oneof::Foo,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::TestOneof {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 | 10 => self.foo = self::test_oneof::Foo::FooInt(input.read_int32()?),
                18 => self.foo = self::test_oneof::Foo::FooString(input.read_string()?),
                26 => 
                    if let self::test_oneof::Foo::FooMessage(foo) = &mut self.foo {
                        input.read_message(&mut **foo)?;
                    } else {
                        let mut foo = ::std::boxed::Box::new(<self::TestAllTypes as ::protrust::LiteMessage>::new());
                        input.read_message(&mut *foo)?;
                        self.foo = self::test_oneof::Foo::FooMessage(foo)
                    },
                35 => 
                    if let self::test_oneof::Foo::Foogroup(foo) = &mut self.foo {
                        input.read_group(&mut **foo)?;
                    } else {
                        let mut foo = ::std::boxed::Box::new(<self::test_oneof::FooGroup as ::protrust::LiteMessage>::new());
                        input.read_group(&mut *foo)?;
                        self.foo = self::test_oneof::Foo::Foogroup(foo)
                    },
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        if let self::test_oneof::Foo::FooInt(foo) = self.foo {
            size += 1;
            size += ::protrust::io::sizes::int32(foo);
        }
        if let self::test_oneof::Foo::FooString(foo) = &self.foo {
            size += 1;
            size += ::protrust::io::sizes::string(foo);
        }
        if let self::test_oneof::Foo::FooMessage(foo) = &self.foo {
            size += 1;
            size += ::protrust::io::sizes::message(&**foo);
        }
        if let self::test_oneof::Foo::Foogroup(foo) = &self.foo {
            size += 1;
            size += ::protrust::io::sizes::group(&**foo);
            size += 1;
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        if let self::test_oneof::Foo::FooInt(foo) = self.foo {
            output.write_raw_tag_bytes(&[8])?;
            output.write_int32(foo)?;
        }
        if let self::test_oneof::Foo::FooString(foo) = &self.foo {
            output.write_raw_tag_bytes(&[18])?;
            output.write_string(foo)?;
        }
        if let self::test_oneof::Foo::FooMessage(foo) = &self.foo {
            output.write_raw_tag_bytes(&[26])?;
            output.write_message(&**foo)?;
        }
        if let self::test_oneof::Foo::Foogroup(foo) = &self.foo {
            output.write_raw_tag_bytes(&[35])?;
            output.write_group(&**foo)?;
            output.write_raw_tag_bytes(&[36])?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        if let self::test_oneof::Foo::FooMessage(foo) = &self.foo {
            if !::protrust::CodedMessage::is_initialized(&**foo) {
                return false;
            }
        }
        if let self::test_oneof::Foo::Foogroup(foo) = &self.foo {
            if !::protrust::CodedMessage::is_initialized(&**foo) {
                return false;
            }
        }
        true
    }
}
impl ::protrust::LiteMessage for self::TestOneof {
    fn new() -> Self {
        Self {
            foo: self::test_oneof::Foo::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        if let self::test_oneof::Foo::FooInt(foo) = other.foo {
            self.foo = self::test_oneof::Foo::FooInt(foo);
        }
        if let self::test_oneof::Foo::FooString(foo) = &other.foo {
            self.foo = self::test_oneof::Foo::FooString(foo.clone());
        }
        if let self::test_oneof::Foo::FooMessage(foo) = &other.foo {
            if let self::test_oneof::Foo::FooMessage(existing) = &mut self.foo {
                existing.merge(foo);
            } else {
                self.foo = self::test_oneof::Foo::FooMessage(foo.clone());
            }
        }
        if let self::test_oneof::Foo::Foogroup(foo) = &other.foo {
            if let self::test_oneof::Foo::Foogroup(existing) = &mut self.foo {
                existing.merge(foo);
            } else {
                self.foo = self::test_oneof::Foo::Foogroup(foo.clone());
            }
        }
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestOneof {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[43]
    }
}
impl self::TestOneof {
    /// Gets a shared reference to the [`foo`] oneof field
    ///
    /// [`foo`]: enum.Foo.html
    pub fn foo(&self) -> &self::test_oneof::Foo {
        &self.foo
    }
    /// Gets a unique reference to the [`foo`] oneof field
    ///
    /// [`foo`]: enum.Foo.html
    pub fn foo_mut(&mut self) -> &mut self::test_oneof::Foo {
        &mut self.foo
    }
}
/// Test oneofs.
pub mod test_oneof {
    #[derive(Clone, Debug, PartialEq)]
    pub struct FooGroup {
        a: ::std::option::Option<i32>,
        b: ::std::option::Option<::std::string::String>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::FooGroup {
        fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    40 | 42 => self.a = ::std::option::Option::Some(input.read_int32()?),
                    50 => self.b = ::std::option::Option::Some(input.read_string()?),
                    36 => break,
                    _ => self.unknown_fields.merge_from(tag, input)?
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            let a = self.a;
            if let ::std::option::Option::Some(a) = a {
                size += 1;
                size += ::protrust::io::sizes::int32(a);
            }
            let b = &self.b;
            if let ::std::option::Option::Some(b) = b {
                size += 1;
                size += ::protrust::io::sizes::string(b);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
            let a = self.a;
            if let ::std::option::Option::Some(a) = a {
                output.write_raw_tag_bytes(&[40])?;
                output.write_int32(a)?;
            }
            let b = &self.b;
            if let ::std::option::Option::Some(b) = b {
                output.write_raw_tag_bytes(&[50])?;
                output.write_string(b)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
    }
    impl ::protrust::LiteMessage for self::FooGroup {
        fn new() -> Self {
            Self {
                a: ::std::option::Option::None,
                b: ::std::option::Option::None,
                unknown_fields: ::protrust::UnknownFieldSet::new(),
            }
        }
        fn merge(&mut self, other: &Self) {
            self.a = other.a;
            self.b = other.b.clone();
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::FooGroup {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
            &self::super::file().messages()[43].messages()[0]
        }
    }
    impl self::FooGroup {
        /// Gets the field number of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub const A_FIELD_NUMBER: i32 = 5;
        /// A constant value representing the default value of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub const A_DEFAULT_VALUE: i32 = 0;
        pub fn a(&self) -> i32 {
            self.a.unwrap_or(Self::A_DEFAULT_VALUE)
        }
        /// Returns an [`Option`] representing the presence of the [`a`] field
        ///
        /// [`a`]: #method.a
        /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
        pub fn a_option(&self) -> ::std::option::Option<i32> {
            self.a
        }
        /// Returns a bool indicating the presence of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub fn has_a(&self) -> bool {
            self.a.is_some()
        }
        /// Sets the value of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub fn set_a(&mut self, value: i32) {
            self.a = ::std::option::Option::Some(value)
        }
        /// Clears the value of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub fn clear_a(&mut self) {
            self.a = ::std::option::Option::None
        }
        /// Gets the field number of the [`b`] field
        ///
        /// [`b`]: #method.b
        pub const B_FIELD_NUMBER: i32 = 6;
        /// A constant value representing the default value of the [`b`] field
        ///
        /// [`b`]: #method.b
        pub const B_DEFAULT_VALUE: &'static str = "";
        pub fn b(&self) -> &str {
            self.b.as_ref().map(|v| &**v).unwrap_or(Self::B_DEFAULT_VALUE)
        }
        /// Returns an [`Option`] representing the presence of the [`b`] field
        ///
        /// [`b`]: #method.b
        /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
        pub fn b_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.b.as_ref()
        }
        /// Returns a unique reference to the [`b`] field
        ///
        /// [`b`]: #method.b
        pub fn b_mut(&mut self) -> &mut ::std::string::String {
            self.b.get_or_insert_with(::std::string::String::new)
        }
        /// Returns a bool indicating the presence of the [`b`] field
        ///
        /// [`b`]: #method.b
        pub fn has_b(&self) -> bool {
            self.b.is_some()
        }
        /// Sets the value of the [`b`] field
        ///
        /// [`b`]: #method.b
        pub fn set_b(&mut self, value: ::std::string::String) {
            self.b = ::std::option::Option::Some(value)
        }
        /// Takes the value of the [`b`] field, leaving it empty
        ///
        /// [`b`]: #method.b
        pub fn take_b(&mut self) -> ::std::option::Option<::std::string::String> {
            self.b.take()
        }
        /// Clears the value of the [`b`] field
        ///
        /// [`b`]: #method.b
        pub fn clear_b(&mut self) {
            self.b = ::std::option::Option::None
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    pub enum Foo {
        /// No value
        None,
        FooInt(i32),
        FooString(::std::string::String),
        FooMessage(::std::boxed::Box<self::super::TestAllTypes>),
        Foogroup(::std::boxed::Box<self::super::test_oneof::FooGroup>),
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct TestOneofBackwardsCompatible {
    foo_int: ::std::option::Option<i32>,
    foo_string: ::std::option::Option<::std::string::String>,
    foo_message: ::std::option::Option<::std::boxed::Box<self::TestAllTypes>>,
    foogroup: ::std::option::Option<::std::boxed::Box<self::test_oneof_backwards_compatible::FooGroup>>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::TestOneofBackwardsCompatible {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 | 10 => self.foo_int = ::std::option::Option::Some(input.read_int32()?),
                18 => self.foo_string = ::std::option::Option::Some(input.read_string()?),
                26 => input.read_message(&mut **self.foo_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                35 => input.read_group(&mut **self.foogroup.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let foo_int = self.foo_int;
        if let ::std::option::Option::Some(foo_int) = foo_int {
            size += 1;
            size += ::protrust::io::sizes::int32(foo_int);
        }
        let foo_string = &self.foo_string;
        if let ::std::option::Option::Some(foo_string) = foo_string {
            size += 1;
            size += ::protrust::io::sizes::string(foo_string);
        }
        let foo_message = &self.foo_message;
        if let ::std::option::Option::Some(foo_message) = foo_message {
            size += 1;
            size += ::protrust::io::sizes::message(&**foo_message);
        }
        let foogroup = &self.foogroup;
        if let ::std::option::Option::Some(foogroup) = foogroup {
            size += 1;
            size += ::protrust::io::sizes::group(&**foogroup);
            size += 1;
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let foo_int = self.foo_int;
        if let ::std::option::Option::Some(foo_int) = foo_int {
            output.write_raw_tag_bytes(&[8])?;
            output.write_int32(foo_int)?;
        }
        let foo_string = &self.foo_string;
        if let ::std::option::Option::Some(foo_string) = foo_string {
            output.write_raw_tag_bytes(&[18])?;
            output.write_string(foo_string)?;
        }
        let foo_message = &self.foo_message;
        if let ::std::option::Option::Some(foo_message) = foo_message {
            output.write_raw_tag_bytes(&[26])?;
            output.write_message(&**foo_message)?;
        }
        let foogroup = &self.foogroup;
        if let ::std::option::Option::Some(foogroup) = foogroup {
            output.write_raw_tag_bytes(&[35])?;
            output.write_group(&**foogroup)?;
            output.write_raw_tag_bytes(&[36])?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        if let Some(foo_message) = &self.foo_message {
            if !::protrust::CodedMessage::is_initialized(&**foo_message) {
                return false;
            }
        }
        if let Some(foogroup) = &self.foogroup {
            if !::protrust::CodedMessage::is_initialized(&**foogroup) {
                return false;
            }
        }
        true
    }
}
impl ::protrust::LiteMessage for self::TestOneofBackwardsCompatible {
    fn new() -> Self {
        Self {
            foo_int: ::std::option::Option::None,
            foo_string: ::std::option::Option::None,
            foo_message: ::std::option::Option::None,
            foogroup: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.foo_int = other.foo_int;
        self.foo_string = other.foo_string.clone();
        if let ::std::option::Option::Some(foo_message) = &other.foo_message {
            self.foo_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(foo_message);
        }
        if let ::std::option::Option::Some(foogroup) = &other.foogroup {
            self.foogroup.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(foogroup);
        }
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestOneofBackwardsCompatible {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[44]
    }
}
impl self::TestOneofBackwardsCompatible {
    /// Gets the field number of the [`foo_int`] field
    ///
    /// [`foo_int`]: #method.foo_int
    pub const FOO_INT_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`foo_int`] field
    ///
    /// [`foo_int`]: #method.foo_int
    pub const FOO_INT_DEFAULT_VALUE: i32 = 0;
    pub fn foo_int(&self) -> i32 {
        self.foo_int.unwrap_or(Self::FOO_INT_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`foo_int`] field
    ///
    /// [`foo_int`]: #method.foo_int
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn foo_int_option(&self) -> ::std::option::Option<i32> {
        self.foo_int
    }
    /// Returns a bool indicating the presence of the [`foo_int`] field
    ///
    /// [`foo_int`]: #method.foo_int
    pub fn has_foo_int(&self) -> bool {
        self.foo_int.is_some()
    }
    /// Sets the value of the [`foo_int`] field
    ///
    /// [`foo_int`]: #method.foo_int
    pub fn set_foo_int(&mut self, value: i32) {
        self.foo_int = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`foo_int`] field
    ///
    /// [`foo_int`]: #method.foo_int
    pub fn clear_foo_int(&mut self) {
        self.foo_int = ::std::option::Option::None
    }
    /// Gets the field number of the [`foo_string`] field
    ///
    /// [`foo_string`]: #method.foo_string
    pub const FOO_STRING_FIELD_NUMBER: i32 = 2;
    /// A constant value representing the default value of the [`foo_string`] field
    ///
    /// [`foo_string`]: #method.foo_string
    pub const FOO_STRING_DEFAULT_VALUE: &'static str = "";
    pub fn foo_string(&self) -> &str {
        self.foo_string.as_ref().map(|v| &**v).unwrap_or(Self::FOO_STRING_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`foo_string`] field
    ///
    /// [`foo_string`]: #method.foo_string
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn foo_string_option(&self) -> ::std::option::Option<&::std::string::String> {
        self.foo_string.as_ref()
    }
    /// Returns a unique reference to the [`foo_string`] field
    ///
    /// [`foo_string`]: #method.foo_string
    pub fn foo_string_mut(&mut self) -> &mut ::std::string::String {
        self.foo_string.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`foo_string`] field
    ///
    /// [`foo_string`]: #method.foo_string
    pub fn has_foo_string(&self) -> bool {
        self.foo_string.is_some()
    }
    /// Sets the value of the [`foo_string`] field
    ///
    /// [`foo_string`]: #method.foo_string
    pub fn set_foo_string(&mut self, value: ::std::string::String) {
        self.foo_string = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`foo_string`] field, leaving it empty
    ///
    /// [`foo_string`]: #method.foo_string
    pub fn take_foo_string(&mut self) -> ::std::option::Option<::std::string::String> {
        self.foo_string.take()
    }
    /// Clears the value of the [`foo_string`] field
    ///
    /// [`foo_string`]: #method.foo_string
    pub fn clear_foo_string(&mut self) {
        self.foo_string = ::std::option::Option::None
    }
    /// Gets the field number of the [`foo_message`] field
    ///
    /// [`foo_message`]: #method.foo_message
    pub const FOO_MESSAGE_FIELD_NUMBER: i32 = 3;
    pub fn foo_message_option(&self) -> ::std::option::Option<&self::TestAllTypes> {
        self.foo_message.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`foo_message`] field
    ///
    /// [`foo_message`]: #method.foo_message
    pub fn foo_message_mut(&mut self) -> &mut self::TestAllTypes {
        self.foo_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`foo_message`] field
    ///
    /// [`foo_message`]: #method.foo_message
    pub fn has_foo_message(&self) -> bool {
        self.foo_message.is_some()
    }
    /// Sets the value of the [`foo_message`] field
    ///
    /// [`foo_message`]: #method.foo_message
    pub fn set_foo_message(&mut self, value: self::TestAllTypes) {
        self.foo_message = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`foo_message`] field, leaving it empty
    ///
    /// [`foo_message`]: #method.foo_message
    pub fn take_foo_message(&mut self) -> ::std::option::Option<self::TestAllTypes> {
        self.foo_message.take().map(|b| *b)
    }
    /// Clears the value of the [`foo_message`] field
    ///
    /// [`foo_message`]: #method.foo_message
    pub fn clear_foo_message(&mut self) {
        self.foo_message = ::std::option::Option::None
    }
    /// Gets the field number of the [`foogroup`] field
    ///
    /// [`foogroup`]: #method.foogroup
    pub const FOOGROUP_FIELD_NUMBER: i32 = 4;
    pub fn foogroup_option(&self) -> ::std::option::Option<&self::test_oneof_backwards_compatible::FooGroup> {
        self.foogroup.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`foogroup`] field
    ///
    /// [`foogroup`]: #method.foogroup
    pub fn foogroup_mut(&mut self) -> &mut self::test_oneof_backwards_compatible::FooGroup {
        self.foogroup.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`foogroup`] field
    ///
    /// [`foogroup`]: #method.foogroup
    pub fn has_foogroup(&self) -> bool {
        self.foogroup.is_some()
    }
    /// Sets the value of the [`foogroup`] field
    ///
    /// [`foogroup`]: #method.foogroup
    pub fn set_foogroup(&mut self, value: self::test_oneof_backwards_compatible::FooGroup) {
        self.foogroup = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`foogroup`] field, leaving it empty
    ///
    /// [`foogroup`]: #method.foogroup
    pub fn take_foogroup(&mut self) -> ::std::option::Option<self::test_oneof_backwards_compatible::FooGroup> {
        self.foogroup.take().map(|b| *b)
    }
    /// Clears the value of the [`foogroup`] field
    ///
    /// [`foogroup`]: #method.foogroup
    pub fn clear_foogroup(&mut self) {
        self.foogroup = ::std::option::Option::None
    }
}
pub mod test_oneof_backwards_compatible {
    #[derive(Clone, Debug, PartialEq)]
    pub struct FooGroup {
        a: ::std::option::Option<i32>,
        b: ::std::option::Option<::std::string::String>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::FooGroup {
        fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    40 | 42 => self.a = ::std::option::Option::Some(input.read_int32()?),
                    50 => self.b = ::std::option::Option::Some(input.read_string()?),
                    36 => break,
                    _ => self.unknown_fields.merge_from(tag, input)?
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            let a = self.a;
            if let ::std::option::Option::Some(a) = a {
                size += 1;
                size += ::protrust::io::sizes::int32(a);
            }
            let b = &self.b;
            if let ::std::option::Option::Some(b) = b {
                size += 1;
                size += ::protrust::io::sizes::string(b);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
            let a = self.a;
            if let ::std::option::Option::Some(a) = a {
                output.write_raw_tag_bytes(&[40])?;
                output.write_int32(a)?;
            }
            let b = &self.b;
            if let ::std::option::Option::Some(b) = b {
                output.write_raw_tag_bytes(&[50])?;
                output.write_string(b)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
    }
    impl ::protrust::LiteMessage for self::FooGroup {
        fn new() -> Self {
            Self {
                a: ::std::option::Option::None,
                b: ::std::option::Option::None,
                unknown_fields: ::protrust::UnknownFieldSet::new(),
            }
        }
        fn merge(&mut self, other: &Self) {
            self.a = other.a;
            self.b = other.b.clone();
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::FooGroup {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
            &self::super::file().messages()[44].messages()[0]
        }
    }
    impl self::FooGroup {
        /// Gets the field number of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub const A_FIELD_NUMBER: i32 = 5;
        /// A constant value representing the default value of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub const A_DEFAULT_VALUE: i32 = 0;
        pub fn a(&self) -> i32 {
            self.a.unwrap_or(Self::A_DEFAULT_VALUE)
        }
        /// Returns an [`Option`] representing the presence of the [`a`] field
        ///
        /// [`a`]: #method.a
        /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
        pub fn a_option(&self) -> ::std::option::Option<i32> {
            self.a
        }
        /// Returns a bool indicating the presence of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub fn has_a(&self) -> bool {
            self.a.is_some()
        }
        /// Sets the value of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub fn set_a(&mut self, value: i32) {
            self.a = ::std::option::Option::Some(value)
        }
        /// Clears the value of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub fn clear_a(&mut self) {
            self.a = ::std::option::Option::None
        }
        /// Gets the field number of the [`b`] field
        ///
        /// [`b`]: #method.b
        pub const B_FIELD_NUMBER: i32 = 6;
        /// A constant value representing the default value of the [`b`] field
        ///
        /// [`b`]: #method.b
        pub const B_DEFAULT_VALUE: &'static str = "";
        pub fn b(&self) -> &str {
            self.b.as_ref().map(|v| &**v).unwrap_or(Self::B_DEFAULT_VALUE)
        }
        /// Returns an [`Option`] representing the presence of the [`b`] field
        ///
        /// [`b`]: #method.b
        /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
        pub fn b_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.b.as_ref()
        }
        /// Returns a unique reference to the [`b`] field
        ///
        /// [`b`]: #method.b
        pub fn b_mut(&mut self) -> &mut ::std::string::String {
            self.b.get_or_insert_with(::std::string::String::new)
        }
        /// Returns a bool indicating the presence of the [`b`] field
        ///
        /// [`b`]: #method.b
        pub fn has_b(&self) -> bool {
            self.b.is_some()
        }
        /// Sets the value of the [`b`] field
        ///
        /// [`b`]: #method.b
        pub fn set_b(&mut self, value: ::std::string::String) {
            self.b = ::std::option::Option::Some(value)
        }
        /// Takes the value of the [`b`] field, leaving it empty
        ///
        /// [`b`]: #method.b
        pub fn take_b(&mut self) -> ::std::option::Option<::std::string::String> {
            self.b.take()
        }
        /// Clears the value of the [`b`] field
        ///
        /// [`b`]: #method.b
        pub fn clear_b(&mut self) {
            self.b = ::std::option::Option::None
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct TestOneof2 {
    baz_int: ::std::option::Option<i32>,
    baz_string: ::std::option::Option<::std::string::String>,
    foo: self::test_oneof2::Foo,
    bar: self::test_oneof2::Bar,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::TestOneof2 {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 | 10 => self.foo = self::test_oneof2::Foo::FooInt(input.read_int32()?),
                18 => self.foo = self::test_oneof2::Foo::FooString(input.read_string()?),
                26 => self.foo = self::test_oneof2::Foo::FooCord(input.read_string()?),
                34 => self.foo = self::test_oneof2::Foo::FooStringPiece(input.read_string()?),
                42 => self.foo = self::test_oneof2::Foo::FooBytes(input.read_bytes()?),
                48 | 50 => self.foo = self::test_oneof2::Foo::FooEnum(input.read_enum_value()?),
                58 => 
                    if let self::test_oneof2::Foo::FooMessage(foo) = &mut self.foo {
                        input.read_message(&mut **foo)?;
                    } else {
                        let mut foo = ::std::boxed::Box::new(<self::test_oneof2::NestedMessage as ::protrust::LiteMessage>::new());
                        input.read_message(&mut *foo)?;
                        self.foo = self::test_oneof2::Foo::FooMessage(foo)
                    },
                67 => 
                    if let self::test_oneof2::Foo::Foogroup(foo) = &mut self.foo {
                        input.read_group(&mut **foo)?;
                    } else {
                        let mut foo = ::std::boxed::Box::new(<self::test_oneof2::FooGroup as ::protrust::LiteMessage>::new());
                        input.read_group(&mut *foo)?;
                        self.foo = self::test_oneof2::Foo::Foogroup(foo)
                    },
                90 => 
                    if let self::test_oneof2::Foo::FooLazyMessage(foo) = &mut self.foo {
                        input.read_message(&mut **foo)?;
                    } else {
                        let mut foo = ::std::boxed::Box::new(<self::test_oneof2::NestedMessage as ::protrust::LiteMessage>::new());
                        input.read_message(&mut *foo)?;
                        self.foo = self::test_oneof2::Foo::FooLazyMessage(foo)
                    },
                96 | 98 => self.bar = self::test_oneof2::Bar::BarInt(input.read_int32()?),
                106 => self.bar = self::test_oneof2::Bar::BarString(input.read_string()?),
                114 => self.bar = self::test_oneof2::Bar::BarCord(input.read_string()?),
                122 => self.bar = self::test_oneof2::Bar::BarStringPiece(input.read_string()?),
                130 => self.bar = self::test_oneof2::Bar::BarBytes(input.read_bytes()?),
                136 | 138 => self.bar = self::test_oneof2::Bar::BarEnum(input.read_enum_value()?),
                144 | 146 => self.baz_int = ::std::option::Option::Some(input.read_int32()?),
                154 => self.baz_string = ::std::option::Option::Some(input.read_string()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        if let self::test_oneof2::Foo::FooInt(foo) = self.foo {
            size += 1;
            size += ::protrust::io::sizes::int32(foo);
        }
        if let self::test_oneof2::Foo::FooString(foo) = &self.foo {
            size += 1;
            size += ::protrust::io::sizes::string(foo);
        }
        if let self::test_oneof2::Foo::FooCord(foo) = &self.foo {
            size += 1;
            size += ::protrust::io::sizes::string(foo);
        }
        if let self::test_oneof2::Foo::FooStringPiece(foo) = &self.foo {
            size += 1;
            size += ::protrust::io::sizes::string(foo);
        }
        if let self::test_oneof2::Foo::FooBytes(foo) = &self.foo {
            size += 1;
            size += ::protrust::io::sizes::bytes(foo);
        }
        if let self::test_oneof2::Foo::FooEnum(foo) = self.foo {
            size += 1;
            size += ::protrust::io::sizes::enum_value(foo);
        }
        if let self::test_oneof2::Foo::FooMessage(foo) = &self.foo {
            size += 1;
            size += ::protrust::io::sizes::message(&**foo);
        }
        if let self::test_oneof2::Foo::Foogroup(foo) = &self.foo {
            size += 1;
            size += ::protrust::io::sizes::group(&**foo);
            size += 1;
        }
        if let self::test_oneof2::Foo::FooLazyMessage(foo) = &self.foo {
            size += 1;
            size += ::protrust::io::sizes::message(&**foo);
        }
        if let self::test_oneof2::Bar::BarInt(bar) = self.bar {
            size += 1;
            size += ::protrust::io::sizes::int32(bar);
        }
        if let self::test_oneof2::Bar::BarString(bar) = &self.bar {
            size += 1;
            size += ::protrust::io::sizes::string(bar);
        }
        if let self::test_oneof2::Bar::BarCord(bar) = &self.bar {
            size += 1;
            size += ::protrust::io::sizes::string(bar);
        }
        if let self::test_oneof2::Bar::BarStringPiece(bar) = &self.bar {
            size += 1;
            size += ::protrust::io::sizes::string(bar);
        }
        if let self::test_oneof2::Bar::BarBytes(bar) = &self.bar {
            size += 2;
            size += ::protrust::io::sizes::bytes(bar);
        }
        if let self::test_oneof2::Bar::BarEnum(bar) = self.bar {
            size += 2;
            size += ::protrust::io::sizes::enum_value(bar);
        }
        let baz_int = self.baz_int;
        if let ::std::option::Option::Some(baz_int) = baz_int {
            size += 2;
            size += ::protrust::io::sizes::int32(baz_int);
        }
        let baz_string = &self.baz_string;
        if let ::std::option::Option::Some(baz_string) = baz_string {
            size += 2;
            size += ::protrust::io::sizes::string(baz_string);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        if let self::test_oneof2::Foo::FooInt(foo) = self.foo {
            output.write_raw_tag_bytes(&[8])?;
            output.write_int32(foo)?;
        }
        if let self::test_oneof2::Foo::FooString(foo) = &self.foo {
            output.write_raw_tag_bytes(&[18])?;
            output.write_string(foo)?;
        }
        if let self::test_oneof2::Foo::FooCord(foo) = &self.foo {
            output.write_raw_tag_bytes(&[26])?;
            output.write_string(foo)?;
        }
        if let self::test_oneof2::Foo::FooStringPiece(foo) = &self.foo {
            output.write_raw_tag_bytes(&[34])?;
            output.write_string(foo)?;
        }
        if let self::test_oneof2::Foo::FooBytes(foo) = &self.foo {
            output.write_raw_tag_bytes(&[42])?;
            output.write_bytes(foo)?;
        }
        if let self::test_oneof2::Foo::FooEnum(foo) = self.foo {
            output.write_raw_tag_bytes(&[48])?;
            output.write_enum_value(foo)?;
        }
        if let self::test_oneof2::Foo::FooMessage(foo) = &self.foo {
            output.write_raw_tag_bytes(&[58])?;
            output.write_message(&**foo)?;
        }
        if let self::test_oneof2::Foo::Foogroup(foo) = &self.foo {
            output.write_raw_tag_bytes(&[67])?;
            output.write_group(&**foo)?;
            output.write_raw_tag_bytes(&[68])?;
        }
        if let self::test_oneof2::Foo::FooLazyMessage(foo) = &self.foo {
            output.write_raw_tag_bytes(&[90])?;
            output.write_message(&**foo)?;
        }
        if let self::test_oneof2::Bar::BarInt(bar) = self.bar {
            output.write_raw_tag_bytes(&[96])?;
            output.write_int32(bar)?;
        }
        if let self::test_oneof2::Bar::BarString(bar) = &self.bar {
            output.write_raw_tag_bytes(&[106])?;
            output.write_string(bar)?;
        }
        if let self::test_oneof2::Bar::BarCord(bar) = &self.bar {
            output.write_raw_tag_bytes(&[114])?;
            output.write_string(bar)?;
        }
        if let self::test_oneof2::Bar::BarStringPiece(bar) = &self.bar {
            output.write_raw_tag_bytes(&[122])?;
            output.write_string(bar)?;
        }
        if let self::test_oneof2::Bar::BarBytes(bar) = &self.bar {
            output.write_raw_tag_bytes(&[130, 1])?;
            output.write_bytes(bar)?;
        }
        if let self::test_oneof2::Bar::BarEnum(bar) = self.bar {
            output.write_raw_tag_bytes(&[136, 1])?;
            output.write_enum_value(bar)?;
        }
        let baz_int = self.baz_int;
        if let ::std::option::Option::Some(baz_int) = baz_int {
            output.write_raw_tag_bytes(&[144, 1])?;
            output.write_int32(baz_int)?;
        }
        let baz_string = &self.baz_string;
        if let ::std::option::Option::Some(baz_string) = baz_string {
            output.write_raw_tag_bytes(&[154, 1])?;
            output.write_string(baz_string)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        if let self::test_oneof2::Foo::FooMessage(foo) = &self.foo {
            if !::protrust::CodedMessage::is_initialized(&**foo) {
                return false;
            }
        }
        if let self::test_oneof2::Foo::Foogroup(foo) = &self.foo {
            if !::protrust::CodedMessage::is_initialized(&**foo) {
                return false;
            }
        }
        if let self::test_oneof2::Foo::FooLazyMessage(foo) = &self.foo {
            if !::protrust::CodedMessage::is_initialized(&**foo) {
                return false;
            }
        }
        true
    }
}
impl ::protrust::LiteMessage for self::TestOneof2 {
    fn new() -> Self {
        Self {
            baz_int: ::std::option::Option::None,
            baz_string: ::std::option::Option::None,
            foo: self::test_oneof2::Foo::None,
            bar: self::test_oneof2::Bar::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        if let self::test_oneof2::Foo::FooInt(foo) = other.foo {
            self.foo = self::test_oneof2::Foo::FooInt(foo);
        }
        if let self::test_oneof2::Foo::FooString(foo) = &other.foo {
            self.foo = self::test_oneof2::Foo::FooString(foo.clone());
        }
        if let self::test_oneof2::Foo::FooCord(foo) = &other.foo {
            self.foo = self::test_oneof2::Foo::FooCord(foo.clone());
        }
        if let self::test_oneof2::Foo::FooStringPiece(foo) = &other.foo {
            self.foo = self::test_oneof2::Foo::FooStringPiece(foo.clone());
        }
        if let self::test_oneof2::Foo::FooBytes(foo) = &other.foo {
            self.foo = self::test_oneof2::Foo::FooBytes(foo.clone());
        }
        if let self::test_oneof2::Foo::FooEnum(foo) = other.foo {
            self.foo = self::test_oneof2::Foo::FooEnum(foo);
        }
        if let self::test_oneof2::Foo::FooMessage(foo) = &other.foo {
            if let self::test_oneof2::Foo::FooMessage(existing) = &mut self.foo {
                existing.merge(foo);
            } else {
                self.foo = self::test_oneof2::Foo::FooMessage(foo.clone());
            }
        }
        if let self::test_oneof2::Foo::Foogroup(foo) = &other.foo {
            if let self::test_oneof2::Foo::Foogroup(existing) = &mut self.foo {
                existing.merge(foo);
            } else {
                self.foo = self::test_oneof2::Foo::Foogroup(foo.clone());
            }
        }
        if let self::test_oneof2::Foo::FooLazyMessage(foo) = &other.foo {
            if let self::test_oneof2::Foo::FooLazyMessage(existing) = &mut self.foo {
                existing.merge(foo);
            } else {
                self.foo = self::test_oneof2::Foo::FooLazyMessage(foo.clone());
            }
        }
        if let self::test_oneof2::Bar::BarInt(bar) = other.bar {
            self.bar = self::test_oneof2::Bar::BarInt(bar);
        }
        if let self::test_oneof2::Bar::BarString(bar) = &other.bar {
            self.bar = self::test_oneof2::Bar::BarString(bar.clone());
        }
        if let self::test_oneof2::Bar::BarCord(bar) = &other.bar {
            self.bar = self::test_oneof2::Bar::BarCord(bar.clone());
        }
        if let self::test_oneof2::Bar::BarStringPiece(bar) = &other.bar {
            self.bar = self::test_oneof2::Bar::BarStringPiece(bar.clone());
        }
        if let self::test_oneof2::Bar::BarBytes(bar) = &other.bar {
            self.bar = self::test_oneof2::Bar::BarBytes(bar.clone());
        }
        if let self::test_oneof2::Bar::BarEnum(bar) = other.bar {
            self.bar = self::test_oneof2::Bar::BarEnum(bar);
        }
        self.baz_int = other.baz_int;
        self.baz_string = other.baz_string.clone();
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestOneof2 {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[45]
    }
}
impl self::TestOneof2 {
    /// Gets the field number of the [`baz_int`] field
    ///
    /// [`baz_int`]: #method.baz_int
    pub const BAZ_INT_FIELD_NUMBER: i32 = 18;
    /// A constant value representing the default value of the [`baz_int`] field
    ///
    /// [`baz_int`]: #method.baz_int
    pub const BAZ_INT_DEFAULT_VALUE: i32 = 0;
    pub fn baz_int(&self) -> i32 {
        self.baz_int.unwrap_or(Self::BAZ_INT_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`baz_int`] field
    ///
    /// [`baz_int`]: #method.baz_int
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn baz_int_option(&self) -> ::std::option::Option<i32> {
        self.baz_int
    }
    /// Returns a bool indicating the presence of the [`baz_int`] field
    ///
    /// [`baz_int`]: #method.baz_int
    pub fn has_baz_int(&self) -> bool {
        self.baz_int.is_some()
    }
    /// Sets the value of the [`baz_int`] field
    ///
    /// [`baz_int`]: #method.baz_int
    pub fn set_baz_int(&mut self, value: i32) {
        self.baz_int = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`baz_int`] field
    ///
    /// [`baz_int`]: #method.baz_int
    pub fn clear_baz_int(&mut self) {
        self.baz_int = ::std::option::Option::None
    }
    /// Gets the field number of the [`baz_string`] field
    ///
    /// [`baz_string`]: #method.baz_string
    pub const BAZ_STRING_FIELD_NUMBER: i32 = 19;
    /// A constant value representing the default value of the [`baz_string`] field
    ///
    /// [`baz_string`]: #method.baz_string
    pub const BAZ_STRING_DEFAULT_VALUE: &'static str = "BAZ";
    pub fn baz_string(&self) -> &str {
        self.baz_string.as_ref().map(|v| &**v).unwrap_or(Self::BAZ_STRING_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`baz_string`] field
    ///
    /// [`baz_string`]: #method.baz_string
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn baz_string_option(&self) -> ::std::option::Option<&::std::string::String> {
        self.baz_string.as_ref()
    }
    /// Returns a unique reference to the [`baz_string`] field
    ///
    /// [`baz_string`]: #method.baz_string
    pub fn baz_string_mut(&mut self) -> &mut ::std::string::String {
        self.baz_string.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`baz_string`] field
    ///
    /// [`baz_string`]: #method.baz_string
    pub fn has_baz_string(&self) -> bool {
        self.baz_string.is_some()
    }
    /// Sets the value of the [`baz_string`] field
    ///
    /// [`baz_string`]: #method.baz_string
    pub fn set_baz_string(&mut self, value: ::std::string::String) {
        self.baz_string = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`baz_string`] field, leaving it empty
    ///
    /// [`baz_string`]: #method.baz_string
    pub fn take_baz_string(&mut self) -> ::std::option::Option<::std::string::String> {
        self.baz_string.take()
    }
    /// Clears the value of the [`baz_string`] field
    ///
    /// [`baz_string`]: #method.baz_string
    pub fn clear_baz_string(&mut self) {
        self.baz_string = ::std::option::Option::None
    }
    /// Gets a shared reference to the [`foo`] oneof field
    ///
    /// [`foo`]: enum.Foo.html
    pub fn foo(&self) -> &self::test_oneof2::Foo {
        &self.foo
    }
    /// Gets a unique reference to the [`foo`] oneof field
    ///
    /// [`foo`]: enum.Foo.html
    pub fn foo_mut(&mut self) -> &mut self::test_oneof2::Foo {
        &mut self.foo
    }
    /// Gets a shared reference to the [`bar`] oneof field
    ///
    /// [`bar`]: enum.Bar.html
    pub fn bar(&self) -> &self::test_oneof2::Bar {
        &self.bar
    }
    /// Gets a unique reference to the [`bar`] oneof field
    ///
    /// [`bar`]: enum.Bar.html
    pub fn bar_mut(&mut self) -> &mut self::test_oneof2::Bar {
        &mut self.bar
    }
}
pub mod test_oneof2 {
    #[derive(Clone, Debug, PartialEq)]
    pub struct FooGroup {
        a: ::std::option::Option<i32>,
        b: ::std::option::Option<::std::string::String>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::FooGroup {
        fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    72 | 74 => self.a = ::std::option::Option::Some(input.read_int32()?),
                    82 => self.b = ::std::option::Option::Some(input.read_string()?),
                    68 => break,
                    _ => self.unknown_fields.merge_from(tag, input)?
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            let a = self.a;
            if let ::std::option::Option::Some(a) = a {
                size += 1;
                size += ::protrust::io::sizes::int32(a);
            }
            let b = &self.b;
            if let ::std::option::Option::Some(b) = b {
                size += 1;
                size += ::protrust::io::sizes::string(b);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
            let a = self.a;
            if let ::std::option::Option::Some(a) = a {
                output.write_raw_tag_bytes(&[72])?;
                output.write_int32(a)?;
            }
            let b = &self.b;
            if let ::std::option::Option::Some(b) = b {
                output.write_raw_tag_bytes(&[82])?;
                output.write_string(b)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
    }
    impl ::protrust::LiteMessage for self::FooGroup {
        fn new() -> Self {
            Self {
                a: ::std::option::Option::None,
                b: ::std::option::Option::None,
                unknown_fields: ::protrust::UnknownFieldSet::new(),
            }
        }
        fn merge(&mut self, other: &Self) {
            self.a = other.a;
            self.b = other.b.clone();
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::FooGroup {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
            &self::super::file().messages()[45].messages()[0]
        }
    }
    impl self::FooGroup {
        /// Gets the field number of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub const A_FIELD_NUMBER: i32 = 9;
        /// A constant value representing the default value of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub const A_DEFAULT_VALUE: i32 = 0;
        pub fn a(&self) -> i32 {
            self.a.unwrap_or(Self::A_DEFAULT_VALUE)
        }
        /// Returns an [`Option`] representing the presence of the [`a`] field
        ///
        /// [`a`]: #method.a
        /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
        pub fn a_option(&self) -> ::std::option::Option<i32> {
            self.a
        }
        /// Returns a bool indicating the presence of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub fn has_a(&self) -> bool {
            self.a.is_some()
        }
        /// Sets the value of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub fn set_a(&mut self, value: i32) {
            self.a = ::std::option::Option::Some(value)
        }
        /// Clears the value of the [`a`] field
        ///
        /// [`a`]: #method.a
        pub fn clear_a(&mut self) {
            self.a = ::std::option::Option::None
        }
        /// Gets the field number of the [`b`] field
        ///
        /// [`b`]: #method.b
        pub const B_FIELD_NUMBER: i32 = 10;
        /// A constant value representing the default value of the [`b`] field
        ///
        /// [`b`]: #method.b
        pub const B_DEFAULT_VALUE: &'static str = "";
        pub fn b(&self) -> &str {
            self.b.as_ref().map(|v| &**v).unwrap_or(Self::B_DEFAULT_VALUE)
        }
        /// Returns an [`Option`] representing the presence of the [`b`] field
        ///
        /// [`b`]: #method.b
        /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
        pub fn b_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.b.as_ref()
        }
        /// Returns a unique reference to the [`b`] field
        ///
        /// [`b`]: #method.b
        pub fn b_mut(&mut self) -> &mut ::std::string::String {
            self.b.get_or_insert_with(::std::string::String::new)
        }
        /// Returns a bool indicating the presence of the [`b`] field
        ///
        /// [`b`]: #method.b
        pub fn has_b(&self) -> bool {
            self.b.is_some()
        }
        /// Sets the value of the [`b`] field
        ///
        /// [`b`]: #method.b
        pub fn set_b(&mut self, value: ::std::string::String) {
            self.b = ::std::option::Option::Some(value)
        }
        /// Takes the value of the [`b`] field, leaving it empty
        ///
        /// [`b`]: #method.b
        pub fn take_b(&mut self) -> ::std::option::Option<::std::string::String> {
            self.b.take()
        }
        /// Clears the value of the [`b`] field
        ///
        /// [`b`]: #method.b
        pub fn clear_b(&mut self) {
            self.b = ::std::option::Option::None
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    pub struct NestedMessage {
        qux_int: ::std::option::Option<i64>,
        corge_int: ::protrust::collections::RepeatedField<i32>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    static NESTED_MESSAGE_CORGE_INT_CODEC: ::protrust::Codec<i32> = ::protrust::Codec::int32(16);
    impl ::protrust::CodedMessage for self::NestedMessage {
        fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.qux_int = ::std::option::Option::Some(input.read_int64()?),
                    16 | 18 => self.corge_int.add_entries(input, &NESTED_MESSAGE_CORGE_INT_CODEC)?,
                    _ => self.unknown_fields.merge_from(tag, input)?
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            let qux_int = self.qux_int;
            if let ::std::option::Option::Some(qux_int) = qux_int {
                size += 1;
                size += ::protrust::io::sizes::int64(qux_int);
            }
            size += self.corge_int.calculate_size(&NESTED_MESSAGE_CORGE_INT_CODEC);
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
            let qux_int = self.qux_int;
            if let ::std::option::Option::Some(qux_int) = qux_int {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int64(qux_int)?;
            }
            self.corge_int.write_to(output, &NESTED_MESSAGE_CORGE_INT_CODEC)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::NestedMessage {
        fn new() -> Self {
            Self {
                qux_int: ::std::option::Option::None,
                corge_int: ::protrust::collections::RepeatedField::new(),
                unknown_fields: ::protrust::UnknownFieldSet::new(),
            }
        }
        fn merge(&mut self, other: &Self) {
            self.qux_int = other.qux_int;
            self.corge_int.merge(&other.corge_int);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::NestedMessage {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
            &self::super::file().messages()[45].messages()[1]
        }
    }
    impl self::NestedMessage {
        /// Gets the field number of the [`qux_int`] field
        ///
        /// [`qux_int`]: #method.qux_int
        pub const QUX_INT_FIELD_NUMBER: i32 = 1;
        /// A constant value representing the default value of the [`qux_int`] field
        ///
        /// [`qux_int`]: #method.qux_int
        pub const QUX_INT_DEFAULT_VALUE: i64 = 0;
        pub fn qux_int(&self) -> i64 {
            self.qux_int.unwrap_or(Self::QUX_INT_DEFAULT_VALUE)
        }
        /// Returns an [`Option`] representing the presence of the [`qux_int`] field
        ///
        /// [`qux_int`]: #method.qux_int
        /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
        pub fn qux_int_option(&self) -> ::std::option::Option<i64> {
            self.qux_int
        }
        /// Returns a bool indicating the presence of the [`qux_int`] field
        ///
        /// [`qux_int`]: #method.qux_int
        pub fn has_qux_int(&self) -> bool {
            self.qux_int.is_some()
        }
        /// Sets the value of the [`qux_int`] field
        ///
        /// [`qux_int`]: #method.qux_int
        pub fn set_qux_int(&mut self, value: i64) {
            self.qux_int = ::std::option::Option::Some(value)
        }
        /// Clears the value of the [`qux_int`] field
        ///
        /// [`qux_int`]: #method.qux_int
        pub fn clear_qux_int(&mut self) {
            self.qux_int = ::std::option::Option::None
        }
        /// Gets the field number of the [`corge_int`] field
        ///
        /// [`corge_int`]: #method.corge_int
        pub const CORGE_INT_FIELD_NUMBER: i32 = 2;
        pub fn corge_int(&self) -> &::protrust::collections::RepeatedField<i32> {
            &self.corge_int
        }
        /// Returns a unique reference to the [`corge_int`] field
        ///
        /// [`corge_int`]: #method.corge_int
        pub fn corge_int_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
            &mut self.corge_int
        }
    }
    #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
    pub enum NestedEnum {
        Foo,
        Bar,
        Baz,
    }
    unsafe impl ::protrust::Enum for self::NestedEnum { }
    impl ::std::convert::TryFrom<i32> for self::NestedEnum {
        type Error = ::protrust::VariantUndefinedError;
        fn try_from(value: i32) -> ::std::result::Result<Self, ::protrust::VariantUndefinedError> {
            #[allow(unreachable_patterns)]
            match value {
                1 => ::std::result::Result::Ok(self::NestedEnum::Foo),
                2 => ::std::result::Result::Ok(self::NestedEnum::Bar),
                3 => ::std::result::Result::Ok(self::NestedEnum::Baz),
                _ => ::std::result::Result::Err(::protrust::VariantUndefinedError)
            }
        }
    }
    impl ::std::convert::From<self::NestedEnum> for i32 {
        fn from(value: self::NestedEnum) -> i32 {
            match value {
                NestedEnum::Foo => 1,
                NestedEnum::Bar => 2,
                NestedEnum::Baz => 3,
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    pub enum Foo {
        /// No value
        None,
        FooInt(i32),
        FooString(::std::string::String),
        FooCord(::std::string::String),
        FooStringPiece(::std::string::String),
        FooBytes(::std::vec::Vec<u8>),
        FooEnum(::protrust::EnumValue<self::super::test_oneof2::NestedEnum>),
        FooMessage(::std::boxed::Box<self::super::test_oneof2::NestedMessage>),
        Foogroup(::std::boxed::Box<self::super::test_oneof2::FooGroup>),
        FooLazyMessage(::std::boxed::Box<self::super::test_oneof2::NestedMessage>),
    }
    #[derive(Clone, Debug, PartialEq)]
    pub enum Bar {
        /// No value
        None,
        BarInt(i32),
        BarString(::std::string::String),
        BarCord(::std::string::String),
        BarStringPiece(::std::string::String),
        BarBytes(::std::vec::Vec<u8>),
        BarEnum(::protrust::EnumValue<self::super::test_oneof2::NestedEnum>),
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct TestRequiredOneof {
    foo: self::test_required_oneof::Foo,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::TestRequiredOneof {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 | 10 => self.foo = self::test_required_oneof::Foo::FooInt(input.read_int32()?),
                18 => self.foo = self::test_required_oneof::Foo::FooString(input.read_string()?),
                26 => 
                    if let self::test_required_oneof::Foo::FooMessage(foo) = &mut self.foo {
                        input.read_message(&mut **foo)?;
                    } else {
                        let mut foo = ::std::boxed::Box::new(<self::test_required_oneof::NestedMessage as ::protrust::LiteMessage>::new());
                        input.read_message(&mut *foo)?;
                        self.foo = self::test_required_oneof::Foo::FooMessage(foo)
                    },
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        if let self::test_required_oneof::Foo::FooInt(foo) = self.foo {
            size += 1;
            size += ::protrust::io::sizes::int32(foo);
        }
        if let self::test_required_oneof::Foo::FooString(foo) = &self.foo {
            size += 1;
            size += ::protrust::io::sizes::string(foo);
        }
        if let self::test_required_oneof::Foo::FooMessage(foo) = &self.foo {
            size += 1;
            size += ::protrust::io::sizes::message(&**foo);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        if let self::test_required_oneof::Foo::FooInt(foo) = self.foo {
            output.write_raw_tag_bytes(&[8])?;
            output.write_int32(foo)?;
        }
        if let self::test_required_oneof::Foo::FooString(foo) = &self.foo {
            output.write_raw_tag_bytes(&[18])?;
            output.write_string(foo)?;
        }
        if let self::test_required_oneof::Foo::FooMessage(foo) = &self.foo {
            output.write_raw_tag_bytes(&[26])?;
            output.write_message(&**foo)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        if let self::test_required_oneof::Foo::FooMessage(foo) = &self.foo {
            if !::protrust::CodedMessage::is_initialized(&**foo) {
                return false;
            }
        }
        true
    }
}
impl ::protrust::LiteMessage for self::TestRequiredOneof {
    fn new() -> Self {
        Self {
            foo: self::test_required_oneof::Foo::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        if let self::test_required_oneof::Foo::FooInt(foo) = other.foo {
            self.foo = self::test_required_oneof::Foo::FooInt(foo);
        }
        if let self::test_required_oneof::Foo::FooString(foo) = &other.foo {
            self.foo = self::test_required_oneof::Foo::FooString(foo.clone());
        }
        if let self::test_required_oneof::Foo::FooMessage(foo) = &other.foo {
            if let self::test_required_oneof::Foo::FooMessage(existing) = &mut self.foo {
                existing.merge(foo);
            } else {
                self.foo = self::test_required_oneof::Foo::FooMessage(foo.clone());
            }
        }
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestRequiredOneof {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[46]
    }
}
impl self::TestRequiredOneof {
    /// Gets a shared reference to the [`foo`] oneof field
    ///
    /// [`foo`]: enum.Foo.html
    pub fn foo(&self) -> &self::test_required_oneof::Foo {
        &self.foo
    }
    /// Gets a unique reference to the [`foo`] oneof field
    ///
    /// [`foo`]: enum.Foo.html
    pub fn foo_mut(&mut self) -> &mut self::test_required_oneof::Foo {
        &mut self.foo
    }
}
pub mod test_required_oneof {
    #[derive(Clone, Debug, PartialEq)]
    pub struct NestedMessage {
        required_double: ::std::option::Option<f64>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::NestedMessage {
        fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    9 | 10 => self.required_double = ::std::option::Option::Some(input.read_double()?),
                    _ => self.unknown_fields.merge_from(tag, input)?
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            let required_double = self.required_double;
            if let ::std::option::Option::Some(required_double) = required_double {
                size += 1;
                size += ::protrust::io::sizes::double(required_double);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
            let required_double = self.required_double;
            if let ::std::option::Option::Some(required_double) = required_double {
                output.write_raw_tag_bytes(&[9])?;
                output.write_double(required_double)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if self.required_double.is_none() {
                return false;
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::NestedMessage {
        fn new() -> Self {
            Self {
                required_double: ::std::option::Option::None,
                unknown_fields: ::protrust::UnknownFieldSet::new(),
            }
        }
        fn merge(&mut self, other: &Self) {
            self.required_double = other.required_double;
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::NestedMessage {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
            &self::super::file().messages()[46].messages()[0]
        }
    }
    impl self::NestedMessage {
        /// Gets the field number of the [`required_double`] field
        ///
        /// [`required_double`]: #method.required_double
        pub const REQUIRED_DOUBLE_FIELD_NUMBER: i32 = 1;
        /// A constant value representing the default value of the [`required_double`] field
        ///
        /// [`required_double`]: #method.required_double
        pub const REQUIRED_DOUBLE_DEFAULT_VALUE: f64 = 0.0;
        pub fn required_double(&self) -> f64 {
            self.required_double.unwrap_or(Self::REQUIRED_DOUBLE_DEFAULT_VALUE)
        }
        /// Returns an [`Option`] representing the presence of the [`required_double`] field
        ///
        /// [`required_double`]: #method.required_double
        /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
        pub fn required_double_option(&self) -> ::std::option::Option<f64> {
            self.required_double
        }
        /// Returns a bool indicating the presence of the [`required_double`] field
        ///
        /// [`required_double`]: #method.required_double
        pub fn has_required_double(&self) -> bool {
            self.required_double.is_some()
        }
        /// Sets the value of the [`required_double`] field
        ///
        /// [`required_double`]: #method.required_double
        pub fn set_required_double(&mut self, value: f64) {
            self.required_double = ::std::option::Option::Some(value)
        }
        /// Clears the value of the [`required_double`] field
        ///
        /// [`required_double`]: #method.required_double
        pub fn clear_required_double(&mut self) {
            self.required_double = ::std::option::Option::None
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    pub enum Foo {
        /// No value
        None,
        FooInt(i32),
        FooString(::std::string::String),
        FooMessage(::std::boxed::Box<self::super::test_required_oneof::NestedMessage>),
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct TestPackedTypes {
    packed_int32: ::protrust::collections::RepeatedField<i32>,
    packed_int64: ::protrust::collections::RepeatedField<i64>,
    packed_uint32: ::protrust::collections::RepeatedField<u32>,
    packed_uint64: ::protrust::collections::RepeatedField<u64>,
    packed_sint32: ::protrust::collections::RepeatedField<i32>,
    packed_sint64: ::protrust::collections::RepeatedField<i64>,
    packed_fixed32: ::protrust::collections::RepeatedField<u32>,
    packed_fixed64: ::protrust::collections::RepeatedField<u64>,
    packed_sfixed32: ::protrust::collections::RepeatedField<i32>,
    packed_sfixed64: ::protrust::collections::RepeatedField<i64>,
    packed_float: ::protrust::collections::RepeatedField<f32>,
    packed_double: ::protrust::collections::RepeatedField<f64>,
    packed_bool: ::protrust::collections::RepeatedField<bool>,
    packed_enum: ::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
static TEST_PACKED_TYPES_PACKED_INT32_CODEC: ::protrust::Codec<i32> = ::protrust::Codec::int32(722);
static TEST_PACKED_TYPES_PACKED_INT64_CODEC: ::protrust::Codec<i64> = ::protrust::Codec::int64(730);
static TEST_PACKED_TYPES_PACKED_UINT32_CODEC: ::protrust::Codec<u32> = ::protrust::Codec::uint32(738);
static TEST_PACKED_TYPES_PACKED_UINT64_CODEC: ::protrust::Codec<u64> = ::protrust::Codec::uint64(746);
static TEST_PACKED_TYPES_PACKED_SINT32_CODEC: ::protrust::Codec<i32> = ::protrust::Codec::sint32(754);
static TEST_PACKED_TYPES_PACKED_SINT64_CODEC: ::protrust::Codec<i64> = ::protrust::Codec::sint64(762);
static TEST_PACKED_TYPES_PACKED_FIXED32_CODEC: ::protrust::Codec<u32> = ::protrust::Codec::fixed32(770);
static TEST_PACKED_TYPES_PACKED_FIXED64_CODEC: ::protrust::Codec<u64> = ::protrust::Codec::fixed64(778);
static TEST_PACKED_TYPES_PACKED_SFIXED32_CODEC: ::protrust::Codec<i32> = ::protrust::Codec::sfixed32(786);
static TEST_PACKED_TYPES_PACKED_SFIXED64_CODEC: ::protrust::Codec<i64> = ::protrust::Codec::sfixed64(794);
static TEST_PACKED_TYPES_PACKED_FLOAT_CODEC: ::protrust::Codec<f32> = ::protrust::Codec::float(802);
static TEST_PACKED_TYPES_PACKED_DOUBLE_CODEC: ::protrust::Codec<f64> = ::protrust::Codec::double(810);
static TEST_PACKED_TYPES_PACKED_BOOL_CODEC: ::protrust::Codec<bool> = ::protrust::Codec::bool(818);
static TEST_PACKED_TYPES_PACKED_ENUM_CODEC: ::protrust::Codec<::protrust::EnumValue<self::ForeignEnum>> = ::protrust::Codec::enum_value(826);
impl ::protrust::CodedMessage for self::TestPackedTypes {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                720 | 722 => self.packed_int32.add_entries(input, &TEST_PACKED_TYPES_PACKED_INT32_CODEC)?,
                728 | 730 => self.packed_int64.add_entries(input, &TEST_PACKED_TYPES_PACKED_INT64_CODEC)?,
                736 | 738 => self.packed_uint32.add_entries(input, &TEST_PACKED_TYPES_PACKED_UINT32_CODEC)?,
                744 | 746 => self.packed_uint64.add_entries(input, &TEST_PACKED_TYPES_PACKED_UINT64_CODEC)?,
                752 | 754 => self.packed_sint32.add_entries(input, &TEST_PACKED_TYPES_PACKED_SINT32_CODEC)?,
                760 | 762 => self.packed_sint64.add_entries(input, &TEST_PACKED_TYPES_PACKED_SINT64_CODEC)?,
                773 | 770 => self.packed_fixed32.add_entries(input, &TEST_PACKED_TYPES_PACKED_FIXED32_CODEC)?,
                777 | 778 => self.packed_fixed64.add_entries(input, &TEST_PACKED_TYPES_PACKED_FIXED64_CODEC)?,
                789 | 786 => self.packed_sfixed32.add_entries(input, &TEST_PACKED_TYPES_PACKED_SFIXED32_CODEC)?,
                793 | 794 => self.packed_sfixed64.add_entries(input, &TEST_PACKED_TYPES_PACKED_SFIXED64_CODEC)?,
                805 | 802 => self.packed_float.add_entries(input, &TEST_PACKED_TYPES_PACKED_FLOAT_CODEC)?,
                809 | 810 => self.packed_double.add_entries(input, &TEST_PACKED_TYPES_PACKED_DOUBLE_CODEC)?,
                816 | 818 => self.packed_bool.add_entries(input, &TEST_PACKED_TYPES_PACKED_BOOL_CODEC)?,
                824 | 826 => self.packed_enum.add_entries(input, &TEST_PACKED_TYPES_PACKED_ENUM_CODEC)?,
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.packed_int32.calculate_size(&TEST_PACKED_TYPES_PACKED_INT32_CODEC);
        size += self.packed_int64.calculate_size(&TEST_PACKED_TYPES_PACKED_INT64_CODEC);
        size += self.packed_uint32.calculate_size(&TEST_PACKED_TYPES_PACKED_UINT32_CODEC);
        size += self.packed_uint64.calculate_size(&TEST_PACKED_TYPES_PACKED_UINT64_CODEC);
        size += self.packed_sint32.calculate_size(&TEST_PACKED_TYPES_PACKED_SINT32_CODEC);
        size += self.packed_sint64.calculate_size(&TEST_PACKED_TYPES_PACKED_SINT64_CODEC);
        size += self.packed_fixed32.calculate_size(&TEST_PACKED_TYPES_PACKED_FIXED32_CODEC);
        size += self.packed_fixed64.calculate_size(&TEST_PACKED_TYPES_PACKED_FIXED64_CODEC);
        size += self.packed_sfixed32.calculate_size(&TEST_PACKED_TYPES_PACKED_SFIXED32_CODEC);
        size += self.packed_sfixed64.calculate_size(&TEST_PACKED_TYPES_PACKED_SFIXED64_CODEC);
        size += self.packed_float.calculate_size(&TEST_PACKED_TYPES_PACKED_FLOAT_CODEC);
        size += self.packed_double.calculate_size(&TEST_PACKED_TYPES_PACKED_DOUBLE_CODEC);
        size += self.packed_bool.calculate_size(&TEST_PACKED_TYPES_PACKED_BOOL_CODEC);
        size += self.packed_enum.calculate_size(&TEST_PACKED_TYPES_PACKED_ENUM_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        self.packed_int32.write_to(output, &TEST_PACKED_TYPES_PACKED_INT32_CODEC)?;
        self.packed_int64.write_to(output, &TEST_PACKED_TYPES_PACKED_INT64_CODEC)?;
        self.packed_uint32.write_to(output, &TEST_PACKED_TYPES_PACKED_UINT32_CODEC)?;
        self.packed_uint64.write_to(output, &TEST_PACKED_TYPES_PACKED_UINT64_CODEC)?;
        self.packed_sint32.write_to(output, &TEST_PACKED_TYPES_PACKED_SINT32_CODEC)?;
        self.packed_sint64.write_to(output, &TEST_PACKED_TYPES_PACKED_SINT64_CODEC)?;
        self.packed_fixed32.write_to(output, &TEST_PACKED_TYPES_PACKED_FIXED32_CODEC)?;
        self.packed_fixed64.write_to(output, &TEST_PACKED_TYPES_PACKED_FIXED64_CODEC)?;
        self.packed_sfixed32.write_to(output, &TEST_PACKED_TYPES_PACKED_SFIXED32_CODEC)?;
        self.packed_sfixed64.write_to(output, &TEST_PACKED_TYPES_PACKED_SFIXED64_CODEC)?;
        self.packed_float.write_to(output, &TEST_PACKED_TYPES_PACKED_FLOAT_CODEC)?;
        self.packed_double.write_to(output, &TEST_PACKED_TYPES_PACKED_DOUBLE_CODEC)?;
        self.packed_bool.write_to(output, &TEST_PACKED_TYPES_PACKED_BOOL_CODEC)?;
        self.packed_enum.write_to(output, &TEST_PACKED_TYPES_PACKED_ENUM_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        true
    }
}
impl ::protrust::LiteMessage for self::TestPackedTypes {
    fn new() -> Self {
        Self {
            packed_int32: ::protrust::collections::RepeatedField::new(),
            packed_int64: ::protrust::collections::RepeatedField::new(),
            packed_uint32: ::protrust::collections::RepeatedField::new(),
            packed_uint64: ::protrust::collections::RepeatedField::new(),
            packed_sint32: ::protrust::collections::RepeatedField::new(),
            packed_sint64: ::protrust::collections::RepeatedField::new(),
            packed_fixed32: ::protrust::collections::RepeatedField::new(),
            packed_fixed64: ::protrust::collections::RepeatedField::new(),
            packed_sfixed32: ::protrust::collections::RepeatedField::new(),
            packed_sfixed64: ::protrust::collections::RepeatedField::new(),
            packed_float: ::protrust::collections::RepeatedField::new(),
            packed_double: ::protrust::collections::RepeatedField::new(),
            packed_bool: ::protrust::collections::RepeatedField::new(),
            packed_enum: ::protrust::collections::RepeatedField::new(),
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.packed_int32.merge(&other.packed_int32);
        self.packed_int64.merge(&other.packed_int64);
        self.packed_uint32.merge(&other.packed_uint32);
        self.packed_uint64.merge(&other.packed_uint64);
        self.packed_sint32.merge(&other.packed_sint32);
        self.packed_sint64.merge(&other.packed_sint64);
        self.packed_fixed32.merge(&other.packed_fixed32);
        self.packed_fixed64.merge(&other.packed_fixed64);
        self.packed_sfixed32.merge(&other.packed_sfixed32);
        self.packed_sfixed64.merge(&other.packed_sfixed64);
        self.packed_float.merge(&other.packed_float);
        self.packed_double.merge(&other.packed_double);
        self.packed_bool.merge(&other.packed_bool);
        self.packed_enum.merge(&other.packed_enum);
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestPackedTypes {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[47]
    }
}
impl self::TestPackedTypes {
    /// Gets the field number of the [`packed_int32`] field
    ///
    /// [`packed_int32`]: #method.packed_int32
    pub const PACKED_INT32_FIELD_NUMBER: i32 = 90;
    pub fn packed_int32(&self) -> &::protrust::collections::RepeatedField<i32> {
        &self.packed_int32
    }
    /// Returns a unique reference to the [`packed_int32`] field
    ///
    /// [`packed_int32`]: #method.packed_int32
    pub fn packed_int32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
        &mut self.packed_int32
    }
    /// Gets the field number of the [`packed_int64`] field
    ///
    /// [`packed_int64`]: #method.packed_int64
    pub const PACKED_INT64_FIELD_NUMBER: i32 = 91;
    pub fn packed_int64(&self) -> &::protrust::collections::RepeatedField<i64> {
        &self.packed_int64
    }
    /// Returns a unique reference to the [`packed_int64`] field
    ///
    /// [`packed_int64`]: #method.packed_int64
    pub fn packed_int64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
        &mut self.packed_int64
    }
    /// Gets the field number of the [`packed_uint32`] field
    ///
    /// [`packed_uint32`]: #method.packed_uint32
    pub const PACKED_UINT32_FIELD_NUMBER: i32 = 92;
    pub fn packed_uint32(&self) -> &::protrust::collections::RepeatedField<u32> {
        &self.packed_uint32
    }
    /// Returns a unique reference to the [`packed_uint32`] field
    ///
    /// [`packed_uint32`]: #method.packed_uint32
    pub fn packed_uint32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u32> {
        &mut self.packed_uint32
    }
    /// Gets the field number of the [`packed_uint64`] field
    ///
    /// [`packed_uint64`]: #method.packed_uint64
    pub const PACKED_UINT64_FIELD_NUMBER: i32 = 93;
    pub fn packed_uint64(&self) -> &::protrust::collections::RepeatedField<u64> {
        &self.packed_uint64
    }
    /// Returns a unique reference to the [`packed_uint64`] field
    ///
    /// [`packed_uint64`]: #method.packed_uint64
    pub fn packed_uint64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u64> {
        &mut self.packed_uint64
    }
    /// Gets the field number of the [`packed_sint32`] field
    ///
    /// [`packed_sint32`]: #method.packed_sint32
    pub const PACKED_SINT32_FIELD_NUMBER: i32 = 94;
    pub fn packed_sint32(&self) -> &::protrust::collections::RepeatedField<i32> {
        &self.packed_sint32
    }
    /// Returns a unique reference to the [`packed_sint32`] field
    ///
    /// [`packed_sint32`]: #method.packed_sint32
    pub fn packed_sint32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
        &mut self.packed_sint32
    }
    /// Gets the field number of the [`packed_sint64`] field
    ///
    /// [`packed_sint64`]: #method.packed_sint64
    pub const PACKED_SINT64_FIELD_NUMBER: i32 = 95;
    pub fn packed_sint64(&self) -> &::protrust::collections::RepeatedField<i64> {
        &self.packed_sint64
    }
    /// Returns a unique reference to the [`packed_sint64`] field
    ///
    /// [`packed_sint64`]: #method.packed_sint64
    pub fn packed_sint64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
        &mut self.packed_sint64
    }
    /// Gets the field number of the [`packed_fixed32`] field
    ///
    /// [`packed_fixed32`]: #method.packed_fixed32
    pub const PACKED_FIXED32_FIELD_NUMBER: i32 = 96;
    pub fn packed_fixed32(&self) -> &::protrust::collections::RepeatedField<u32> {
        &self.packed_fixed32
    }
    /// Returns a unique reference to the [`packed_fixed32`] field
    ///
    /// [`packed_fixed32`]: #method.packed_fixed32
    pub fn packed_fixed32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u32> {
        &mut self.packed_fixed32
    }
    /// Gets the field number of the [`packed_fixed64`] field
    ///
    /// [`packed_fixed64`]: #method.packed_fixed64
    pub const PACKED_FIXED64_FIELD_NUMBER: i32 = 97;
    pub fn packed_fixed64(&self) -> &::protrust::collections::RepeatedField<u64> {
        &self.packed_fixed64
    }
    /// Returns a unique reference to the [`packed_fixed64`] field
    ///
    /// [`packed_fixed64`]: #method.packed_fixed64
    pub fn packed_fixed64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u64> {
        &mut self.packed_fixed64
    }
    /// Gets the field number of the [`packed_sfixed32`] field
    ///
    /// [`packed_sfixed32`]: #method.packed_sfixed32
    pub const PACKED_SFIXED32_FIELD_NUMBER: i32 = 98;
    pub fn packed_sfixed32(&self) -> &::protrust::collections::RepeatedField<i32> {
        &self.packed_sfixed32
    }
    /// Returns a unique reference to the [`packed_sfixed32`] field
    ///
    /// [`packed_sfixed32`]: #method.packed_sfixed32
    pub fn packed_sfixed32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
        &mut self.packed_sfixed32
    }
    /// Gets the field number of the [`packed_sfixed64`] field
    ///
    /// [`packed_sfixed64`]: #method.packed_sfixed64
    pub const PACKED_SFIXED64_FIELD_NUMBER: i32 = 99;
    pub fn packed_sfixed64(&self) -> &::protrust::collections::RepeatedField<i64> {
        &self.packed_sfixed64
    }
    /// Returns a unique reference to the [`packed_sfixed64`] field
    ///
    /// [`packed_sfixed64`]: #method.packed_sfixed64
    pub fn packed_sfixed64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
        &mut self.packed_sfixed64
    }
    /// Gets the field number of the [`packed_float`] field
    ///
    /// [`packed_float`]: #method.packed_float
    pub const PACKED_FLOAT_FIELD_NUMBER: i32 = 100;
    pub fn packed_float(&self) -> &::protrust::collections::RepeatedField<f32> {
        &self.packed_float
    }
    /// Returns a unique reference to the [`packed_float`] field
    ///
    /// [`packed_float`]: #method.packed_float
    pub fn packed_float_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<f32> {
        &mut self.packed_float
    }
    /// Gets the field number of the [`packed_double`] field
    ///
    /// [`packed_double`]: #method.packed_double
    pub const PACKED_DOUBLE_FIELD_NUMBER: i32 = 101;
    pub fn packed_double(&self) -> &::protrust::collections::RepeatedField<f64> {
        &self.packed_double
    }
    /// Returns a unique reference to the [`packed_double`] field
    ///
    /// [`packed_double`]: #method.packed_double
    pub fn packed_double_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<f64> {
        &mut self.packed_double
    }
    /// Gets the field number of the [`packed_bool`] field
    ///
    /// [`packed_bool`]: #method.packed_bool
    pub const PACKED_BOOL_FIELD_NUMBER: i32 = 102;
    pub fn packed_bool(&self) -> &::protrust::collections::RepeatedField<bool> {
        &self.packed_bool
    }
    /// Returns a unique reference to the [`packed_bool`] field
    ///
    /// [`packed_bool`]: #method.packed_bool
    pub fn packed_bool_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<bool> {
        &mut self.packed_bool
    }
    /// Gets the field number of the [`packed_enum`] field
    ///
    /// [`packed_enum`]: #method.packed_enum
    pub const PACKED_ENUM_FIELD_NUMBER: i32 = 103;
    pub fn packed_enum(&self) -> &::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>> {
        &self.packed_enum
    }
    /// Returns a unique reference to the [`packed_enum`] field
    ///
    /// [`packed_enum`]: #method.packed_enum
    pub fn packed_enum_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>> {
        &mut self.packed_enum
    }
}
/// A message with the same fields as TestPackedTypes, but without packing. Used
/// to test packed <-> unpacked wire compatibility.
#[derive(Clone, Debug, PartialEq)]
pub struct TestUnpackedTypes {
    unpacked_int32: ::protrust::collections::RepeatedField<i32>,
    unpacked_int64: ::protrust::collections::RepeatedField<i64>,
    unpacked_uint32: ::protrust::collections::RepeatedField<u32>,
    unpacked_uint64: ::protrust::collections::RepeatedField<u64>,
    unpacked_sint32: ::protrust::collections::RepeatedField<i32>,
    unpacked_sint64: ::protrust::collections::RepeatedField<i64>,
    unpacked_fixed32: ::protrust::collections::RepeatedField<u32>,
    unpacked_fixed64: ::protrust::collections::RepeatedField<u64>,
    unpacked_sfixed32: ::protrust::collections::RepeatedField<i32>,
    unpacked_sfixed64: ::protrust::collections::RepeatedField<i64>,
    unpacked_float: ::protrust::collections::RepeatedField<f32>,
    unpacked_double: ::protrust::collections::RepeatedField<f64>,
    unpacked_bool: ::protrust::collections::RepeatedField<bool>,
    unpacked_enum: ::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
static TEST_UNPACKED_TYPES_UNPACKED_INT32_CODEC: ::protrust::Codec<i32> = ::protrust::Codec::int32(720);
static TEST_UNPACKED_TYPES_UNPACKED_INT64_CODEC: ::protrust::Codec<i64> = ::protrust::Codec::int64(728);
static TEST_UNPACKED_TYPES_UNPACKED_UINT32_CODEC: ::protrust::Codec<u32> = ::protrust::Codec::uint32(736);
static TEST_UNPACKED_TYPES_UNPACKED_UINT64_CODEC: ::protrust::Codec<u64> = ::protrust::Codec::uint64(744);
static TEST_UNPACKED_TYPES_UNPACKED_SINT32_CODEC: ::protrust::Codec<i32> = ::protrust::Codec::sint32(752);
static TEST_UNPACKED_TYPES_UNPACKED_SINT64_CODEC: ::protrust::Codec<i64> = ::protrust::Codec::sint64(760);
static TEST_UNPACKED_TYPES_UNPACKED_FIXED32_CODEC: ::protrust::Codec<u32> = ::protrust::Codec::fixed32(773);
static TEST_UNPACKED_TYPES_UNPACKED_FIXED64_CODEC: ::protrust::Codec<u64> = ::protrust::Codec::fixed64(777);
static TEST_UNPACKED_TYPES_UNPACKED_SFIXED32_CODEC: ::protrust::Codec<i32> = ::protrust::Codec::sfixed32(789);
static TEST_UNPACKED_TYPES_UNPACKED_SFIXED64_CODEC: ::protrust::Codec<i64> = ::protrust::Codec::sfixed64(793);
static TEST_UNPACKED_TYPES_UNPACKED_FLOAT_CODEC: ::protrust::Codec<f32> = ::protrust::Codec::float(805);
static TEST_UNPACKED_TYPES_UNPACKED_DOUBLE_CODEC: ::protrust::Codec<f64> = ::protrust::Codec::double(809);
static TEST_UNPACKED_TYPES_UNPACKED_BOOL_CODEC: ::protrust::Codec<bool> = ::protrust::Codec::bool(816);
static TEST_UNPACKED_TYPES_UNPACKED_ENUM_CODEC: ::protrust::Codec<::protrust::EnumValue<self::ForeignEnum>> = ::protrust::Codec::enum_value(824);
impl ::protrust::CodedMessage for self::TestUnpackedTypes {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                720 | 722 => self.unpacked_int32.add_entries(input, &TEST_UNPACKED_TYPES_UNPACKED_INT32_CODEC)?,
                728 | 730 => self.unpacked_int64.add_entries(input, &TEST_UNPACKED_TYPES_UNPACKED_INT64_CODEC)?,
                736 | 738 => self.unpacked_uint32.add_entries(input, &TEST_UNPACKED_TYPES_UNPACKED_UINT32_CODEC)?,
                744 | 746 => self.unpacked_uint64.add_entries(input, &TEST_UNPACKED_TYPES_UNPACKED_UINT64_CODEC)?,
                752 | 754 => self.unpacked_sint32.add_entries(input, &TEST_UNPACKED_TYPES_UNPACKED_SINT32_CODEC)?,
                760 | 762 => self.unpacked_sint64.add_entries(input, &TEST_UNPACKED_TYPES_UNPACKED_SINT64_CODEC)?,
                773 | 770 => self.unpacked_fixed32.add_entries(input, &TEST_UNPACKED_TYPES_UNPACKED_FIXED32_CODEC)?,
                777 | 778 => self.unpacked_fixed64.add_entries(input, &TEST_UNPACKED_TYPES_UNPACKED_FIXED64_CODEC)?,
                789 | 786 => self.unpacked_sfixed32.add_entries(input, &TEST_UNPACKED_TYPES_UNPACKED_SFIXED32_CODEC)?,
                793 | 794 => self.unpacked_sfixed64.add_entries(input, &TEST_UNPACKED_TYPES_UNPACKED_SFIXED64_CODEC)?,
                805 | 802 => self.unpacked_float.add_entries(input, &TEST_UNPACKED_TYPES_UNPACKED_FLOAT_CODEC)?,
                809 | 810 => self.unpacked_double.add_entries(input, &TEST_UNPACKED_TYPES_UNPACKED_DOUBLE_CODEC)?,
                816 | 818 => self.unpacked_bool.add_entries(input, &TEST_UNPACKED_TYPES_UNPACKED_BOOL_CODEC)?,
                824 | 826 => self.unpacked_enum.add_entries(input, &TEST_UNPACKED_TYPES_UNPACKED_ENUM_CODEC)?,
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.unpacked_int32.calculate_size(&TEST_UNPACKED_TYPES_UNPACKED_INT32_CODEC);
        size += self.unpacked_int64.calculate_size(&TEST_UNPACKED_TYPES_UNPACKED_INT64_CODEC);
        size += self.unpacked_uint32.calculate_size(&TEST_UNPACKED_TYPES_UNPACKED_UINT32_CODEC);
        size += self.unpacked_uint64.calculate_size(&TEST_UNPACKED_TYPES_UNPACKED_UINT64_CODEC);
        size += self.unpacked_sint32.calculate_size(&TEST_UNPACKED_TYPES_UNPACKED_SINT32_CODEC);
        size += self.unpacked_sint64.calculate_size(&TEST_UNPACKED_TYPES_UNPACKED_SINT64_CODEC);
        size += self.unpacked_fixed32.calculate_size(&TEST_UNPACKED_TYPES_UNPACKED_FIXED32_CODEC);
        size += self.unpacked_fixed64.calculate_size(&TEST_UNPACKED_TYPES_UNPACKED_FIXED64_CODEC);
        size += self.unpacked_sfixed32.calculate_size(&TEST_UNPACKED_TYPES_UNPACKED_SFIXED32_CODEC);
        size += self.unpacked_sfixed64.calculate_size(&TEST_UNPACKED_TYPES_UNPACKED_SFIXED64_CODEC);
        size += self.unpacked_float.calculate_size(&TEST_UNPACKED_TYPES_UNPACKED_FLOAT_CODEC);
        size += self.unpacked_double.calculate_size(&TEST_UNPACKED_TYPES_UNPACKED_DOUBLE_CODEC);
        size += self.unpacked_bool.calculate_size(&TEST_UNPACKED_TYPES_UNPACKED_BOOL_CODEC);
        size += self.unpacked_enum.calculate_size(&TEST_UNPACKED_TYPES_UNPACKED_ENUM_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        self.unpacked_int32.write_to(output, &TEST_UNPACKED_TYPES_UNPACKED_INT32_CODEC)?;
        self.unpacked_int64.write_to(output, &TEST_UNPACKED_TYPES_UNPACKED_INT64_CODEC)?;
        self.unpacked_uint32.write_to(output, &TEST_UNPACKED_TYPES_UNPACKED_UINT32_CODEC)?;
        self.unpacked_uint64.write_to(output, &TEST_UNPACKED_TYPES_UNPACKED_UINT64_CODEC)?;
        self.unpacked_sint32.write_to(output, &TEST_UNPACKED_TYPES_UNPACKED_SINT32_CODEC)?;
        self.unpacked_sint64.write_to(output, &TEST_UNPACKED_TYPES_UNPACKED_SINT64_CODEC)?;
        self.unpacked_fixed32.write_to(output, &TEST_UNPACKED_TYPES_UNPACKED_FIXED32_CODEC)?;
        self.unpacked_fixed64.write_to(output, &TEST_UNPACKED_TYPES_UNPACKED_FIXED64_CODEC)?;
        self.unpacked_sfixed32.write_to(output, &TEST_UNPACKED_TYPES_UNPACKED_SFIXED32_CODEC)?;
        self.unpacked_sfixed64.write_to(output, &TEST_UNPACKED_TYPES_UNPACKED_SFIXED64_CODEC)?;
        self.unpacked_float.write_to(output, &TEST_UNPACKED_TYPES_UNPACKED_FLOAT_CODEC)?;
        self.unpacked_double.write_to(output, &TEST_UNPACKED_TYPES_UNPACKED_DOUBLE_CODEC)?;
        self.unpacked_bool.write_to(output, &TEST_UNPACKED_TYPES_UNPACKED_BOOL_CODEC)?;
        self.unpacked_enum.write_to(output, &TEST_UNPACKED_TYPES_UNPACKED_ENUM_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        true
    }
}
impl ::protrust::LiteMessage for self::TestUnpackedTypes {
    fn new() -> Self {
        Self {
            unpacked_int32: ::protrust::collections::RepeatedField::new(),
            unpacked_int64: ::protrust::collections::RepeatedField::new(),
            unpacked_uint32: ::protrust::collections::RepeatedField::new(),
            unpacked_uint64: ::protrust::collections::RepeatedField::new(),
            unpacked_sint32: ::protrust::collections::RepeatedField::new(),
            unpacked_sint64: ::protrust::collections::RepeatedField::new(),
            unpacked_fixed32: ::protrust::collections::RepeatedField::new(),
            unpacked_fixed64: ::protrust::collections::RepeatedField::new(),
            unpacked_sfixed32: ::protrust::collections::RepeatedField::new(),
            unpacked_sfixed64: ::protrust::collections::RepeatedField::new(),
            unpacked_float: ::protrust::collections::RepeatedField::new(),
            unpacked_double: ::protrust::collections::RepeatedField::new(),
            unpacked_bool: ::protrust::collections::RepeatedField::new(),
            unpacked_enum: ::protrust::collections::RepeatedField::new(),
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.unpacked_int32.merge(&other.unpacked_int32);
        self.unpacked_int64.merge(&other.unpacked_int64);
        self.unpacked_uint32.merge(&other.unpacked_uint32);
        self.unpacked_uint64.merge(&other.unpacked_uint64);
        self.unpacked_sint32.merge(&other.unpacked_sint32);
        self.unpacked_sint64.merge(&other.unpacked_sint64);
        self.unpacked_fixed32.merge(&other.unpacked_fixed32);
        self.unpacked_fixed64.merge(&other.unpacked_fixed64);
        self.unpacked_sfixed32.merge(&other.unpacked_sfixed32);
        self.unpacked_sfixed64.merge(&other.unpacked_sfixed64);
        self.unpacked_float.merge(&other.unpacked_float);
        self.unpacked_double.merge(&other.unpacked_double);
        self.unpacked_bool.merge(&other.unpacked_bool);
        self.unpacked_enum.merge(&other.unpacked_enum);
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestUnpackedTypes {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[48]
    }
}
impl self::TestUnpackedTypes {
    /// Gets the field number of the [`unpacked_int32`] field
    ///
    /// [`unpacked_int32`]: #method.unpacked_int32
    pub const UNPACKED_INT32_FIELD_NUMBER: i32 = 90;
    pub fn unpacked_int32(&self) -> &::protrust::collections::RepeatedField<i32> {
        &self.unpacked_int32
    }
    /// Returns a unique reference to the [`unpacked_int32`] field
    ///
    /// [`unpacked_int32`]: #method.unpacked_int32
    pub fn unpacked_int32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
        &mut self.unpacked_int32
    }
    /// Gets the field number of the [`unpacked_int64`] field
    ///
    /// [`unpacked_int64`]: #method.unpacked_int64
    pub const UNPACKED_INT64_FIELD_NUMBER: i32 = 91;
    pub fn unpacked_int64(&self) -> &::protrust::collections::RepeatedField<i64> {
        &self.unpacked_int64
    }
    /// Returns a unique reference to the [`unpacked_int64`] field
    ///
    /// [`unpacked_int64`]: #method.unpacked_int64
    pub fn unpacked_int64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
        &mut self.unpacked_int64
    }
    /// Gets the field number of the [`unpacked_uint32`] field
    ///
    /// [`unpacked_uint32`]: #method.unpacked_uint32
    pub const UNPACKED_UINT32_FIELD_NUMBER: i32 = 92;
    pub fn unpacked_uint32(&self) -> &::protrust::collections::RepeatedField<u32> {
        &self.unpacked_uint32
    }
    /// Returns a unique reference to the [`unpacked_uint32`] field
    ///
    /// [`unpacked_uint32`]: #method.unpacked_uint32
    pub fn unpacked_uint32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u32> {
        &mut self.unpacked_uint32
    }
    /// Gets the field number of the [`unpacked_uint64`] field
    ///
    /// [`unpacked_uint64`]: #method.unpacked_uint64
    pub const UNPACKED_UINT64_FIELD_NUMBER: i32 = 93;
    pub fn unpacked_uint64(&self) -> &::protrust::collections::RepeatedField<u64> {
        &self.unpacked_uint64
    }
    /// Returns a unique reference to the [`unpacked_uint64`] field
    ///
    /// [`unpacked_uint64`]: #method.unpacked_uint64
    pub fn unpacked_uint64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u64> {
        &mut self.unpacked_uint64
    }
    /// Gets the field number of the [`unpacked_sint32`] field
    ///
    /// [`unpacked_sint32`]: #method.unpacked_sint32
    pub const UNPACKED_SINT32_FIELD_NUMBER: i32 = 94;
    pub fn unpacked_sint32(&self) -> &::protrust::collections::RepeatedField<i32> {
        &self.unpacked_sint32
    }
    /// Returns a unique reference to the [`unpacked_sint32`] field
    ///
    /// [`unpacked_sint32`]: #method.unpacked_sint32
    pub fn unpacked_sint32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
        &mut self.unpacked_sint32
    }
    /// Gets the field number of the [`unpacked_sint64`] field
    ///
    /// [`unpacked_sint64`]: #method.unpacked_sint64
    pub const UNPACKED_SINT64_FIELD_NUMBER: i32 = 95;
    pub fn unpacked_sint64(&self) -> &::protrust::collections::RepeatedField<i64> {
        &self.unpacked_sint64
    }
    /// Returns a unique reference to the [`unpacked_sint64`] field
    ///
    /// [`unpacked_sint64`]: #method.unpacked_sint64
    pub fn unpacked_sint64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
        &mut self.unpacked_sint64
    }
    /// Gets the field number of the [`unpacked_fixed32`] field
    ///
    /// [`unpacked_fixed32`]: #method.unpacked_fixed32
    pub const UNPACKED_FIXED32_FIELD_NUMBER: i32 = 96;
    pub fn unpacked_fixed32(&self) -> &::protrust::collections::RepeatedField<u32> {
        &self.unpacked_fixed32
    }
    /// Returns a unique reference to the [`unpacked_fixed32`] field
    ///
    /// [`unpacked_fixed32`]: #method.unpacked_fixed32
    pub fn unpacked_fixed32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u32> {
        &mut self.unpacked_fixed32
    }
    /// Gets the field number of the [`unpacked_fixed64`] field
    ///
    /// [`unpacked_fixed64`]: #method.unpacked_fixed64
    pub const UNPACKED_FIXED64_FIELD_NUMBER: i32 = 97;
    pub fn unpacked_fixed64(&self) -> &::protrust::collections::RepeatedField<u64> {
        &self.unpacked_fixed64
    }
    /// Returns a unique reference to the [`unpacked_fixed64`] field
    ///
    /// [`unpacked_fixed64`]: #method.unpacked_fixed64
    pub fn unpacked_fixed64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u64> {
        &mut self.unpacked_fixed64
    }
    /// Gets the field number of the [`unpacked_sfixed32`] field
    ///
    /// [`unpacked_sfixed32`]: #method.unpacked_sfixed32
    pub const UNPACKED_SFIXED32_FIELD_NUMBER: i32 = 98;
    pub fn unpacked_sfixed32(&self) -> &::protrust::collections::RepeatedField<i32> {
        &self.unpacked_sfixed32
    }
    /// Returns a unique reference to the [`unpacked_sfixed32`] field
    ///
    /// [`unpacked_sfixed32`]: #method.unpacked_sfixed32
    pub fn unpacked_sfixed32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
        &mut self.unpacked_sfixed32
    }
    /// Gets the field number of the [`unpacked_sfixed64`] field
    ///
    /// [`unpacked_sfixed64`]: #method.unpacked_sfixed64
    pub const UNPACKED_SFIXED64_FIELD_NUMBER: i32 = 99;
    pub fn unpacked_sfixed64(&self) -> &::protrust::collections::RepeatedField<i64> {
        &self.unpacked_sfixed64
    }
    /// Returns a unique reference to the [`unpacked_sfixed64`] field
    ///
    /// [`unpacked_sfixed64`]: #method.unpacked_sfixed64
    pub fn unpacked_sfixed64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
        &mut self.unpacked_sfixed64
    }
    /// Gets the field number of the [`unpacked_float`] field
    ///
    /// [`unpacked_float`]: #method.unpacked_float
    pub const UNPACKED_FLOAT_FIELD_NUMBER: i32 = 100;
    pub fn unpacked_float(&self) -> &::protrust::collections::RepeatedField<f32> {
        &self.unpacked_float
    }
    /// Returns a unique reference to the [`unpacked_float`] field
    ///
    /// [`unpacked_float`]: #method.unpacked_float
    pub fn unpacked_float_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<f32> {
        &mut self.unpacked_float
    }
    /// Gets the field number of the [`unpacked_double`] field
    ///
    /// [`unpacked_double`]: #method.unpacked_double
    pub const UNPACKED_DOUBLE_FIELD_NUMBER: i32 = 101;
    pub fn unpacked_double(&self) -> &::protrust::collections::RepeatedField<f64> {
        &self.unpacked_double
    }
    /// Returns a unique reference to the [`unpacked_double`] field
    ///
    /// [`unpacked_double`]: #method.unpacked_double
    pub fn unpacked_double_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<f64> {
        &mut self.unpacked_double
    }
    /// Gets the field number of the [`unpacked_bool`] field
    ///
    /// [`unpacked_bool`]: #method.unpacked_bool
    pub const UNPACKED_BOOL_FIELD_NUMBER: i32 = 102;
    pub fn unpacked_bool(&self) -> &::protrust::collections::RepeatedField<bool> {
        &self.unpacked_bool
    }
    /// Returns a unique reference to the [`unpacked_bool`] field
    ///
    /// [`unpacked_bool`]: #method.unpacked_bool
    pub fn unpacked_bool_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<bool> {
        &mut self.unpacked_bool
    }
    /// Gets the field number of the [`unpacked_enum`] field
    ///
    /// [`unpacked_enum`]: #method.unpacked_enum
    pub const UNPACKED_ENUM_FIELD_NUMBER: i32 = 103;
    pub fn unpacked_enum(&self) -> &::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>> {
        &self.unpacked_enum
    }
    /// Returns a unique reference to the [`unpacked_enum`] field
    ///
    /// [`unpacked_enum`]: #method.unpacked_enum
    pub fn unpacked_enum_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>> {
        &mut self.unpacked_enum
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct TestPackedExtensions {
    unknown_fields: ::protrust::UnknownFieldSet,
    extensions: ::protrust::ExtensionSet<Self>,
}
impl ::protrust::CodedMessage for self::TestPackedExtensions {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        self.unknown_fields.write_to(output)?;
        self.extensions.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::TestPackedExtensions {
    fn new() -> Self {
        Self {
            unknown_fields: ::protrust::UnknownFieldSet::new(),
            extensions: ::protrust::ExtensionSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.unknown_fields.merge(&other.unknown_fields);
        self.extensions.merge(&other.extensions);
    }
}
impl ::protrust::ExtensionMessage for self::TestPackedExtensions {
    fn registry(&self) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> { self.extensions.registry() }
    fn replace_registry(&mut self, extensions: ::std::option::Option<&'static ::protrust::ExtensionRegistry>) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> { self.extensions.replace_registry(extensions) }
    fn field<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::cmp::PartialEq<D> + ::std::fmt::Debug + ::std::marker::Sync, D: ::std::fmt::Debug + ::std::marker::Sync>(&self, extension: &'static ::protrust::Extension<Self, V, D>) -> ::std::option::Option<&::protrust::ExtensionField<V, D>> { self.extensions.field(extension) }
    fn field_mut<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::cmp::PartialEq<D> + ::std::fmt::Debug + ::std::marker::Sync, D: ::std::fmt::Debug + ::std::marker::Sync>(&mut self, extension: &'static ::protrust::Extension<Self, V, D>) -> ::std::option::Option<&mut ::protrust::ExtensionField<V, D>> { self.extensions.field_mut(extension) }
    fn repeated_field<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::fmt::Debug + ::std::marker::Sync + 'static>(&self, extension: &'static ::protrust::RepeatedExtension<Self, V>) -> ::std::option::Option<&::protrust::collections::RepeatedField<V>> { self.extensions.repeated_field(extension) }
    fn repeated_field_mut<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::fmt::Debug + ::std::marker::Sync + 'static>(&mut self, extension: &'static ::protrust::RepeatedExtension<Self, V>) -> ::std::option::Option<&mut ::protrust::collections::RepeatedField<V>> { self.extensions.repeated_field_mut(extension) }
}
impl ::protrust::Message for self::TestPackedExtensions {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[49]
    }
}
impl self::TestPackedExtensions {
}
#[derive(Clone, Debug, PartialEq)]
pub struct TestUnpackedExtensions {
    unknown_fields: ::protrust::UnknownFieldSet,
    extensions: ::protrust::ExtensionSet<Self>,
}
impl ::protrust::CodedMessage for self::TestUnpackedExtensions {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        self.unknown_fields.write_to(output)?;
        self.extensions.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::TestUnpackedExtensions {
    fn new() -> Self {
        Self {
            unknown_fields: ::protrust::UnknownFieldSet::new(),
            extensions: ::protrust::ExtensionSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.unknown_fields.merge(&other.unknown_fields);
        self.extensions.merge(&other.extensions);
    }
}
impl ::protrust::ExtensionMessage for self::TestUnpackedExtensions {
    fn registry(&self) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> { self.extensions.registry() }
    fn replace_registry(&mut self, extensions: ::std::option::Option<&'static ::protrust::ExtensionRegistry>) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> { self.extensions.replace_registry(extensions) }
    fn field<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::cmp::PartialEq<D> + ::std::fmt::Debug + ::std::marker::Sync, D: ::std::fmt::Debug + ::std::marker::Sync>(&self, extension: &'static ::protrust::Extension<Self, V, D>) -> ::std::option::Option<&::protrust::ExtensionField<V, D>> { self.extensions.field(extension) }
    fn field_mut<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::cmp::PartialEq<D> + ::std::fmt::Debug + ::std::marker::Sync, D: ::std::fmt::Debug + ::std::marker::Sync>(&mut self, extension: &'static ::protrust::Extension<Self, V, D>) -> ::std::option::Option<&mut ::protrust::ExtensionField<V, D>> { self.extensions.field_mut(extension) }
    fn repeated_field<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::fmt::Debug + ::std::marker::Sync + 'static>(&self, extension: &'static ::protrust::RepeatedExtension<Self, V>) -> ::std::option::Option<&::protrust::collections::RepeatedField<V>> { self.extensions.repeated_field(extension) }
    fn repeated_field_mut<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::fmt::Debug + ::std::marker::Sync + 'static>(&mut self, extension: &'static ::protrust::RepeatedExtension<Self, V>) -> ::std::option::Option<&mut ::protrust::collections::RepeatedField<V>> { self.extensions.repeated_field_mut(extension) }
}
impl ::protrust::Message for self::TestUnpackedExtensions {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[50]
    }
}
impl self::TestUnpackedExtensions {
}
/// Used by ExtensionSetTest/DynamicExtensions.  The test actually builds
/// a set of extensions to TestAllExtensions dynamically, based on the fields
/// of this message type.
#[derive(Clone, Debug, PartialEq)]
pub struct TestDynamicExtensions {
    scalar_extension: ::std::option::Option<u32>,
    enum_extension: ::std::option::Option<::protrust::EnumValue<self::ForeignEnum>>,
    dynamic_enum_extension: ::std::option::Option<::protrust::EnumValue<self::test_dynamic_extensions::DynamicEnumType>>,
    message_extension: ::std::option::Option<::std::boxed::Box<self::ForeignMessage>>,
    dynamic_message_extension: ::std::option::Option<::std::boxed::Box<self::test_dynamic_extensions::DynamicMessageType>>,
    repeated_extension: ::protrust::collections::RepeatedField<::std::string::String>,
    packed_extension: ::protrust::collections::RepeatedField<i32>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
static TEST_DYNAMIC_EXTENSIONS_REPEATED_EXTENSION_CODEC: ::protrust::Codec<::std::string::String> = ::protrust::Codec::string(16042);
static TEST_DYNAMIC_EXTENSIONS_PACKED_EXTENSION_CODEC: ::protrust::Codec<i32> = ::protrust::Codec::sint32(16050);
impl ::protrust::CodedMessage for self::TestDynamicExtensions {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                16005 | 16002 => self.scalar_extension = ::std::option::Option::Some(input.read_fixed32()?),
                16008 | 16010 => self.enum_extension = ::std::option::Option::Some(input.read_enum_value()?),
                16016 | 16018 => self.dynamic_enum_extension = ::std::option::Option::Some(input.read_enum_value()?),
                16026 => input.read_message(&mut **self.message_extension.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                16034 => input.read_message(&mut **self.dynamic_message_extension.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                16042 => self.repeated_extension.add_entries(input, &TEST_DYNAMIC_EXTENSIONS_REPEATED_EXTENSION_CODEC)?,
                16048 | 16050 => self.packed_extension.add_entries(input, &TEST_DYNAMIC_EXTENSIONS_PACKED_EXTENSION_CODEC)?,
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let scalar_extension = self.scalar_extension;
        if let ::std::option::Option::Some(scalar_extension) = scalar_extension {
            size += 2;
            size += ::protrust::io::sizes::fixed32(scalar_extension);
        }
        let enum_extension = self.enum_extension;
        if let ::std::option::Option::Some(enum_extension) = enum_extension {
            size += 2;
            size += ::protrust::io::sizes::enum_value(enum_extension);
        }
        let dynamic_enum_extension = self.dynamic_enum_extension;
        if let ::std::option::Option::Some(dynamic_enum_extension) = dynamic_enum_extension {
            size += 2;
            size += ::protrust::io::sizes::enum_value(dynamic_enum_extension);
        }
        let message_extension = &self.message_extension;
        if let ::std::option::Option::Some(message_extension) = message_extension {
            size += 2;
            size += ::protrust::io::sizes::message(&**message_extension);
        }
        let dynamic_message_extension = &self.dynamic_message_extension;
        if let ::std::option::Option::Some(dynamic_message_extension) = dynamic_message_extension {
            size += 2;
            size += ::protrust::io::sizes::message(&**dynamic_message_extension);
        }
        size += self.repeated_extension.calculate_size(&TEST_DYNAMIC_EXTENSIONS_REPEATED_EXTENSION_CODEC);
        size += self.packed_extension.calculate_size(&TEST_DYNAMIC_EXTENSIONS_PACKED_EXTENSION_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let scalar_extension = self.scalar_extension;
        if let ::std::option::Option::Some(scalar_extension) = scalar_extension {
            output.write_raw_tag_bytes(&[133, 125])?;
            output.write_fixed32(scalar_extension)?;
        }
        let enum_extension = self.enum_extension;
        if let ::std::option::Option::Some(enum_extension) = enum_extension {
            output.write_raw_tag_bytes(&[136, 125])?;
            output.write_enum_value(enum_extension)?;
        }
        let dynamic_enum_extension = self.dynamic_enum_extension;
        if let ::std::option::Option::Some(dynamic_enum_extension) = dynamic_enum_extension {
            output.write_raw_tag_bytes(&[144, 125])?;
            output.write_enum_value(dynamic_enum_extension)?;
        }
        let message_extension = &self.message_extension;
        if let ::std::option::Option::Some(message_extension) = message_extension {
            output.write_raw_tag_bytes(&[154, 125])?;
            output.write_message(&**message_extension)?;
        }
        let dynamic_message_extension = &self.dynamic_message_extension;
        if let ::std::option::Option::Some(dynamic_message_extension) = dynamic_message_extension {
            output.write_raw_tag_bytes(&[162, 125])?;
            output.write_message(&**dynamic_message_extension)?;
        }
        self.repeated_extension.write_to(output, &TEST_DYNAMIC_EXTENSIONS_REPEATED_EXTENSION_CODEC)?;
        self.packed_extension.write_to(output, &TEST_DYNAMIC_EXTENSIONS_PACKED_EXTENSION_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        if let Some(message_extension) = &self.message_extension {
            if !::protrust::CodedMessage::is_initialized(&**message_extension) {
                return false;
            }
        }
        if let Some(dynamic_message_extension) = &self.dynamic_message_extension {
            if !::protrust::CodedMessage::is_initialized(&**dynamic_message_extension) {
                return false;
            }
        }
        true
    }
}
impl ::protrust::LiteMessage for self::TestDynamicExtensions {
    fn new() -> Self {
        Self {
            scalar_extension: ::std::option::Option::None,
            enum_extension: ::std::option::Option::None,
            dynamic_enum_extension: ::std::option::Option::None,
            message_extension: ::std::option::Option::None,
            dynamic_message_extension: ::std::option::Option::None,
            repeated_extension: ::protrust::collections::RepeatedField::new(),
            packed_extension: ::protrust::collections::RepeatedField::new(),
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.scalar_extension = other.scalar_extension;
        self.enum_extension = other.enum_extension;
        self.dynamic_enum_extension = other.dynamic_enum_extension;
        if let ::std::option::Option::Some(message_extension) = &other.message_extension {
            self.message_extension.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(message_extension);
        }
        if let ::std::option::Option::Some(dynamic_message_extension) = &other.dynamic_message_extension {
            self.dynamic_message_extension.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(dynamic_message_extension);
        }
        self.repeated_extension.merge(&other.repeated_extension);
        self.packed_extension.merge(&other.packed_extension);
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestDynamicExtensions {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[51]
    }
}
impl self::TestDynamicExtensions {
    /// Gets the field number of the [`scalar_extension`] field
    ///
    /// [`scalar_extension`]: #method.scalar_extension
    pub const SCALAR_EXTENSION_FIELD_NUMBER: i32 = 2000;
    /// A constant value representing the default value of the [`scalar_extension`] field
    ///
    /// [`scalar_extension`]: #method.scalar_extension
    pub const SCALAR_EXTENSION_DEFAULT_VALUE: u32 = 0;
    pub fn scalar_extension(&self) -> u32 {
        self.scalar_extension.unwrap_or(Self::SCALAR_EXTENSION_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`scalar_extension`] field
    ///
    /// [`scalar_extension`]: #method.scalar_extension
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn scalar_extension_option(&self) -> ::std::option::Option<u32> {
        self.scalar_extension
    }
    /// Returns a bool indicating the presence of the [`scalar_extension`] field
    ///
    /// [`scalar_extension`]: #method.scalar_extension
    pub fn has_scalar_extension(&self) -> bool {
        self.scalar_extension.is_some()
    }
    /// Sets the value of the [`scalar_extension`] field
    ///
    /// [`scalar_extension`]: #method.scalar_extension
    pub fn set_scalar_extension(&mut self, value: u32) {
        self.scalar_extension = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`scalar_extension`] field
    ///
    /// [`scalar_extension`]: #method.scalar_extension
    pub fn clear_scalar_extension(&mut self) {
        self.scalar_extension = ::std::option::Option::None
    }
    /// Gets the field number of the [`enum_extension`] field
    ///
    /// [`enum_extension`]: #method.enum_extension
    pub const ENUM_EXTENSION_FIELD_NUMBER: i32 = 2001;
    /// A constant value representing the default value of the [`enum_extension`] field
    ///
    /// [`enum_extension`]: #method.enum_extension
    pub const ENUM_EXTENSION_DEFAULT_VALUE: ::protrust::EnumValue<self::ForeignEnum> = ::protrust::EnumValue::Undefined(0);
    pub fn enum_extension(&self) -> ::protrust::EnumValue<self::ForeignEnum> {
        self.enum_extension.unwrap_or(Self::ENUM_EXTENSION_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`enum_extension`] field
    ///
    /// [`enum_extension`]: #method.enum_extension
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn enum_extension_option(&self) -> ::std::option::Option<::protrust::EnumValue<self::ForeignEnum>> {
        self.enum_extension
    }
    /// Returns a bool indicating the presence of the [`enum_extension`] field
    ///
    /// [`enum_extension`]: #method.enum_extension
    pub fn has_enum_extension(&self) -> bool {
        self.enum_extension.is_some()
    }
    /// Sets the value of the [`enum_extension`] field
    ///
    /// [`enum_extension`]: #method.enum_extension
    pub fn set_enum_extension(&mut self, value: ::protrust::EnumValue<self::ForeignEnum>) {
        self.enum_extension = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`enum_extension`] field
    ///
    /// [`enum_extension`]: #method.enum_extension
    pub fn clear_enum_extension(&mut self) {
        self.enum_extension = ::std::option::Option::None
    }
    /// Gets the field number of the [`dynamic_enum_extension`] field
    ///
    /// [`dynamic_enum_extension`]: #method.dynamic_enum_extension
    pub const DYNAMIC_ENUM_EXTENSION_FIELD_NUMBER: i32 = 2002;
    /// A constant value representing the default value of the [`dynamic_enum_extension`] field
    ///
    /// [`dynamic_enum_extension`]: #method.dynamic_enum_extension
    pub const DYNAMIC_ENUM_EXTENSION_DEFAULT_VALUE: ::protrust::EnumValue<self::test_dynamic_extensions::DynamicEnumType> = ::protrust::EnumValue::Undefined(0);
    pub fn dynamic_enum_extension(&self) -> ::protrust::EnumValue<self::test_dynamic_extensions::DynamicEnumType> {
        self.dynamic_enum_extension.unwrap_or(Self::DYNAMIC_ENUM_EXTENSION_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`dynamic_enum_extension`] field
    ///
    /// [`dynamic_enum_extension`]: #method.dynamic_enum_extension
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn dynamic_enum_extension_option(&self) -> ::std::option::Option<::protrust::EnumValue<self::test_dynamic_extensions::DynamicEnumType>> {
        self.dynamic_enum_extension
    }
    /// Returns a bool indicating the presence of the [`dynamic_enum_extension`] field
    ///
    /// [`dynamic_enum_extension`]: #method.dynamic_enum_extension
    pub fn has_dynamic_enum_extension(&self) -> bool {
        self.dynamic_enum_extension.is_some()
    }
    /// Sets the value of the [`dynamic_enum_extension`] field
    ///
    /// [`dynamic_enum_extension`]: #method.dynamic_enum_extension
    pub fn set_dynamic_enum_extension(&mut self, value: ::protrust::EnumValue<self::test_dynamic_extensions::DynamicEnumType>) {
        self.dynamic_enum_extension = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`dynamic_enum_extension`] field
    ///
    /// [`dynamic_enum_extension`]: #method.dynamic_enum_extension
    pub fn clear_dynamic_enum_extension(&mut self) {
        self.dynamic_enum_extension = ::std::option::Option::None
    }
    /// Gets the field number of the [`message_extension`] field
    ///
    /// [`message_extension`]: #method.message_extension
    pub const MESSAGE_EXTENSION_FIELD_NUMBER: i32 = 2003;
    pub fn message_extension_option(&self) -> ::std::option::Option<&self::ForeignMessage> {
        self.message_extension.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`message_extension`] field
    ///
    /// [`message_extension`]: #method.message_extension
    pub fn message_extension_mut(&mut self) -> &mut self::ForeignMessage {
        self.message_extension.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`message_extension`] field
    ///
    /// [`message_extension`]: #method.message_extension
    pub fn has_message_extension(&self) -> bool {
        self.message_extension.is_some()
    }
    /// Sets the value of the [`message_extension`] field
    ///
    /// [`message_extension`]: #method.message_extension
    pub fn set_message_extension(&mut self, value: self::ForeignMessage) {
        self.message_extension = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`message_extension`] field, leaving it empty
    ///
    /// [`message_extension`]: #method.message_extension
    pub fn take_message_extension(&mut self) -> ::std::option::Option<self::ForeignMessage> {
        self.message_extension.take().map(|b| *b)
    }
    /// Clears the value of the [`message_extension`] field
    ///
    /// [`message_extension`]: #method.message_extension
    pub fn clear_message_extension(&mut self) {
        self.message_extension = ::std::option::Option::None
    }
    /// Gets the field number of the [`dynamic_message_extension`] field
    ///
    /// [`dynamic_message_extension`]: #method.dynamic_message_extension
    pub const DYNAMIC_MESSAGE_EXTENSION_FIELD_NUMBER: i32 = 2004;
    pub fn dynamic_message_extension_option(&self) -> ::std::option::Option<&self::test_dynamic_extensions::DynamicMessageType> {
        self.dynamic_message_extension.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`dynamic_message_extension`] field
    ///
    /// [`dynamic_message_extension`]: #method.dynamic_message_extension
    pub fn dynamic_message_extension_mut(&mut self) -> &mut self::test_dynamic_extensions::DynamicMessageType {
        self.dynamic_message_extension.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`dynamic_message_extension`] field
    ///
    /// [`dynamic_message_extension`]: #method.dynamic_message_extension
    pub fn has_dynamic_message_extension(&self) -> bool {
        self.dynamic_message_extension.is_some()
    }
    /// Sets the value of the [`dynamic_message_extension`] field
    ///
    /// [`dynamic_message_extension`]: #method.dynamic_message_extension
    pub fn set_dynamic_message_extension(&mut self, value: self::test_dynamic_extensions::DynamicMessageType) {
        self.dynamic_message_extension = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`dynamic_message_extension`] field, leaving it empty
    ///
    /// [`dynamic_message_extension`]: #method.dynamic_message_extension
    pub fn take_dynamic_message_extension(&mut self) -> ::std::option::Option<self::test_dynamic_extensions::DynamicMessageType> {
        self.dynamic_message_extension.take().map(|b| *b)
    }
    /// Clears the value of the [`dynamic_message_extension`] field
    ///
    /// [`dynamic_message_extension`]: #method.dynamic_message_extension
    pub fn clear_dynamic_message_extension(&mut self) {
        self.dynamic_message_extension = ::std::option::Option::None
    }
    /// Gets the field number of the [`repeated_extension`] field
    ///
    /// [`repeated_extension`]: #method.repeated_extension
    pub const REPEATED_EXTENSION_FIELD_NUMBER: i32 = 2005;
    pub fn repeated_extension(&self) -> &::protrust::collections::RepeatedField<::std::string::String> {
        &self.repeated_extension
    }
    /// Returns a unique reference to the [`repeated_extension`] field
    ///
    /// [`repeated_extension`]: #method.repeated_extension
    pub fn repeated_extension_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<::std::string::String> {
        &mut self.repeated_extension
    }
    /// Gets the field number of the [`packed_extension`] field
    ///
    /// [`packed_extension`]: #method.packed_extension
    pub const PACKED_EXTENSION_FIELD_NUMBER: i32 = 2006;
    pub fn packed_extension(&self) -> &::protrust::collections::RepeatedField<i32> {
        &self.packed_extension
    }
    /// Returns a unique reference to the [`packed_extension`] field
    ///
    /// [`packed_extension`]: #method.packed_extension
    pub fn packed_extension_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
        &mut self.packed_extension
    }
}
/// Used by ExtensionSetTest/DynamicExtensions.  The test actually builds
/// a set of extensions to TestAllExtensions dynamically, based on the fields
/// of this message type.
pub mod test_dynamic_extensions {
    #[derive(Clone, Debug, PartialEq)]
    pub struct DynamicMessageType {
        dynamic_field: ::std::option::Option<i32>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::DynamicMessageType {
        fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    16800 | 16802 => self.dynamic_field = ::std::option::Option::Some(input.read_int32()?),
                    _ => self.unknown_fields.merge_from(tag, input)?
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            let dynamic_field = self.dynamic_field;
            if let ::std::option::Option::Some(dynamic_field) = dynamic_field {
                size += 3;
                size += ::protrust::io::sizes::int32(dynamic_field);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
            let dynamic_field = self.dynamic_field;
            if let ::std::option::Option::Some(dynamic_field) = dynamic_field {
                output.write_raw_tag_bytes(&[160, 131, 1])?;
                output.write_int32(dynamic_field)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
    }
    impl ::protrust::LiteMessage for self::DynamicMessageType {
        fn new() -> Self {
            Self {
                dynamic_field: ::std::option::Option::None,
                unknown_fields: ::protrust::UnknownFieldSet::new(),
            }
        }
        fn merge(&mut self, other: &Self) {
            self.dynamic_field = other.dynamic_field;
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::DynamicMessageType {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
            &self::super::file().messages()[51].messages()[0]
        }
    }
    impl self::DynamicMessageType {
        /// Gets the field number of the [`dynamic_field`] field
        ///
        /// [`dynamic_field`]: #method.dynamic_field
        pub const DYNAMIC_FIELD_FIELD_NUMBER: i32 = 2100;
        /// A constant value representing the default value of the [`dynamic_field`] field
        ///
        /// [`dynamic_field`]: #method.dynamic_field
        pub const DYNAMIC_FIELD_DEFAULT_VALUE: i32 = 0;
        pub fn dynamic_field(&self) -> i32 {
            self.dynamic_field.unwrap_or(Self::DYNAMIC_FIELD_DEFAULT_VALUE)
        }
        /// Returns an [`Option`] representing the presence of the [`dynamic_field`] field
        ///
        /// [`dynamic_field`]: #method.dynamic_field
        /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
        pub fn dynamic_field_option(&self) -> ::std::option::Option<i32> {
            self.dynamic_field
        }
        /// Returns a bool indicating the presence of the [`dynamic_field`] field
        ///
        /// [`dynamic_field`]: #method.dynamic_field
        pub fn has_dynamic_field(&self) -> bool {
            self.dynamic_field.is_some()
        }
        /// Sets the value of the [`dynamic_field`] field
        ///
        /// [`dynamic_field`]: #method.dynamic_field
        pub fn set_dynamic_field(&mut self, value: i32) {
            self.dynamic_field = ::std::option::Option::Some(value)
        }
        /// Clears the value of the [`dynamic_field`] field
        ///
        /// [`dynamic_field`]: #method.dynamic_field
        pub fn clear_dynamic_field(&mut self) {
            self.dynamic_field = ::std::option::Option::None
        }
    }
    #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
    pub enum DynamicEnumType {
        DynamicFoo,
        DynamicBar,
        DynamicBaz,
    }
    unsafe impl ::protrust::Enum for self::DynamicEnumType { }
    impl ::std::convert::TryFrom<i32> for self::DynamicEnumType {
        type Error = ::protrust::VariantUndefinedError;
        fn try_from(value: i32) -> ::std::result::Result<Self, ::protrust::VariantUndefinedError> {
            #[allow(unreachable_patterns)]
            match value {
                2200 => ::std::result::Result::Ok(self::DynamicEnumType::DynamicFoo),
                2201 => ::std::result::Result::Ok(self::DynamicEnumType::DynamicBar),
                2202 => ::std::result::Result::Ok(self::DynamicEnumType::DynamicBaz),
                _ => ::std::result::Result::Err(::protrust::VariantUndefinedError)
            }
        }
    }
    impl ::std::convert::From<self::DynamicEnumType> for i32 {
        fn from(value: self::DynamicEnumType) -> i32 {
            match value {
                DynamicEnumType::DynamicFoo => 2200,
                DynamicEnumType::DynamicBar => 2201,
                DynamicEnumType::DynamicBaz => 2202,
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct TestRepeatedScalarDifferentTagSizes {
    repeated_fixed32: ::protrust::collections::RepeatedField<u32>,
    repeated_int32: ::protrust::collections::RepeatedField<i32>,
    repeated_fixed64: ::protrust::collections::RepeatedField<u64>,
    repeated_int64: ::protrust::collections::RepeatedField<i64>,
    repeated_float: ::protrust::collections::RepeatedField<f32>,
    repeated_uint64: ::protrust::collections::RepeatedField<u64>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
static TEST_REPEATED_SCALAR_DIFFERENT_TAG_SIZES_REPEATED_FIXED32_CODEC: ::protrust::Codec<u32> = ::protrust::Codec::fixed32(101);
static TEST_REPEATED_SCALAR_DIFFERENT_TAG_SIZES_REPEATED_INT32_CODEC: ::protrust::Codec<i32> = ::protrust::Codec::int32(104);
static TEST_REPEATED_SCALAR_DIFFERENT_TAG_SIZES_REPEATED_FIXED64_CODEC: ::protrust::Codec<u64> = ::protrust::Codec::fixed64(16369);
static TEST_REPEATED_SCALAR_DIFFERENT_TAG_SIZES_REPEATED_INT64_CODEC: ::protrust::Codec<i64> = ::protrust::Codec::int64(16376);
static TEST_REPEATED_SCALAR_DIFFERENT_TAG_SIZES_REPEATED_FLOAT_CODEC: ::protrust::Codec<f32> = ::protrust::Codec::float(2097141);
static TEST_REPEATED_SCALAR_DIFFERENT_TAG_SIZES_REPEATED_UINT64_CODEC: ::protrust::Codec<u64> = ::protrust::Codec::uint64(2097144);
impl ::protrust::CodedMessage for self::TestRepeatedScalarDifferentTagSizes {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                101 | 98 => self.repeated_fixed32.add_entries(input, &TEST_REPEATED_SCALAR_DIFFERENT_TAG_SIZES_REPEATED_FIXED32_CODEC)?,
                104 | 106 => self.repeated_int32.add_entries(input, &TEST_REPEATED_SCALAR_DIFFERENT_TAG_SIZES_REPEATED_INT32_CODEC)?,
                16369 | 16370 => self.repeated_fixed64.add_entries(input, &TEST_REPEATED_SCALAR_DIFFERENT_TAG_SIZES_REPEATED_FIXED64_CODEC)?,
                16376 | 16378 => self.repeated_int64.add_entries(input, &TEST_REPEATED_SCALAR_DIFFERENT_TAG_SIZES_REPEATED_INT64_CODEC)?,
                2097141 | 2097138 => self.repeated_float.add_entries(input, &TEST_REPEATED_SCALAR_DIFFERENT_TAG_SIZES_REPEATED_FLOAT_CODEC)?,
                2097144 | 2097146 => self.repeated_uint64.add_entries(input, &TEST_REPEATED_SCALAR_DIFFERENT_TAG_SIZES_REPEATED_UINT64_CODEC)?,
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.repeated_fixed32.calculate_size(&TEST_REPEATED_SCALAR_DIFFERENT_TAG_SIZES_REPEATED_FIXED32_CODEC);
        size += self.repeated_int32.calculate_size(&TEST_REPEATED_SCALAR_DIFFERENT_TAG_SIZES_REPEATED_INT32_CODEC);
        size += self.repeated_fixed64.calculate_size(&TEST_REPEATED_SCALAR_DIFFERENT_TAG_SIZES_REPEATED_FIXED64_CODEC);
        size += self.repeated_int64.calculate_size(&TEST_REPEATED_SCALAR_DIFFERENT_TAG_SIZES_REPEATED_INT64_CODEC);
        size += self.repeated_float.calculate_size(&TEST_REPEATED_SCALAR_DIFFERENT_TAG_SIZES_REPEATED_FLOAT_CODEC);
        size += self.repeated_uint64.calculate_size(&TEST_REPEATED_SCALAR_DIFFERENT_TAG_SIZES_REPEATED_UINT64_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        self.repeated_fixed32.write_to(output, &TEST_REPEATED_SCALAR_DIFFERENT_TAG_SIZES_REPEATED_FIXED32_CODEC)?;
        self.repeated_int32.write_to(output, &TEST_REPEATED_SCALAR_DIFFERENT_TAG_SIZES_REPEATED_INT32_CODEC)?;
        self.repeated_fixed64.write_to(output, &TEST_REPEATED_SCALAR_DIFFERENT_TAG_SIZES_REPEATED_FIXED64_CODEC)?;
        self.repeated_int64.write_to(output, &TEST_REPEATED_SCALAR_DIFFERENT_TAG_SIZES_REPEATED_INT64_CODEC)?;
        self.repeated_float.write_to(output, &TEST_REPEATED_SCALAR_DIFFERENT_TAG_SIZES_REPEATED_FLOAT_CODEC)?;
        self.repeated_uint64.write_to(output, &TEST_REPEATED_SCALAR_DIFFERENT_TAG_SIZES_REPEATED_UINT64_CODEC)?;
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        true
    }
}
impl ::protrust::LiteMessage for self::TestRepeatedScalarDifferentTagSizes {
    fn new() -> Self {
        Self {
            repeated_fixed32: ::protrust::collections::RepeatedField::new(),
            repeated_int32: ::protrust::collections::RepeatedField::new(),
            repeated_fixed64: ::protrust::collections::RepeatedField::new(),
            repeated_int64: ::protrust::collections::RepeatedField::new(),
            repeated_float: ::protrust::collections::RepeatedField::new(),
            repeated_uint64: ::protrust::collections::RepeatedField::new(),
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.repeated_fixed32.merge(&other.repeated_fixed32);
        self.repeated_int32.merge(&other.repeated_int32);
        self.repeated_fixed64.merge(&other.repeated_fixed64);
        self.repeated_int64.merge(&other.repeated_int64);
        self.repeated_float.merge(&other.repeated_float);
        self.repeated_uint64.merge(&other.repeated_uint64);
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestRepeatedScalarDifferentTagSizes {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[52]
    }
}
impl self::TestRepeatedScalarDifferentTagSizes {
    /// Gets the field number of the [`repeated_fixed32`] field
    ///
    /// [`repeated_fixed32`]: #method.repeated_fixed32
    pub const REPEATED_FIXED32_FIELD_NUMBER: i32 = 12;
    /// Parsing repeated fixed size values used to fail. This message needs to be
    /// used in order to get a tag of the right size; all of the repeated fields
    /// in TestAllTypes didn't trigger the check.
    pub fn repeated_fixed32(&self) -> &::protrust::collections::RepeatedField<u32> {
        &self.repeated_fixed32
    }
    /// Returns a unique reference to the [`repeated_fixed32`] field
    ///
    /// [`repeated_fixed32`]: #method.repeated_fixed32
    pub fn repeated_fixed32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u32> {
        &mut self.repeated_fixed32
    }
    /// Gets the field number of the [`repeated_int32`] field
    ///
    /// [`repeated_int32`]: #method.repeated_int32
    pub const REPEATED_INT32_FIELD_NUMBER: i32 = 13;
    /// Check for a varint type, just for good measure.
    pub fn repeated_int32(&self) -> &::protrust::collections::RepeatedField<i32> {
        &self.repeated_int32
    }
    /// Returns a unique reference to the [`repeated_int32`] field
    ///
    /// [`repeated_int32`]: #method.repeated_int32
    pub fn repeated_int32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
        &mut self.repeated_int32
    }
    /// Gets the field number of the [`repeated_fixed64`] field
    ///
    /// [`repeated_fixed64`]: #method.repeated_fixed64
    pub const REPEATED_FIXED64_FIELD_NUMBER: i32 = 2046;
    /// These have two-byte tags.
    pub fn repeated_fixed64(&self) -> &::protrust::collections::RepeatedField<u64> {
        &self.repeated_fixed64
    }
    /// Returns a unique reference to the [`repeated_fixed64`] field
    ///
    /// [`repeated_fixed64`]: #method.repeated_fixed64
    pub fn repeated_fixed64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u64> {
        &mut self.repeated_fixed64
    }
    /// Gets the field number of the [`repeated_int64`] field
    ///
    /// [`repeated_int64`]: #method.repeated_int64
    pub const REPEATED_INT64_FIELD_NUMBER: i32 = 2047;
    pub fn repeated_int64(&self) -> &::protrust::collections::RepeatedField<i64> {
        &self.repeated_int64
    }
    /// Returns a unique reference to the [`repeated_int64`] field
    ///
    /// [`repeated_int64`]: #method.repeated_int64
    pub fn repeated_int64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
        &mut self.repeated_int64
    }
    /// Gets the field number of the [`repeated_float`] field
    ///
    /// [`repeated_float`]: #method.repeated_float
    pub const REPEATED_FLOAT_FIELD_NUMBER: i32 = 262142;
    /// Three byte tags.
    pub fn repeated_float(&self) -> &::protrust::collections::RepeatedField<f32> {
        &self.repeated_float
    }
    /// Returns a unique reference to the [`repeated_float`] field
    ///
    /// [`repeated_float`]: #method.repeated_float
    pub fn repeated_float_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<f32> {
        &mut self.repeated_float
    }
    /// Gets the field number of the [`repeated_uint64`] field
    ///
    /// [`repeated_uint64`]: #method.repeated_uint64
    pub const REPEATED_UINT64_FIELD_NUMBER: i32 = 262143;
    pub fn repeated_uint64(&self) -> &::protrust::collections::RepeatedField<u64> {
        &self.repeated_uint64
    }
    /// Returns a unique reference to the [`repeated_uint64`] field
    ///
    /// [`repeated_uint64`]: #method.repeated_uint64
    pub fn repeated_uint64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u64> {
        &mut self.repeated_uint64
    }
}
/// Test that if an optional or required message/group field appears multiple
/// times in the input, they need to be merged.
#[derive(Clone, Debug, PartialEq)]
pub struct TestParsingMerge {
    required_all_types: ::std::option::Option<::std::boxed::Box<self::TestAllTypes>>,
    optional_all_types: ::std::option::Option<::std::boxed::Box<self::TestAllTypes>>,
    repeated_all_types: ::protrust::collections::RepeatedField<self::TestAllTypes>,
    optionalgroup: ::std::option::Option<::std::boxed::Box<self::test_parsing_merge::OptionalGroup>>,
    repeatedgroup: ::protrust::collections::RepeatedField<self::test_parsing_merge::RepeatedGroup>,
    unknown_fields: ::protrust::UnknownFieldSet,
    extensions: ::protrust::ExtensionSet<Self>,
}
static TEST_PARSING_MERGE_REPEATED_ALL_TYPES_CODEC: ::protrust::Codec<self::TestAllTypes> = ::protrust::Codec::message(26);
static TEST_PARSING_MERGE_REPEATEDGROUP_CODEC: ::protrust::Codec<self::test_parsing_merge::RepeatedGroup> = ::protrust::Codec::group(163, 164);
impl ::protrust::CodedMessage for self::TestParsingMerge {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => input.read_message(&mut **self.required_all_types.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                18 => input.read_message(&mut **self.optional_all_types.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                26 => self.repeated_all_types.add_entries(input, &TEST_PARSING_MERGE_REPEATED_ALL_TYPES_CODEC)?,
                83 => input.read_group(&mut **self.optionalgroup.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                163 => self.repeatedgroup.add_entries(input, &TEST_PARSING_MERGE_REPEATEDGROUP_CODEC)?,
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let required_all_types = &self.required_all_types;
        if let ::std::option::Option::Some(required_all_types) = required_all_types {
            size += 1;
            size += ::protrust::io::sizes::message(&**required_all_types);
        }
        let optional_all_types = &self.optional_all_types;
        if let ::std::option::Option::Some(optional_all_types) = optional_all_types {
            size += 1;
            size += ::protrust::io::sizes::message(&**optional_all_types);
        }
        size += self.repeated_all_types.calculate_size(&TEST_PARSING_MERGE_REPEATED_ALL_TYPES_CODEC);
        let optionalgroup = &self.optionalgroup;
        if let ::std::option::Option::Some(optionalgroup) = optionalgroup {
            size += 1;
            size += ::protrust::io::sizes::group(&**optionalgroup);
            size += 1;
        }
        size += self.repeatedgroup.calculate_size(&TEST_PARSING_MERGE_REPEATEDGROUP_CODEC);
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let required_all_types = &self.required_all_types;
        if let ::std::option::Option::Some(required_all_types) = required_all_types {
            output.write_raw_tag_bytes(&[10])?;
            output.write_message(&**required_all_types)?;
        }
        let optional_all_types = &self.optional_all_types;
        if let ::std::option::Option::Some(optional_all_types) = optional_all_types {
            output.write_raw_tag_bytes(&[18])?;
            output.write_message(&**optional_all_types)?;
        }
        self.repeated_all_types.write_to(output, &TEST_PARSING_MERGE_REPEATED_ALL_TYPES_CODEC)?;
        let optionalgroup = &self.optionalgroup;
        if let ::std::option::Option::Some(optionalgroup) = optionalgroup {
            output.write_raw_tag_bytes(&[83])?;
            output.write_group(&**optionalgroup)?;
            output.write_raw_tag_bytes(&[84])?;
        }
        self.repeatedgroup.write_to(output, &TEST_PARSING_MERGE_REPEATEDGROUP_CODEC)?;
        self.unknown_fields.write_to(output)?;
        self.extensions.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        if let Some(required_all_types) = &self.required_all_types {
            if !::protrust::CodedMessage::is_initialized(&**required_all_types) {
                return false;
            }
        }
        if let Some(optional_all_types) = &self.optional_all_types {
            if !::protrust::CodedMessage::is_initialized(&**optional_all_types) {
                return false;
            }
        }
        if !self.repeated_all_types.is_initialized() {
            return false;
        }
        if let Some(optionalgroup) = &self.optionalgroup {
            if !::protrust::CodedMessage::is_initialized(&**optionalgroup) {
                return false;
            }
        }
        true
    }
}
impl ::protrust::LiteMessage for self::TestParsingMerge {
    fn new() -> Self {
        Self {
            required_all_types: ::std::option::Option::None,
            optional_all_types: ::std::option::Option::None,
            repeated_all_types: ::protrust::collections::RepeatedField::new(),
            optionalgroup: ::std::option::Option::None,
            repeatedgroup: ::protrust::collections::RepeatedField::new(),
            unknown_fields: ::protrust::UnknownFieldSet::new(),
            extensions: ::protrust::ExtensionSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        if let ::std::option::Option::Some(required_all_types) = &other.required_all_types {
            self.required_all_types.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(required_all_types);
        }
        if let ::std::option::Option::Some(optional_all_types) = &other.optional_all_types {
            self.optional_all_types.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(optional_all_types);
        }
        self.repeated_all_types.merge(&other.repeated_all_types);
        if let ::std::option::Option::Some(optionalgroup) = &other.optionalgroup {
            self.optionalgroup.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(optionalgroup);
        }
        self.repeatedgroup.merge(&other.repeatedgroup);
        self.unknown_fields.merge(&other.unknown_fields);
        self.extensions.merge(&other.extensions);
    }
}
impl ::protrust::ExtensionMessage for self::TestParsingMerge {
    fn registry(&self) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> { self.extensions.registry() }
    fn replace_registry(&mut self, extensions: ::std::option::Option<&'static ::protrust::ExtensionRegistry>) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> { self.extensions.replace_registry(extensions) }
    fn field<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::cmp::PartialEq<D> + ::std::fmt::Debug + ::std::marker::Sync, D: ::std::fmt::Debug + ::std::marker::Sync>(&self, extension: &'static ::protrust::Extension<Self, V, D>) -> ::std::option::Option<&::protrust::ExtensionField<V, D>> { self.extensions.field(extension) }
    fn field_mut<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::cmp::PartialEq<D> + ::std::fmt::Debug + ::std::marker::Sync, D: ::std::fmt::Debug + ::std::marker::Sync>(&mut self, extension: &'static ::protrust::Extension<Self, V, D>) -> ::std::option::Option<&mut ::protrust::ExtensionField<V, D>> { self.extensions.field_mut(extension) }
    fn repeated_field<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::fmt::Debug + ::std::marker::Sync + 'static>(&self, extension: &'static ::protrust::RepeatedExtension<Self, V>) -> ::std::option::Option<&::protrust::collections::RepeatedField<V>> { self.extensions.repeated_field(extension) }
    fn repeated_field_mut<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::fmt::Debug + ::std::marker::Sync + 'static>(&mut self, extension: &'static ::protrust::RepeatedExtension<Self, V>) -> ::std::option::Option<&mut ::protrust::collections::RepeatedField<V>> { self.extensions.repeated_field_mut(extension) }
}
impl ::protrust::Message for self::TestParsingMerge {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[53]
    }
}
impl self::TestParsingMerge {
    /// Gets the field number of the [`required_all_types`] field
    ///
    /// [`required_all_types`]: #method.required_all_types
    pub const REQUIRED_ALL_TYPES_FIELD_NUMBER: i32 = 1;
    pub fn required_all_types_option(&self) -> ::std::option::Option<&self::TestAllTypes> {
        self.required_all_types.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`required_all_types`] field
    ///
    /// [`required_all_types`]: #method.required_all_types
    pub fn required_all_types_mut(&mut self) -> &mut self::TestAllTypes {
        self.required_all_types.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`required_all_types`] field
    ///
    /// [`required_all_types`]: #method.required_all_types
    pub fn has_required_all_types(&self) -> bool {
        self.required_all_types.is_some()
    }
    /// Sets the value of the [`required_all_types`] field
    ///
    /// [`required_all_types`]: #method.required_all_types
    pub fn set_required_all_types(&mut self, value: self::TestAllTypes) {
        self.required_all_types = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`required_all_types`] field, leaving it empty
    ///
    /// [`required_all_types`]: #method.required_all_types
    pub fn take_required_all_types(&mut self) -> ::std::option::Option<self::TestAllTypes> {
        self.required_all_types.take().map(|b| *b)
    }
    /// Clears the value of the [`required_all_types`] field
    ///
    /// [`required_all_types`]: #method.required_all_types
    pub fn clear_required_all_types(&mut self) {
        self.required_all_types = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_all_types`] field
    ///
    /// [`optional_all_types`]: #method.optional_all_types
    pub const OPTIONAL_ALL_TYPES_FIELD_NUMBER: i32 = 2;
    pub fn optional_all_types_option(&self) -> ::std::option::Option<&self::TestAllTypes> {
        self.optional_all_types.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`optional_all_types`] field
    ///
    /// [`optional_all_types`]: #method.optional_all_types
    pub fn optional_all_types_mut(&mut self) -> &mut self::TestAllTypes {
        self.optional_all_types.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`optional_all_types`] field
    ///
    /// [`optional_all_types`]: #method.optional_all_types
    pub fn has_optional_all_types(&self) -> bool {
        self.optional_all_types.is_some()
    }
    /// Sets the value of the [`optional_all_types`] field
    ///
    /// [`optional_all_types`]: #method.optional_all_types
    pub fn set_optional_all_types(&mut self, value: self::TestAllTypes) {
        self.optional_all_types = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`optional_all_types`] field, leaving it empty
    ///
    /// [`optional_all_types`]: #method.optional_all_types
    pub fn take_optional_all_types(&mut self) -> ::std::option::Option<self::TestAllTypes> {
        self.optional_all_types.take().map(|b| *b)
    }
    /// Clears the value of the [`optional_all_types`] field
    ///
    /// [`optional_all_types`]: #method.optional_all_types
    pub fn clear_optional_all_types(&mut self) {
        self.optional_all_types = ::std::option::Option::None
    }
    /// Gets the field number of the [`repeated_all_types`] field
    ///
    /// [`repeated_all_types`]: #method.repeated_all_types
    pub const REPEATED_ALL_TYPES_FIELD_NUMBER: i32 = 3;
    pub fn repeated_all_types(&self) -> &::protrust::collections::RepeatedField<self::TestAllTypes> {
        &self.repeated_all_types
    }
    /// Returns a unique reference to the [`repeated_all_types`] field
    ///
    /// [`repeated_all_types`]: #method.repeated_all_types
    pub fn repeated_all_types_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<self::TestAllTypes> {
        &mut self.repeated_all_types
    }
    /// Gets the field number of the [`optionalgroup`] field
    ///
    /// [`optionalgroup`]: #method.optionalgroup
    pub const OPTIONALGROUP_FIELD_NUMBER: i32 = 10;
    pub fn optionalgroup_option(&self) -> ::std::option::Option<&self::test_parsing_merge::OptionalGroup> {
        self.optionalgroup.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`optionalgroup`] field
    ///
    /// [`optionalgroup`]: #method.optionalgroup
    pub fn optionalgroup_mut(&mut self) -> &mut self::test_parsing_merge::OptionalGroup {
        self.optionalgroup.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`optionalgroup`] field
    ///
    /// [`optionalgroup`]: #method.optionalgroup
    pub fn has_optionalgroup(&self) -> bool {
        self.optionalgroup.is_some()
    }
    /// Sets the value of the [`optionalgroup`] field
    ///
    /// [`optionalgroup`]: #method.optionalgroup
    pub fn set_optionalgroup(&mut self, value: self::test_parsing_merge::OptionalGroup) {
        self.optionalgroup = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`optionalgroup`] field, leaving it empty
    ///
    /// [`optionalgroup`]: #method.optionalgroup
    pub fn take_optionalgroup(&mut self) -> ::std::option::Option<self::test_parsing_merge::OptionalGroup> {
        self.optionalgroup.take().map(|b| *b)
    }
    /// Clears the value of the [`optionalgroup`] field
    ///
    /// [`optionalgroup`]: #method.optionalgroup
    pub fn clear_optionalgroup(&mut self) {
        self.optionalgroup = ::std::option::Option::None
    }
    /// Gets the field number of the [`repeatedgroup`] field
    ///
    /// [`repeatedgroup`]: #method.repeatedgroup
    pub const REPEATEDGROUP_FIELD_NUMBER: i32 = 20;
    pub fn repeatedgroup(&self) -> &::protrust::collections::RepeatedField<self::test_parsing_merge::RepeatedGroup> {
        &self.repeatedgroup
    }
    /// Returns a unique reference to the [`repeatedgroup`] field
    ///
    /// [`repeatedgroup`]: #method.repeatedgroup
    pub fn repeatedgroup_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<self::test_parsing_merge::RepeatedGroup> {
        &mut self.repeatedgroup
    }
}
/// Test that if an optional or required message/group field appears multiple
/// times in the input, they need to be merged.
pub mod test_parsing_merge {
    /// RepeatedFieldsGenerator defines matching field types as TestParsingMerge,
    /// except that all fields are repeated. In the tests, we will serialize the
    /// RepeatedFieldsGenerator to bytes, and parse the bytes to TestParsingMerge.
    /// Repeated fields in RepeatedFieldsGenerator are expected to be merged into
    /// the corresponding required/optional fields in TestParsingMerge.
    #[derive(Clone, Debug, PartialEq)]
    pub struct RepeatedFieldsGenerator {
        field1: ::protrust::collections::RepeatedField<self::super::TestAllTypes>,
        field2: ::protrust::collections::RepeatedField<self::super::TestAllTypes>,
        field3: ::protrust::collections::RepeatedField<self::super::TestAllTypes>,
        group1: ::protrust::collections::RepeatedField<self::repeated_fields_generator::Group1>,
        group2: ::protrust::collections::RepeatedField<self::repeated_fields_generator::Group2>,
        ext1: ::protrust::collections::RepeatedField<self::super::TestAllTypes>,
        ext2: ::protrust::collections::RepeatedField<self::super::TestAllTypes>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    static REPEATED_FIELDS_GENERATOR_FIELD1_CODEC: ::protrust::Codec<self::super::TestAllTypes> = ::protrust::Codec::message(10);
    static REPEATED_FIELDS_GENERATOR_FIELD2_CODEC: ::protrust::Codec<self::super::TestAllTypes> = ::protrust::Codec::message(18);
    static REPEATED_FIELDS_GENERATOR_FIELD3_CODEC: ::protrust::Codec<self::super::TestAllTypes> = ::protrust::Codec::message(26);
    static REPEATED_FIELDS_GENERATOR_GROUP1_CODEC: ::protrust::Codec<self::repeated_fields_generator::Group1> = ::protrust::Codec::group(83, 84);
    static REPEATED_FIELDS_GENERATOR_GROUP2_CODEC: ::protrust::Codec<self::repeated_fields_generator::Group2> = ::protrust::Codec::group(163, 164);
    static REPEATED_FIELDS_GENERATOR_EXT1_CODEC: ::protrust::Codec<self::super::TestAllTypes> = ::protrust::Codec::message(8002);
    static REPEATED_FIELDS_GENERATOR_EXT2_CODEC: ::protrust::Codec<self::super::TestAllTypes> = ::protrust::Codec::message(8010);
    impl ::protrust::CodedMessage for self::RepeatedFieldsGenerator {
        fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => self.field1.add_entries(input, &REPEATED_FIELDS_GENERATOR_FIELD1_CODEC)?,
                    18 => self.field2.add_entries(input, &REPEATED_FIELDS_GENERATOR_FIELD2_CODEC)?,
                    26 => self.field3.add_entries(input, &REPEATED_FIELDS_GENERATOR_FIELD3_CODEC)?,
                    83 => self.group1.add_entries(input, &REPEATED_FIELDS_GENERATOR_GROUP1_CODEC)?,
                    163 => self.group2.add_entries(input, &REPEATED_FIELDS_GENERATOR_GROUP2_CODEC)?,
                    8002 => self.ext1.add_entries(input, &REPEATED_FIELDS_GENERATOR_EXT1_CODEC)?,
                    8010 => self.ext2.add_entries(input, &REPEATED_FIELDS_GENERATOR_EXT2_CODEC)?,
                    _ => self.unknown_fields.merge_from(tag, input)?
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            size += self.field1.calculate_size(&REPEATED_FIELDS_GENERATOR_FIELD1_CODEC);
            size += self.field2.calculate_size(&REPEATED_FIELDS_GENERATOR_FIELD2_CODEC);
            size += self.field3.calculate_size(&REPEATED_FIELDS_GENERATOR_FIELD3_CODEC);
            size += self.group1.calculate_size(&REPEATED_FIELDS_GENERATOR_GROUP1_CODEC);
            size += self.group2.calculate_size(&REPEATED_FIELDS_GENERATOR_GROUP2_CODEC);
            size += self.ext1.calculate_size(&REPEATED_FIELDS_GENERATOR_EXT1_CODEC);
            size += self.ext2.calculate_size(&REPEATED_FIELDS_GENERATOR_EXT2_CODEC);
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
            self.field1.write_to(output, &REPEATED_FIELDS_GENERATOR_FIELD1_CODEC)?;
            self.field2.write_to(output, &REPEATED_FIELDS_GENERATOR_FIELD2_CODEC)?;
            self.field3.write_to(output, &REPEATED_FIELDS_GENERATOR_FIELD3_CODEC)?;
            self.group1.write_to(output, &REPEATED_FIELDS_GENERATOR_GROUP1_CODEC)?;
            self.group2.write_to(output, &REPEATED_FIELDS_GENERATOR_GROUP2_CODEC)?;
            self.ext1.write_to(output, &REPEATED_FIELDS_GENERATOR_EXT1_CODEC)?;
            self.ext2.write_to(output, &REPEATED_FIELDS_GENERATOR_EXT2_CODEC)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.field1.is_initialized() {
                return false;
            }
            if !self.field2.is_initialized() {
                return false;
            }
            if !self.field3.is_initialized() {
                return false;
            }
            if !self.ext1.is_initialized() {
                return false;
            }
            if !self.ext2.is_initialized() {
                return false;
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::RepeatedFieldsGenerator {
        fn new() -> Self {
            Self {
                field1: ::protrust::collections::RepeatedField::new(),
                field2: ::protrust::collections::RepeatedField::new(),
                field3: ::protrust::collections::RepeatedField::new(),
                group1: ::protrust::collections::RepeatedField::new(),
                group2: ::protrust::collections::RepeatedField::new(),
                ext1: ::protrust::collections::RepeatedField::new(),
                ext2: ::protrust::collections::RepeatedField::new(),
                unknown_fields: ::protrust::UnknownFieldSet::new(),
            }
        }
        fn merge(&mut self, other: &Self) {
            self.field1.merge(&other.field1);
            self.field2.merge(&other.field2);
            self.field3.merge(&other.field3);
            self.group1.merge(&other.group1);
            self.group2.merge(&other.group2);
            self.ext1.merge(&other.ext1);
            self.ext2.merge(&other.ext2);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::RepeatedFieldsGenerator {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
            &self::super::file().messages()[53].messages()[0]
        }
    }
    impl self::RepeatedFieldsGenerator {
        /// Gets the field number of the [`field1`] field
        ///
        /// [`field1`]: #method.field1
        pub const FIELD1_FIELD_NUMBER: i32 = 1;
        pub fn field1(&self) -> &::protrust::collections::RepeatedField<self::super::TestAllTypes> {
            &self.field1
        }
        /// Returns a unique reference to the [`field1`] field
        ///
        /// [`field1`]: #method.field1
        pub fn field1_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<self::super::TestAllTypes> {
            &mut self.field1
        }
        /// Gets the field number of the [`field2`] field
        ///
        /// [`field2`]: #method.field2
        pub const FIELD2_FIELD_NUMBER: i32 = 2;
        pub fn field2(&self) -> &::protrust::collections::RepeatedField<self::super::TestAllTypes> {
            &self.field2
        }
        /// Returns a unique reference to the [`field2`] field
        ///
        /// [`field2`]: #method.field2
        pub fn field2_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<self::super::TestAllTypes> {
            &mut self.field2
        }
        /// Gets the field number of the [`field3`] field
        ///
        /// [`field3`]: #method.field3
        pub const FIELD3_FIELD_NUMBER: i32 = 3;
        pub fn field3(&self) -> &::protrust::collections::RepeatedField<self::super::TestAllTypes> {
            &self.field3
        }
        /// Returns a unique reference to the [`field3`] field
        ///
        /// [`field3`]: #method.field3
        pub fn field3_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<self::super::TestAllTypes> {
            &mut self.field3
        }
        /// Gets the field number of the [`group1`] field
        ///
        /// [`group1`]: #method.group1
        pub const GROUP1_FIELD_NUMBER: i32 = 10;
        pub fn group1(&self) -> &::protrust::collections::RepeatedField<self::repeated_fields_generator::Group1> {
            &self.group1
        }
        /// Returns a unique reference to the [`group1`] field
        ///
        /// [`group1`]: #method.group1
        pub fn group1_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<self::repeated_fields_generator::Group1> {
            &mut self.group1
        }
        /// Gets the field number of the [`group2`] field
        ///
        /// [`group2`]: #method.group2
        pub const GROUP2_FIELD_NUMBER: i32 = 20;
        pub fn group2(&self) -> &::protrust::collections::RepeatedField<self::repeated_fields_generator::Group2> {
            &self.group2
        }
        /// Returns a unique reference to the [`group2`] field
        ///
        /// [`group2`]: #method.group2
        pub fn group2_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<self::repeated_fields_generator::Group2> {
            &mut self.group2
        }
        /// Gets the field number of the [`ext1`] field
        ///
        /// [`ext1`]: #method.ext1
        pub const EXT1_FIELD_NUMBER: i32 = 1000;
        pub fn ext1(&self) -> &::protrust::collections::RepeatedField<self::super::TestAllTypes> {
            &self.ext1
        }
        /// Returns a unique reference to the [`ext1`] field
        ///
        /// [`ext1`]: #method.ext1
        pub fn ext1_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<self::super::TestAllTypes> {
            &mut self.ext1
        }
        /// Gets the field number of the [`ext2`] field
        ///
        /// [`ext2`]: #method.ext2
        pub const EXT2_FIELD_NUMBER: i32 = 1001;
        pub fn ext2(&self) -> &::protrust::collections::RepeatedField<self::super::TestAllTypes> {
            &self.ext2
        }
        /// Returns a unique reference to the [`ext2`] field
        ///
        /// [`ext2`]: #method.ext2
        pub fn ext2_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<self::super::TestAllTypes> {
            &mut self.ext2
        }
    }
    /// RepeatedFieldsGenerator defines matching field types as TestParsingMerge,
    /// except that all fields are repeated. In the tests, we will serialize the
    /// RepeatedFieldsGenerator to bytes, and parse the bytes to TestParsingMerge.
    /// Repeated fields in RepeatedFieldsGenerator are expected to be merged into
    /// the corresponding required/optional fields in TestParsingMerge.
    pub mod repeated_fields_generator {
        #[derive(Clone, Debug, PartialEq)]
        pub struct Group1 {
            field1: ::std::option::Option<::std::boxed::Box<self::super::super::TestAllTypes>>,
            unknown_fields: ::protrust::UnknownFieldSet,
        }
        impl ::protrust::CodedMessage for self::Group1 {
            fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        90 => input.read_message(&mut **self.field1.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                        84 => break,
                        _ => self.unknown_fields.merge_from(tag, input)?
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> i32 {
                let mut size = 0i32;
                let field1 = &self.field1;
                if let ::std::option::Option::Some(field1) = field1 {
                    size += 1;
                    size += ::protrust::io::sizes::message(&**field1);
                }
                size += self.unknown_fields.calculate_size();
                size
            }
            fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
                let field1 = &self.field1;
                if let ::std::option::Option::Some(field1) = field1 {
                    output.write_raw_tag_bytes(&[90])?;
                    output.write_message(&**field1)?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                if let Some(field1) = &self.field1 {
                    if !::protrust::CodedMessage::is_initialized(&**field1) {
                        return false;
                    }
                }
                true
            }
        }
        impl ::protrust::LiteMessage for self::Group1 {
            fn new() -> Self {
                Self {
                    field1: ::std::option::Option::None,
                    unknown_fields: ::protrust::UnknownFieldSet::new(),
                }
            }
            fn merge(&mut self, other: &Self) {
                if let ::std::option::Option::Some(field1) = &other.field1 {
                    self.field1.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(field1);
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl ::protrust::Message for self::Group1 {
            fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
                &self::super::super::file().messages()[53].messages()[0].messages()[0]
            }
        }
        impl self::Group1 {
            /// Gets the field number of the [`field1`] field
            ///
            /// [`field1`]: #method.field1
            pub const FIELD1_FIELD_NUMBER: i32 = 11;
            pub fn field1_option(&self) -> ::std::option::Option<&self::super::super::TestAllTypes> {
                self.field1.as_ref().map(|b| &**b)
            }
            /// Returns a unique reference to the [`field1`] field
            ///
            /// [`field1`]: #method.field1
            pub fn field1_mut(&mut self) -> &mut self::super::super::TestAllTypes {
                self.field1.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
            }
            /// Returns a bool indicating the presence of the [`field1`] field
            ///
            /// [`field1`]: #method.field1
            pub fn has_field1(&self) -> bool {
                self.field1.is_some()
            }
            /// Sets the value of the [`field1`] field
            ///
            /// [`field1`]: #method.field1
            pub fn set_field1(&mut self, value: self::super::super::TestAllTypes) {
                self.field1 = ::std::option::Option::Some(::std::boxed::Box::new(value))
            }
            /// Takes the value of the [`field1`] field, leaving it empty
            ///
            /// [`field1`]: #method.field1
            pub fn take_field1(&mut self) -> ::std::option::Option<self::super::super::TestAllTypes> {
                self.field1.take().map(|b| *b)
            }
            /// Clears the value of the [`field1`] field
            ///
            /// [`field1`]: #method.field1
            pub fn clear_field1(&mut self) {
                self.field1 = ::std::option::Option::None
            }
        }
        #[derive(Clone, Debug, PartialEq)]
        pub struct Group2 {
            field1: ::std::option::Option<::std::boxed::Box<self::super::super::TestAllTypes>>,
            unknown_fields: ::protrust::UnknownFieldSet,
        }
        impl ::protrust::CodedMessage for self::Group2 {
            fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        170 => input.read_message(&mut **self.field1.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                        164 => break,
                        _ => self.unknown_fields.merge_from(tag, input)?
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> i32 {
                let mut size = 0i32;
                let field1 = &self.field1;
                if let ::std::option::Option::Some(field1) = field1 {
                    size += 2;
                    size += ::protrust::io::sizes::message(&**field1);
                }
                size += self.unknown_fields.calculate_size();
                size
            }
            fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
                let field1 = &self.field1;
                if let ::std::option::Option::Some(field1) = field1 {
                    output.write_raw_tag_bytes(&[170, 1])?;
                    output.write_message(&**field1)?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                if let Some(field1) = &self.field1 {
                    if !::protrust::CodedMessage::is_initialized(&**field1) {
                        return false;
                    }
                }
                true
            }
        }
        impl ::protrust::LiteMessage for self::Group2 {
            fn new() -> Self {
                Self {
                    field1: ::std::option::Option::None,
                    unknown_fields: ::protrust::UnknownFieldSet::new(),
                }
            }
            fn merge(&mut self, other: &Self) {
                if let ::std::option::Option::Some(field1) = &other.field1 {
                    self.field1.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(field1);
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl ::protrust::Message for self::Group2 {
            fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
                &self::super::super::file().messages()[53].messages()[0].messages()[1]
            }
        }
        impl self::Group2 {
            /// Gets the field number of the [`field1`] field
            ///
            /// [`field1`]: #method.field1
            pub const FIELD1_FIELD_NUMBER: i32 = 21;
            pub fn field1_option(&self) -> ::std::option::Option<&self::super::super::TestAllTypes> {
                self.field1.as_ref().map(|b| &**b)
            }
            /// Returns a unique reference to the [`field1`] field
            ///
            /// [`field1`]: #method.field1
            pub fn field1_mut(&mut self) -> &mut self::super::super::TestAllTypes {
                self.field1.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
            }
            /// Returns a bool indicating the presence of the [`field1`] field
            ///
            /// [`field1`]: #method.field1
            pub fn has_field1(&self) -> bool {
                self.field1.is_some()
            }
            /// Sets the value of the [`field1`] field
            ///
            /// [`field1`]: #method.field1
            pub fn set_field1(&mut self, value: self::super::super::TestAllTypes) {
                self.field1 = ::std::option::Option::Some(::std::boxed::Box::new(value))
            }
            /// Takes the value of the [`field1`] field, leaving it empty
            ///
            /// [`field1`]: #method.field1
            pub fn take_field1(&mut self) -> ::std::option::Option<self::super::super::TestAllTypes> {
                self.field1.take().map(|b| *b)
            }
            /// Clears the value of the [`field1`] field
            ///
            /// [`field1`]: #method.field1
            pub fn clear_field1(&mut self) {
                self.field1 = ::std::option::Option::None
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    pub struct OptionalGroup {
        optional_group_all_types: ::std::option::Option<::std::boxed::Box<self::super::TestAllTypes>>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::OptionalGroup {
        fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    90 => input.read_message(&mut **self.optional_group_all_types.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                    84 => break,
                    _ => self.unknown_fields.merge_from(tag, input)?
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            let optional_group_all_types = &self.optional_group_all_types;
            if let ::std::option::Option::Some(optional_group_all_types) = optional_group_all_types {
                size += 1;
                size += ::protrust::io::sizes::message(&**optional_group_all_types);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
            let optional_group_all_types = &self.optional_group_all_types;
            if let ::std::option::Option::Some(optional_group_all_types) = optional_group_all_types {
                output.write_raw_tag_bytes(&[90])?;
                output.write_message(&**optional_group_all_types)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let Some(optional_group_all_types) = &self.optional_group_all_types {
                if !::protrust::CodedMessage::is_initialized(&**optional_group_all_types) {
                    return false;
                }
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::OptionalGroup {
        fn new() -> Self {
            Self {
                optional_group_all_types: ::std::option::Option::None,
                unknown_fields: ::protrust::UnknownFieldSet::new(),
            }
        }
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(optional_group_all_types) = &other.optional_group_all_types {
                self.optional_group_all_types.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(optional_group_all_types);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::OptionalGroup {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
            &self::super::file().messages()[53].messages()[1]
        }
    }
    impl self::OptionalGroup {
        /// Gets the field number of the [`optional_group_all_types`] field
        ///
        /// [`optional_group_all_types`]: #method.optional_group_all_types
        pub const OPTIONAL_GROUP_ALL_TYPES_FIELD_NUMBER: i32 = 11;
        pub fn optional_group_all_types_option(&self) -> ::std::option::Option<&self::super::TestAllTypes> {
            self.optional_group_all_types.as_ref().map(|b| &**b)
        }
        /// Returns a unique reference to the [`optional_group_all_types`] field
        ///
        /// [`optional_group_all_types`]: #method.optional_group_all_types
        pub fn optional_group_all_types_mut(&mut self) -> &mut self::super::TestAllTypes {
            self.optional_group_all_types.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
        }
        /// Returns a bool indicating the presence of the [`optional_group_all_types`] field
        ///
        /// [`optional_group_all_types`]: #method.optional_group_all_types
        pub fn has_optional_group_all_types(&self) -> bool {
            self.optional_group_all_types.is_some()
        }
        /// Sets the value of the [`optional_group_all_types`] field
        ///
        /// [`optional_group_all_types`]: #method.optional_group_all_types
        pub fn set_optional_group_all_types(&mut self, value: self::super::TestAllTypes) {
            self.optional_group_all_types = ::std::option::Option::Some(::std::boxed::Box::new(value))
        }
        /// Takes the value of the [`optional_group_all_types`] field, leaving it empty
        ///
        /// [`optional_group_all_types`]: #method.optional_group_all_types
        pub fn take_optional_group_all_types(&mut self) -> ::std::option::Option<self::super::TestAllTypes> {
            self.optional_group_all_types.take().map(|b| *b)
        }
        /// Clears the value of the [`optional_group_all_types`] field
        ///
        /// [`optional_group_all_types`]: #method.optional_group_all_types
        pub fn clear_optional_group_all_types(&mut self) {
            self.optional_group_all_types = ::std::option::Option::None
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    pub struct RepeatedGroup {
        repeated_group_all_types: ::std::option::Option<::std::boxed::Box<self::super::TestAllTypes>>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::RepeatedGroup {
        fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    170 => input.read_message(&mut **self.repeated_group_all_types.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                    164 => break,
                    _ => self.unknown_fields.merge_from(tag, input)?
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            let repeated_group_all_types = &self.repeated_group_all_types;
            if let ::std::option::Option::Some(repeated_group_all_types) = repeated_group_all_types {
                size += 2;
                size += ::protrust::io::sizes::message(&**repeated_group_all_types);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
            let repeated_group_all_types = &self.repeated_group_all_types;
            if let ::std::option::Option::Some(repeated_group_all_types) = repeated_group_all_types {
                output.write_raw_tag_bytes(&[170, 1])?;
                output.write_message(&**repeated_group_all_types)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let Some(repeated_group_all_types) = &self.repeated_group_all_types {
                if !::protrust::CodedMessage::is_initialized(&**repeated_group_all_types) {
                    return false;
                }
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::RepeatedGroup {
        fn new() -> Self {
            Self {
                repeated_group_all_types: ::std::option::Option::None,
                unknown_fields: ::protrust::UnknownFieldSet::new(),
            }
        }
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(repeated_group_all_types) = &other.repeated_group_all_types {
                self.repeated_group_all_types.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(repeated_group_all_types);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::RepeatedGroup {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
            &self::super::file().messages()[53].messages()[2]
        }
    }
    impl self::RepeatedGroup {
        /// Gets the field number of the [`repeated_group_all_types`] field
        ///
        /// [`repeated_group_all_types`]: #method.repeated_group_all_types
        pub const REPEATED_GROUP_ALL_TYPES_FIELD_NUMBER: i32 = 21;
        pub fn repeated_group_all_types_option(&self) -> ::std::option::Option<&self::super::TestAllTypes> {
            self.repeated_group_all_types.as_ref().map(|b| &**b)
        }
        /// Returns a unique reference to the [`repeated_group_all_types`] field
        ///
        /// [`repeated_group_all_types`]: #method.repeated_group_all_types
        pub fn repeated_group_all_types_mut(&mut self) -> &mut self::super::TestAllTypes {
            self.repeated_group_all_types.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
        }
        /// Returns a bool indicating the presence of the [`repeated_group_all_types`] field
        ///
        /// [`repeated_group_all_types`]: #method.repeated_group_all_types
        pub fn has_repeated_group_all_types(&self) -> bool {
            self.repeated_group_all_types.is_some()
        }
        /// Sets the value of the [`repeated_group_all_types`] field
        ///
        /// [`repeated_group_all_types`]: #method.repeated_group_all_types
        pub fn set_repeated_group_all_types(&mut self, value: self::super::TestAllTypes) {
            self.repeated_group_all_types = ::std::option::Option::Some(::std::boxed::Box::new(value))
        }
        /// Takes the value of the [`repeated_group_all_types`] field, leaving it empty
        ///
        /// [`repeated_group_all_types`]: #method.repeated_group_all_types
        pub fn take_repeated_group_all_types(&mut self) -> ::std::option::Option<self::super::TestAllTypes> {
            self.repeated_group_all_types.take().map(|b| *b)
        }
        /// Clears the value of the [`repeated_group_all_types`] field
        ///
        /// [`repeated_group_all_types`]: #method.repeated_group_all_types
        pub fn clear_repeated_group_all_types(&mut self) {
            self.repeated_group_all_types = ::std::option::Option::None
        }
    }
    pub static OPTIONAL_EXT: ::protrust::Extension<self::super::TestParsingMerge, self::super::TestAllTypes, self::super::TestAllTypes> = ::protrust::Extension::message(8002);
    pub static REPEATED_EXT: ::protrust::RepeatedExtension<self::super::TestParsingMerge, self::super::TestAllTypes> = ::protrust::RepeatedExtension::message(8010);
}
#[derive(Clone, Debug, PartialEq)]
pub struct TestCommentInjectionMessage {
    a: ::std::option::Option<::std::string::String>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::TestCommentInjectionMessage {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                10 => self.a = ::std::option::Option::Some(input.read_string()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let a = &self.a;
        if let ::std::option::Option::Some(a) = a {
            size += 1;
            size += ::protrust::io::sizes::string(a);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let a = &self.a;
        if let ::std::option::Option::Some(a) = a {
            output.write_raw_tag_bytes(&[10])?;
            output.write_string(a)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::TestCommentInjectionMessage {
    fn new() -> Self {
        Self {
            a: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.a = other.a.clone();
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestCommentInjectionMessage {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[54]
    }
}
impl self::TestCommentInjectionMessage {
    /// Gets the field number of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub const A_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub const A_DEFAULT_VALUE: &'static str = "*/ <- Neither should this.";
    /// */ <- This should not close the generated doc comment
    pub fn a(&self) -> &str {
        self.a.as_ref().map(|v| &**v).unwrap_or(Self::A_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`a`] field
    ///
    /// [`a`]: #method.a
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn a_option(&self) -> ::std::option::Option<&::std::string::String> {
        self.a.as_ref()
    }
    /// Returns a unique reference to the [`a`] field
    ///
    /// [`a`]: #method.a
    pub fn a_mut(&mut self) -> &mut ::std::string::String {
        self.a.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub fn has_a(&self) -> bool {
        self.a.is_some()
    }
    /// Sets the value of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub fn set_a(&mut self, value: ::std::string::String) {
        self.a = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`a`] field, leaving it empty
    ///
    /// [`a`]: #method.a
    pub fn take_a(&mut self) -> ::std::option::Option<::std::string::String> {
        self.a.take()
    }
    /// Clears the value of the [`a`] field
    ///
    /// [`a`]: #method.a
    pub fn clear_a(&mut self) {
        self.a = ::std::option::Option::None
    }
}
/// Test that RPC services work.
#[derive(Clone, Debug, PartialEq)]
pub struct FooRequest {
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::FooRequest {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::FooRequest {
    fn new() -> Self {
        Self {
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::FooRequest {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[55]
    }
}
impl self::FooRequest {
}
#[derive(Clone, Debug, PartialEq)]
pub struct FooResponse {
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::FooResponse {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::FooResponse {
    fn new() -> Self {
        Self {
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::FooResponse {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[56]
    }
}
impl self::FooResponse {
}
#[derive(Clone, Debug, PartialEq)]
pub struct FooClientMessage {
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::FooClientMessage {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::FooClientMessage {
    fn new() -> Self {
        Self {
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::FooClientMessage {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[57]
    }
}
impl self::FooClientMessage {
}
#[derive(Clone, Debug, PartialEq)]
pub struct FooServerMessage {
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::FooServerMessage {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::FooServerMessage {
    fn new() -> Self {
        Self {
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::FooServerMessage {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[58]
    }
}
impl self::FooServerMessage {
}
#[derive(Clone, Debug, PartialEq)]
pub struct BarRequest {
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::BarRequest {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::BarRequest {
    fn new() -> Self {
        Self {
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::BarRequest {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[59]
    }
}
impl self::BarRequest {
}
#[derive(Clone, Debug, PartialEq)]
pub struct BarResponse {
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::BarResponse {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::BarResponse {
    fn new() -> Self {
        Self {
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::BarResponse {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[60]
    }
}
impl self::BarResponse {
}
#[derive(Clone, Debug, PartialEq)]
pub struct TestJsonName {
    field_name1: ::std::option::Option<i32>,
    fieldName2: ::std::option::Option<i32>,
    FieldName3: ::std::option::Option<i32>,
    _field_name4: ::std::option::Option<i32>,
    FIELD_NAME5: ::std::option::Option<i32>,
    field_name6: ::std::option::Option<i32>,
    unknown_fields: ::protrust::UnknownFieldSet,
}
impl ::protrust::CodedMessage for self::TestJsonName {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 | 10 => self.field_name1 = ::std::option::Option::Some(input.read_int32()?),
                16 | 18 => self.fieldName2 = ::std::option::Option::Some(input.read_int32()?),
                24 | 26 => self.FieldName3 = ::std::option::Option::Some(input.read_int32()?),
                32 | 34 => self._field_name4 = ::std::option::Option::Some(input.read_int32()?),
                40 | 42 => self.FIELD_NAME5 = ::std::option::Option::Some(input.read_int32()?),
                48 | 50 => self.field_name6 = ::std::option::Option::Some(input.read_int32()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let field_name1 = self.field_name1;
        if let ::std::option::Option::Some(field_name1) = field_name1 {
            size += 1;
            size += ::protrust::io::sizes::int32(field_name1);
        }
        let fieldName2 = self.fieldName2;
        if let ::std::option::Option::Some(fieldName2) = fieldName2 {
            size += 1;
            size += ::protrust::io::sizes::int32(fieldName2);
        }
        let FieldName3 = self.FieldName3;
        if let ::std::option::Option::Some(FieldName3) = FieldName3 {
            size += 1;
            size += ::protrust::io::sizes::int32(FieldName3);
        }
        let _field_name4 = self._field_name4;
        if let ::std::option::Option::Some(_field_name4) = _field_name4 {
            size += 1;
            size += ::protrust::io::sizes::int32(_field_name4);
        }
        let FIELD_NAME5 = self.FIELD_NAME5;
        if let ::std::option::Option::Some(FIELD_NAME5) = FIELD_NAME5 {
            size += 1;
            size += ::protrust::io::sizes::int32(FIELD_NAME5);
        }
        let field_name6 = self.field_name6;
        if let ::std::option::Option::Some(field_name6) = field_name6 {
            size += 1;
            size += ::protrust::io::sizes::int32(field_name6);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let field_name1 = self.field_name1;
        if let ::std::option::Option::Some(field_name1) = field_name1 {
            output.write_raw_tag_bytes(&[8])?;
            output.write_int32(field_name1)?;
        }
        let fieldName2 = self.fieldName2;
        if let ::std::option::Option::Some(fieldName2) = fieldName2 {
            output.write_raw_tag_bytes(&[16])?;
            output.write_int32(fieldName2)?;
        }
        let FieldName3 = self.FieldName3;
        if let ::std::option::Option::Some(FieldName3) = FieldName3 {
            output.write_raw_tag_bytes(&[24])?;
            output.write_int32(FieldName3)?;
        }
        let _field_name4 = self._field_name4;
        if let ::std::option::Option::Some(_field_name4) = _field_name4 {
            output.write_raw_tag_bytes(&[32])?;
            output.write_int32(_field_name4)?;
        }
        let FIELD_NAME5 = self.FIELD_NAME5;
        if let ::std::option::Option::Some(FIELD_NAME5) = FIELD_NAME5 {
            output.write_raw_tag_bytes(&[40])?;
            output.write_int32(FIELD_NAME5)?;
        }
        let field_name6 = self.field_name6;
        if let ::std::option::Option::Some(field_name6) = field_name6 {
            output.write_raw_tag_bytes(&[48])?;
            output.write_int32(field_name6)?;
        }
        self.unknown_fields.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::TestJsonName {
    fn new() -> Self {
        Self {
            field_name1: ::std::option::Option::None,
            fieldName2: ::std::option::Option::None,
            FieldName3: ::std::option::Option::None,
            _field_name4: ::std::option::Option::None,
            FIELD_NAME5: ::std::option::Option::None,
            field_name6: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.field_name1 = other.field_name1;
        self.fieldName2 = other.fieldName2;
        self.FieldName3 = other.FieldName3;
        self._field_name4 = other._field_name4;
        self.FIELD_NAME5 = other.FIELD_NAME5;
        self.field_name6 = other.field_name6;
        self.unknown_fields.merge(&other.unknown_fields);
    }
}
impl ::protrust::Message for self::TestJsonName {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[61]
    }
}
impl self::TestJsonName {
    /// Gets the field number of the [`field_name1`] field
    ///
    /// [`field_name1`]: #method.field_name1
    pub const FIELD_NAME1_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`field_name1`] field
    ///
    /// [`field_name1`]: #method.field_name1
    pub const FIELD_NAME1_DEFAULT_VALUE: i32 = 0;
    pub fn field_name1(&self) -> i32 {
        self.field_name1.unwrap_or(Self::FIELD_NAME1_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`field_name1`] field
    ///
    /// [`field_name1`]: #method.field_name1
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn field_name1_option(&self) -> ::std::option::Option<i32> {
        self.field_name1
    }
    /// Returns a bool indicating the presence of the [`field_name1`] field
    ///
    /// [`field_name1`]: #method.field_name1
    pub fn has_field_name1(&self) -> bool {
        self.field_name1.is_some()
    }
    /// Sets the value of the [`field_name1`] field
    ///
    /// [`field_name1`]: #method.field_name1
    pub fn set_field_name1(&mut self, value: i32) {
        self.field_name1 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`field_name1`] field
    ///
    /// [`field_name1`]: #method.field_name1
    pub fn clear_field_name1(&mut self) {
        self.field_name1 = ::std::option::Option::None
    }
    /// Gets the field number of the [`fieldName2`] field
    ///
    /// [`fieldName2`]: #method.fieldName2
    pub const FIELDNAME2_FIELD_NUMBER: i32 = 2;
    /// A constant value representing the default value of the [`fieldName2`] field
    ///
    /// [`fieldName2`]: #method.fieldName2
    pub const FIELDNAME2_DEFAULT_VALUE: i32 = 0;
    pub fn fieldName2(&self) -> i32 {
        self.fieldName2.unwrap_or(Self::FIELDNAME2_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`fieldName2`] field
    ///
    /// [`fieldName2`]: #method.fieldName2
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn fieldName2_option(&self) -> ::std::option::Option<i32> {
        self.fieldName2
    }
    /// Returns a bool indicating the presence of the [`fieldName2`] field
    ///
    /// [`fieldName2`]: #method.fieldName2
    pub fn has_fieldName2(&self) -> bool {
        self.fieldName2.is_some()
    }
    /// Sets the value of the [`fieldName2`] field
    ///
    /// [`fieldName2`]: #method.fieldName2
    pub fn set_fieldName2(&mut self, value: i32) {
        self.fieldName2 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`fieldName2`] field
    ///
    /// [`fieldName2`]: #method.fieldName2
    pub fn clear_fieldName2(&mut self) {
        self.fieldName2 = ::std::option::Option::None
    }
    /// Gets the field number of the [`FieldName3`] field
    ///
    /// [`FieldName3`]: #method.FieldName3
    pub const FIELDNAME3_FIELD_NUMBER: i32 = 3;
    /// A constant value representing the default value of the [`FieldName3`] field
    ///
    /// [`FieldName3`]: #method.FieldName3
    pub const FIELDNAME3_DEFAULT_VALUE: i32 = 0;
    pub fn FieldName3(&self) -> i32 {
        self.FieldName3.unwrap_or(Self::FIELDNAME3_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`FieldName3`] field
    ///
    /// [`FieldName3`]: #method.FieldName3
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn FieldName3_option(&self) -> ::std::option::Option<i32> {
        self.FieldName3
    }
    /// Returns a bool indicating the presence of the [`FieldName3`] field
    ///
    /// [`FieldName3`]: #method.FieldName3
    pub fn has_FieldName3(&self) -> bool {
        self.FieldName3.is_some()
    }
    /// Sets the value of the [`FieldName3`] field
    ///
    /// [`FieldName3`]: #method.FieldName3
    pub fn set_FieldName3(&mut self, value: i32) {
        self.FieldName3 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`FieldName3`] field
    ///
    /// [`FieldName3`]: #method.FieldName3
    pub fn clear_FieldName3(&mut self) {
        self.FieldName3 = ::std::option::Option::None
    }
    /// Gets the field number of the [`_field_name4`] field
    ///
    /// [`_field_name4`]: #method._field_name4
    pub const _FIELD_NAME4_FIELD_NUMBER: i32 = 4;
    /// A constant value representing the default value of the [`_field_name4`] field
    ///
    /// [`_field_name4`]: #method._field_name4
    pub const _FIELD_NAME4_DEFAULT_VALUE: i32 = 0;
    pub fn _field_name4(&self) -> i32 {
        self._field_name4.unwrap_or(Self::_FIELD_NAME4_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`_field_name4`] field
    ///
    /// [`_field_name4`]: #method._field_name4
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn _field_name4_option(&self) -> ::std::option::Option<i32> {
        self._field_name4
    }
    /// Returns a bool indicating the presence of the [`_field_name4`] field
    ///
    /// [`_field_name4`]: #method._field_name4
    pub fn has__field_name4(&self) -> bool {
        self._field_name4.is_some()
    }
    /// Sets the value of the [`_field_name4`] field
    ///
    /// [`_field_name4`]: #method._field_name4
    pub fn set__field_name4(&mut self, value: i32) {
        self._field_name4 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`_field_name4`] field
    ///
    /// [`_field_name4`]: #method._field_name4
    pub fn clear__field_name4(&mut self) {
        self._field_name4 = ::std::option::Option::None
    }
    /// Gets the field number of the [`FIELD_NAME5`] field
    ///
    /// [`FIELD_NAME5`]: #method.FIELD_NAME5
    pub const FIELD_NAME5_FIELD_NUMBER: i32 = 5;
    /// A constant value representing the default value of the [`FIELD_NAME5`] field
    ///
    /// [`FIELD_NAME5`]: #method.FIELD_NAME5
    pub const FIELD_NAME5_DEFAULT_VALUE: i32 = 0;
    pub fn FIELD_NAME5(&self) -> i32 {
        self.FIELD_NAME5.unwrap_or(Self::FIELD_NAME5_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`FIELD_NAME5`] field
    ///
    /// [`FIELD_NAME5`]: #method.FIELD_NAME5
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn FIELD_NAME5_option(&self) -> ::std::option::Option<i32> {
        self.FIELD_NAME5
    }
    /// Returns a bool indicating the presence of the [`FIELD_NAME5`] field
    ///
    /// [`FIELD_NAME5`]: #method.FIELD_NAME5
    pub fn has_FIELD_NAME5(&self) -> bool {
        self.FIELD_NAME5.is_some()
    }
    /// Sets the value of the [`FIELD_NAME5`] field
    ///
    /// [`FIELD_NAME5`]: #method.FIELD_NAME5
    pub fn set_FIELD_NAME5(&mut self, value: i32) {
        self.FIELD_NAME5 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`FIELD_NAME5`] field
    ///
    /// [`FIELD_NAME5`]: #method.FIELD_NAME5
    pub fn clear_FIELD_NAME5(&mut self) {
        self.FIELD_NAME5 = ::std::option::Option::None
    }
    /// Gets the field number of the [`field_name6`] field
    ///
    /// [`field_name6`]: #method.field_name6
    pub const FIELD_NAME6_FIELD_NUMBER: i32 = 6;
    /// A constant value representing the default value of the [`field_name6`] field
    ///
    /// [`field_name6`]: #method.field_name6
    pub const FIELD_NAME6_DEFAULT_VALUE: i32 = 0;
    pub fn field_name6(&self) -> i32 {
        self.field_name6.unwrap_or(Self::FIELD_NAME6_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`field_name6`] field
    ///
    /// [`field_name6`]: #method.field_name6
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn field_name6_option(&self) -> ::std::option::Option<i32> {
        self.field_name6
    }
    /// Returns a bool indicating the presence of the [`field_name6`] field
    ///
    /// [`field_name6`]: #method.field_name6
    pub fn has_field_name6(&self) -> bool {
        self.field_name6.is_some()
    }
    /// Sets the value of the [`field_name6`] field
    ///
    /// [`field_name6`]: #method.field_name6
    pub fn set_field_name6(&mut self, value: i32) {
        self.field_name6 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`field_name6`] field
    ///
    /// [`field_name6`]: #method.field_name6
    pub fn clear_field_name6(&mut self) {
        self.field_name6 = ::std::option::Option::None
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct TestHugeFieldNumbers {
    optional_int32: ::std::option::Option<i32>,
    fixed_32: ::std::option::Option<i32>,
    repeated_int32: ::protrust::collections::RepeatedField<i32>,
    packed_int32: ::protrust::collections::RepeatedField<i32>,
    optional_enum: ::std::option::Option<::protrust::EnumValue<self::ForeignEnum>>,
    optional_string: ::std::option::Option<::std::string::String>,
    optional_bytes: ::std::option::Option<::std::vec::Vec<u8>>,
    optional_message: ::std::option::Option<::std::boxed::Box<self::ForeignMessage>>,
    optionalgroup: ::std::option::Option<::std::boxed::Box<self::test_huge_field_numbers::OptionalGroup>>,
    string_string_map: ::protrust::collections::MapField<::std::string::String, ::std::string::String>,
    oneof_field: self::test_huge_field_numbers::OneofField,
    unknown_fields: ::protrust::UnknownFieldSet,
    extensions: ::protrust::ExtensionSet<Self>,
}
static TEST_HUGE_FIELD_NUMBERS_REPEATED_INT32_CODEC: ::protrust::Codec<i32> = ::protrust::Codec::int32(4294960016);
static TEST_HUGE_FIELD_NUMBERS_PACKED_INT32_CODEC: ::protrust::Codec<i32> = ::protrust::Codec::int32(4294960026);
static TEST_HUGE_FIELD_NUMBERS_STRING_STRING_MAP_CODEC: ::protrust::collections::MapCodec<::std::string::String, ::std::string::String> = ::protrust::collections::MapCodec::new(::protrust::Codec::string(10), ::protrust::Codec::string(18), 4294960082);
impl ::protrust::CodedMessage for self::TestHugeFieldNumbers {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                4294960000 | 4294960002 => self.optional_int32 = ::std::option::Option::Some(input.read_int32()?),
                4294960008 | 4294960010 => self.fixed_32 = ::std::option::Option::Some(input.read_int32()?),
                4294960016 | 4294960018 => self.repeated_int32.add_entries(input, &TEST_HUGE_FIELD_NUMBERS_REPEATED_INT32_CODEC)?,
                4294960024 | 4294960026 => self.packed_int32.add_entries(input, &TEST_HUGE_FIELD_NUMBERS_PACKED_INT32_CODEC)?,
                4294960032 | 4294960034 => self.optional_enum = ::std::option::Option::Some(input.read_enum_value()?),
                4294960042 => self.optional_string = ::std::option::Option::Some(input.read_string()?),
                4294960050 => self.optional_bytes = ::std::option::Option::Some(input.read_bytes()?),
                4294960058 => input.read_message(&mut **self.optional_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                4294960067 => input.read_group(&mut **self.optionalgroup.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())))?,
                4294960082 => self.string_string_map.add_entries(input, &TEST_HUGE_FIELD_NUMBERS_STRING_STRING_MAP_CODEC)?,
                4294960088 | 4294960090 => self.oneof_field = self::test_huge_field_numbers::OneofField::OneofUint32(input.read_uint32()?),
                4294960098 => 
                    if let self::test_huge_field_numbers::OneofField::OneofTestAllTypes(oneof_field) = &mut self.oneof_field {
                        input.read_message(&mut **oneof_field)?;
                    } else {
                        let mut oneof_field = ::std::boxed::Box::new(<self::TestAllTypes as ::protrust::LiteMessage>::new());
                        input.read_message(&mut *oneof_field)?;
                        self.oneof_field = self::test_huge_field_numbers::OneofField::OneofTestAllTypes(oneof_field)
                    },
                4294960106 => self.oneof_field = self::test_huge_field_numbers::OneofField::OneofString(input.read_string()?),
                4294960114 => self.oneof_field = self::test_huge_field_numbers::OneofField::OneofBytes(input.read_bytes()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let optional_int32 = self.optional_int32;
        if let ::std::option::Option::Some(optional_int32) = optional_int32 {
            size += 5;
            size += ::protrust::io::sizes::int32(optional_int32);
        }
        let fixed_32 = self.fixed_32;
        if let ::std::option::Option::Some(fixed_32) = fixed_32 {
            size += 5;
            size += ::protrust::io::sizes::int32(fixed_32);
        }
        size += self.repeated_int32.calculate_size(&TEST_HUGE_FIELD_NUMBERS_REPEATED_INT32_CODEC);
        size += self.packed_int32.calculate_size(&TEST_HUGE_FIELD_NUMBERS_PACKED_INT32_CODEC);
        let optional_enum = self.optional_enum;
        if let ::std::option::Option::Some(optional_enum) = optional_enum {
            size += 5;
            size += ::protrust::io::sizes::enum_value(optional_enum);
        }
        let optional_string = &self.optional_string;
        if let ::std::option::Option::Some(optional_string) = optional_string {
            size += 5;
            size += ::protrust::io::sizes::string(optional_string);
        }
        let optional_bytes = &self.optional_bytes;
        if let ::std::option::Option::Some(optional_bytes) = optional_bytes {
            size += 5;
            size += ::protrust::io::sizes::bytes(optional_bytes);
        }
        let optional_message = &self.optional_message;
        if let ::std::option::Option::Some(optional_message) = optional_message {
            size += 5;
            size += ::protrust::io::sizes::message(&**optional_message);
        }
        let optionalgroup = &self.optionalgroup;
        if let ::std::option::Option::Some(optionalgroup) = optionalgroup {
            size += 5;
            size += ::protrust::io::sizes::group(&**optionalgroup);
            size += 5;
        }
        size += self.string_string_map.calculate_size(&TEST_HUGE_FIELD_NUMBERS_STRING_STRING_MAP_CODEC);
        if let self::test_huge_field_numbers::OneofField::OneofUint32(oneof_field) = self.oneof_field {
            size += 5;
            size += ::protrust::io::sizes::uint32(oneof_field);
        }
        if let self::test_huge_field_numbers::OneofField::OneofTestAllTypes(oneof_field) = &self.oneof_field {
            size += 5;
            size += ::protrust::io::sizes::message(&**oneof_field);
        }
        if let self::test_huge_field_numbers::OneofField::OneofString(oneof_field) = &self.oneof_field {
            size += 5;
            size += ::protrust::io::sizes::string(oneof_field);
        }
        if let self::test_huge_field_numbers::OneofField::OneofBytes(oneof_field) = &self.oneof_field {
            size += 5;
            size += ::protrust::io::sizes::bytes(oneof_field);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let optional_int32 = self.optional_int32;
        if let ::std::option::Option::Some(optional_int32) = optional_int32 {
            output.write_raw_tag_bytes(&[128, 199, 255, 255, 15])?;
            output.write_int32(optional_int32)?;
        }
        let fixed_32 = self.fixed_32;
        if let ::std::option::Option::Some(fixed_32) = fixed_32 {
            output.write_raw_tag_bytes(&[136, 199, 255, 255, 15])?;
            output.write_int32(fixed_32)?;
        }
        self.repeated_int32.write_to(output, &TEST_HUGE_FIELD_NUMBERS_REPEATED_INT32_CODEC)?;
        self.packed_int32.write_to(output, &TEST_HUGE_FIELD_NUMBERS_PACKED_INT32_CODEC)?;
        let optional_enum = self.optional_enum;
        if let ::std::option::Option::Some(optional_enum) = optional_enum {
            output.write_raw_tag_bytes(&[160, 199, 255, 255, 15])?;
            output.write_enum_value(optional_enum)?;
        }
        let optional_string = &self.optional_string;
        if let ::std::option::Option::Some(optional_string) = optional_string {
            output.write_raw_tag_bytes(&[170, 199, 255, 255, 15])?;
            output.write_string(optional_string)?;
        }
        let optional_bytes = &self.optional_bytes;
        if let ::std::option::Option::Some(optional_bytes) = optional_bytes {
            output.write_raw_tag_bytes(&[178, 199, 255, 255, 15])?;
            output.write_bytes(optional_bytes)?;
        }
        let optional_message = &self.optional_message;
        if let ::std::option::Option::Some(optional_message) = optional_message {
            output.write_raw_tag_bytes(&[186, 199, 255, 255, 15])?;
            output.write_message(&**optional_message)?;
        }
        let optionalgroup = &self.optionalgroup;
        if let ::std::option::Option::Some(optionalgroup) = optionalgroup {
            output.write_raw_tag_bytes(&[195, 199, 255, 255, 15])?;
            output.write_group(&**optionalgroup)?;
            output.write_raw_tag_bytes(&[196, 199, 255, 255, 15])?;
        }
        self.string_string_map.write_to(output, &TEST_HUGE_FIELD_NUMBERS_STRING_STRING_MAP_CODEC)?;
        if let self::test_huge_field_numbers::OneofField::OneofUint32(oneof_field) = self.oneof_field {
            output.write_raw_tag_bytes(&[216, 199, 255, 255, 15])?;
            output.write_uint32(oneof_field)?;
        }
        if let self::test_huge_field_numbers::OneofField::OneofTestAllTypes(oneof_field) = &self.oneof_field {
            output.write_raw_tag_bytes(&[226, 199, 255, 255, 15])?;
            output.write_message(&**oneof_field)?;
        }
        if let self::test_huge_field_numbers::OneofField::OneofString(oneof_field) = &self.oneof_field {
            output.write_raw_tag_bytes(&[234, 199, 255, 255, 15])?;
            output.write_string(oneof_field)?;
        }
        if let self::test_huge_field_numbers::OneofField::OneofBytes(oneof_field) = &self.oneof_field {
            output.write_raw_tag_bytes(&[242, 199, 255, 255, 15])?;
            output.write_bytes(oneof_field)?;
        }
        self.unknown_fields.write_to(output)?;
        self.extensions.write_to(output)?;
        ::std::result::Result::Ok(())
    }
    fn is_initialized(&self) -> bool {
        if let Some(optional_message) = &self.optional_message {
            if !::protrust::CodedMessage::is_initialized(&**optional_message) {
                return false;
            }
        }
        if let Some(optionalgroup) = &self.optionalgroup {
            if !::protrust::CodedMessage::is_initialized(&**optionalgroup) {
                return false;
            }
        }
        if let self::test_huge_field_numbers::OneofField::OneofTestAllTypes(oneof_field) = &self.oneof_field {
            if !::protrust::CodedMessage::is_initialized(&**oneof_field) {
                return false;
            }
        }
        true
    }
}
impl ::protrust::LiteMessage for self::TestHugeFieldNumbers {
    fn new() -> Self {
        Self {
            optional_int32: ::std::option::Option::None,
            fixed_32: ::std::option::Option::None,
            repeated_int32: ::protrust::collections::RepeatedField::new(),
            packed_int32: ::protrust::collections::RepeatedField::new(),
            optional_enum: ::std::option::Option::None,
            optional_string: ::std::option::Option::None,
            optional_bytes: ::std::option::Option::None,
            optional_message: ::std::option::Option::None,
            optionalgroup: ::std::option::Option::None,
            string_string_map: ::protrust::collections::MapField::new(),
            oneof_field: self::test_huge_field_numbers::OneofField::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
            extensions: ::protrust::ExtensionSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.optional_int32 = other.optional_int32;
        self.fixed_32 = other.fixed_32;
        self.repeated_int32.merge(&other.repeated_int32);
        self.packed_int32.merge(&other.packed_int32);
        self.optional_enum = other.optional_enum;
        self.optional_string = other.optional_string.clone();
        self.optional_bytes = other.optional_bytes.clone();
        if let ::std::option::Option::Some(optional_message) = &other.optional_message {
            self.optional_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(optional_message);
        }
        if let ::std::option::Option::Some(optionalgroup) = &other.optionalgroup {
            self.optionalgroup.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).merge(optionalgroup);
        }
        self.string_string_map.merge(&other.string_string_map);
        if let self::test_huge_field_numbers::OneofField::OneofUint32(oneof_field) = other.oneof_field {
            self.oneof_field = self::test_huge_field_numbers::OneofField::OneofUint32(oneof_field);
        }
        if let self::test_huge_field_numbers::OneofField::OneofTestAllTypes(oneof_field) = &other.oneof_field {
            if let self::test_huge_field_numbers::OneofField::OneofTestAllTypes(existing) = &mut self.oneof_field {
                existing.merge(oneof_field);
            } else {
                self.oneof_field = self::test_huge_field_numbers::OneofField::OneofTestAllTypes(oneof_field.clone());
            }
        }
        if let self::test_huge_field_numbers::OneofField::OneofString(oneof_field) = &other.oneof_field {
            self.oneof_field = self::test_huge_field_numbers::OneofField::OneofString(oneof_field.clone());
        }
        if let self::test_huge_field_numbers::OneofField::OneofBytes(oneof_field) = &other.oneof_field {
            self.oneof_field = self::test_huge_field_numbers::OneofField::OneofBytes(oneof_field.clone());
        }
        self.unknown_fields.merge(&other.unknown_fields);
        self.extensions.merge(&other.extensions);
    }
}
impl ::protrust::ExtensionMessage for self::TestHugeFieldNumbers {
    fn registry(&self) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> { self.extensions.registry() }
    fn replace_registry(&mut self, extensions: ::std::option::Option<&'static ::protrust::ExtensionRegistry>) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> { self.extensions.replace_registry(extensions) }
    fn field<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::cmp::PartialEq<D> + ::std::fmt::Debug + ::std::marker::Sync, D: ::std::fmt::Debug + ::std::marker::Sync>(&self, extension: &'static ::protrust::Extension<Self, V, D>) -> ::std::option::Option<&::protrust::ExtensionField<V, D>> { self.extensions.field(extension) }
    fn field_mut<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::cmp::PartialEq<D> + ::std::fmt::Debug + ::std::marker::Sync, D: ::std::fmt::Debug + ::std::marker::Sync>(&mut self, extension: &'static ::protrust::Extension<Self, V, D>) -> ::std::option::Option<&mut ::protrust::ExtensionField<V, D>> { self.extensions.field_mut(extension) }
    fn repeated_field<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::fmt::Debug + ::std::marker::Sync + 'static>(&self, extension: &'static ::protrust::RepeatedExtension<Self, V>) -> ::std::option::Option<&::protrust::collections::RepeatedField<V>> { self.extensions.repeated_field(extension) }
    fn repeated_field_mut<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::fmt::Debug + ::std::marker::Sync + 'static>(&mut self, extension: &'static ::protrust::RepeatedExtension<Self, V>) -> ::std::option::Option<&mut ::protrust::collections::RepeatedField<V>> { self.extensions.repeated_field_mut(extension) }
}
impl ::protrust::Message for self::TestHugeFieldNumbers {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[62]
    }
}
impl self::TestHugeFieldNumbers {
    /// Gets the field number of the [`optional_int32`] field
    ///
    /// [`optional_int32`]: #method.optional_int32
    pub const OPTIONAL_INT32_FIELD_NUMBER: i32 = 536870000;
    /// A constant value representing the default value of the [`optional_int32`] field
    ///
    /// [`optional_int32`]: #method.optional_int32
    pub const OPTIONAL_INT32_DEFAULT_VALUE: i32 = 0;
    pub fn optional_int32(&self) -> i32 {
        self.optional_int32.unwrap_or(Self::OPTIONAL_INT32_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`optional_int32`] field
    ///
    /// [`optional_int32`]: #method.optional_int32
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn optional_int32_option(&self) -> ::std::option::Option<i32> {
        self.optional_int32
    }
    /// Returns a bool indicating the presence of the [`optional_int32`] field
    ///
    /// [`optional_int32`]: #method.optional_int32
    pub fn has_optional_int32(&self) -> bool {
        self.optional_int32.is_some()
    }
    /// Sets the value of the [`optional_int32`] field
    ///
    /// [`optional_int32`]: #method.optional_int32
    pub fn set_optional_int32(&mut self, value: i32) {
        self.optional_int32 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`optional_int32`] field
    ///
    /// [`optional_int32`]: #method.optional_int32
    pub fn clear_optional_int32(&mut self) {
        self.optional_int32 = ::std::option::Option::None
    }
    /// Gets the field number of the [`fixed_32`] field
    ///
    /// [`fixed_32`]: #method.fixed_32
    pub const FIXED_32_FIELD_NUMBER: i32 = 536870001;
    /// A constant value representing the default value of the [`fixed_32`] field
    ///
    /// [`fixed_32`]: #method.fixed_32
    pub const FIXED_32_DEFAULT_VALUE: i32 = 0;
    pub fn fixed_32(&self) -> i32 {
        self.fixed_32.unwrap_or(Self::FIXED_32_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`fixed_32`] field
    ///
    /// [`fixed_32`]: #method.fixed_32
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn fixed_32_option(&self) -> ::std::option::Option<i32> {
        self.fixed_32
    }
    /// Returns a bool indicating the presence of the [`fixed_32`] field
    ///
    /// [`fixed_32`]: #method.fixed_32
    pub fn has_fixed_32(&self) -> bool {
        self.fixed_32.is_some()
    }
    /// Sets the value of the [`fixed_32`] field
    ///
    /// [`fixed_32`]: #method.fixed_32
    pub fn set_fixed_32(&mut self, value: i32) {
        self.fixed_32 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`fixed_32`] field
    ///
    /// [`fixed_32`]: #method.fixed_32
    pub fn clear_fixed_32(&mut self) {
        self.fixed_32 = ::std::option::Option::None
    }
    /// Gets the field number of the [`repeated_int32`] field
    ///
    /// [`repeated_int32`]: #method.repeated_int32
    pub const REPEATED_INT32_FIELD_NUMBER: i32 = 536870002;
    pub fn repeated_int32(&self) -> &::protrust::collections::RepeatedField<i32> {
        &self.repeated_int32
    }
    /// Returns a unique reference to the [`repeated_int32`] field
    ///
    /// [`repeated_int32`]: #method.repeated_int32
    pub fn repeated_int32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
        &mut self.repeated_int32
    }
    /// Gets the field number of the [`packed_int32`] field
    ///
    /// [`packed_int32`]: #method.packed_int32
    pub const PACKED_INT32_FIELD_NUMBER: i32 = 536870003;
    pub fn packed_int32(&self) -> &::protrust::collections::RepeatedField<i32> {
        &self.packed_int32
    }
    /// Returns a unique reference to the [`packed_int32`] field
    ///
    /// [`packed_int32`]: #method.packed_int32
    pub fn packed_int32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
        &mut self.packed_int32
    }
    /// Gets the field number of the [`optional_enum`] field
    ///
    /// [`optional_enum`]: #method.optional_enum
    pub const OPTIONAL_ENUM_FIELD_NUMBER: i32 = 536870004;
    /// A constant value representing the default value of the [`optional_enum`] field
    ///
    /// [`optional_enum`]: #method.optional_enum
    pub const OPTIONAL_ENUM_DEFAULT_VALUE: ::protrust::EnumValue<self::ForeignEnum> = ::protrust::EnumValue::Undefined(0);
    pub fn optional_enum(&self) -> ::protrust::EnumValue<self::ForeignEnum> {
        self.optional_enum.unwrap_or(Self::OPTIONAL_ENUM_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`optional_enum`] field
    ///
    /// [`optional_enum`]: #method.optional_enum
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn optional_enum_option(&self) -> ::std::option::Option<::protrust::EnumValue<self::ForeignEnum>> {
        self.optional_enum
    }
    /// Returns a bool indicating the presence of the [`optional_enum`] field
    ///
    /// [`optional_enum`]: #method.optional_enum
    pub fn has_optional_enum(&self) -> bool {
        self.optional_enum.is_some()
    }
    /// Sets the value of the [`optional_enum`] field
    ///
    /// [`optional_enum`]: #method.optional_enum
    pub fn set_optional_enum(&mut self, value: ::protrust::EnumValue<self::ForeignEnum>) {
        self.optional_enum = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`optional_enum`] field
    ///
    /// [`optional_enum`]: #method.optional_enum
    pub fn clear_optional_enum(&mut self) {
        self.optional_enum = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_string`] field
    ///
    /// [`optional_string`]: #method.optional_string
    pub const OPTIONAL_STRING_FIELD_NUMBER: i32 = 536870005;
    /// A constant value representing the default value of the [`optional_string`] field
    ///
    /// [`optional_string`]: #method.optional_string
    pub const OPTIONAL_STRING_DEFAULT_VALUE: &'static str = "";
    pub fn optional_string(&self) -> &str {
        self.optional_string.as_ref().map(|v| &**v).unwrap_or(Self::OPTIONAL_STRING_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`optional_string`] field
    ///
    /// [`optional_string`]: #method.optional_string
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn optional_string_option(&self) -> ::std::option::Option<&::std::string::String> {
        self.optional_string.as_ref()
    }
    /// Returns a unique reference to the [`optional_string`] field
    ///
    /// [`optional_string`]: #method.optional_string
    pub fn optional_string_mut(&mut self) -> &mut ::std::string::String {
        self.optional_string.get_or_insert_with(::std::string::String::new)
    }
    /// Returns a bool indicating the presence of the [`optional_string`] field
    ///
    /// [`optional_string`]: #method.optional_string
    pub fn has_optional_string(&self) -> bool {
        self.optional_string.is_some()
    }
    /// Sets the value of the [`optional_string`] field
    ///
    /// [`optional_string`]: #method.optional_string
    pub fn set_optional_string(&mut self, value: ::std::string::String) {
        self.optional_string = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`optional_string`] field, leaving it empty
    ///
    /// [`optional_string`]: #method.optional_string
    pub fn take_optional_string(&mut self) -> ::std::option::Option<::std::string::String> {
        self.optional_string.take()
    }
    /// Clears the value of the [`optional_string`] field
    ///
    /// [`optional_string`]: #method.optional_string
    pub fn clear_optional_string(&mut self) {
        self.optional_string = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_bytes`] field
    ///
    /// [`optional_bytes`]: #method.optional_bytes
    pub const OPTIONAL_BYTES_FIELD_NUMBER: i32 = 536870006;
    /// A constant value representing the default value of the [`optional_bytes`] field
    ///
    /// [`optional_bytes`]: #method.optional_bytes
    pub const OPTIONAL_BYTES_DEFAULT_VALUE: &'static [u8] = &[];
    pub fn optional_bytes(&self) -> &[u8] {
        self.optional_bytes.as_ref().map(|v| &**v).unwrap_or(Self::OPTIONAL_BYTES_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`optional_bytes`] field
    ///
    /// [`optional_bytes`]: #method.optional_bytes
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn optional_bytes_option(&self) -> ::std::option::Option<&::std::vec::Vec<u8>> {
        self.optional_bytes.as_ref()
    }
    /// Returns a unique reference to the [`optional_bytes`] field
    ///
    /// [`optional_bytes`]: #method.optional_bytes
    pub fn optional_bytes_mut(&mut self) -> &mut ::std::vec::Vec<u8> {
        self.optional_bytes.get_or_insert_with(::std::vec::Vec::new)
    }
    /// Returns a bool indicating the presence of the [`optional_bytes`] field
    ///
    /// [`optional_bytes`]: #method.optional_bytes
    pub fn has_optional_bytes(&self) -> bool {
        self.optional_bytes.is_some()
    }
    /// Sets the value of the [`optional_bytes`] field
    ///
    /// [`optional_bytes`]: #method.optional_bytes
    pub fn set_optional_bytes(&mut self, value: ::std::vec::Vec<u8>) {
        self.optional_bytes = ::std::option::Option::Some(value)
    }
    /// Takes the value of the [`optional_bytes`] field, leaving it empty
    ///
    /// [`optional_bytes`]: #method.optional_bytes
    pub fn take_optional_bytes(&mut self) -> ::std::option::Option<::std::vec::Vec<u8>> {
        self.optional_bytes.take()
    }
    /// Clears the value of the [`optional_bytes`] field
    ///
    /// [`optional_bytes`]: #method.optional_bytes
    pub fn clear_optional_bytes(&mut self) {
        self.optional_bytes = ::std::option::Option::None
    }
    /// Gets the field number of the [`optional_message`] field
    ///
    /// [`optional_message`]: #method.optional_message
    pub const OPTIONAL_MESSAGE_FIELD_NUMBER: i32 = 536870007;
    pub fn optional_message_option(&self) -> ::std::option::Option<&self::ForeignMessage> {
        self.optional_message.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`optional_message`] field
    ///
    /// [`optional_message`]: #method.optional_message
    pub fn optional_message_mut(&mut self) -> &mut self::ForeignMessage {
        self.optional_message.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`optional_message`] field
    ///
    /// [`optional_message`]: #method.optional_message
    pub fn has_optional_message(&self) -> bool {
        self.optional_message.is_some()
    }
    /// Sets the value of the [`optional_message`] field
    ///
    /// [`optional_message`]: #method.optional_message
    pub fn set_optional_message(&mut self, value: self::ForeignMessage) {
        self.optional_message = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`optional_message`] field, leaving it empty
    ///
    /// [`optional_message`]: #method.optional_message
    pub fn take_optional_message(&mut self) -> ::std::option::Option<self::ForeignMessage> {
        self.optional_message.take().map(|b| *b)
    }
    /// Clears the value of the [`optional_message`] field
    ///
    /// [`optional_message`]: #method.optional_message
    pub fn clear_optional_message(&mut self) {
        self.optional_message = ::std::option::Option::None
    }
    /// Gets the field number of the [`optionalgroup`] field
    ///
    /// [`optionalgroup`]: #method.optionalgroup
    pub const OPTIONALGROUP_FIELD_NUMBER: i32 = 536870008;
    pub fn optionalgroup_option(&self) -> ::std::option::Option<&self::test_huge_field_numbers::OptionalGroup> {
        self.optionalgroup.as_ref().map(|b| &**b)
    }
    /// Returns a unique reference to the [`optionalgroup`] field
    ///
    /// [`optionalgroup`]: #method.optionalgroup
    pub fn optionalgroup_mut(&mut self) -> &mut self::test_huge_field_numbers::OptionalGroup {
        self.optionalgroup.get_or_insert_with(|| ::std::boxed::Box::new(::protrust::LiteMessage::new())).as_mut()
    }
    /// Returns a bool indicating the presence of the [`optionalgroup`] field
    ///
    /// [`optionalgroup`]: #method.optionalgroup
    pub fn has_optionalgroup(&self) -> bool {
        self.optionalgroup.is_some()
    }
    /// Sets the value of the [`optionalgroup`] field
    ///
    /// [`optionalgroup`]: #method.optionalgroup
    pub fn set_optionalgroup(&mut self, value: self::test_huge_field_numbers::OptionalGroup) {
        self.optionalgroup = ::std::option::Option::Some(::std::boxed::Box::new(value))
    }
    /// Takes the value of the [`optionalgroup`] field, leaving it empty
    ///
    /// [`optionalgroup`]: #method.optionalgroup
    pub fn take_optionalgroup(&mut self) -> ::std::option::Option<self::test_huge_field_numbers::OptionalGroup> {
        self.optionalgroup.take().map(|b| *b)
    }
    /// Clears the value of the [`optionalgroup`] field
    ///
    /// [`optionalgroup`]: #method.optionalgroup
    pub fn clear_optionalgroup(&mut self) {
        self.optionalgroup = ::std::option::Option::None
    }
    /// Gets the field number of the [`string_string_map`] field
    ///
    /// [`string_string_map`]: #method.string_string_map
    pub const STRING_STRING_MAP_FIELD_NUMBER: i32 = 536870010;
    pub fn string_string_map(&self) -> &::protrust::collections::MapField<::std::string::String, ::std::string::String> {
        &self.string_string_map
    }
    /// Returns a unique reference to the [`string_string_map`] field
    ///
    /// [`string_string_map`]: #method.string_string_map
    pub fn string_string_map_mut(&mut self) -> &mut ::protrust::collections::MapField<::std::string::String, ::std::string::String> {
        &mut self.string_string_map
    }
    /// Gets a shared reference to the [`oneof_field`] oneof field
    ///
    /// [`oneof_field`]: enum.OneofField.html
    pub fn oneof_field(&self) -> &self::test_huge_field_numbers::OneofField {
        &self.oneof_field
    }
    /// Gets a unique reference to the [`oneof_field`] oneof field
    ///
    /// [`oneof_field`]: enum.OneofField.html
    pub fn oneof_field_mut(&mut self) -> &mut self::test_huge_field_numbers::OneofField {
        &mut self.oneof_field
    }
}
pub mod test_huge_field_numbers {
    #[derive(Clone, Debug, PartialEq)]
    pub struct OptionalGroup {
        group_a: ::std::option::Option<i32>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::OptionalGroup {
        fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    4294960072 | 4294960074 => self.group_a = ::std::option::Option::Some(input.read_int32()?),
                    4294960068 => break,
                    _ => self.unknown_fields.merge_from(tag, input)?
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            let group_a = self.group_a;
            if let ::std::option::Option::Some(group_a) = group_a {
                size += 5;
                size += ::protrust::io::sizes::int32(group_a);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
            let group_a = self.group_a;
            if let ::std::option::Option::Some(group_a) = group_a {
                output.write_raw_tag_bytes(&[200, 199, 255, 255, 15])?;
                output.write_int32(group_a)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
    }
    impl ::protrust::LiteMessage for self::OptionalGroup {
        fn new() -> Self {
            Self {
                group_a: ::std::option::Option::None,
                unknown_fields: ::protrust::UnknownFieldSet::new(),
            }
        }
        fn merge(&mut self, other: &Self) {
            self.group_a = other.group_a;
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::OptionalGroup {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
            &self::super::file().messages()[62].messages()[0]
        }
    }
    impl self::OptionalGroup {
        /// Gets the field number of the [`group_a`] field
        ///
        /// [`group_a`]: #method.group_a
        pub const GROUP_A_FIELD_NUMBER: i32 = 536870009;
        /// A constant value representing the default value of the [`group_a`] field
        ///
        /// [`group_a`]: #method.group_a
        pub const GROUP_A_DEFAULT_VALUE: i32 = 0;
        pub fn group_a(&self) -> i32 {
            self.group_a.unwrap_or(Self::GROUP_A_DEFAULT_VALUE)
        }
        /// Returns an [`Option`] representing the presence of the [`group_a`] field
        ///
        /// [`group_a`]: #method.group_a
        /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
        pub fn group_a_option(&self) -> ::std::option::Option<i32> {
            self.group_a
        }
        /// Returns a bool indicating the presence of the [`group_a`] field
        ///
        /// [`group_a`]: #method.group_a
        pub fn has_group_a(&self) -> bool {
            self.group_a.is_some()
        }
        /// Sets the value of the [`group_a`] field
        ///
        /// [`group_a`]: #method.group_a
        pub fn set_group_a(&mut self, value: i32) {
            self.group_a = ::std::option::Option::Some(value)
        }
        /// Clears the value of the [`group_a`] field
        ///
        /// [`group_a`]: #method.group_a
        pub fn clear_group_a(&mut self) {
            self.group_a = ::std::option::Option::None
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    pub enum OneofField {
        /// No value
        None,
        OneofUint32(u32),
        OneofTestAllTypes(::std::boxed::Box<self::super::TestAllTypes>),
        OneofString(::std::string::String),
        OneofBytes(::std::vec::Vec<u8>),
    }
}
#[derive(Clone, Debug, PartialEq)]
pub struct TestExtensionInsideTable {
    field1: ::std::option::Option<i32>,
    field2: ::std::option::Option<i32>,
    field3: ::std::option::Option<i32>,
    field4: ::std::option::Option<i32>,
    field6: ::std::option::Option<i32>,
    field7: ::std::option::Option<i32>,
    field8: ::std::option::Option<i32>,
    field9: ::std::option::Option<i32>,
    field10: ::std::option::Option<i32>,
    unknown_fields: ::protrust::UnknownFieldSet,
    extensions: ::protrust::ExtensionSet<Self>,
}
impl ::protrust::CodedMessage for self::TestExtensionInsideTable {
    fn merge_from(&mut self, input: &mut ::protrust::io::CodedInput) -> ::protrust::io::InputResult<()> {
        while let ::std::option::Option::Some(tag) = input.read_tag()? {
            match tag.get() {
                8 | 10 => self.field1 = ::std::option::Option::Some(input.read_int32()?),
                16 | 18 => self.field2 = ::std::option::Option::Some(input.read_int32()?),
                24 | 26 => self.field3 = ::std::option::Option::Some(input.read_int32()?),
                32 | 34 => self.field4 = ::std::option::Option::Some(input.read_int32()?),
                48 | 50 => self.field6 = ::std::option::Option::Some(input.read_int32()?),
                56 | 58 => self.field7 = ::std::option::Option::Some(input.read_int32()?),
                64 | 66 => self.field8 = ::std::option::Option::Some(input.read_int32()?),
                72 | 74 => self.field9 = ::std::option::Option::Some(input.read_int32()?),
                80 | 82 => self.field10 = ::std::option::Option::Some(input.read_int32()?),
                _ => self.unknown_fields.merge_from(tag, input)?
            }
        }
        ::std::result::Result::Ok(())
    }
    fn calculate_size(&self) -> i32 {
        let mut size = 0i32;
        let field1 = self.field1;
        if let ::std::option::Option::Some(field1) = field1 {
            size += 1;
            size += ::protrust::io::sizes::int32(field1);
        }
        let field2 = self.field2;
        if let ::std::option::Option::Some(field2) = field2 {
            size += 1;
            size += ::protrust::io::sizes::int32(field2);
        }
        let field3 = self.field3;
        if let ::std::option::Option::Some(field3) = field3 {
            size += 1;
            size += ::protrust::io::sizes::int32(field3);
        }
        let field4 = self.field4;
        if let ::std::option::Option::Some(field4) = field4 {
            size += 1;
            size += ::protrust::io::sizes::int32(field4);
        }
        let field6 = self.field6;
        if let ::std::option::Option::Some(field6) = field6 {
            size += 1;
            size += ::protrust::io::sizes::int32(field6);
        }
        let field7 = self.field7;
        if let ::std::option::Option::Some(field7) = field7 {
            size += 1;
            size += ::protrust::io::sizes::int32(field7);
        }
        let field8 = self.field8;
        if let ::std::option::Option::Some(field8) = field8 {
            size += 1;
            size += ::protrust::io::sizes::int32(field8);
        }
        let field9 = self.field9;
        if let ::std::option::Option::Some(field9) = field9 {
            size += 1;
            size += ::protrust::io::sizes::int32(field9);
        }
        let field10 = self.field10;
        if let ::std::option::Option::Some(field10) = field10 {
            size += 1;
            size += ::protrust::io::sizes::int32(field10);
        }
        size += self.unknown_fields.calculate_size();
        size
    }
    fn write_to(&self, output: &mut ::protrust::io::CodedOutput) -> ::protrust::io::OutputResult {
        let field1 = self.field1;
        if let ::std::option::Option::Some(field1) = field1 {
            output.write_raw_tag_bytes(&[8])?;
            output.write_int32(field1)?;
        }
        let field2 = self.field2;
        if let ::std::option::Option::Some(field2) = field2 {
            output.write_raw_tag_bytes(&[16])?;
            output.write_int32(field2)?;
        }
        let field3 = self.field3;
        if let ::std::option::Option::Some(field3) = field3 {
            output.write_raw_tag_bytes(&[24])?;
            output.write_int32(field3)?;
        }
        let field4 = self.field4;
        if let ::std::option::Option::Some(field4) = field4 {
            output.write_raw_tag_bytes(&[32])?;
            output.write_int32(field4)?;
        }
        let field6 = self.field6;
        if let ::std::option::Option::Some(field6) = field6 {
            output.write_raw_tag_bytes(&[48])?;
            output.write_int32(field6)?;
        }
        let field7 = self.field7;
        if let ::std::option::Option::Some(field7) = field7 {
            output.write_raw_tag_bytes(&[56])?;
            output.write_int32(field7)?;
        }
        let field8 = self.field8;
        if let ::std::option::Option::Some(field8) = field8 {
            output.write_raw_tag_bytes(&[64])?;
            output.write_int32(field8)?;
        }
        let field9 = self.field9;
        if let ::std::option::Option::Some(field9) = field9 {
            output.write_raw_tag_bytes(&[72])?;
            output.write_int32(field9)?;
        }
        let field10 = self.field10;
        if let ::std::option::Option::Some(field10) = field10 {
            output.write_raw_tag_bytes(&[80])?;
            output.write_int32(field10)?;
        }
        self.unknown_fields.write_to(output)?;
        self.extensions.write_to(output)?;
        ::std::result::Result::Ok(())
    }
}
impl ::protrust::LiteMessage for self::TestExtensionInsideTable {
    fn new() -> Self {
        Self {
            field1: ::std::option::Option::None,
            field2: ::std::option::Option::None,
            field3: ::std::option::Option::None,
            field4: ::std::option::Option::None,
            field6: ::std::option::Option::None,
            field7: ::std::option::Option::None,
            field8: ::std::option::Option::None,
            field9: ::std::option::Option::None,
            field10: ::std::option::Option::None,
            unknown_fields: ::protrust::UnknownFieldSet::new(),
            extensions: ::protrust::ExtensionSet::new(),
        }
    }
    fn merge(&mut self, other: &Self) {
        self.field1 = other.field1;
        self.field2 = other.field2;
        self.field3 = other.field3;
        self.field4 = other.field4;
        self.field6 = other.field6;
        self.field7 = other.field7;
        self.field8 = other.field8;
        self.field9 = other.field9;
        self.field10 = other.field10;
        self.unknown_fields.merge(&other.unknown_fields);
        self.extensions.merge(&other.extensions);
    }
}
impl ::protrust::ExtensionMessage for self::TestExtensionInsideTable {
    fn registry(&self) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> { self.extensions.registry() }
    fn replace_registry(&mut self, extensions: ::std::option::Option<&'static ::protrust::ExtensionRegistry>) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> { self.extensions.replace_registry(extensions) }
    fn field<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::cmp::PartialEq<D> + ::std::fmt::Debug + ::std::marker::Sync, D: ::std::fmt::Debug + ::std::marker::Sync>(&self, extension: &'static ::protrust::Extension<Self, V, D>) -> ::std::option::Option<&::protrust::ExtensionField<V, D>> { self.extensions.field(extension) }
    fn field_mut<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::cmp::PartialEq<D> + ::std::fmt::Debug + ::std::marker::Sync, D: ::std::fmt::Debug + ::std::marker::Sync>(&mut self, extension: &'static ::protrust::Extension<Self, V, D>) -> ::std::option::Option<&mut ::protrust::ExtensionField<V, D>> { self.extensions.field_mut(extension) }
    fn repeated_field<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::fmt::Debug + ::std::marker::Sync + 'static>(&self, extension: &'static ::protrust::RepeatedExtension<Self, V>) -> ::std::option::Option<&::protrust::collections::RepeatedField<V>> { self.extensions.repeated_field(extension) }
    fn repeated_field_mut<V: ::std::clone::Clone + ::std::cmp::PartialEq + ::std::fmt::Debug + ::std::marker::Sync + 'static>(&mut self, extension: &'static ::protrust::RepeatedExtension<Self, V>) -> ::std::option::Option<&mut ::protrust::collections::RepeatedField<V>> { self.extensions.repeated_field_mut(extension) }
}
impl ::protrust::Message for self::TestExtensionInsideTable {
    fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor {
        &self::file().messages()[63]
    }
}
impl self::TestExtensionInsideTable {
    /// Gets the field number of the [`field1`] field
    ///
    /// [`field1`]: #method.field1
    pub const FIELD1_FIELD_NUMBER: i32 = 1;
    /// A constant value representing the default value of the [`field1`] field
    ///
    /// [`field1`]: #method.field1
    pub const FIELD1_DEFAULT_VALUE: i32 = 0;
    pub fn field1(&self) -> i32 {
        self.field1.unwrap_or(Self::FIELD1_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`field1`] field
    ///
    /// [`field1`]: #method.field1
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn field1_option(&self) -> ::std::option::Option<i32> {
        self.field1
    }
    /// Returns a bool indicating the presence of the [`field1`] field
    ///
    /// [`field1`]: #method.field1
    pub fn has_field1(&self) -> bool {
        self.field1.is_some()
    }
    /// Sets the value of the [`field1`] field
    ///
    /// [`field1`]: #method.field1
    pub fn set_field1(&mut self, value: i32) {
        self.field1 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`field1`] field
    ///
    /// [`field1`]: #method.field1
    pub fn clear_field1(&mut self) {
        self.field1 = ::std::option::Option::None
    }
    /// Gets the field number of the [`field2`] field
    ///
    /// [`field2`]: #method.field2
    pub const FIELD2_FIELD_NUMBER: i32 = 2;
    /// A constant value representing the default value of the [`field2`] field
    ///
    /// [`field2`]: #method.field2
    pub const FIELD2_DEFAULT_VALUE: i32 = 0;
    pub fn field2(&self) -> i32 {
        self.field2.unwrap_or(Self::FIELD2_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`field2`] field
    ///
    /// [`field2`]: #method.field2
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn field2_option(&self) -> ::std::option::Option<i32> {
        self.field2
    }
    /// Returns a bool indicating the presence of the [`field2`] field
    ///
    /// [`field2`]: #method.field2
    pub fn has_field2(&self) -> bool {
        self.field2.is_some()
    }
    /// Sets the value of the [`field2`] field
    ///
    /// [`field2`]: #method.field2
    pub fn set_field2(&mut self, value: i32) {
        self.field2 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`field2`] field
    ///
    /// [`field2`]: #method.field2
    pub fn clear_field2(&mut self) {
        self.field2 = ::std::option::Option::None
    }
    /// Gets the field number of the [`field3`] field
    ///
    /// [`field3`]: #method.field3
    pub const FIELD3_FIELD_NUMBER: i32 = 3;
    /// A constant value representing the default value of the [`field3`] field
    ///
    /// [`field3`]: #method.field3
    pub const FIELD3_DEFAULT_VALUE: i32 = 0;
    pub fn field3(&self) -> i32 {
        self.field3.unwrap_or(Self::FIELD3_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`field3`] field
    ///
    /// [`field3`]: #method.field3
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn field3_option(&self) -> ::std::option::Option<i32> {
        self.field3
    }
    /// Returns a bool indicating the presence of the [`field3`] field
    ///
    /// [`field3`]: #method.field3
    pub fn has_field3(&self) -> bool {
        self.field3.is_some()
    }
    /// Sets the value of the [`field3`] field
    ///
    /// [`field3`]: #method.field3
    pub fn set_field3(&mut self, value: i32) {
        self.field3 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`field3`] field
    ///
    /// [`field3`]: #method.field3
    pub fn clear_field3(&mut self) {
        self.field3 = ::std::option::Option::None
    }
    /// Gets the field number of the [`field4`] field
    ///
    /// [`field4`]: #method.field4
    pub const FIELD4_FIELD_NUMBER: i32 = 4;
    /// A constant value representing the default value of the [`field4`] field
    ///
    /// [`field4`]: #method.field4
    pub const FIELD4_DEFAULT_VALUE: i32 = 0;
    pub fn field4(&self) -> i32 {
        self.field4.unwrap_or(Self::FIELD4_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`field4`] field
    ///
    /// [`field4`]: #method.field4
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn field4_option(&self) -> ::std::option::Option<i32> {
        self.field4
    }
    /// Returns a bool indicating the presence of the [`field4`] field
    ///
    /// [`field4`]: #method.field4
    pub fn has_field4(&self) -> bool {
        self.field4.is_some()
    }
    /// Sets the value of the [`field4`] field
    ///
    /// [`field4`]: #method.field4
    pub fn set_field4(&mut self, value: i32) {
        self.field4 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`field4`] field
    ///
    /// [`field4`]: #method.field4
    pub fn clear_field4(&mut self) {
        self.field4 = ::std::option::Option::None
    }
    /// Gets the field number of the [`field6`] field
    ///
    /// [`field6`]: #method.field6
    pub const FIELD6_FIELD_NUMBER: i32 = 6;
    /// A constant value representing the default value of the [`field6`] field
    ///
    /// [`field6`]: #method.field6
    pub const FIELD6_DEFAULT_VALUE: i32 = 0;
    pub fn field6(&self) -> i32 {
        self.field6.unwrap_or(Self::FIELD6_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`field6`] field
    ///
    /// [`field6`]: #method.field6
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn field6_option(&self) -> ::std::option::Option<i32> {
        self.field6
    }
    /// Returns a bool indicating the presence of the [`field6`] field
    ///
    /// [`field6`]: #method.field6
    pub fn has_field6(&self) -> bool {
        self.field6.is_some()
    }
    /// Sets the value of the [`field6`] field
    ///
    /// [`field6`]: #method.field6
    pub fn set_field6(&mut self, value: i32) {
        self.field6 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`field6`] field
    ///
    /// [`field6`]: #method.field6
    pub fn clear_field6(&mut self) {
        self.field6 = ::std::option::Option::None
    }
    /// Gets the field number of the [`field7`] field
    ///
    /// [`field7`]: #method.field7
    pub const FIELD7_FIELD_NUMBER: i32 = 7;
    /// A constant value representing the default value of the [`field7`] field
    ///
    /// [`field7`]: #method.field7
    pub const FIELD7_DEFAULT_VALUE: i32 = 0;
    pub fn field7(&self) -> i32 {
        self.field7.unwrap_or(Self::FIELD7_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`field7`] field
    ///
    /// [`field7`]: #method.field7
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn field7_option(&self) -> ::std::option::Option<i32> {
        self.field7
    }
    /// Returns a bool indicating the presence of the [`field7`] field
    ///
    /// [`field7`]: #method.field7
    pub fn has_field7(&self) -> bool {
        self.field7.is_some()
    }
    /// Sets the value of the [`field7`] field
    ///
    /// [`field7`]: #method.field7
    pub fn set_field7(&mut self, value: i32) {
        self.field7 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`field7`] field
    ///
    /// [`field7`]: #method.field7
    pub fn clear_field7(&mut self) {
        self.field7 = ::std::option::Option::None
    }
    /// Gets the field number of the [`field8`] field
    ///
    /// [`field8`]: #method.field8
    pub const FIELD8_FIELD_NUMBER: i32 = 8;
    /// A constant value representing the default value of the [`field8`] field
    ///
    /// [`field8`]: #method.field8
    pub const FIELD8_DEFAULT_VALUE: i32 = 0;
    pub fn field8(&self) -> i32 {
        self.field8.unwrap_or(Self::FIELD8_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`field8`] field
    ///
    /// [`field8`]: #method.field8
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn field8_option(&self) -> ::std::option::Option<i32> {
        self.field8
    }
    /// Returns a bool indicating the presence of the [`field8`] field
    ///
    /// [`field8`]: #method.field8
    pub fn has_field8(&self) -> bool {
        self.field8.is_some()
    }
    /// Sets the value of the [`field8`] field
    ///
    /// [`field8`]: #method.field8
    pub fn set_field8(&mut self, value: i32) {
        self.field8 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`field8`] field
    ///
    /// [`field8`]: #method.field8
    pub fn clear_field8(&mut self) {
        self.field8 = ::std::option::Option::None
    }
    /// Gets the field number of the [`field9`] field
    ///
    /// [`field9`]: #method.field9
    pub const FIELD9_FIELD_NUMBER: i32 = 9;
    /// A constant value representing the default value of the [`field9`] field
    ///
    /// [`field9`]: #method.field9
    pub const FIELD9_DEFAULT_VALUE: i32 = 0;
    pub fn field9(&self) -> i32 {
        self.field9.unwrap_or(Self::FIELD9_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`field9`] field
    ///
    /// [`field9`]: #method.field9
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn field9_option(&self) -> ::std::option::Option<i32> {
        self.field9
    }
    /// Returns a bool indicating the presence of the [`field9`] field
    ///
    /// [`field9`]: #method.field9
    pub fn has_field9(&self) -> bool {
        self.field9.is_some()
    }
    /// Sets the value of the [`field9`] field
    ///
    /// [`field9`]: #method.field9
    pub fn set_field9(&mut self, value: i32) {
        self.field9 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`field9`] field
    ///
    /// [`field9`]: #method.field9
    pub fn clear_field9(&mut self) {
        self.field9 = ::std::option::Option::None
    }
    /// Gets the field number of the [`field10`] field
    ///
    /// [`field10`]: #method.field10
    pub const FIELD10_FIELD_NUMBER: i32 = 10;
    /// A constant value representing the default value of the [`field10`] field
    ///
    /// [`field10`]: #method.field10
    pub const FIELD10_DEFAULT_VALUE: i32 = 0;
    pub fn field10(&self) -> i32 {
        self.field10.unwrap_or(Self::FIELD10_DEFAULT_VALUE)
    }
    /// Returns an [`Option`] representing the presence of the [`field10`] field
    ///
    /// [`field10`]: #method.field10
    /// [`Option`]: https://doc.rust-lang.org/std/option/enum.Option.html
    pub fn field10_option(&self) -> ::std::option::Option<i32> {
        self.field10
    }
    /// Returns a bool indicating the presence of the [`field10`] field
    ///
    /// [`field10`]: #method.field10
    pub fn has_field10(&self) -> bool {
        self.field10.is_some()
    }
    /// Sets the value of the [`field10`] field
    ///
    /// [`field10`]: #method.field10
    pub fn set_field10(&mut self, value: i32) {
        self.field10 = ::std::option::Option::Some(value)
    }
    /// Clears the value of the [`field10`] field
    ///
    /// [`field10`]: #method.field10
    pub fn clear_field10(&mut self) {
        self.field10 = ::std::option::Option::None
    }
}
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum ForeignEnum {
    ForeignFoo,
    ForeignBar,
    ForeignBaz,
}
unsafe impl ::protrust::Enum for self::ForeignEnum { }
impl ::std::convert::TryFrom<i32> for self::ForeignEnum {
    type Error = ::protrust::VariantUndefinedError;
    fn try_from(value: i32) -> ::std::result::Result<Self, ::protrust::VariantUndefinedError> {
        #[allow(unreachable_patterns)]
        match value {
            4 => ::std::result::Result::Ok(self::ForeignEnum::ForeignFoo),
            5 => ::std::result::Result::Ok(self::ForeignEnum::ForeignBar),
            6 => ::std::result::Result::Ok(self::ForeignEnum::ForeignBaz),
            _ => ::std::result::Result::Err(::protrust::VariantUndefinedError)
        }
    }
}
impl ::std::convert::From<self::ForeignEnum> for i32 {
    fn from(value: self::ForeignEnum) -> i32 {
        match value {
            ForeignEnum::ForeignFoo => 4,
            ForeignEnum::ForeignBar => 5,
            ForeignEnum::ForeignBaz => 6,
        }
    }
}
/// Test an enum that has multiple values with the same number.
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TestEnumWithDupValue {
    Foo1,
    Bar1,
    Baz,
    Foo2,
    Bar2,
}
unsafe impl ::protrust::Enum for self::TestEnumWithDupValue { }
impl ::std::convert::TryFrom<i32> for self::TestEnumWithDupValue {
    type Error = ::protrust::VariantUndefinedError;
    fn try_from(value: i32) -> ::std::result::Result<Self, ::protrust::VariantUndefinedError> {
        #[allow(unreachable_patterns)]
        match value {
            1 => ::std::result::Result::Ok(self::TestEnumWithDupValue::Foo1),
            2 => ::std::result::Result::Ok(self::TestEnumWithDupValue::Bar1),
            3 => ::std::result::Result::Ok(self::TestEnumWithDupValue::Baz),
            1 => ::std::result::Result::Ok(self::TestEnumWithDupValue::Foo2),
            2 => ::std::result::Result::Ok(self::TestEnumWithDupValue::Bar2),
            _ => ::std::result::Result::Err(::protrust::VariantUndefinedError)
        }
    }
}
impl ::std::convert::From<self::TestEnumWithDupValue> for i32 {
    fn from(value: self::TestEnumWithDupValue) -> i32 {
        match value {
            TestEnumWithDupValue::Foo1 => 1,
            TestEnumWithDupValue::Bar1 => 2,
            TestEnumWithDupValue::Baz => 3,
            TestEnumWithDupValue::Foo2 => 1,
            TestEnumWithDupValue::Bar2 => 2,
        }
    }
}
/// Test an enum with large, unordered values.
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum TestSparseEnum {
    SparseA,
    SparseB,
    SparseC,
    SparseD,
    SparseE,
    SparseF,
    SparseG,
}
unsafe impl ::protrust::Enum for self::TestSparseEnum { }
impl ::std::convert::TryFrom<i32> for self::TestSparseEnum {
    type Error = ::protrust::VariantUndefinedError;
    fn try_from(value: i32) -> ::std::result::Result<Self, ::protrust::VariantUndefinedError> {
        #[allow(unreachable_patterns)]
        match value {
            123 => ::std::result::Result::Ok(self::TestSparseEnum::SparseA),
            62374 => ::std::result::Result::Ok(self::TestSparseEnum::SparseB),
            12589234 => ::std::result::Result::Ok(self::TestSparseEnum::SparseC),
            -15 => ::std::result::Result::Ok(self::TestSparseEnum::SparseD),
            -53452 => ::std::result::Result::Ok(self::TestSparseEnum::SparseE),
            0 => ::std::result::Result::Ok(self::TestSparseEnum::SparseF),
            2 => ::std::result::Result::Ok(self::TestSparseEnum::SparseG),
            _ => ::std::result::Result::Err(::protrust::VariantUndefinedError)
        }
    }
}
impl ::std::convert::From<self::TestSparseEnum> for i32 {
    fn from(value: self::TestSparseEnum) -> i32 {
        match value {
            TestSparseEnum::SparseA => 123,
            TestSparseEnum::SparseB => 62374,
            TestSparseEnum::SparseC => 12589234,
            TestSparseEnum::SparseD => -15,
            TestSparseEnum::SparseE => -53452,
            TestSparseEnum::SparseF => 0,
            TestSparseEnum::SparseG => 2,
        }
    }
}