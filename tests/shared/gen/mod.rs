/* generated by protoc-gen-rust */

mod externals {}
static mut EXTERNAL_REGISTRIES: ::std::option::Option<[&'static ::protrust::ExtensionRegistry; 0]> =
    ::std::option::Option::None;
static mut EXTENSIONS_REGISTRY: ::std::option::Option<::protrust::ExtensionRegistry> =
    ::std::option::Option::None;
static EXTENSIONS_INIT: ::std::sync::Once = ::std::sync::Once::new();
fn extensions_init() {
    unsafe {
        self::EXTERNAL_REGISTRIES = ::std::option::Option::Some([]);
        self :: EXTENSIONS_REGISTRY = :: std :: option :: Option :: Some ( :: protrust :: ExtensionRegistry :: new ( self :: EXTERNAL_REGISTRIES . as_ref ( ) . unwrap ( ) , & [ ( :: std :: any :: TypeId :: of :: < self :: unittest_proto :: TestFieldOrderings > ( ) , & [ & self :: unittest_proto :: MY_EXTENSION_STRING , & self :: unittest_proto :: MY_EXTENSION_INT , & self :: unittest_proto :: test_extension_orderings1 :: TEST_EXT_ORDERINGS1 , & self :: unittest_proto :: test_extension_orderings2 :: TEST_EXT_ORDERINGS2 , & self :: unittest_proto :: test_extension_orderings2 :: test_extension_orderings3 :: TEST_EXT_ORDERINGS3 , ] ) , ( :: std :: any :: TypeId :: of :: < self :: unittest_proto :: TestExtensionInsideTable > ( ) , & [ & self :: unittest_proto :: TEST_EXTENSION_INSIDE_TABLE_EXTENSION , ] ) , ( :: std :: any :: TypeId :: of :: < self :: unittest_proto :: TestParsingMerge > ( ) , & [ & self :: unittest_proto :: test_parsing_merge :: OPTIONAL_EXT , & self :: unittest_proto :: test_parsing_merge :: REPEATED_EXT , ] ) , ( :: std :: any :: TypeId :: of :: < self :: unittest_proto :: TestAllExtensions > ( ) , & [ & self :: unittest_proto :: OPTIONAL_INT32_EXTENSION , & self :: unittest_proto :: OPTIONAL_INT64_EXTENSION , & self :: unittest_proto :: OPTIONAL_UINT32_EXTENSION , & self :: unittest_proto :: OPTIONAL_UINT64_EXTENSION , & self :: unittest_proto :: OPTIONAL_SINT32_EXTENSION , & self :: unittest_proto :: OPTIONAL_SINT64_EXTENSION , & self :: unittest_proto :: OPTIONAL_FIXED32_EXTENSION , & self :: unittest_proto :: OPTIONAL_FIXED64_EXTENSION , & self :: unittest_proto :: OPTIONAL_SFIXED32_EXTENSION , & self :: unittest_proto :: OPTIONAL_SFIXED64_EXTENSION , & self :: unittest_proto :: OPTIONAL_FLOAT_EXTENSION , & self :: unittest_proto :: OPTIONAL_DOUBLE_EXTENSION , & self :: unittest_proto :: OPTIONAL_BOOL_EXTENSION , & self :: unittest_proto :: OPTIONAL_STRING_EXTENSION , & self :: unittest_proto :: OPTIONAL_BYTES_EXTENSION , & self :: unittest_proto :: OPTIONALGROUP_EXTENSION , & self :: unittest_proto :: OPTIONAL_NESTED_MESSAGE_EXTENSION , & self :: unittest_proto :: OPTIONAL_FOREIGN_MESSAGE_EXTENSION , & self :: unittest_proto :: OPTIONAL_IMPORT_MESSAGE_EXTENSION , & self :: unittest_proto :: OPTIONAL_NESTED_ENUM_EXTENSION , & self :: unittest_proto :: OPTIONAL_FOREIGN_ENUM_EXTENSION , & self :: unittest_proto :: OPTIONAL_IMPORT_ENUM_EXTENSION , & self :: unittest_proto :: OPTIONAL_STRING_PIECE_EXTENSION , & self :: unittest_proto :: OPTIONAL_CORD_EXTENSION , & self :: unittest_proto :: OPTIONAL_PUBLIC_IMPORT_MESSAGE_EXTENSION , & self :: unittest_proto :: OPTIONAL_LAZY_MESSAGE_EXTENSION , & self :: unittest_proto :: REPEATED_INT32_EXTENSION , & self :: unittest_proto :: REPEATED_INT64_EXTENSION , & self :: unittest_proto :: REPEATED_UINT32_EXTENSION , & self :: unittest_proto :: REPEATED_UINT64_EXTENSION , & self :: unittest_proto :: REPEATED_SINT32_EXTENSION , & self :: unittest_proto :: REPEATED_SINT64_EXTENSION , & self :: unittest_proto :: REPEATED_FIXED32_EXTENSION , & self :: unittest_proto :: REPEATED_FIXED64_EXTENSION , & self :: unittest_proto :: REPEATED_SFIXED32_EXTENSION , & self :: unittest_proto :: REPEATED_SFIXED64_EXTENSION , & self :: unittest_proto :: REPEATED_FLOAT_EXTENSION , & self :: unittest_proto :: REPEATED_DOUBLE_EXTENSION , & self :: unittest_proto :: REPEATED_BOOL_EXTENSION , & self :: unittest_proto :: REPEATED_STRING_EXTENSION , & self :: unittest_proto :: REPEATED_BYTES_EXTENSION , & self :: unittest_proto :: REPEATEDGROUP_EXTENSION , & self :: unittest_proto :: REPEATED_NESTED_MESSAGE_EXTENSION , & self :: unittest_proto :: REPEATED_FOREIGN_MESSAGE_EXTENSION , & self :: unittest_proto :: REPEATED_IMPORT_MESSAGE_EXTENSION , & self :: unittest_proto :: REPEATED_NESTED_ENUM_EXTENSION , & self :: unittest_proto :: REPEATED_FOREIGN_ENUM_EXTENSION , & self :: unittest_proto :: REPEATED_IMPORT_ENUM_EXTENSION , & self :: unittest_proto :: REPEATED_STRING_PIECE_EXTENSION , & self :: unittest_proto :: REPEATED_CORD_EXTENSION , & self :: unittest_proto :: REPEATED_LAZY_MESSAGE_EXTENSION , & self :: unittest_proto :: DEFAULT_INT32_EXTENSION , & self :: unittest_proto :: DEFAULT_INT64_EXTENSION , & self :: unittest_proto :: DEFAULT_UINT32_EXTENSION , & self :: unittest_proto :: DEFAULT_UINT64_EXTENSION , & self :: unittest_proto :: DEFAULT_SINT32_EXTENSION , & self :: unittest_proto :: DEFAULT_SINT64_EXTENSION , & self :: unittest_proto :: DEFAULT_FIXED32_EXTENSION , & self :: unittest_proto :: DEFAULT_FIXED64_EXTENSION , & self :: unittest_proto :: DEFAULT_SFIXED32_EXTENSION , & self :: unittest_proto :: DEFAULT_SFIXED64_EXTENSION , & self :: unittest_proto :: DEFAULT_FLOAT_EXTENSION , & self :: unittest_proto :: DEFAULT_DOUBLE_EXTENSION , & self :: unittest_proto :: DEFAULT_BOOL_EXTENSION , & self :: unittest_proto :: DEFAULT_STRING_EXTENSION , & self :: unittest_proto :: DEFAULT_BYTES_EXTENSION , & self :: unittest_proto :: DEFAULT_NESTED_ENUM_EXTENSION , & self :: unittest_proto :: DEFAULT_FOREIGN_ENUM_EXTENSION , & self :: unittest_proto :: DEFAULT_IMPORT_ENUM_EXTENSION , & self :: unittest_proto :: DEFAULT_STRING_PIECE_EXTENSION , & self :: unittest_proto :: DEFAULT_CORD_EXTENSION , & self :: unittest_proto :: ONEOF_UINT32_EXTENSION , & self :: unittest_proto :: ONEOF_NESTED_MESSAGE_EXTENSION , & self :: unittest_proto :: ONEOF_STRING_EXTENSION , & self :: unittest_proto :: ONEOF_BYTES_EXTENSION , & self :: unittest_proto :: test_nested_extension :: TEST , & self :: unittest_proto :: test_nested_extension :: NESTED_STRING_EXTENSION , & self :: unittest_proto :: test_required :: SINGLE , & self :: unittest_proto :: test_required :: MULTI , ] ) , ( :: std :: any :: TypeId :: of :: < self :: unittest_proto :: TestUnpackedExtensions > ( ) , & [ & self :: unittest_proto :: UNPACKED_INT32_EXTENSION , & self :: unittest_proto :: UNPACKED_INT64_EXTENSION , & self :: unittest_proto :: UNPACKED_UINT32_EXTENSION , & self :: unittest_proto :: UNPACKED_UINT64_EXTENSION , & self :: unittest_proto :: UNPACKED_SINT32_EXTENSION , & self :: unittest_proto :: UNPACKED_SINT64_EXTENSION , & self :: unittest_proto :: UNPACKED_FIXED32_EXTENSION , & self :: unittest_proto :: UNPACKED_FIXED64_EXTENSION , & self :: unittest_proto :: UNPACKED_SFIXED32_EXTENSION , & self :: unittest_proto :: UNPACKED_SFIXED64_EXTENSION , & self :: unittest_proto :: UNPACKED_FLOAT_EXTENSION , & self :: unittest_proto :: UNPACKED_DOUBLE_EXTENSION , & self :: unittest_proto :: UNPACKED_BOOL_EXTENSION , & self :: unittest_proto :: UNPACKED_ENUM_EXTENSION , ] ) , ( :: std :: any :: TypeId :: of :: < self :: unittest_proto :: TestGroupExtension > ( ) , & [ & self :: unittest_proto :: test_nested_extension :: OPTIONALGROUP_EXTENSION , & self :: unittest_proto :: test_nested_extension :: OPTIONAL_FOREIGN_ENUM_EXTENSION , ] ) , ( :: std :: any :: TypeId :: of :: < self :: unittest_proto :: TestHugeFieldNumbers > ( ) , & [ & self :: unittest_proto :: TEST_ALL_TYPES , ] ) , ( :: std :: any :: TypeId :: of :: < self :: unittest_proto :: TestPackedExtensions > ( ) , & [ & self :: unittest_proto :: PACKED_INT32_EXTENSION , & self :: unittest_proto :: PACKED_INT64_EXTENSION , & self :: unittest_proto :: PACKED_UINT32_EXTENSION , & self :: unittest_proto :: PACKED_UINT64_EXTENSION , & self :: unittest_proto :: PACKED_SINT32_EXTENSION , & self :: unittest_proto :: PACKED_SINT64_EXTENSION , & self :: unittest_proto :: PACKED_FIXED32_EXTENSION , & self :: unittest_proto :: PACKED_FIXED64_EXTENSION , & self :: unittest_proto :: PACKED_SFIXED32_EXTENSION , & self :: unittest_proto :: PACKED_SFIXED64_EXTENSION , & self :: unittest_proto :: PACKED_FLOAT_EXTENSION , & self :: unittest_proto :: PACKED_DOUBLE_EXTENSION , & self :: unittest_proto :: PACKED_BOOL_EXTENSION , & self :: unittest_proto :: PACKED_ENUM_EXTENSION , ] ) , ] ) ) ;
    }
}
pub fn extensions() -> &'static ::protrust::ExtensionRegistry {
    unsafe {
        self::EXTENSIONS_INIT.call_once(extensions_init);
        self::EXTENSIONS_REGISTRY.as_ref().unwrap()
    }
}
static mut EXTERNAL_DEPS: ::std::option::Option<
    [&'static ::protrust::reflect::DescriptorPool<'static>; 0],
> = ::std::option::Option::None;
static mut FILES: ::std::option::Option<[::protrust::descriptor::FileDescriptorProto; 4]> =
    ::std::option::Option::None;
static mut POOL: ::std::option::Option<::protrust::reflect::DescriptorPool<'static>> =
    ::std::option::Option::None;
static POOL_INIT: ::std::sync::Once = ::std::sync::Once::new();
fn pool_init() {
    unsafe {
        self::EXTERNAL_DEPS = ::std::option::Option::Some([]);
        self::FILES = ::std::option::Option::Some([
            ::protrust::LiteMessage::read_new_from_input(
                &mut ::protrust::io::CodedInput::new(&mut UNITTEST_PROTO_BINARY.as_ref())
                    .with_registry(::std::option::Option::Some(self::extensions())),
            )
            .expect("couldn't read file descriptor"),
            ::protrust::LiteMessage::read_new_from_input(
                &mut ::protrust::io::CodedInput::new(&mut UNITTEST_PROTO3_PROTO_BINARY.as_ref())
                    .with_registry(::std::option::Option::Some(self::extensions())),
            )
            .expect("couldn't read file descriptor"),
            ::protrust::LiteMessage::read_new_from_input(
                &mut ::protrust::io::CodedInput::new(&mut UNITTEST_IMPORT_PROTO_BINARY.as_ref())
                    .with_registry(::std::option::Option::Some(self::extensions())),
            )
            .expect("couldn't read file descriptor"),
            ::protrust::LiteMessage::read_new_from_input(
                &mut ::protrust::io::CodedInput::new(
                    &mut UNITTEST_IMPORT_PUBLIC_PROTO_BINARY.as_ref(),
                )
                .with_registry(::std::option::Option::Some(self::extensions())),
            )
            .expect("couldn't read file descriptor"),
        ]);
        self :: POOL = :: std :: option :: Option :: Some ( :: protrust :: reflect :: DescriptorPool :: build_from_generated_code ( self :: FILES . as_ref ( ) . unwrap ( ) . as_ref ( ) , self :: EXTERNAL_DEPS . as_ref ( ) . unwrap ( ) , :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: GeneratedCodeInfo { structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestAllTypes as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: test_all_types :: NestedMessage as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: nested_message :: BB_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: test_all_types :: OptionalGroup as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: optional_group :: A_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: test_all_types :: RepeatedGroup as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: repeated_group :: A_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: OPTIONAL_INT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: OPTIONAL_INT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: OPTIONAL_UINT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: OPTIONAL_UINT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: OPTIONAL_SINT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: OPTIONAL_SINT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: OPTIONAL_FIXED32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: OPTIONAL_FIXED64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: OPTIONAL_SFIXED32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: OPTIONAL_SFIXED64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: OPTIONAL_FLOAT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: OPTIONAL_DOUBLE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: OPTIONAL_BOOL_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: OPTIONAL_STRING_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: OPTIONAL_BYTES_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: OPTIONALGROUP_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: OPTIONAL_NESTED_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: OPTIONAL_FOREIGN_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: OPTIONAL_IMPORT_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: OPTIONAL_NESTED_ENUM_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: OPTIONAL_FOREIGN_ENUM_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: OPTIONAL_IMPORT_ENUM_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: OPTIONAL_STRING_PIECE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: OPTIONAL_CORD_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: OPTIONAL_PUBLIC_IMPORT_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: OPTIONAL_LAZY_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_all_types :: REPEATED_INT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_all_types :: REPEATED_INT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_all_types :: REPEATED_UINT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_all_types :: REPEATED_UINT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_all_types :: REPEATED_SINT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_all_types :: REPEATED_SINT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_all_types :: REPEATED_FIXED32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_all_types :: REPEATED_FIXED64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_all_types :: REPEATED_SFIXED32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_all_types :: REPEATED_SFIXED64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_all_types :: REPEATED_FLOAT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_all_types :: REPEATED_DOUBLE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_all_types :: REPEATED_BOOL_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_all_types :: REPEATED_STRING_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_all_types :: REPEATED_BYTES_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_all_types :: REPEATEDGROUP_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_all_types :: REPEATED_NESTED_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_all_types :: REPEATED_FOREIGN_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_all_types :: REPEATED_IMPORT_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_all_types :: REPEATED_NESTED_ENUM_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_all_types :: REPEATED_FOREIGN_ENUM_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_all_types :: REPEATED_IMPORT_ENUM_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_all_types :: REPEATED_STRING_PIECE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_all_types :: REPEATED_CORD_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_all_types :: REPEATED_LAZY_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: DEFAULT_INT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: DEFAULT_INT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: DEFAULT_UINT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: DEFAULT_UINT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: DEFAULT_SINT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: DEFAULT_SINT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: DEFAULT_FIXED32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: DEFAULT_FIXED64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: DEFAULT_SFIXED32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: DEFAULT_SFIXED64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: DEFAULT_FLOAT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: DEFAULT_DOUBLE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: DEFAULT_BOOL_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: DEFAULT_STRING_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: DEFAULT_BYTES_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: DEFAULT_NESTED_ENUM_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: DEFAULT_FOREIGN_ENUM_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: DEFAULT_IMPORT_ENUM_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: DEFAULT_STRING_PIECE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: DEFAULT_CORD_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: ONEOF_UINT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: ONEOF_NESTED_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: ONEOF_STRING_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_all_types :: ONEOF_BYTES_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: NestedTestAllTypes as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: nested_test_all_types :: CHILD_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: nested_test_all_types :: PAYLOAD_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: nested_test_all_types :: REPEATED_CHILD_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestDeprecatedFields as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_deprecated_fields :: DEPRECATED_INT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_deprecated_fields :: DEPRECATED_INT32_IN_ONEOF_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestDeprecatedMessage as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: None , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: ForeignMessage as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: foreign_message :: C_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: foreign_message :: D_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestReservedFields as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: None , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestAllExtensions as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: None , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: OptionalGroup_extension as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: optional_group_extension :: A_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: RepeatedGroup_extension as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: repeated_group_extension :: A_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestGroup as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: test_group :: OptionalGroup as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_group :: optional_group :: A_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_group :: OPTIONALGROUP_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_group :: OPTIONAL_FOREIGN_ENUM_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestGroupExtension as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: None , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestNestedExtension as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: test_nested_extension :: OptionalGroup_extension as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_nested_extension :: optional_group_extension :: A_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , fields : :: std :: option :: Option :: None , extensions : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_nested_extension :: TEST ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_nested_extension :: NESTED_STRING_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_nested_extension :: OPTIONALGROUP_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_nested_extension :: OPTIONAL_FOREIGN_ENUM_EXTENSION ) , ] ) ) , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestRequired as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: A_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY2_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: B_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY4_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY5_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY6_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY7_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY8_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY9_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY10_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY11_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY12_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY13_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY14_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY15_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY16_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY17_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY18_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY19_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY20_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY21_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY22_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY23_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY24_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY25_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY26_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY27_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY28_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY29_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY30_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY31_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: DUMMY32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: C_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required :: SINGLE ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_required :: MULTI ) , ] ) ) , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestRequiredForeign as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required_foreign :: OPTIONAL_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_required_foreign :: REPEATED_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required_foreign :: DUMMY_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestRequiredMessage as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required_message :: OPTIONAL_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_required_message :: REPEATED_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required_message :: REQUIRED_MESSAGE_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestForeignNested as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_foreign_nested :: FOREIGN_NESTED_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestEmptyMessage as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: None , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestEmptyMessageWithExtensions as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: None , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestMultipleExtensionRanges as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: None , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestReallyLargeTagNumber as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_really_large_tag_number :: A_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_really_large_tag_number :: BB_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestRecursiveMessage as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_recursive_message :: A_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_recursive_message :: I_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestMutualRecursionA as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: test_mutual_recursion_a :: SubMessage as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_mutual_recursion_a :: sub_message :: B_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: test_mutual_recursion_a :: SubGroup as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_mutual_recursion_a :: sub_group :: SUB_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_mutual_recursion_a :: sub_group :: NOT_IN_THIS_SCC_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_mutual_recursion_a :: BB_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_mutual_recursion_a :: SUBGROUP_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestMutualRecursionB as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_mutual_recursion_b :: A_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_mutual_recursion_b :: OPTIONAL_INT32_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestIsInitialized as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: test_is_initialized :: SubMessage as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: test_is_initialized :: sub_message :: SubGroup as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_is_initialized :: sub_message :: sub_group :: I_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_is_initialized :: sub_message :: SUBGROUP_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_is_initialized :: SUB_MESSAGE_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestDupFieldNumber as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: test_dup_field_number :: Foo as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_dup_field_number :: foo :: A_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: test_dup_field_number :: Bar as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_dup_field_number :: bar :: A_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_dup_field_number :: A_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_dup_field_number :: FOO_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_dup_field_number :: BAR_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestEagerMessage as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_eager_message :: SUB_MESSAGE_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestLazyMessage as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_lazy_message :: SUB_MESSAGE_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestNestedMessageHasBits as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: test_nested_message_has_bits :: NestedMessage as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_nested_message_has_bits :: nested_message :: NESTEDMESSAGE_REPEATED_INT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_nested_message_has_bits :: nested_message :: NESTEDMESSAGE_REPEATED_FOREIGNMESSAGE_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_nested_message_has_bits :: OPTIONAL_NESTED_MESSAGE_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestCamelCaseFieldNames as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_camel_case_field_names :: PRIMITIVEFIELD_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_camel_case_field_names :: STRINGFIELD_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_camel_case_field_names :: ENUMFIELD_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_camel_case_field_names :: MESSAGEFIELD_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_camel_case_field_names :: STRINGPIECEFIELD_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_camel_case_field_names :: CORDFIELD_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_camel_case_field_names :: REPEATEDPRIMITIVEFIELD_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_camel_case_field_names :: REPEATEDSTRINGFIELD_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_camel_case_field_names :: REPEATEDENUMFIELD_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_camel_case_field_names :: REPEATEDMESSAGEFIELD_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_camel_case_field_names :: REPEATEDSTRINGPIECEFIELD_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_camel_case_field_names :: REPEATEDCORDFIELD_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestFieldOrderings as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: test_field_orderings :: NestedMessage as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_field_orderings :: nested_message :: OO_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_field_orderings :: nested_message :: BB_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_field_orderings :: MY_STRING_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_field_orderings :: MY_INT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_field_orderings :: MY_FLOAT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_field_orderings :: OPTIONAL_NESTED_MESSAGE_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestExtensionOrderings1 as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extension_orderings1 :: MY_STRING_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extension_orderings1 :: TEST_EXT_ORDERINGS1 ) , ] ) ) , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestExtensionOrderings2 as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: test_extension_orderings2 :: TestExtensionOrderings3 as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extension_orderings2 :: test_extension_orderings3 :: MY_STRING_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extension_orderings2 :: test_extension_orderings3 :: TEST_EXT_ORDERINGS3 ) , ] ) ) , } , ] ) ) , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extension_orderings2 :: MY_STRING_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extension_orderings2 :: TEST_EXT_ORDERINGS2 ) , ] ) ) , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestExtremeDefaultValues as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extreme_default_values :: ESCAPED_BYTES_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extreme_default_values :: LARGE_UINT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extreme_default_values :: LARGE_UINT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extreme_default_values :: SMALL_INT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extreme_default_values :: SMALL_INT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extreme_default_values :: REALLY_SMALL_INT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extreme_default_values :: REALLY_SMALL_INT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extreme_default_values :: UTF8_STRING_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extreme_default_values :: ZERO_FLOAT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extreme_default_values :: ONE_FLOAT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extreme_default_values :: SMALL_FLOAT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extreme_default_values :: NEGATIVE_ONE_FLOAT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extreme_default_values :: NEGATIVE_FLOAT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extreme_default_values :: LARGE_FLOAT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extreme_default_values :: SMALL_NEGATIVE_FLOAT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extreme_default_values :: INF_DOUBLE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extreme_default_values :: NEG_INF_DOUBLE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extreme_default_values :: NAN_DOUBLE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extreme_default_values :: INF_FLOAT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extreme_default_values :: NEG_INF_FLOAT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extreme_default_values :: NAN_FLOAT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extreme_default_values :: CPP_TRIGRAPH_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extreme_default_values :: STRING_WITH_ZERO_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extreme_default_values :: BYTES_WITH_ZERO_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extreme_default_values :: STRING_PIECE_WITH_ZERO_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extreme_default_values :: CORD_WITH_ZERO_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extreme_default_values :: REPLACEMENT_STRING_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: SparseEnumMessage as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: sparse_enum_message :: SPARSE_ENUM_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: OneString as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: one_string :: DATA_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: MoreString as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: more_string :: DATA_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: OneBytes as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: one_bytes :: DATA_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: MoreBytes as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: more_bytes :: DATA_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: Int32Message as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: int32_message :: DATA_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: Uint32Message as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: uint32_message :: DATA_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: Int64Message as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: int64_message :: DATA_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: Uint64Message as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: uint64_message :: DATA_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: BoolMessage as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: bool_message :: DATA_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestOneof as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: test_oneof :: FooGroup as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof :: foo_group :: A_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof :: foo_group :: B_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof :: FOO_INT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof :: FOO_STRING_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof :: FOO_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof :: FOOGROUP_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestOneofBackwardsCompatible as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: test_oneof_backwards_compatible :: FooGroup as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof_backwards_compatible :: foo_group :: A_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof_backwards_compatible :: foo_group :: B_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof_backwards_compatible :: FOO_INT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof_backwards_compatible :: FOO_STRING_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof_backwards_compatible :: FOO_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof_backwards_compatible :: FOOGROUP_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestOneof2 as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: test_oneof2 :: FooGroup as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof2 :: foo_group :: A_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof2 :: foo_group :: B_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: test_oneof2 :: NestedMessage as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof2 :: nested_message :: QUX_INT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_oneof2 :: nested_message :: CORGE_INT_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof2 :: FOO_INT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof2 :: FOO_STRING_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof2 :: FOO_CORD_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof2 :: FOO_STRING_PIECE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof2 :: FOO_BYTES_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof2 :: FOO_ENUM_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof2 :: FOO_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof2 :: FOOGROUP_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof2 :: FOO_LAZY_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof2 :: BAR_INT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof2 :: BAR_STRING_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof2 :: BAR_CORD_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof2 :: BAR_STRING_PIECE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof2 :: BAR_BYTES_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof2 :: BAR_ENUM_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof2 :: BAZ_INT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_oneof2 :: BAZ_STRING_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestRequiredOneof as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: test_required_oneof :: NestedMessage as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required_oneof :: nested_message :: REQUIRED_DOUBLE_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required_oneof :: FOO_INT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required_oneof :: FOO_STRING_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_required_oneof :: FOO_MESSAGE_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestPackedTypes as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_packed_types :: PACKED_INT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_packed_types :: PACKED_INT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_packed_types :: PACKED_UINT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_packed_types :: PACKED_UINT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_packed_types :: PACKED_SINT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_packed_types :: PACKED_SINT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_packed_types :: PACKED_FIXED32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_packed_types :: PACKED_FIXED64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_packed_types :: PACKED_SFIXED32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_packed_types :: PACKED_SFIXED64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_packed_types :: PACKED_FLOAT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_packed_types :: PACKED_DOUBLE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_packed_types :: PACKED_BOOL_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_packed_types :: PACKED_ENUM_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestUnpackedTypes as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_unpacked_types :: UNPACKED_INT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_unpacked_types :: UNPACKED_INT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_unpacked_types :: UNPACKED_UINT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_unpacked_types :: UNPACKED_UINT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_unpacked_types :: UNPACKED_SINT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_unpacked_types :: UNPACKED_SINT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_unpacked_types :: UNPACKED_FIXED32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_unpacked_types :: UNPACKED_FIXED64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_unpacked_types :: UNPACKED_SFIXED32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_unpacked_types :: UNPACKED_SFIXED64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_unpacked_types :: UNPACKED_FLOAT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_unpacked_types :: UNPACKED_DOUBLE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_unpacked_types :: UNPACKED_BOOL_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_unpacked_types :: UNPACKED_ENUM_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestPackedExtensions as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: None , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestUnpackedExtensions as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: None , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestDynamicExtensions as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: test_dynamic_extensions :: DynamicMessageType as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_dynamic_extensions :: dynamic_message_type :: DYNAMIC_FIELD_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_dynamic_extensions :: SCALAR_EXTENSION_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_dynamic_extensions :: ENUM_EXTENSION_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_dynamic_extensions :: DYNAMIC_ENUM_EXTENSION_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_dynamic_extensions :: MESSAGE_EXTENSION_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_dynamic_extensions :: DYNAMIC_MESSAGE_EXTENSION_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_dynamic_extensions :: REPEATED_EXTENSION_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_dynamic_extensions :: PACKED_EXTENSION_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestRepeatedScalarDifferentTagSizes as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_repeated_scalar_different_tag_sizes :: REPEATED_FIXED32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_repeated_scalar_different_tag_sizes :: REPEATED_INT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_repeated_scalar_different_tag_sizes :: REPEATED_FIXED64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_repeated_scalar_different_tag_sizes :: REPEATED_INT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_repeated_scalar_different_tag_sizes :: REPEATED_FLOAT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_repeated_scalar_different_tag_sizes :: REPEATED_UINT64_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestParsingMerge as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: test_parsing_merge :: RepeatedFieldsGenerator as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: test_parsing_merge :: repeated_fields_generator :: Group1 as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_parsing_merge :: repeated_fields_generator :: group1 :: FIELD1_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: test_parsing_merge :: repeated_fields_generator :: Group2 as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_parsing_merge :: repeated_fields_generator :: group2 :: FIELD1_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_parsing_merge :: repeated_fields_generator :: FIELD1_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_parsing_merge :: repeated_fields_generator :: FIELD2_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_parsing_merge :: repeated_fields_generator :: FIELD3_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_parsing_merge :: repeated_fields_generator :: GROUP1_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_parsing_merge :: repeated_fields_generator :: GROUP2_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_parsing_merge :: repeated_fields_generator :: EXT1_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_parsing_merge :: repeated_fields_generator :: EXT2_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: test_parsing_merge :: OptionalGroup as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_parsing_merge :: optional_group :: OPTIONAL_GROUP_ALL_TYPES_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: test_parsing_merge :: RepeatedGroup as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_parsing_merge :: repeated_group :: REPEATED_GROUP_ALL_TYPES_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_parsing_merge :: REQUIRED_ALL_TYPES_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_parsing_merge :: OPTIONAL_ALL_TYPES_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_parsing_merge :: REPEATED_ALL_TYPES_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_parsing_merge :: OPTIONALGROUP_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_parsing_merge :: REPEATEDGROUP_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_parsing_merge :: OPTIONAL_EXT ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_parsing_merge :: REPEATED_EXT ) , ] ) ) , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestCommentInjectionMessage as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_comment_injection_message :: A_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: FooRequest as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: None , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: FooResponse as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: None , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: FooClientMessage as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: None , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: FooServerMessage as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: None , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: BarRequest as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: None , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: BarResponse as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: None , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestJsonName as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_json_name :: FIELD_NAME1_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_json_name :: FIELDNAME2_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_json_name :: FIELDNAME3_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_json_name :: _FIELD_NAME4_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_json_name :: FIELD_NAME5_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_json_name :: FIELD_NAME6_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestHugeFieldNumbers as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: test_huge_field_numbers :: OptionalGroup as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_huge_field_numbers :: optional_group :: GROUP_A_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_huge_field_numbers :: OPTIONAL_INT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_huge_field_numbers :: FIXED_32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_huge_field_numbers :: REPEATED_INT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: test_huge_field_numbers :: PACKED_INT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_huge_field_numbers :: OPTIONAL_ENUM_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_huge_field_numbers :: OPTIONAL_STRING_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_huge_field_numbers :: OPTIONAL_BYTES_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_huge_field_numbers :: OPTIONAL_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_huge_field_numbers :: OPTIONALGROUP_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Map ( & self :: unittest_proto :: test_huge_field_numbers :: STRING_STRING_MAP_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_huge_field_numbers :: ONEOF_UINT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_huge_field_numbers :: ONEOF_TEST_ALL_TYPES_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_huge_field_numbers :: ONEOF_STRING_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_huge_field_numbers :: ONEOF_BYTES_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto :: TestExtensionInsideTable as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extension_inside_table :: FIELD1_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extension_inside_table :: FIELD2_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extension_inside_table :: FIELD3_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extension_inside_table :: FIELD4_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extension_inside_table :: FIELD6_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extension_inside_table :: FIELD7_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extension_inside_table :: FIELD8_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extension_inside_table :: FIELD9_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: test_extension_inside_table :: FIELD10_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , extensions : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: OPTIONAL_INT32_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: OPTIONAL_INT64_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: OPTIONAL_UINT32_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: OPTIONAL_UINT64_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: OPTIONAL_SINT32_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: OPTIONAL_SINT64_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: OPTIONAL_FIXED32_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: OPTIONAL_FIXED64_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: OPTIONAL_SFIXED32_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: OPTIONAL_SFIXED64_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: OPTIONAL_FLOAT_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: OPTIONAL_DOUBLE_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: OPTIONAL_BOOL_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: OPTIONAL_STRING_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: OPTIONAL_BYTES_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: OPTIONALGROUP_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: OPTIONAL_NESTED_MESSAGE_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: OPTIONAL_FOREIGN_MESSAGE_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: OPTIONAL_IMPORT_MESSAGE_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: OPTIONAL_NESTED_ENUM_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: OPTIONAL_FOREIGN_ENUM_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: OPTIONAL_IMPORT_ENUM_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: OPTIONAL_STRING_PIECE_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: OPTIONAL_CORD_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: OPTIONAL_PUBLIC_IMPORT_MESSAGE_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: OPTIONAL_LAZY_MESSAGE_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: REPEATED_INT32_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: REPEATED_INT64_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: REPEATED_UINT32_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: REPEATED_UINT64_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: REPEATED_SINT32_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: REPEATED_SINT64_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: REPEATED_FIXED32_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: REPEATED_FIXED64_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: REPEATED_SFIXED32_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: REPEATED_SFIXED64_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: REPEATED_FLOAT_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: REPEATED_DOUBLE_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: REPEATED_BOOL_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: REPEATED_STRING_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: REPEATED_BYTES_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: REPEATEDGROUP_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: REPEATED_NESTED_MESSAGE_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: REPEATED_FOREIGN_MESSAGE_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: REPEATED_IMPORT_MESSAGE_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: REPEATED_NESTED_ENUM_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: REPEATED_FOREIGN_ENUM_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: REPEATED_IMPORT_ENUM_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: REPEATED_STRING_PIECE_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: REPEATED_CORD_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: REPEATED_LAZY_MESSAGE_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: DEFAULT_INT32_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: DEFAULT_INT64_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: DEFAULT_UINT32_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: DEFAULT_UINT64_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: DEFAULT_SINT32_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: DEFAULT_SINT64_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: DEFAULT_FIXED32_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: DEFAULT_FIXED64_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: DEFAULT_SFIXED32_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: DEFAULT_SFIXED64_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: DEFAULT_FLOAT_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: DEFAULT_DOUBLE_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: DEFAULT_BOOL_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: DEFAULT_STRING_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: DEFAULT_BYTES_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: DEFAULT_NESTED_ENUM_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: DEFAULT_FOREIGN_ENUM_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: DEFAULT_IMPORT_ENUM_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: DEFAULT_STRING_PIECE_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: DEFAULT_CORD_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: ONEOF_UINT32_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: ONEOF_NESTED_MESSAGE_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: ONEOF_STRING_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: ONEOF_BYTES_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: MY_EXTENSION_STRING ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: MY_EXTENSION_INT ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: PACKED_INT32_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: PACKED_INT64_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: PACKED_UINT32_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: PACKED_UINT64_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: PACKED_SINT32_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: PACKED_SINT64_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: PACKED_FIXED32_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: PACKED_FIXED64_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: PACKED_SFIXED32_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: PACKED_SFIXED64_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: PACKED_FLOAT_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: PACKED_DOUBLE_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: PACKED_BOOL_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: PACKED_ENUM_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: UNPACKED_INT32_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: UNPACKED_INT64_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: UNPACKED_UINT32_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: UNPACKED_UINT64_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: UNPACKED_SINT32_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: UNPACKED_SINT64_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: UNPACKED_FIXED32_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: UNPACKED_FIXED64_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: UNPACKED_SFIXED32_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: UNPACKED_SFIXED64_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: UNPACKED_FLOAT_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: UNPACKED_DOUBLE_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: UNPACKED_BOOL_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto :: UNPACKED_ENUM_EXTENSION ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: TEST_ALL_TYPES ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto :: TEST_EXTENSION_INSIDE_TABLE_EXTENSION ) , ] ) ) , } , :: protrust :: reflect :: GeneratedCodeInfo { structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto3_proto :: TestAllTypes as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto3_proto :: test_all_types :: NestedMessage as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: nested_message :: BB_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: OPTIONAL_INT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: OPTIONAL_INT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: OPTIONAL_UINT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: OPTIONAL_UINT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: OPTIONAL_SINT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: OPTIONAL_SINT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: OPTIONAL_FIXED32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: OPTIONAL_FIXED64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: OPTIONAL_SFIXED32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: OPTIONAL_SFIXED64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: OPTIONAL_FLOAT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: OPTIONAL_DOUBLE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: OPTIONAL_BOOL_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: OPTIONAL_STRING_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: OPTIONAL_BYTES_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: OPTIONAL_NESTED_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: OPTIONAL_FOREIGN_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: OPTIONAL_IMPORT_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: OPTIONAL_NESTED_ENUM_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: OPTIONAL_FOREIGN_ENUM_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: OPTIONAL_STRING_PIECE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: OPTIONAL_CORD_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: OPTIONAL_PUBLIC_IMPORT_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: OPTIONAL_LAZY_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: OPTIONAL_LAZY_IMPORT_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_all_types :: REPEATED_INT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_all_types :: REPEATED_INT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_all_types :: REPEATED_UINT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_all_types :: REPEATED_UINT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_all_types :: REPEATED_SINT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_all_types :: REPEATED_SINT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_all_types :: REPEATED_FIXED32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_all_types :: REPEATED_FIXED64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_all_types :: REPEATED_SFIXED32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_all_types :: REPEATED_SFIXED64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_all_types :: REPEATED_FLOAT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_all_types :: REPEATED_DOUBLE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_all_types :: REPEATED_BOOL_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_all_types :: REPEATED_STRING_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_all_types :: REPEATED_BYTES_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_all_types :: REPEATED_NESTED_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_all_types :: REPEATED_FOREIGN_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_all_types :: REPEATED_IMPORT_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_all_types :: REPEATED_NESTED_ENUM_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_all_types :: REPEATED_FOREIGN_ENUM_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_all_types :: REPEATED_STRING_PIECE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_all_types :: REPEATED_CORD_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_all_types :: REPEATED_LAZY_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: ONEOF_UINT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: ONEOF_NESTED_MESSAGE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: ONEOF_STRING_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_all_types :: ONEOF_BYTES_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto3_proto :: TestPackedTypes as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_packed_types :: PACKED_INT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_packed_types :: PACKED_INT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_packed_types :: PACKED_UINT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_packed_types :: PACKED_UINT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_packed_types :: PACKED_SINT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_packed_types :: PACKED_SINT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_packed_types :: PACKED_FIXED32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_packed_types :: PACKED_FIXED64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_packed_types :: PACKED_SFIXED32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_packed_types :: PACKED_SFIXED64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_packed_types :: PACKED_FLOAT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_packed_types :: PACKED_DOUBLE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_packed_types :: PACKED_BOOL_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_packed_types :: PACKED_ENUM_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto3_proto :: TestUnpackedTypes as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_unpacked_types :: REPEATED_INT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_unpacked_types :: REPEATED_INT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_unpacked_types :: REPEATED_UINT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_unpacked_types :: REPEATED_UINT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_unpacked_types :: REPEATED_SINT32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_unpacked_types :: REPEATED_SINT64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_unpacked_types :: REPEATED_FIXED32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_unpacked_types :: REPEATED_FIXED64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_unpacked_types :: REPEATED_SFIXED32_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_unpacked_types :: REPEATED_SFIXED64_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_unpacked_types :: REPEATED_FLOAT_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_unpacked_types :: REPEATED_DOUBLE_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_unpacked_types :: REPEATED_BOOL_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Repeated ( & self :: unittest_proto3_proto :: test_unpacked_types :: REPEATED_NESTED_ENUM_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto3_proto :: NestedTestAllTypes as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: nested_test_all_types :: CHILD_REFLECTOR ) , :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: nested_test_all_types :: PAYLOAD_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto3_proto :: ForeignMessage as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: foreign_message :: C_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto3_proto :: TestEmptyMessage as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: None , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_proto3_proto :: TestOneof2 as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_proto3_proto :: test_oneof2 :: FOO_ENUM_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedCodeInfo { structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_import_proto :: ImportMessage as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_import_proto :: import_message :: D_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , extensions : :: std :: option :: Option :: None , } , :: protrust :: reflect :: GeneratedCodeInfo { structs : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: GeneratedStructInfo { new : || :: std :: boxed :: Box :: new ( < self :: unittest_import_public_proto :: PublicImportMessage as :: protrust :: LiteMessage > :: new ( ) ) , structs : :: std :: option :: Option :: None , fields : :: std :: option :: Option :: Some ( :: std :: boxed :: Box :: new ( [ :: protrust :: reflect :: access :: FieldAccessor :: Single ( & self :: unittest_import_public_proto :: public_import_message :: E_REFLECTOR ) , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) , extensions : :: std :: option :: Option :: None , } , ] ) ) ) ;
    }
}
pub fn pool() -> &'static ::protrust::reflect::DescriptorPool<'static> {
    unsafe {
        self::POOL_INIT.call_once(pool_init);
        self::POOL.as_ref().unwrap()
    }
}
static UNITTEST_PROTO_BINARY: &'static [u8] = &[
    10, 14, 117, 110, 105, 116, 116, 101, 115, 116, 46, 112, 114, 111, 116, 111, 18, 17, 112, 114,
    111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 26, 21, 117, 110, 105,
    116, 116, 101, 115, 116, 95, 105, 109, 112, 111, 114, 116, 46, 112, 114, 111, 116, 111, 34,
    254, 34, 10, 12, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 18, 37, 10, 14, 111,
    112, 116, 105, 111, 110, 97, 108, 95, 105, 110, 116, 51, 50, 24, 1, 32, 1, 40, 5, 82, 13, 111,
    112, 116, 105, 111, 110, 97, 108, 73, 110, 116, 51, 50, 18, 37, 10, 14, 111, 112, 116, 105,
    111, 110, 97, 108, 95, 105, 110, 116, 54, 52, 24, 2, 32, 1, 40, 3, 82, 13, 111, 112, 116, 105,
    111, 110, 97, 108, 73, 110, 116, 54, 52, 18, 39, 10, 15, 111, 112, 116, 105, 111, 110, 97, 108,
    95, 117, 105, 110, 116, 51, 50, 24, 3, 32, 1, 40, 13, 82, 14, 111, 112, 116, 105, 111, 110, 97,
    108, 85, 105, 110, 116, 51, 50, 18, 39, 10, 15, 111, 112, 116, 105, 111, 110, 97, 108, 95, 117,
    105, 110, 116, 54, 52, 24, 4, 32, 1, 40, 4, 82, 14, 111, 112, 116, 105, 111, 110, 97, 108, 85,
    105, 110, 116, 54, 52, 18, 39, 10, 15, 111, 112, 116, 105, 111, 110, 97, 108, 95, 115, 105,
    110, 116, 51, 50, 24, 5, 32, 1, 40, 17, 82, 14, 111, 112, 116, 105, 111, 110, 97, 108, 83, 105,
    110, 116, 51, 50, 18, 39, 10, 15, 111, 112, 116, 105, 111, 110, 97, 108, 95, 115, 105, 110,
    116, 54, 52, 24, 6, 32, 1, 40, 18, 82, 14, 111, 112, 116, 105, 111, 110, 97, 108, 83, 105, 110,
    116, 54, 52, 18, 41, 10, 16, 111, 112, 116, 105, 111, 110, 97, 108, 95, 102, 105, 120, 101,
    100, 51, 50, 24, 7, 32, 1, 40, 7, 82, 15, 111, 112, 116, 105, 111, 110, 97, 108, 70, 105, 120,
    101, 100, 51, 50, 18, 41, 10, 16, 111, 112, 116, 105, 111, 110, 97, 108, 95, 102, 105, 120,
    101, 100, 54, 52, 24, 8, 32, 1, 40, 6, 82, 15, 111, 112, 116, 105, 111, 110, 97, 108, 70, 105,
    120, 101, 100, 54, 52, 18, 43, 10, 17, 111, 112, 116, 105, 111, 110, 97, 108, 95, 115, 102,
    105, 120, 101, 100, 51, 50, 24, 9, 32, 1, 40, 15, 82, 16, 111, 112, 116, 105, 111, 110, 97,
    108, 83, 102, 105, 120, 101, 100, 51, 50, 18, 43, 10, 17, 111, 112, 116, 105, 111, 110, 97,
    108, 95, 115, 102, 105, 120, 101, 100, 54, 52, 24, 10, 32, 1, 40, 16, 82, 16, 111, 112, 116,
    105, 111, 110, 97, 108, 83, 102, 105, 120, 101, 100, 54, 52, 18, 37, 10, 14, 111, 112, 116,
    105, 111, 110, 97, 108, 95, 102, 108, 111, 97, 116, 24, 11, 32, 1, 40, 2, 82, 13, 111, 112,
    116, 105, 111, 110, 97, 108, 70, 108, 111, 97, 116, 18, 39, 10, 15, 111, 112, 116, 105, 111,
    110, 97, 108, 95, 100, 111, 117, 98, 108, 101, 24, 12, 32, 1, 40, 1, 82, 14, 111, 112, 116,
    105, 111, 110, 97, 108, 68, 111, 117, 98, 108, 101, 18, 35, 10, 13, 111, 112, 116, 105, 111,
    110, 97, 108, 95, 98, 111, 111, 108, 24, 13, 32, 1, 40, 8, 82, 12, 111, 112, 116, 105, 111,
    110, 97, 108, 66, 111, 111, 108, 18, 39, 10, 15, 111, 112, 116, 105, 111, 110, 97, 108, 95,
    115, 116, 114, 105, 110, 103, 24, 14, 32, 1, 40, 9, 82, 14, 111, 112, 116, 105, 111, 110, 97,
    108, 83, 116, 114, 105, 110, 103, 18, 37, 10, 14, 111, 112, 116, 105, 111, 110, 97, 108, 95,
    98, 121, 116, 101, 115, 24, 15, 32, 1, 40, 12, 82, 13, 111, 112, 116, 105, 111, 110, 97, 108,
    66, 121, 116, 101, 115, 18, 83, 10, 13, 111, 112, 116, 105, 111, 110, 97, 108, 103, 114, 111,
    117, 112, 24, 16, 32, 1, 40, 10, 50, 45, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117,
    110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115,
    46, 79, 112, 116, 105, 111, 110, 97, 108, 71, 114, 111, 117, 112, 82, 13, 111, 112, 116, 105,
    111, 110, 97, 108, 103, 114, 111, 117, 112, 18, 101, 10, 23, 111, 112, 116, 105, 111, 110, 97,
    108, 95, 110, 101, 115, 116, 101, 100, 95, 109, 101, 115, 115, 97, 103, 101, 24, 18, 32, 1, 40,
    11, 50, 45, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115,
    116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 46, 78, 101, 115, 116, 101,
    100, 77, 101, 115, 115, 97, 103, 101, 82, 21, 111, 112, 116, 105, 111, 110, 97, 108, 78, 101,
    115, 116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 18, 91, 10, 24, 111, 112, 116, 105, 111,
    110, 97, 108, 95, 102, 111, 114, 101, 105, 103, 110, 95, 109, 101, 115, 115, 97, 103, 101, 24,
    19, 32, 1, 40, 11, 50, 33, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116,
    116, 101, 115, 116, 46, 70, 111, 114, 101, 105, 103, 110, 77, 101, 115, 115, 97, 103, 101, 82,
    22, 111, 112, 116, 105, 111, 110, 97, 108, 70, 111, 114, 101, 105, 103, 110, 77, 101, 115, 115,
    97, 103, 101, 18, 95, 10, 23, 111, 112, 116, 105, 111, 110, 97, 108, 95, 105, 109, 112, 111,
    114, 116, 95, 109, 101, 115, 115, 97, 103, 101, 24, 20, 32, 1, 40, 11, 50, 39, 46, 112, 114,
    111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 95, 105, 109, 112,
    111, 114, 116, 46, 73, 109, 112, 111, 114, 116, 77, 101, 115, 115, 97, 103, 101, 82, 21, 111,
    112, 116, 105, 111, 110, 97, 108, 73, 109, 112, 111, 114, 116, 77, 101, 115, 115, 97, 103, 101,
    18, 92, 10, 20, 111, 112, 116, 105, 111, 110, 97, 108, 95, 110, 101, 115, 116, 101, 100, 95,
    101, 110, 117, 109, 24, 21, 32, 1, 40, 14, 50, 42, 46, 112, 114, 111, 116, 111, 98, 117, 102,
    95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112,
    101, 115, 46, 78, 101, 115, 116, 101, 100, 69, 110, 117, 109, 82, 18, 111, 112, 116, 105, 111,
    110, 97, 108, 78, 101, 115, 116, 101, 100, 69, 110, 117, 109, 18, 82, 10, 21, 111, 112, 116,
    105, 111, 110, 97, 108, 95, 102, 111, 114, 101, 105, 103, 110, 95, 101, 110, 117, 109, 24, 22,
    32, 1, 40, 14, 50, 30, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116,
    101, 115, 116, 46, 70, 111, 114, 101, 105, 103, 110, 69, 110, 117, 109, 82, 19, 111, 112, 116,
    105, 111, 110, 97, 108, 70, 111, 114, 101, 105, 103, 110, 69, 110, 117, 109, 18, 86, 10, 20,
    111, 112, 116, 105, 111, 110, 97, 108, 95, 105, 109, 112, 111, 114, 116, 95, 101, 110, 117,
    109, 24, 23, 32, 1, 40, 14, 50, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110,
    105, 116, 116, 101, 115, 116, 95, 105, 109, 112, 111, 114, 116, 46, 73, 109, 112, 111, 114,
    116, 69, 110, 117, 109, 82, 18, 111, 112, 116, 105, 111, 110, 97, 108, 73, 109, 112, 111, 114,
    116, 69, 110, 117, 109, 18, 54, 10, 21, 111, 112, 116, 105, 111, 110, 97, 108, 95, 115, 116,
    114, 105, 110, 103, 95, 112, 105, 101, 99, 101, 24, 24, 32, 1, 40, 9, 82, 19, 111, 112, 116,
    105, 111, 110, 97, 108, 83, 116, 114, 105, 110, 103, 80, 105, 101, 99, 101, 66, 2, 8, 2, 18,
    39, 10, 13, 111, 112, 116, 105, 111, 110, 97, 108, 95, 99, 111, 114, 100, 24, 25, 32, 1, 40, 9,
    82, 12, 111, 112, 116, 105, 111, 110, 97, 108, 67, 111, 114, 100, 66, 2, 8, 1, 18, 114, 10, 30,
    111, 112, 116, 105, 111, 110, 97, 108, 95, 112, 117, 98, 108, 105, 99, 95, 105, 109, 112, 111,
    114, 116, 95, 109, 101, 115, 115, 97, 103, 101, 24, 26, 32, 1, 40, 11, 50, 45, 46, 112, 114,
    111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 95, 105, 109, 112,
    111, 114, 116, 46, 80, 117, 98, 108, 105, 99, 73, 109, 112, 111, 114, 116, 77, 101, 115, 115,
    97, 103, 101, 82, 27, 111, 112, 116, 105, 111, 110, 97, 108, 80, 117, 98, 108, 105, 99, 73,
    109, 112, 111, 114, 116, 77, 101, 115, 115, 97, 103, 101, 18, 101, 10, 21, 111, 112, 116, 105,
    111, 110, 97, 108, 95, 108, 97, 122, 121, 95, 109, 101, 115, 115, 97, 103, 101, 24, 27, 32, 1,
    40, 11, 50, 45, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101,
    115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 46, 78, 101, 115, 116,
    101, 100, 77, 101, 115, 115, 97, 103, 101, 82, 19, 111, 112, 116, 105, 111, 110, 97, 108, 76,
    97, 122, 121, 77, 101, 115, 115, 97, 103, 101, 66, 2, 40, 1, 18, 37, 10, 14, 114, 101, 112,
    101, 97, 116, 101, 100, 95, 105, 110, 116, 51, 50, 24, 31, 32, 3, 40, 5, 82, 13, 114, 101, 112,
    101, 97, 116, 101, 100, 73, 110, 116, 51, 50, 18, 37, 10, 14, 114, 101, 112, 101, 97, 116, 101,
    100, 95, 105, 110, 116, 54, 52, 24, 32, 32, 3, 40, 3, 82, 13, 114, 101, 112, 101, 97, 116, 101,
    100, 73, 110, 116, 54, 52, 18, 39, 10, 15, 114, 101, 112, 101, 97, 116, 101, 100, 95, 117, 105,
    110, 116, 51, 50, 24, 33, 32, 3, 40, 13, 82, 14, 114, 101, 112, 101, 97, 116, 101, 100, 85,
    105, 110, 116, 51, 50, 18, 39, 10, 15, 114, 101, 112, 101, 97, 116, 101, 100, 95, 117, 105,
    110, 116, 54, 52, 24, 34, 32, 3, 40, 4, 82, 14, 114, 101, 112, 101, 97, 116, 101, 100, 85, 105,
    110, 116, 54, 52, 18, 39, 10, 15, 114, 101, 112, 101, 97, 116, 101, 100, 95, 115, 105, 110,
    116, 51, 50, 24, 35, 32, 3, 40, 17, 82, 14, 114, 101, 112, 101, 97, 116, 101, 100, 83, 105,
    110, 116, 51, 50, 18, 39, 10, 15, 114, 101, 112, 101, 97, 116, 101, 100, 95, 115, 105, 110,
    116, 54, 52, 24, 36, 32, 3, 40, 18, 82, 14, 114, 101, 112, 101, 97, 116, 101, 100, 83, 105,
    110, 116, 54, 52, 18, 41, 10, 16, 114, 101, 112, 101, 97, 116, 101, 100, 95, 102, 105, 120,
    101, 100, 51, 50, 24, 37, 32, 3, 40, 7, 82, 15, 114, 101, 112, 101, 97, 116, 101, 100, 70, 105,
    120, 101, 100, 51, 50, 18, 41, 10, 16, 114, 101, 112, 101, 97, 116, 101, 100, 95, 102, 105,
    120, 101, 100, 54, 52, 24, 38, 32, 3, 40, 6, 82, 15, 114, 101, 112, 101, 97, 116, 101, 100, 70,
    105, 120, 101, 100, 54, 52, 18, 43, 10, 17, 114, 101, 112, 101, 97, 116, 101, 100, 95, 115,
    102, 105, 120, 101, 100, 51, 50, 24, 39, 32, 3, 40, 15, 82, 16, 114, 101, 112, 101, 97, 116,
    101, 100, 83, 102, 105, 120, 101, 100, 51, 50, 18, 43, 10, 17, 114, 101, 112, 101, 97, 116,
    101, 100, 95, 115, 102, 105, 120, 101, 100, 54, 52, 24, 40, 32, 3, 40, 16, 82, 16, 114, 101,
    112, 101, 97, 116, 101, 100, 83, 102, 105, 120, 101, 100, 54, 52, 18, 37, 10, 14, 114, 101,
    112, 101, 97, 116, 101, 100, 95, 102, 108, 111, 97, 116, 24, 41, 32, 3, 40, 2, 82, 13, 114,
    101, 112, 101, 97, 116, 101, 100, 70, 108, 111, 97, 116, 18, 39, 10, 15, 114, 101, 112, 101,
    97, 116, 101, 100, 95, 100, 111, 117, 98, 108, 101, 24, 42, 32, 3, 40, 1, 82, 14, 114, 101,
    112, 101, 97, 116, 101, 100, 68, 111, 117, 98, 108, 101, 18, 35, 10, 13, 114, 101, 112, 101,
    97, 116, 101, 100, 95, 98, 111, 111, 108, 24, 43, 32, 3, 40, 8, 82, 12, 114, 101, 112, 101, 97,
    116, 101, 100, 66, 111, 111, 108, 18, 39, 10, 15, 114, 101, 112, 101, 97, 116, 101, 100, 95,
    115, 116, 114, 105, 110, 103, 24, 44, 32, 3, 40, 9, 82, 14, 114, 101, 112, 101, 97, 116, 101,
    100, 83, 116, 114, 105, 110, 103, 18, 37, 10, 14, 114, 101, 112, 101, 97, 116, 101, 100, 95,
    98, 121, 116, 101, 115, 24, 45, 32, 3, 40, 12, 82, 13, 114, 101, 112, 101, 97, 116, 101, 100,
    66, 121, 116, 101, 115, 18, 83, 10, 13, 114, 101, 112, 101, 97, 116, 101, 100, 103, 114, 111,
    117, 112, 24, 46, 32, 3, 40, 10, 50, 45, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117,
    110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115,
    46, 82, 101, 112, 101, 97, 116, 101, 100, 71, 114, 111, 117, 112, 82, 13, 114, 101, 112, 101,
    97, 116, 101, 100, 103, 114, 111, 117, 112, 18, 101, 10, 23, 114, 101, 112, 101, 97, 116, 101,
    100, 95, 110, 101, 115, 116, 101, 100, 95, 109, 101, 115, 115, 97, 103, 101, 24, 48, 32, 3, 40,
    11, 50, 45, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115,
    116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 46, 78, 101, 115, 116, 101,
    100, 77, 101, 115, 115, 97, 103, 101, 82, 21, 114, 101, 112, 101, 97, 116, 101, 100, 78, 101,
    115, 116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 18, 91, 10, 24, 114, 101, 112, 101, 97,
    116, 101, 100, 95, 102, 111, 114, 101, 105, 103, 110, 95, 109, 101, 115, 115, 97, 103, 101, 24,
    49, 32, 3, 40, 11, 50, 33, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116,
    116, 101, 115, 116, 46, 70, 111, 114, 101, 105, 103, 110, 77, 101, 115, 115, 97, 103, 101, 82,
    22, 114, 101, 112, 101, 97, 116, 101, 100, 70, 111, 114, 101, 105, 103, 110, 77, 101, 115, 115,
    97, 103, 101, 18, 95, 10, 23, 114, 101, 112, 101, 97, 116, 101, 100, 95, 105, 109, 112, 111,
    114, 116, 95, 109, 101, 115, 115, 97, 103, 101, 24, 50, 32, 3, 40, 11, 50, 39, 46, 112, 114,
    111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 95, 105, 109, 112,
    111, 114, 116, 46, 73, 109, 112, 111, 114, 116, 77, 101, 115, 115, 97, 103, 101, 82, 21, 114,
    101, 112, 101, 97, 116, 101, 100, 73, 109, 112, 111, 114, 116, 77, 101, 115, 115, 97, 103, 101,
    18, 92, 10, 20, 114, 101, 112, 101, 97, 116, 101, 100, 95, 110, 101, 115, 116, 101, 100, 95,
    101, 110, 117, 109, 24, 51, 32, 3, 40, 14, 50, 42, 46, 112, 114, 111, 116, 111, 98, 117, 102,
    95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112,
    101, 115, 46, 78, 101, 115, 116, 101, 100, 69, 110, 117, 109, 82, 18, 114, 101, 112, 101, 97,
    116, 101, 100, 78, 101, 115, 116, 101, 100, 69, 110, 117, 109, 18, 82, 10, 21, 114, 101, 112,
    101, 97, 116, 101, 100, 95, 102, 111, 114, 101, 105, 103, 110, 95, 101, 110, 117, 109, 24, 52,
    32, 3, 40, 14, 50, 30, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116,
    101, 115, 116, 46, 70, 111, 114, 101, 105, 103, 110, 69, 110, 117, 109, 82, 19, 114, 101, 112,
    101, 97, 116, 101, 100, 70, 111, 114, 101, 105, 103, 110, 69, 110, 117, 109, 18, 86, 10, 20,
    114, 101, 112, 101, 97, 116, 101, 100, 95, 105, 109, 112, 111, 114, 116, 95, 101, 110, 117,
    109, 24, 53, 32, 3, 40, 14, 50, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110,
    105, 116, 116, 101, 115, 116, 95, 105, 109, 112, 111, 114, 116, 46, 73, 109, 112, 111, 114,
    116, 69, 110, 117, 109, 82, 18, 114, 101, 112, 101, 97, 116, 101, 100, 73, 109, 112, 111, 114,
    116, 69, 110, 117, 109, 18, 54, 10, 21, 114, 101, 112, 101, 97, 116, 101, 100, 95, 115, 116,
    114, 105, 110, 103, 95, 112, 105, 101, 99, 101, 24, 54, 32, 3, 40, 9, 82, 19, 114, 101, 112,
    101, 97, 116, 101, 100, 83, 116, 114, 105, 110, 103, 80, 105, 101, 99, 101, 66, 2, 8, 2, 18,
    39, 10, 13, 114, 101, 112, 101, 97, 116, 101, 100, 95, 99, 111, 114, 100, 24, 55, 32, 3, 40, 9,
    82, 12, 114, 101, 112, 101, 97, 116, 101, 100, 67, 111, 114, 100, 66, 2, 8, 1, 18, 101, 10, 21,
    114, 101, 112, 101, 97, 116, 101, 100, 95, 108, 97, 122, 121, 95, 109, 101, 115, 115, 97, 103,
    101, 24, 57, 32, 3, 40, 11, 50, 45, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110,
    105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 46,
    78, 101, 115, 116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 82, 19, 114, 101, 112, 101, 97,
    116, 101, 100, 76, 97, 122, 121, 77, 101, 115, 115, 97, 103, 101, 66, 2, 40, 1, 18, 39, 10, 13,
    100, 101, 102, 97, 117, 108, 116, 95, 105, 110, 116, 51, 50, 24, 61, 32, 1, 40, 5, 58, 2, 52,
    49, 82, 12, 100, 101, 102, 97, 117, 108, 116, 73, 110, 116, 51, 50, 18, 39, 10, 13, 100, 101,
    102, 97, 117, 108, 116, 95, 105, 110, 116, 54, 52, 24, 62, 32, 1, 40, 3, 58, 2, 52, 50, 82, 12,
    100, 101, 102, 97, 117, 108, 116, 73, 110, 116, 54, 52, 18, 41, 10, 14, 100, 101, 102, 97, 117,
    108, 116, 95, 117, 105, 110, 116, 51, 50, 24, 63, 32, 1, 40, 13, 58, 2, 52, 51, 82, 13, 100,
    101, 102, 97, 117, 108, 116, 85, 105, 110, 116, 51, 50, 18, 41, 10, 14, 100, 101, 102, 97, 117,
    108, 116, 95, 117, 105, 110, 116, 54, 52, 24, 64, 32, 1, 40, 4, 58, 2, 52, 52, 82, 13, 100,
    101, 102, 97, 117, 108, 116, 85, 105, 110, 116, 54, 52, 18, 42, 10, 14, 100, 101, 102, 97, 117,
    108, 116, 95, 115, 105, 110, 116, 51, 50, 24, 65, 32, 1, 40, 17, 58, 3, 45, 52, 53, 82, 13,
    100, 101, 102, 97, 117, 108, 116, 83, 105, 110, 116, 51, 50, 18, 41, 10, 14, 100, 101, 102, 97,
    117, 108, 116, 95, 115, 105, 110, 116, 54, 52, 24, 66, 32, 1, 40, 18, 58, 2, 52, 54, 82, 13,
    100, 101, 102, 97, 117, 108, 116, 83, 105, 110, 116, 54, 52, 18, 43, 10, 15, 100, 101, 102, 97,
    117, 108, 116, 95, 102, 105, 120, 101, 100, 51, 50, 24, 67, 32, 1, 40, 7, 58, 2, 52, 55, 82,
    14, 100, 101, 102, 97, 117, 108, 116, 70, 105, 120, 101, 100, 51, 50, 18, 43, 10, 15, 100, 101,
    102, 97, 117, 108, 116, 95, 102, 105, 120, 101, 100, 54, 52, 24, 68, 32, 1, 40, 6, 58, 2, 52,
    56, 82, 14, 100, 101, 102, 97, 117, 108, 116, 70, 105, 120, 101, 100, 54, 52, 18, 45, 10, 16,
    100, 101, 102, 97, 117, 108, 116, 95, 115, 102, 105, 120, 101, 100, 51, 50, 24, 69, 32, 1, 40,
    15, 58, 2, 52, 57, 82, 15, 100, 101, 102, 97, 117, 108, 116, 83, 102, 105, 120, 101, 100, 51,
    50, 18, 46, 10, 16, 100, 101, 102, 97, 117, 108, 116, 95, 115, 102, 105, 120, 101, 100, 54, 52,
    24, 70, 32, 1, 40, 16, 58, 3, 45, 53, 48, 82, 15, 100, 101, 102, 97, 117, 108, 116, 83, 102,
    105, 120, 101, 100, 54, 52, 18, 41, 10, 13, 100, 101, 102, 97, 117, 108, 116, 95, 102, 108,
    111, 97, 116, 24, 71, 32, 1, 40, 2, 58, 4, 53, 49, 46, 53, 82, 12, 100, 101, 102, 97, 117, 108,
    116, 70, 108, 111, 97, 116, 18, 44, 10, 14, 100, 101, 102, 97, 117, 108, 116, 95, 100, 111,
    117, 98, 108, 101, 24, 72, 32, 1, 40, 1, 58, 5, 53, 50, 48, 48, 48, 82, 13, 100, 101, 102, 97,
    117, 108, 116, 68, 111, 117, 98, 108, 101, 18, 39, 10, 12, 100, 101, 102, 97, 117, 108, 116,
    95, 98, 111, 111, 108, 24, 73, 32, 1, 40, 8, 58, 4, 116, 114, 117, 101, 82, 11, 100, 101, 102,
    97, 117, 108, 116, 66, 111, 111, 108, 18, 44, 10, 14, 100, 101, 102, 97, 117, 108, 116, 95,
    115, 116, 114, 105, 110, 103, 24, 74, 32, 1, 40, 9, 58, 5, 104, 101, 108, 108, 111, 82, 13,
    100, 101, 102, 97, 117, 108, 116, 83, 116, 114, 105, 110, 103, 18, 42, 10, 13, 100, 101, 102,
    97, 117, 108, 116, 95, 98, 121, 116, 101, 115, 24, 75, 32, 1, 40, 12, 58, 5, 119, 111, 114,
    108, 100, 82, 12, 100, 101, 102, 97, 117, 108, 116, 66, 121, 116, 101, 115, 18, 95, 10, 19,
    100, 101, 102, 97, 117, 108, 116, 95, 110, 101, 115, 116, 101, 100, 95, 101, 110, 117, 109, 24,
    81, 32, 1, 40, 14, 50, 42, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116,
    116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 46, 78, 101,
    115, 116, 101, 100, 69, 110, 117, 109, 58, 3, 66, 65, 82, 82, 17, 100, 101, 102, 97, 117, 108,
    116, 78, 101, 115, 116, 101, 100, 69, 110, 117, 109, 18, 93, 10, 20, 100, 101, 102, 97, 117,
    108, 116, 95, 102, 111, 114, 101, 105, 103, 110, 95, 101, 110, 117, 109, 24, 82, 32, 1, 40, 14,
    50, 30, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116,
    46, 70, 111, 114, 101, 105, 103, 110, 69, 110, 117, 109, 58, 11, 70, 79, 82, 69, 73, 71, 78,
    95, 66, 65, 82, 82, 18, 100, 101, 102, 97, 117, 108, 116, 70, 111, 114, 101, 105, 103, 110, 69,
    110, 117, 109, 18, 96, 10, 19, 100, 101, 102, 97, 117, 108, 116, 95, 105, 109, 112, 111, 114,
    116, 95, 101, 110, 117, 109, 24, 83, 32, 1, 40, 14, 50, 36, 46, 112, 114, 111, 116, 111, 98,
    117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 95, 105, 109, 112, 111, 114, 116, 46, 73,
    109, 112, 111, 114, 116, 69, 110, 117, 109, 58, 10, 73, 77, 80, 79, 82, 84, 95, 66, 65, 82, 82,
    17, 100, 101, 102, 97, 117, 108, 116, 73, 109, 112, 111, 114, 116, 69, 110, 117, 109, 18, 57,
    10, 20, 100, 101, 102, 97, 117, 108, 116, 95, 115, 116, 114, 105, 110, 103, 95, 112, 105, 101,
    99, 101, 24, 84, 32, 1, 40, 9, 58, 3, 97, 98, 99, 82, 18, 100, 101, 102, 97, 117, 108, 116, 83,
    116, 114, 105, 110, 103, 80, 105, 101, 99, 101, 66, 2, 8, 2, 18, 42, 10, 12, 100, 101, 102, 97,
    117, 108, 116, 95, 99, 111, 114, 100, 24, 85, 32, 1, 40, 9, 58, 3, 49, 50, 51, 82, 11, 100,
    101, 102, 97, 117, 108, 116, 67, 111, 114, 100, 66, 2, 8, 1, 18, 35, 10, 12, 111, 110, 101,
    111, 102, 95, 117, 105, 110, 116, 51, 50, 24, 111, 32, 1, 40, 13, 72, 0, 82, 11, 111, 110, 101,
    111, 102, 85, 105, 110, 116, 51, 50, 18, 97, 10, 20, 111, 110, 101, 111, 102, 95, 110, 101,
    115, 116, 101, 100, 95, 109, 101, 115, 115, 97, 103, 101, 24, 112, 32, 1, 40, 11, 50, 45, 46,
    112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101,
    115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 46, 78, 101, 115, 116, 101, 100, 77, 101, 115,
    115, 97, 103, 101, 72, 0, 82, 18, 111, 110, 101, 111, 102, 78, 101, 115, 116, 101, 100, 77,
    101, 115, 115, 97, 103, 101, 18, 35, 10, 12, 111, 110, 101, 111, 102, 95, 115, 116, 114, 105,
    110, 103, 24, 113, 32, 1, 40, 9, 72, 0, 82, 11, 111, 110, 101, 111, 102, 83, 116, 114, 105,
    110, 103, 18, 33, 10, 11, 111, 110, 101, 111, 102, 95, 98, 121, 116, 101, 115, 24, 114, 32, 1,
    40, 12, 72, 0, 82, 10, 111, 110, 101, 111, 102, 66, 121, 116, 101, 115, 26, 31, 10, 13, 78,
    101, 115, 116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 18, 14, 10, 2, 98, 98, 24, 1, 32, 1,
    40, 5, 82, 2, 98, 98, 26, 29, 10, 13, 79, 112, 116, 105, 111, 110, 97, 108, 71, 114, 111, 117,
    112, 18, 12, 10, 1, 97, 24, 17, 32, 1, 40, 5, 82, 1, 97, 26, 29, 10, 13, 82, 101, 112, 101, 97,
    116, 101, 100, 71, 114, 111, 117, 112, 18, 12, 10, 1, 97, 24, 47, 32, 1, 40, 5, 82, 1, 97, 34,
    57, 10, 10, 78, 101, 115, 116, 101, 100, 69, 110, 117, 109, 18, 7, 10, 3, 70, 79, 79, 16, 1,
    18, 7, 10, 3, 66, 65, 82, 16, 2, 18, 7, 10, 3, 66, 65, 90, 16, 3, 18, 16, 10, 3, 78, 69, 71,
    16, 255, 255, 255, 255, 255, 255, 255, 255, 255, 1, 66, 13, 10, 11, 111, 110, 101, 111, 102,
    95, 102, 105, 101, 108, 100, 34, 218, 1, 10, 18, 78, 101, 115, 116, 101, 100, 84, 101, 115,
    116, 65, 108, 108, 84, 121, 112, 101, 115, 18, 59, 10, 5, 99, 104, 105, 108, 100, 24, 1, 32, 1,
    40, 11, 50, 37, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101,
    115, 116, 46, 78, 101, 115, 116, 101, 100, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101,
    115, 82, 5, 99, 104, 105, 108, 100, 18, 57, 10, 7, 112, 97, 121, 108, 111, 97, 100, 24, 2, 32,
    1, 40, 11, 50, 31, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101,
    115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 82, 7, 112, 97, 121,
    108, 111, 97, 100, 18, 76, 10, 14, 114, 101, 112, 101, 97, 116, 101, 100, 95, 99, 104, 105,
    108, 100, 24, 3, 32, 3, 40, 11, 50, 37, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117,
    110, 105, 116, 116, 101, 115, 116, 46, 78, 101, 115, 116, 101, 100, 84, 101, 115, 116, 65, 108,
    108, 84, 121, 112, 101, 115, 82, 13, 114, 101, 112, 101, 97, 116, 101, 100, 67, 104, 105, 108,
    100, 34, 150, 1, 10, 20, 84, 101, 115, 116, 68, 101, 112, 114, 101, 99, 97, 116, 101, 100, 70,
    105, 101, 108, 100, 115, 18, 45, 10, 16, 100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 95,
    105, 110, 116, 51, 50, 24, 1, 32, 1, 40, 5, 82, 15, 100, 101, 112, 114, 101, 99, 97, 116, 101,
    100, 73, 110, 116, 51, 50, 66, 2, 24, 1, 18, 63, 10, 25, 100, 101, 112, 114, 101, 99, 97, 116,
    101, 100, 95, 105, 110, 116, 51, 50, 95, 105, 110, 95, 111, 110, 101, 111, 102, 24, 2, 32, 1,
    40, 5, 72, 0, 82, 22, 100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 73, 110, 116, 51, 50, 73,
    110, 79, 110, 101, 111, 102, 66, 2, 24, 1, 66, 14, 10, 12, 111, 110, 101, 111, 102, 95, 102,
    105, 101, 108, 100, 115, 34, 27, 10, 21, 84, 101, 115, 116, 68, 101, 112, 114, 101, 99, 97,
    116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 58, 2, 24, 1, 34, 44, 10, 14, 70, 111, 114,
    101, 105, 103, 110, 77, 101, 115, 115, 97, 103, 101, 18, 12, 10, 1, 99, 24, 1, 32, 1, 40, 5,
    82, 1, 99, 18, 12, 10, 1, 100, 24, 2, 32, 1, 40, 5, 82, 1, 100, 34, 48, 10, 18, 84, 101, 115,
    116, 82, 101, 115, 101, 114, 118, 101, 100, 70, 105, 101, 108, 100, 115, 74, 4, 8, 2, 16, 3,
    74, 4, 8, 15, 16, 16, 74, 4, 8, 9, 16, 12, 82, 3, 98, 97, 114, 82, 3, 98, 97, 122, 34, 29, 10,
    17, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 42, 8, 8,
    1, 16, 128, 128, 128, 128, 2, 34, 39, 10, 23, 79, 112, 116, 105, 111, 110, 97, 108, 71, 114,
    111, 117, 112, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 18, 12, 10, 1, 97, 24, 17, 32,
    1, 40, 5, 82, 1, 97, 34, 39, 10, 23, 82, 101, 112, 101, 97, 116, 101, 100, 71, 114, 111, 117,
    112, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 18, 12, 10, 1, 97, 24, 47, 32, 1, 40, 5,
    82, 1, 97, 34, 208, 1, 10, 9, 84, 101, 115, 116, 71, 114, 111, 117, 112, 18, 80, 10, 13, 111,
    112, 116, 105, 111, 110, 97, 108, 103, 114, 111, 117, 112, 24, 16, 32, 1, 40, 10, 50, 42, 46,
    112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101,
    115, 116, 71, 114, 111, 117, 112, 46, 79, 112, 116, 105, 111, 110, 97, 108, 71, 114, 111, 117,
    112, 82, 13, 111, 112, 116, 105, 111, 110, 97, 108, 103, 114, 111, 117, 112, 18, 82, 10, 21,
    111, 112, 116, 105, 111, 110, 97, 108, 95, 102, 111, 114, 101, 105, 103, 110, 95, 101, 110,
    117, 109, 24, 22, 32, 1, 40, 14, 50, 30, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117,
    110, 105, 116, 116, 101, 115, 116, 46, 70, 111, 114, 101, 105, 103, 110, 69, 110, 117, 109, 82,
    19, 111, 112, 116, 105, 111, 110, 97, 108, 70, 111, 114, 101, 105, 103, 110, 69, 110, 117, 109,
    26, 29, 10, 13, 79, 112, 116, 105, 111, 110, 97, 108, 71, 114, 111, 117, 112, 18, 12, 10, 1,
    97, 24, 17, 32, 1, 40, 5, 82, 1, 97, 34, 30, 10, 18, 84, 101, 115, 116, 71, 114, 111, 117, 112,
    69, 120, 116, 101, 110, 115, 105, 111, 110, 42, 8, 8, 1, 16, 128, 128, 128, 128, 2, 34, 142, 4,
    10, 19, 84, 101, 115, 116, 78, 101, 115, 116, 101, 100, 69, 120, 116, 101, 110, 115, 105, 111,
    110, 50, 63, 10, 4, 116, 101, 115, 116, 24, 234, 7, 32, 1, 40, 9, 18, 36, 46, 112, 114, 111,
    116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65,
    108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 58, 4, 116, 101, 115, 116, 82, 4,
    116, 101, 115, 116, 50, 93, 10, 23, 110, 101, 115, 116, 101, 100, 95, 115, 116, 114, 105, 110,
    103, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 235, 7, 32, 1, 40, 9, 18, 36, 46,
    112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101,
    115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 21, 110, 101, 115,
    116, 101, 100, 83, 116, 114, 105, 110, 103, 69, 120, 116, 101, 110, 115, 105, 111, 110, 50,
    158, 1, 10, 23, 111, 112, 116, 105, 111, 110, 97, 108, 103, 114, 111, 117, 112, 95, 101, 120,
    116, 101, 110, 115, 105, 111, 110, 24, 16, 32, 1, 40, 10, 50, 62, 46, 112, 114, 111, 116, 111,
    98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 78, 101, 115,
    116, 101, 100, 69, 120, 116, 101, 110, 115, 105, 111, 110, 46, 79, 112, 116, 105, 111, 110, 97,
    108, 71, 114, 111, 117, 112, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 18, 37, 46, 112,
    114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115,
    116, 71, 114, 111, 117, 112, 69, 120, 116, 101, 110, 115, 105, 111, 110, 82, 22, 111, 112, 116,
    105, 111, 110, 97, 108, 103, 114, 111, 117, 112, 69, 120, 116, 101, 110, 115, 105, 111, 110,
    50, 140, 1, 10, 31, 111, 112, 116, 105, 111, 110, 97, 108, 95, 102, 111, 114, 101, 105, 103,
    110, 95, 101, 110, 117, 109, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 22, 32, 1,
    40, 14, 50, 30, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101,
    115, 116, 46, 70, 111, 114, 101, 105, 103, 110, 69, 110, 117, 109, 18, 37, 46, 112, 114, 111,
    116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 71,
    114, 111, 117, 112, 69, 120, 116, 101, 110, 115, 105, 111, 110, 82, 28, 111, 112, 116, 105,
    111, 110, 97, 108, 70, 111, 114, 101, 105, 103, 110, 69, 110, 117, 109, 69, 120, 116, 101, 110,
    115, 105, 111, 110, 26, 39, 10, 23, 79, 112, 116, 105, 111, 110, 97, 108, 71, 114, 111, 117,
    112, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 18, 12, 10, 1, 97, 24, 17, 32, 1, 40, 5,
    82, 1, 97, 34, 244, 7, 10, 12, 84, 101, 115, 116, 82, 101, 113, 117, 105, 114, 101, 100, 18,
    12, 10, 1, 97, 24, 1, 32, 2, 40, 5, 82, 1, 97, 18, 22, 10, 6, 100, 117, 109, 109, 121, 50, 24,
    2, 32, 1, 40, 5, 82, 6, 100, 117, 109, 109, 121, 50, 18, 12, 10, 1, 98, 24, 3, 32, 2, 40, 5,
    82, 1, 98, 18, 22, 10, 6, 100, 117, 109, 109, 121, 52, 24, 4, 32, 1, 40, 5, 82, 6, 100, 117,
    109, 109, 121, 52, 18, 22, 10, 6, 100, 117, 109, 109, 121, 53, 24, 5, 32, 1, 40, 5, 82, 6, 100,
    117, 109, 109, 121, 53, 18, 22, 10, 6, 100, 117, 109, 109, 121, 54, 24, 6, 32, 1, 40, 5, 82, 6,
    100, 117, 109, 109, 121, 54, 18, 22, 10, 6, 100, 117, 109, 109, 121, 55, 24, 7, 32, 1, 40, 5,
    82, 6, 100, 117, 109, 109, 121, 55, 18, 22, 10, 6, 100, 117, 109, 109, 121, 56, 24, 8, 32, 1,
    40, 5, 82, 6, 100, 117, 109, 109, 121, 56, 18, 22, 10, 6, 100, 117, 109, 109, 121, 57, 24, 9,
    32, 1, 40, 5, 82, 6, 100, 117, 109, 109, 121, 57, 18, 24, 10, 7, 100, 117, 109, 109, 121, 49,
    48, 24, 10, 32, 1, 40, 5, 82, 7, 100, 117, 109, 109, 121, 49, 48, 18, 24, 10, 7, 100, 117, 109,
    109, 121, 49, 49, 24, 11, 32, 1, 40, 5, 82, 7, 100, 117, 109, 109, 121, 49, 49, 18, 24, 10, 7,
    100, 117, 109, 109, 121, 49, 50, 24, 12, 32, 1, 40, 5, 82, 7, 100, 117, 109, 109, 121, 49, 50,
    18, 24, 10, 7, 100, 117, 109, 109, 121, 49, 51, 24, 13, 32, 1, 40, 5, 82, 7, 100, 117, 109,
    109, 121, 49, 51, 18, 24, 10, 7, 100, 117, 109, 109, 121, 49, 52, 24, 14, 32, 1, 40, 5, 82, 7,
    100, 117, 109, 109, 121, 49, 52, 18, 24, 10, 7, 100, 117, 109, 109, 121, 49, 53, 24, 15, 32, 1,
    40, 5, 82, 7, 100, 117, 109, 109, 121, 49, 53, 18, 24, 10, 7, 100, 117, 109, 109, 121, 49, 54,
    24, 16, 32, 1, 40, 5, 82, 7, 100, 117, 109, 109, 121, 49, 54, 18, 24, 10, 7, 100, 117, 109,
    109, 121, 49, 55, 24, 17, 32, 1, 40, 5, 82, 7, 100, 117, 109, 109, 121, 49, 55, 18, 24, 10, 7,
    100, 117, 109, 109, 121, 49, 56, 24, 18, 32, 1, 40, 5, 82, 7, 100, 117, 109, 109, 121, 49, 56,
    18, 24, 10, 7, 100, 117, 109, 109, 121, 49, 57, 24, 19, 32, 1, 40, 5, 82, 7, 100, 117, 109,
    109, 121, 49, 57, 18, 24, 10, 7, 100, 117, 109, 109, 121, 50, 48, 24, 20, 32, 1, 40, 5, 82, 7,
    100, 117, 109, 109, 121, 50, 48, 18, 24, 10, 7, 100, 117, 109, 109, 121, 50, 49, 24, 21, 32, 1,
    40, 5, 82, 7, 100, 117, 109, 109, 121, 50, 49, 18, 24, 10, 7, 100, 117, 109, 109, 121, 50, 50,
    24, 22, 32, 1, 40, 5, 82, 7, 100, 117, 109, 109, 121, 50, 50, 18, 24, 10, 7, 100, 117, 109,
    109, 121, 50, 51, 24, 23, 32, 1, 40, 5, 82, 7, 100, 117, 109, 109, 121, 50, 51, 18, 24, 10, 7,
    100, 117, 109, 109, 121, 50, 52, 24, 24, 32, 1, 40, 5, 82, 7, 100, 117, 109, 109, 121, 50, 52,
    18, 24, 10, 7, 100, 117, 109, 109, 121, 50, 53, 24, 25, 32, 1, 40, 5, 82, 7, 100, 117, 109,
    109, 121, 50, 53, 18, 24, 10, 7, 100, 117, 109, 109, 121, 50, 54, 24, 26, 32, 1, 40, 5, 82, 7,
    100, 117, 109, 109, 121, 50, 54, 18, 24, 10, 7, 100, 117, 109, 109, 121, 50, 55, 24, 27, 32, 1,
    40, 5, 82, 7, 100, 117, 109, 109, 121, 50, 55, 18, 24, 10, 7, 100, 117, 109, 109, 121, 50, 56,
    24, 28, 32, 1, 40, 5, 82, 7, 100, 117, 109, 109, 121, 50, 56, 18, 24, 10, 7, 100, 117, 109,
    109, 121, 50, 57, 24, 29, 32, 1, 40, 5, 82, 7, 100, 117, 109, 109, 121, 50, 57, 18, 24, 10, 7,
    100, 117, 109, 109, 121, 51, 48, 24, 30, 32, 1, 40, 5, 82, 7, 100, 117, 109, 109, 121, 51, 48,
    18, 24, 10, 7, 100, 117, 109, 109, 121, 51, 49, 24, 31, 32, 1, 40, 5, 82, 7, 100, 117, 109,
    109, 121, 51, 49, 18, 24, 10, 7, 100, 117, 109, 109, 121, 51, 50, 24, 32, 32, 1, 40, 5, 82, 7,
    100, 117, 109, 109, 121, 51, 50, 18, 12, 10, 1, 99, 24, 33, 32, 2, 40, 5, 82, 1, 99, 50, 94,
    10, 6, 115, 105, 110, 103, 108, 101, 24, 232, 7, 32, 1, 40, 11, 50, 31, 46, 112, 114, 111, 116,
    111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 82, 101,
    113, 117, 105, 114, 101, 100, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110,
    105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115,
    105, 111, 110, 115, 82, 6, 115, 105, 110, 103, 108, 101, 50, 92, 10, 5, 109, 117, 108, 116,
    105, 24, 233, 7, 32, 3, 40, 11, 50, 31, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117,
    110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 82, 101, 113, 117, 105, 114, 101,
    100, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115,
    116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82,
    5, 109, 117, 108, 116, 105, 34, 195, 1, 10, 19, 84, 101, 115, 116, 82, 101, 113, 117, 105, 114,
    101, 100, 70, 111, 114, 101, 105, 103, 110, 18, 74, 10, 16, 111, 112, 116, 105, 111, 110, 97,
    108, 95, 109, 101, 115, 115, 97, 103, 101, 24, 1, 32, 1, 40, 11, 50, 31, 46, 112, 114, 111,
    116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 82,
    101, 113, 117, 105, 114, 101, 100, 82, 15, 111, 112, 116, 105, 111, 110, 97, 108, 77, 101, 115,
    115, 97, 103, 101, 18, 74, 10, 16, 114, 101, 112, 101, 97, 116, 101, 100, 95, 109, 101, 115,
    115, 97, 103, 101, 24, 2, 32, 3, 40, 11, 50, 31, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95,
    117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 82, 101, 113, 117, 105, 114,
    101, 100, 82, 15, 114, 101, 112, 101, 97, 116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 18,
    20, 10, 5, 100, 117, 109, 109, 121, 24, 3, 32, 1, 40, 5, 82, 5, 100, 117, 109, 109, 121, 34,
    249, 1, 10, 19, 84, 101, 115, 116, 82, 101, 113, 117, 105, 114, 101, 100, 77, 101, 115, 115,
    97, 103, 101, 18, 74, 10, 16, 111, 112, 116, 105, 111, 110, 97, 108, 95, 109, 101, 115, 115,
    97, 103, 101, 24, 1, 32, 1, 40, 11, 50, 31, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117,
    110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 82, 101, 113, 117, 105, 114, 101,
    100, 82, 15, 111, 112, 116, 105, 111, 110, 97, 108, 77, 101, 115, 115, 97, 103, 101, 18, 74,
    10, 16, 114, 101, 112, 101, 97, 116, 101, 100, 95, 109, 101, 115, 115, 97, 103, 101, 24, 2, 32,
    3, 40, 11, 50, 31, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101,
    115, 116, 46, 84, 101, 115, 116, 82, 101, 113, 117, 105, 114, 101, 100, 82, 15, 114, 101, 112,
    101, 97, 116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 18, 74, 10, 16, 114, 101, 113, 117,
    105, 114, 101, 100, 95, 109, 101, 115, 115, 97, 103, 101, 24, 3, 32, 2, 40, 11, 50, 31, 46,
    112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101,
    115, 116, 82, 101, 113, 117, 105, 114, 101, 100, 82, 15, 114, 101, 113, 117, 105, 114, 101,
    100, 77, 101, 115, 115, 97, 103, 101, 34, 105, 10, 17, 84, 101, 115, 116, 70, 111, 114, 101,
    105, 103, 110, 78, 101, 115, 116, 101, 100, 18, 84, 10, 14, 102, 111, 114, 101, 105, 103, 110,
    95, 110, 101, 115, 116, 101, 100, 24, 1, 32, 1, 40, 11, 50, 45, 46, 112, 114, 111, 116, 111,
    98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108,
    84, 121, 112, 101, 115, 46, 78, 101, 115, 116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 82,
    13, 102, 111, 114, 101, 105, 103, 110, 78, 101, 115, 116, 101, 100, 34, 18, 10, 16, 84, 101,
    115, 116, 69, 109, 112, 116, 121, 77, 101, 115, 115, 97, 103, 101, 34, 42, 10, 30, 84, 101,
    115, 116, 69, 109, 112, 116, 121, 77, 101, 115, 115, 97, 103, 101, 87, 105, 116, 104, 69, 120,
    116, 101, 110, 115, 105, 111, 110, 115, 42, 8, 8, 1, 16, 128, 128, 128, 128, 2, 34, 55, 10, 27,
    84, 101, 115, 116, 77, 117, 108, 116, 105, 112, 108, 101, 69, 120, 116, 101, 110, 115, 105,
    111, 110, 82, 97, 110, 103, 101, 115, 42, 4, 8, 42, 16, 43, 42, 6, 8, 175, 32, 16, 148, 33, 42,
    10, 8, 128, 128, 4, 16, 128, 128, 128, 128, 2, 34, 59, 10, 24, 84, 101, 115, 116, 82, 101, 97,
    108, 108, 121, 76, 97, 114, 103, 101, 84, 97, 103, 78, 117, 109, 98, 101, 114, 18, 12, 10, 1,
    97, 24, 1, 32, 1, 40, 5, 82, 1, 97, 18, 17, 10, 2, 98, 98, 24, 255, 255, 255, 127, 32, 1, 40,
    5, 82, 2, 98, 98, 34, 91, 10, 20, 84, 101, 115, 116, 82, 101, 99, 117, 114, 115, 105, 118, 101,
    77, 101, 115, 115, 97, 103, 101, 18, 53, 10, 1, 97, 24, 1, 32, 1, 40, 11, 50, 39, 46, 112, 114,
    111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116,
    82, 101, 99, 117, 114, 115, 105, 118, 101, 77, 101, 115, 115, 97, 103, 101, 82, 1, 97, 18, 12,
    10, 1, 105, 24, 2, 32, 1, 40, 5, 82, 1, 105, 34, 140, 3, 10, 20, 84, 101, 115, 116, 77, 117,
    116, 117, 97, 108, 82, 101, 99, 117, 114, 115, 105, 111, 110, 65, 18, 55, 10, 2, 98, 98, 24, 1,
    32, 1, 40, 11, 50, 39, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116,
    101, 115, 116, 46, 84, 101, 115, 116, 77, 117, 116, 117, 97, 108, 82, 101, 99, 117, 114, 115,
    105, 111, 110, 66, 82, 2, 98, 98, 18, 76, 10, 8, 115, 117, 98, 103, 114, 111, 117, 112, 24, 2,
    32, 1, 40, 10, 50, 48, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116,
    101, 115, 116, 46, 84, 101, 115, 116, 77, 117, 116, 117, 97, 108, 82, 101, 99, 117, 114, 115,
    105, 111, 110, 65, 46, 83, 117, 98, 71, 114, 111, 117, 112, 82, 8, 115, 117, 98, 103, 114, 111,
    117, 112, 26, 67, 10, 10, 83, 117, 98, 77, 101, 115, 115, 97, 103, 101, 18, 53, 10, 1, 98, 24,
    1, 32, 1, 40, 11, 50, 39, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116,
    116, 101, 115, 116, 46, 84, 101, 115, 116, 77, 117, 116, 117, 97, 108, 82, 101, 99, 117, 114,
    115, 105, 111, 110, 66, 82, 1, 98, 26, 167, 1, 10, 8, 83, 117, 98, 71, 114, 111, 117, 112, 18,
    83, 10, 11, 115, 117, 98, 95, 109, 101, 115, 115, 97, 103, 101, 24, 3, 32, 1, 40, 11, 50, 50,
    46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84,
    101, 115, 116, 77, 117, 116, 117, 97, 108, 82, 101, 99, 117, 114, 115, 105, 111, 110, 65, 46,
    83, 117, 98, 77, 101, 115, 115, 97, 103, 101, 82, 10, 115, 117, 98, 77, 101, 115, 115, 97, 103,
    101, 18, 70, 10, 15, 110, 111, 116, 95, 105, 110, 95, 116, 104, 105, 115, 95, 115, 99, 99, 24,
    4, 32, 1, 40, 11, 50, 31, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116,
    116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 82, 12, 110,
    111, 116, 73, 110, 84, 104, 105, 115, 83, 99, 99, 34, 116, 10, 20, 84, 101, 115, 116, 77, 117,
    116, 117, 97, 108, 82, 101, 99, 117, 114, 115, 105, 111, 110, 66, 18, 53, 10, 1, 97, 24, 1, 32,
    1, 40, 11, 50, 39, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101,
    115, 116, 46, 84, 101, 115, 116, 77, 117, 116, 117, 97, 108, 82, 101, 99, 117, 114, 115, 105,
    111, 110, 65, 82, 1, 97, 18, 37, 10, 14, 111, 112, 116, 105, 111, 110, 97, 108, 95, 105, 110,
    116, 51, 50, 24, 2, 32, 1, 40, 5, 82, 13, 111, 112, 116, 105, 111, 110, 97, 108, 73, 110, 116,
    51, 50, 34, 227, 1, 10, 17, 84, 101, 115, 116, 73, 115, 73, 110, 105, 116, 105, 97, 108, 105,
    122, 101, 100, 18, 80, 10, 11, 115, 117, 98, 95, 109, 101, 115, 115, 97, 103, 101, 24, 1, 32,
    1, 40, 11, 50, 47, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101,
    115, 116, 46, 84, 101, 115, 116, 73, 115, 73, 110, 105, 116, 105, 97, 108, 105, 122, 101, 100,
    46, 83, 117, 98, 77, 101, 115, 115, 97, 103, 101, 82, 10, 115, 117, 98, 77, 101, 115, 115, 97,
    103, 101, 26, 124, 10, 10, 83, 117, 98, 77, 101, 115, 115, 97, 103, 101, 18, 84, 10, 8, 115,
    117, 98, 103, 114, 111, 117, 112, 24, 1, 32, 1, 40, 10, 50, 56, 46, 112, 114, 111, 116, 111,
    98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 73, 115, 73,
    110, 105, 116, 105, 97, 108, 105, 122, 101, 100, 46, 83, 117, 98, 77, 101, 115, 115, 97, 103,
    101, 46, 83, 117, 98, 71, 114, 111, 117, 112, 82, 8, 115, 117, 98, 103, 114, 111, 117, 112, 26,
    24, 10, 8, 83, 117, 98, 71, 114, 111, 117, 112, 18, 12, 10, 1, 105, 24, 2, 32, 2, 40, 5, 82, 1,
    105, 34, 198, 1, 10, 18, 84, 101, 115, 116, 68, 117, 112, 70, 105, 101, 108, 100, 78, 117, 109,
    98, 101, 114, 18, 12, 10, 1, 97, 24, 1, 32, 1, 40, 5, 82, 1, 97, 18, 59, 10, 3, 102, 111, 111,
    24, 2, 32, 1, 40, 10, 50, 41, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105,
    116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 68, 117, 112, 70, 105, 101, 108, 100, 78, 117,
    109, 98, 101, 114, 46, 70, 111, 111, 82, 3, 102, 111, 111, 18, 59, 10, 3, 98, 97, 114, 24, 3,
    32, 1, 40, 10, 50, 41, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116,
    101, 115, 116, 46, 84, 101, 115, 116, 68, 117, 112, 70, 105, 101, 108, 100, 78, 117, 109, 98,
    101, 114, 46, 66, 97, 114, 82, 3, 98, 97, 114, 26, 19, 10, 3, 70, 111, 111, 18, 12, 10, 1, 97,
    24, 1, 32, 1, 40, 5, 82, 1, 97, 26, 19, 10, 3, 66, 97, 114, 18, 12, 10, 1, 97, 24, 1, 32, 1,
    40, 5, 82, 1, 97, 34, 88, 10, 16, 84, 101, 115, 116, 69, 97, 103, 101, 114, 77, 101, 115, 115,
    97, 103, 101, 18, 68, 10, 11, 115, 117, 98, 95, 109, 101, 115, 115, 97, 103, 101, 24, 1, 32, 1,
    40, 11, 50, 31, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101,
    115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 82, 10, 115, 117, 98,
    77, 101, 115, 115, 97, 103, 101, 66, 2, 40, 0, 34, 87, 10, 15, 84, 101, 115, 116, 76, 97, 122,
    121, 77, 101, 115, 115, 97, 103, 101, 18, 68, 10, 11, 115, 117, 98, 95, 109, 101, 115, 115, 97,
    103, 101, 24, 1, 32, 1, 40, 11, 50, 31, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117,
    110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115,
    82, 10, 115, 117, 98, 77, 101, 115, 115, 97, 103, 101, 66, 2, 40, 1, 34, 216, 2, 10, 24, 84,
    101, 115, 116, 78, 101, 115, 116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 72, 97, 115, 66,
    105, 116, 115, 18, 113, 10, 23, 111, 112, 116, 105, 111, 110, 97, 108, 95, 110, 101, 115, 116,
    101, 100, 95, 109, 101, 115, 115, 97, 103, 101, 24, 1, 32, 1, 40, 11, 50, 57, 46, 112, 114,
    111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116,
    78, 101, 115, 116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 72, 97, 115, 66, 105, 116, 115,
    46, 78, 101, 115, 116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 82, 21, 111, 112, 116, 105,
    111, 110, 97, 108, 78, 101, 115, 116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 26, 200, 1,
    10, 13, 78, 101, 115, 116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 18, 64, 10, 28, 110, 101,
    115, 116, 101, 100, 109, 101, 115, 115, 97, 103, 101, 95, 114, 101, 112, 101, 97, 116, 101,
    100, 95, 105, 110, 116, 51, 50, 24, 1, 32, 3, 40, 5, 82, 26, 110, 101, 115, 116, 101, 100, 109,
    101, 115, 115, 97, 103, 101, 82, 101, 112, 101, 97, 116, 101, 100, 73, 110, 116, 51, 50, 18,
    117, 10, 37, 110, 101, 115, 116, 101, 100, 109, 101, 115, 115, 97, 103, 101, 95, 114, 101, 112,
    101, 97, 116, 101, 100, 95, 102, 111, 114, 101, 105, 103, 110, 109, 101, 115, 115, 97, 103,
    101, 24, 2, 32, 3, 40, 11, 50, 33, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110,
    105, 116, 116, 101, 115, 116, 46, 70, 111, 114, 101, 105, 103, 110, 77, 101, 115, 115, 97, 103,
    101, 82, 35, 110, 101, 115, 116, 101, 100, 109, 101, 115, 115, 97, 103, 101, 82, 101, 112, 101,
    97, 116, 101, 100, 70, 111, 114, 101, 105, 103, 110, 109, 101, 115, 115, 97, 103, 101, 34, 187,
    5, 10, 23, 84, 101, 115, 116, 67, 97, 109, 101, 108, 67, 97, 115, 101, 70, 105, 101, 108, 100,
    78, 97, 109, 101, 115, 18, 38, 10, 14, 80, 114, 105, 109, 105, 116, 105, 118, 101, 70, 105,
    101, 108, 100, 24, 1, 32, 1, 40, 5, 82, 14, 80, 114, 105, 109, 105, 116, 105, 118, 101, 70,
    105, 101, 108, 100, 18, 32, 10, 11, 83, 116, 114, 105, 110, 103, 70, 105, 101, 108, 100, 24, 2,
    32, 1, 40, 9, 82, 11, 83, 116, 114, 105, 110, 103, 70, 105, 101, 108, 100, 18, 60, 10, 9, 69,
    110, 117, 109, 70, 105, 101, 108, 100, 24, 3, 32, 1, 40, 14, 50, 30, 46, 112, 114, 111, 116,
    111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 70, 111, 114, 101, 105, 103,
    110, 69, 110, 117, 109, 82, 9, 69, 110, 117, 109, 70, 105, 101, 108, 100, 18, 69, 10, 12, 77,
    101, 115, 115, 97, 103, 101, 70, 105, 101, 108, 100, 24, 4, 32, 1, 40, 11, 50, 33, 46, 112,
    114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 70, 111, 114,
    101, 105, 103, 110, 77, 101, 115, 115, 97, 103, 101, 82, 12, 77, 101, 115, 115, 97, 103, 101,
    70, 105, 101, 108, 100, 18, 46, 10, 16, 83, 116, 114, 105, 110, 103, 80, 105, 101, 99, 101, 70,
    105, 101, 108, 100, 24, 5, 32, 1, 40, 9, 82, 16, 83, 116, 114, 105, 110, 103, 80, 105, 101, 99,
    101, 70, 105, 101, 108, 100, 66, 2, 8, 2, 18, 32, 10, 9, 67, 111, 114, 100, 70, 105, 101, 108,
    100, 24, 6, 32, 1, 40, 9, 82, 9, 67, 111, 114, 100, 70, 105, 101, 108, 100, 66, 2, 8, 1, 18,
    54, 10, 22, 82, 101, 112, 101, 97, 116, 101, 100, 80, 114, 105, 109, 105, 116, 105, 118, 101,
    70, 105, 101, 108, 100, 24, 7, 32, 3, 40, 5, 82, 22, 82, 101, 112, 101, 97, 116, 101, 100, 80,
    114, 105, 109, 105, 116, 105, 118, 101, 70, 105, 101, 108, 100, 18, 48, 10, 19, 82, 101, 112,
    101, 97, 116, 101, 100, 83, 116, 114, 105, 110, 103, 70, 105, 101, 108, 100, 24, 8, 32, 3, 40,
    9, 82, 19, 82, 101, 112, 101, 97, 116, 101, 100, 83, 116, 114, 105, 110, 103, 70, 105, 101,
    108, 100, 18, 76, 10, 17, 82, 101, 112, 101, 97, 116, 101, 100, 69, 110, 117, 109, 70, 105,
    101, 108, 100, 24, 9, 32, 3, 40, 14, 50, 30, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95,
    117, 110, 105, 116, 116, 101, 115, 116, 46, 70, 111, 114, 101, 105, 103, 110, 69, 110, 117,
    109, 82, 17, 82, 101, 112, 101, 97, 116, 101, 100, 69, 110, 117, 109, 70, 105, 101, 108, 100,
    18, 85, 10, 20, 82, 101, 112, 101, 97, 116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 70, 105,
    101, 108, 100, 24, 10, 32, 3, 40, 11, 50, 33, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95,
    117, 110, 105, 116, 116, 101, 115, 116, 46, 70, 111, 114, 101, 105, 103, 110, 77, 101, 115,
    115, 97, 103, 101, 82, 20, 82, 101, 112, 101, 97, 116, 101, 100, 77, 101, 115, 115, 97, 103,
    101, 70, 105, 101, 108, 100, 18, 62, 10, 24, 82, 101, 112, 101, 97, 116, 101, 100, 83, 116,
    114, 105, 110, 103, 80, 105, 101, 99, 101, 70, 105, 101, 108, 100, 24, 11, 32, 3, 40, 9, 82,
    24, 82, 101, 112, 101, 97, 116, 101, 100, 83, 116, 114, 105, 110, 103, 80, 105, 101, 99, 101,
    70, 105, 101, 108, 100, 66, 2, 8, 2, 18, 48, 10, 17, 82, 101, 112, 101, 97, 116, 101, 100, 67,
    111, 114, 100, 70, 105, 101, 108, 100, 24, 12, 32, 3, 40, 9, 82, 17, 82, 101, 112, 101, 97,
    116, 101, 100, 67, 111, 114, 100, 70, 105, 101, 108, 100, 66, 2, 8, 1, 34, 142, 2, 10, 18, 84,
    101, 115, 116, 70, 105, 101, 108, 100, 79, 114, 100, 101, 114, 105, 110, 103, 115, 18, 27, 10,
    9, 109, 121, 95, 115, 116, 114, 105, 110, 103, 24, 11, 32, 1, 40, 9, 82, 8, 109, 121, 83, 116,
    114, 105, 110, 103, 18, 21, 10, 6, 109, 121, 95, 105, 110, 116, 24, 1, 32, 1, 40, 3, 82, 5,
    109, 121, 73, 110, 116, 18, 25, 10, 8, 109, 121, 95, 102, 108, 111, 97, 116, 24, 101, 32, 1,
    40, 2, 82, 7, 109, 121, 70, 108, 111, 97, 116, 18, 108, 10, 23, 111, 112, 116, 105, 111, 110,
    97, 108, 95, 110, 101, 115, 116, 101, 100, 95, 109, 101, 115, 115, 97, 103, 101, 24, 200, 1,
    32, 1, 40, 11, 50, 51, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116,
    101, 115, 116, 46, 84, 101, 115, 116, 70, 105, 101, 108, 100, 79, 114, 100, 101, 114, 105, 110,
    103, 115, 46, 78, 101, 115, 116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 82, 21, 111, 112,
    116, 105, 111, 110, 97, 108, 78, 101, 115, 116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 26,
    47, 10, 13, 78, 101, 115, 116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 18, 14, 10, 2, 111,
    111, 24, 2, 32, 1, 40, 3, 82, 2, 111, 111, 18, 14, 10, 2, 98, 98, 24, 1, 32, 1, 40, 5, 82, 2,
    98, 98, 42, 4, 8, 2, 16, 11, 42, 4, 8, 12, 16, 101, 34, 186, 1, 10, 23, 84, 101, 115, 116, 69,
    120, 116, 101, 110, 115, 105, 111, 110, 79, 114, 100, 101, 114, 105, 110, 103, 115, 49, 18, 27,
    10, 9, 109, 121, 95, 115, 116, 114, 105, 110, 103, 24, 1, 32, 1, 40, 9, 82, 8, 109, 121, 83,
    116, 114, 105, 110, 103, 50, 129, 1, 10, 19, 116, 101, 115, 116, 95, 101, 120, 116, 95, 111,
    114, 100, 101, 114, 105, 110, 103, 115, 49, 24, 13, 32, 1, 40, 11, 50, 42, 46, 112, 114, 111,
    116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 69,
    120, 116, 101, 110, 115, 105, 111, 110, 79, 114, 100, 101, 114, 105, 110, 103, 115, 49, 18, 37,
    46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84,
    101, 115, 116, 70, 105, 101, 108, 100, 79, 114, 100, 101, 114, 105, 110, 103, 115, 82, 17, 116,
    101, 115, 116, 69, 120, 116, 79, 114, 100, 101, 114, 105, 110, 103, 115, 49, 34, 143, 3, 10,
    23, 84, 101, 115, 116, 69, 120, 116, 101, 110, 115, 105, 111, 110, 79, 114, 100, 101, 114, 105,
    110, 103, 115, 50, 18, 27, 10, 9, 109, 121, 95, 115, 116, 114, 105, 110, 103, 24, 1, 32, 1, 40,
    9, 82, 8, 109, 121, 83, 116, 114, 105, 110, 103, 50, 129, 1, 10, 19, 116, 101, 115, 116, 95,
    101, 120, 116, 95, 111, 114, 100, 101, 114, 105, 110, 103, 115, 50, 24, 12, 32, 1, 40, 11, 50,
    42, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46,
    84, 101, 115, 116, 69, 120, 116, 101, 110, 115, 105, 111, 110, 79, 114, 100, 101, 114, 105,
    110, 103, 115, 50, 18, 37, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116,
    116, 101, 115, 116, 46, 84, 101, 115, 116, 70, 105, 101, 108, 100, 79, 114, 100, 101, 114, 105,
    110, 103, 115, 82, 17, 116, 101, 115, 116, 69, 120, 116, 79, 114, 100, 101, 114, 105, 110, 103,
    115, 50, 26, 210, 1, 10, 23, 84, 101, 115, 116, 69, 120, 116, 101, 110, 115, 105, 111, 110, 79,
    114, 100, 101, 114, 105, 110, 103, 115, 51, 18, 27, 10, 9, 109, 121, 95, 115, 116, 114, 105,
    110, 103, 24, 1, 32, 1, 40, 9, 82, 8, 109, 121, 83, 116, 114, 105, 110, 103, 50, 153, 1, 10,
    19, 116, 101, 115, 116, 95, 101, 120, 116, 95, 111, 114, 100, 101, 114, 105, 110, 103, 115, 51,
    24, 14, 32, 1, 40, 11, 50, 66, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105,
    116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 69, 120, 116, 101, 110, 115, 105, 111, 110, 79,
    114, 100, 101, 114, 105, 110, 103, 115, 50, 46, 84, 101, 115, 116, 69, 120, 116, 101, 110, 115,
    105, 111, 110, 79, 114, 100, 101, 114, 105, 110, 103, 115, 51, 18, 37, 46, 112, 114, 111, 116,
    111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 70, 105,
    101, 108, 100, 79, 114, 100, 101, 114, 105, 110, 103, 115, 82, 17, 116, 101, 115, 116, 69, 120,
    116, 79, 114, 100, 101, 114, 105, 110, 103, 115, 51, 34, 175, 10, 10, 24, 84, 101, 115, 116,
    69, 120, 116, 114, 101, 109, 101, 68, 101, 102, 97, 117, 108, 116, 86, 97, 108, 117, 101, 115,
    18, 77, 10, 13, 101, 115, 99, 97, 112, 101, 100, 95, 98, 121, 116, 101, 115, 24, 1, 32, 1, 40,
    12, 58, 40, 92, 48, 48, 48, 92, 48, 48, 49, 92, 48, 48, 55, 92, 48, 49, 48, 92, 48, 49, 52, 92,
    110, 92, 114, 92, 116, 92, 48, 49, 51, 92, 92, 92, 39, 92, 34, 92, 51, 55, 54, 82, 12, 101,
    115, 99, 97, 112, 101, 100, 66, 121, 116, 101, 115, 18, 45, 10, 12, 108, 97, 114, 103, 101, 95,
    117, 105, 110, 116, 51, 50, 24, 2, 32, 1, 40, 13, 58, 10, 52, 50, 57, 52, 57, 54, 55, 50, 57,
    53, 82, 11, 108, 97, 114, 103, 101, 85, 105, 110, 116, 51, 50, 18, 55, 10, 12, 108, 97, 114,
    103, 101, 95, 117, 105, 110, 116, 54, 52, 24, 3, 32, 1, 40, 4, 58, 20, 49, 56, 52, 52, 54, 55,
    52, 52, 48, 55, 51, 55, 48, 57, 53, 53, 49, 54, 49, 53, 82, 11, 108, 97, 114, 103, 101, 85,
    105, 110, 116, 54, 52, 18, 44, 10, 11, 115, 109, 97, 108, 108, 95, 105, 110, 116, 51, 50, 24,
    4, 32, 1, 40, 5, 58, 11, 45, 50, 49, 52, 55, 52, 56, 51, 54, 52, 55, 82, 10, 115, 109, 97, 108,
    108, 73, 110, 116, 51, 50, 18, 53, 10, 11, 115, 109, 97, 108, 108, 95, 105, 110, 116, 54, 52,
    24, 5, 32, 1, 40, 3, 58, 20, 45, 57, 50, 50, 51, 51, 55, 50, 48, 51, 54, 56, 53, 52, 55, 55,
    53, 56, 48, 55, 82, 10, 115, 109, 97, 108, 108, 73, 110, 116, 54, 52, 18, 57, 10, 18, 114, 101,
    97, 108, 108, 121, 95, 115, 109, 97, 108, 108, 95, 105, 110, 116, 51, 50, 24, 21, 32, 1, 40, 5,
    58, 11, 45, 50, 49, 52, 55, 52, 56, 51, 54, 52, 56, 82, 16, 114, 101, 97, 108, 108, 121, 83,
    109, 97, 108, 108, 73, 110, 116, 51, 50, 18, 66, 10, 18, 114, 101, 97, 108, 108, 121, 95, 115,
    109, 97, 108, 108, 95, 105, 110, 116, 54, 52, 24, 22, 32, 1, 40, 3, 58, 20, 45, 57, 50, 50, 51,
    51, 55, 50, 48, 51, 54, 56, 53, 52, 55, 55, 53, 56, 48, 56, 82, 16, 114, 101, 97, 108, 108,
    121, 83, 109, 97, 108, 108, 73, 110, 116, 54, 52, 18, 36, 10, 11, 117, 116, 102, 56, 95, 115,
    116, 114, 105, 110, 103, 24, 6, 32, 1, 40, 9, 58, 3, 225, 136, 180, 82, 10, 117, 116, 102, 56,
    83, 116, 114, 105, 110, 103, 18, 32, 10, 10, 122, 101, 114, 111, 95, 102, 108, 111, 97, 116,
    24, 7, 32, 1, 40, 2, 58, 1, 48, 82, 9, 122, 101, 114, 111, 70, 108, 111, 97, 116, 18, 30, 10,
    9, 111, 110, 101, 95, 102, 108, 111, 97, 116, 24, 8, 32, 1, 40, 2, 58, 1, 49, 82, 8, 111, 110,
    101, 70, 108, 111, 97, 116, 18, 36, 10, 11, 115, 109, 97, 108, 108, 95, 102, 108, 111, 97, 116,
    24, 9, 32, 1, 40, 2, 58, 3, 49, 46, 53, 82, 10, 115, 109, 97, 108, 108, 70, 108, 111, 97, 116,
    18, 48, 10, 18, 110, 101, 103, 97, 116, 105, 118, 101, 95, 111, 110, 101, 95, 102, 108, 111,
    97, 116, 24, 10, 32, 1, 40, 2, 58, 2, 45, 49, 82, 16, 110, 101, 103, 97, 116, 105, 118, 101,
    79, 110, 101, 70, 108, 111, 97, 116, 18, 43, 10, 14, 110, 101, 103, 97, 116, 105, 118, 101, 95,
    102, 108, 111, 97, 116, 24, 11, 32, 1, 40, 2, 58, 4, 45, 49, 46, 53, 82, 13, 110, 101, 103, 97,
    116, 105, 118, 101, 70, 108, 111, 97, 116, 18, 38, 10, 11, 108, 97, 114, 103, 101, 95, 102,
    108, 111, 97, 116, 24, 12, 32, 1, 40, 2, 58, 5, 50, 101, 43, 48, 56, 82, 10, 108, 97, 114, 103,
    101, 70, 108, 111, 97, 116, 18, 56, 10, 20, 115, 109, 97, 108, 108, 95, 110, 101, 103, 97, 116,
    105, 118, 101, 95, 102, 108, 111, 97, 116, 24, 13, 32, 1, 40, 2, 58, 6, 45, 56, 101, 45, 50,
    56, 82, 18, 115, 109, 97, 108, 108, 78, 101, 103, 97, 116, 105, 118, 101, 70, 108, 111, 97,
    116, 18, 34, 10, 10, 105, 110, 102, 95, 100, 111, 117, 98, 108, 101, 24, 14, 32, 1, 40, 1, 58,
    3, 105, 110, 102, 82, 9, 105, 110, 102, 68, 111, 117, 98, 108, 101, 18, 42, 10, 14, 110, 101,
    103, 95, 105, 110, 102, 95, 100, 111, 117, 98, 108, 101, 24, 15, 32, 1, 40, 1, 58, 4, 45, 105,
    110, 102, 82, 12, 110, 101, 103, 73, 110, 102, 68, 111, 117, 98, 108, 101, 18, 34, 10, 10, 110,
    97, 110, 95, 100, 111, 117, 98, 108, 101, 24, 16, 32, 1, 40, 1, 58, 3, 110, 97, 110, 82, 9,
    110, 97, 110, 68, 111, 117, 98, 108, 101, 18, 32, 10, 9, 105, 110, 102, 95, 102, 108, 111, 97,
    116, 24, 17, 32, 1, 40, 2, 58, 3, 105, 110, 102, 82, 8, 105, 110, 102, 70, 108, 111, 97, 116,
    18, 40, 10, 13, 110, 101, 103, 95, 105, 110, 102, 95, 102, 108, 111, 97, 116, 24, 18, 32, 1,
    40, 2, 58, 4, 45, 105, 110, 102, 82, 11, 110, 101, 103, 73, 110, 102, 70, 108, 111, 97, 116,
    18, 32, 10, 9, 110, 97, 110, 95, 102, 108, 111, 97, 116, 24, 19, 32, 1, 40, 2, 58, 3, 110, 97,
    110, 82, 8, 110, 97, 110, 70, 108, 111, 97, 116, 18, 56, 10, 12, 99, 112, 112, 95, 116, 114,
    105, 103, 114, 97, 112, 104, 24, 20, 32, 1, 40, 9, 58, 21, 63, 32, 63, 32, 63, 63, 32, 63, 63,
    32, 63, 63, 63, 32, 63, 63, 47, 32, 63, 63, 45, 82, 11, 99, 112, 112, 84, 114, 105, 103, 114,
    97, 112, 104, 18, 48, 10, 16, 115, 116, 114, 105, 110, 103, 95, 119, 105, 116, 104, 95, 122,
    101, 114, 111, 24, 23, 32, 1, 40, 9, 58, 6, 104, 101, 108, 0, 108, 111, 82, 14, 115, 116, 114,
    105, 110, 103, 87, 105, 116, 104, 90, 101, 114, 111, 18, 49, 10, 15, 98, 121, 116, 101, 115,
    95, 119, 105, 116, 104, 95, 122, 101, 114, 111, 24, 24, 32, 1, 40, 12, 58, 9, 119, 111, 114,
    92, 48, 48, 48, 108, 100, 82, 13, 98, 121, 116, 101, 115, 87, 105, 116, 104, 90, 101, 114, 111,
    18, 61, 10, 22, 115, 116, 114, 105, 110, 103, 95, 112, 105, 101, 99, 101, 95, 119, 105, 116,
    104, 95, 122, 101, 114, 111, 24, 25, 32, 1, 40, 9, 58, 4, 97, 98, 0, 99, 82, 19, 115, 116, 114,
    105, 110, 103, 80, 105, 101, 99, 101, 87, 105, 116, 104, 90, 101, 114, 111, 66, 2, 8, 2, 18,
    46, 10, 14, 99, 111, 114, 100, 95, 119, 105, 116, 104, 95, 122, 101, 114, 111, 24, 26, 32, 1,
    40, 9, 58, 4, 49, 50, 0, 51, 82, 12, 99, 111, 114, 100, 87, 105, 116, 104, 90, 101, 114, 111,
    66, 2, 8, 1, 18, 57, 10, 18, 114, 101, 112, 108, 97, 99, 101, 109, 101, 110, 116, 95, 115, 116,
    114, 105, 110, 103, 24, 27, 32, 1, 40, 9, 58, 10, 36, 123, 117, 110, 107, 110, 111, 119, 110,
    125, 82, 17, 114, 101, 112, 108, 97, 99, 101, 109, 101, 110, 116, 83, 116, 114, 105, 110, 103,
    34, 87, 10, 17, 83, 112, 97, 114, 115, 101, 69, 110, 117, 109, 77, 101, 115, 115, 97, 103, 101,
    18, 66, 10, 11, 115, 112, 97, 114, 115, 101, 95, 101, 110, 117, 109, 24, 1, 32, 1, 40, 14, 50,
    33, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46,
    84, 101, 115, 116, 83, 112, 97, 114, 115, 101, 69, 110, 117, 109, 82, 10, 115, 112, 97, 114,
    115, 101, 69, 110, 117, 109, 34, 31, 10, 9, 79, 110, 101, 83, 116, 114, 105, 110, 103, 18, 18,
    10, 4, 100, 97, 116, 97, 24, 1, 32, 1, 40, 9, 82, 4, 100, 97, 116, 97, 34, 32, 10, 10, 77, 111,
    114, 101, 83, 116, 114, 105, 110, 103, 18, 18, 10, 4, 100, 97, 116, 97, 24, 1, 32, 3, 40, 9,
    82, 4, 100, 97, 116, 97, 34, 30, 10, 8, 79, 110, 101, 66, 121, 116, 101, 115, 18, 18, 10, 4,
    100, 97, 116, 97, 24, 1, 32, 1, 40, 12, 82, 4, 100, 97, 116, 97, 34, 31, 10, 9, 77, 111, 114,
    101, 66, 121, 116, 101, 115, 18, 18, 10, 4, 100, 97, 116, 97, 24, 1, 32, 3, 40, 12, 82, 4, 100,
    97, 116, 97, 34, 34, 10, 12, 73, 110, 116, 51, 50, 77, 101, 115, 115, 97, 103, 101, 18, 18, 10,
    4, 100, 97, 116, 97, 24, 1, 32, 1, 40, 5, 82, 4, 100, 97, 116, 97, 34, 35, 10, 13, 85, 105,
    110, 116, 51, 50, 77, 101, 115, 115, 97, 103, 101, 18, 18, 10, 4, 100, 97, 116, 97, 24, 1, 32,
    1, 40, 13, 82, 4, 100, 97, 116, 97, 34, 34, 10, 12, 73, 110, 116, 54, 52, 77, 101, 115, 115,
    97, 103, 101, 18, 18, 10, 4, 100, 97, 116, 97, 24, 1, 32, 1, 40, 3, 82, 4, 100, 97, 116, 97,
    34, 35, 10, 13, 85, 105, 110, 116, 54, 52, 77, 101, 115, 115, 97, 103, 101, 18, 18, 10, 4, 100,
    97, 116, 97, 24, 1, 32, 1, 40, 4, 82, 4, 100, 97, 116, 97, 34, 33, 10, 11, 66, 111, 111, 108,
    77, 101, 115, 115, 97, 103, 101, 18, 18, 10, 4, 100, 97, 116, 97, 24, 1, 32, 1, 40, 8, 82, 4,
    100, 97, 116, 97, 34, 255, 1, 10, 9, 84, 101, 115, 116, 79, 110, 101, 111, 102, 18, 25, 10, 7,
    102, 111, 111, 95, 105, 110, 116, 24, 1, 32, 1, 40, 5, 72, 0, 82, 6, 102, 111, 111, 73, 110,
    116, 18, 31, 10, 10, 102, 111, 111, 95, 115, 116, 114, 105, 110, 103, 24, 2, 32, 1, 40, 9, 72,
    0, 82, 9, 102, 111, 111, 83, 116, 114, 105, 110, 103, 18, 66, 10, 11, 102, 111, 111, 95, 109,
    101, 115, 115, 97, 103, 101, 24, 3, 32, 1, 40, 11, 50, 31, 46, 112, 114, 111, 116, 111, 98,
    117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84,
    121, 112, 101, 115, 72, 0, 82, 10, 102, 111, 111, 77, 101, 115, 115, 97, 103, 101, 18, 67, 10,
    8, 102, 111, 111, 103, 114, 111, 117, 112, 24, 4, 32, 1, 40, 10, 50, 37, 46, 112, 114, 111,
    116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 79,
    110, 101, 111, 102, 46, 70, 111, 111, 71, 114, 111, 117, 112, 72, 0, 82, 8, 102, 111, 111, 103,
    114, 111, 117, 112, 26, 38, 10, 8, 70, 111, 111, 71, 114, 111, 117, 112, 18, 12, 10, 1, 97, 24,
    5, 32, 1, 40, 5, 82, 1, 97, 18, 12, 10, 1, 98, 24, 6, 32, 1, 40, 9, 82, 1, 98, 66, 5, 10, 3,
    102, 111, 111, 34, 150, 2, 10, 28, 84, 101, 115, 116, 79, 110, 101, 111, 102, 66, 97, 99, 107,
    119, 97, 114, 100, 115, 67, 111, 109, 112, 97, 116, 105, 98, 108, 101, 18, 23, 10, 7, 102, 111,
    111, 95, 105, 110, 116, 24, 1, 32, 1, 40, 5, 82, 6, 102, 111, 111, 73, 110, 116, 18, 29, 10,
    10, 102, 111, 111, 95, 115, 116, 114, 105, 110, 103, 24, 2, 32, 1, 40, 9, 82, 9, 102, 111, 111,
    83, 116, 114, 105, 110, 103, 18, 64, 10, 11, 102, 111, 111, 95, 109, 101, 115, 115, 97, 103,
    101, 24, 3, 32, 1, 40, 11, 50, 31, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110,
    105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 82,
    10, 102, 111, 111, 77, 101, 115, 115, 97, 103, 101, 18, 84, 10, 8, 102, 111, 111, 103, 114,
    111, 117, 112, 24, 4, 32, 1, 40, 10, 50, 56, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95,
    117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 79, 110, 101, 111, 102, 66, 97,
    99, 107, 119, 97, 114, 100, 115, 67, 111, 109, 112, 97, 116, 105, 98, 108, 101, 46, 70, 111,
    111, 71, 114, 111, 117, 112, 82, 8, 102, 111, 111, 103, 114, 111, 117, 112, 26, 38, 10, 8, 70,
    111, 111, 71, 114, 111, 117, 112, 18, 12, 10, 1, 97, 24, 5, 32, 1, 40, 5, 82, 1, 97, 18, 12,
    10, 1, 98, 24, 6, 32, 1, 40, 9, 82, 1, 98, 34, 237, 7, 10, 10, 84, 101, 115, 116, 79, 110, 101,
    111, 102, 50, 18, 25, 10, 7, 102, 111, 111, 95, 105, 110, 116, 24, 1, 32, 1, 40, 5, 72, 0, 82,
    6, 102, 111, 111, 73, 110, 116, 18, 31, 10, 10, 102, 111, 111, 95, 115, 116, 114, 105, 110,
    103, 24, 2, 32, 1, 40, 9, 72, 0, 82, 9, 102, 111, 111, 83, 116, 114, 105, 110, 103, 18, 31, 10,
    8, 102, 111, 111, 95, 99, 111, 114, 100, 24, 3, 32, 1, 40, 9, 72, 0, 82, 7, 102, 111, 111, 67,
    111, 114, 100, 66, 2, 8, 1, 18, 46, 10, 16, 102, 111, 111, 95, 115, 116, 114, 105, 110, 103,
    95, 112, 105, 101, 99, 101, 24, 4, 32, 1, 40, 9, 72, 0, 82, 14, 102, 111, 111, 83, 116, 114,
    105, 110, 103, 80, 105, 101, 99, 101, 66, 2, 8, 2, 18, 29, 10, 9, 102, 111, 111, 95, 98, 121,
    116, 101, 115, 24, 5, 32, 1, 40, 12, 72, 0, 82, 8, 102, 111, 111, 66, 121, 116, 101, 115, 18,
    69, 10, 8, 102, 111, 111, 95, 101, 110, 117, 109, 24, 6, 32, 1, 40, 14, 50, 40, 46, 112, 114,
    111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116,
    79, 110, 101, 111, 102, 50, 46, 78, 101, 115, 116, 101, 100, 69, 110, 117, 109, 72, 0, 82, 7,
    102, 111, 111, 69, 110, 117, 109, 18, 78, 10, 11, 102, 111, 111, 95, 109, 101, 115, 115, 97,
    103, 101, 24, 7, 32, 1, 40, 11, 50, 43, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117,
    110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 79, 110, 101, 111, 102, 50, 46, 78,
    101, 115, 116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 72, 0, 82, 10, 102, 111, 111, 77,
    101, 115, 115, 97, 103, 101, 18, 68, 10, 8, 102, 111, 111, 103, 114, 111, 117, 112, 24, 8, 32,
    1, 40, 10, 50, 38, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101,
    115, 116, 46, 84, 101, 115, 116, 79, 110, 101, 111, 102, 50, 46, 70, 111, 111, 71, 114, 111,
    117, 112, 72, 0, 82, 8, 102, 111, 111, 103, 114, 111, 117, 112, 18, 91, 10, 16, 102, 111, 111,
    95, 108, 97, 122, 121, 95, 109, 101, 115, 115, 97, 103, 101, 24, 11, 32, 1, 40, 11, 50, 43, 46,
    112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101,
    115, 116, 79, 110, 101, 111, 102, 50, 46, 78, 101, 115, 116, 101, 100, 77, 101, 115, 115, 97,
    103, 101, 72, 0, 82, 14, 102, 111, 111, 76, 97, 122, 121, 77, 101, 115, 115, 97, 103, 101, 66,
    2, 40, 1, 18, 28, 10, 7, 98, 97, 114, 95, 105, 110, 116, 24, 12, 32, 1, 40, 5, 58, 1, 53, 72,
    1, 82, 6, 98, 97, 114, 73, 110, 116, 18, 39, 10, 10, 98, 97, 114, 95, 115, 116, 114, 105, 110,
    103, 24, 13, 32, 1, 40, 9, 58, 6, 83, 84, 82, 73, 78, 71, 72, 1, 82, 9, 98, 97, 114, 83, 116,
    114, 105, 110, 103, 18, 37, 10, 8, 98, 97, 114, 95, 99, 111, 114, 100, 24, 14, 32, 1, 40, 9,
    58, 4, 67, 79, 82, 68, 72, 1, 82, 7, 98, 97, 114, 67, 111, 114, 100, 66, 2, 8, 1, 18, 54, 10,
    16, 98, 97, 114, 95, 115, 116, 114, 105, 110, 103, 95, 112, 105, 101, 99, 101, 24, 15, 32, 1,
    40, 9, 58, 6, 83, 80, 73, 69, 67, 69, 72, 1, 82, 14, 98, 97, 114, 83, 116, 114, 105, 110, 103,
    80, 105, 101, 99, 101, 66, 2, 8, 2, 18, 36, 10, 9, 98, 97, 114, 95, 98, 121, 116, 101, 115, 24,
    16, 32, 1, 40, 12, 58, 5, 66, 89, 84, 69, 83, 72, 1, 82, 8, 98, 97, 114, 66, 121, 116, 101,
    115, 18, 74, 10, 8, 98, 97, 114, 95, 101, 110, 117, 109, 24, 17, 32, 1, 40, 14, 50, 40, 46,
    112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101,
    115, 116, 79, 110, 101, 111, 102, 50, 46, 78, 101, 115, 116, 101, 100, 69, 110, 117, 109, 58,
    3, 66, 65, 82, 72, 1, 82, 7, 98, 97, 114, 69, 110, 117, 109, 18, 23, 10, 7, 98, 97, 122, 95,
    105, 110, 116, 24, 18, 32, 1, 40, 5, 82, 6, 98, 97, 122, 73, 110, 116, 18, 34, 10, 10, 98, 97,
    122, 95, 115, 116, 114, 105, 110, 103, 24, 19, 32, 1, 40, 9, 58, 3, 66, 65, 90, 82, 9, 98, 97,
    122, 83, 116, 114, 105, 110, 103, 26, 38, 10, 8, 70, 111, 111, 71, 114, 111, 117, 112, 18, 12,
    10, 1, 97, 24, 9, 32, 1, 40, 5, 82, 1, 97, 18, 12, 10, 1, 98, 24, 10, 32, 1, 40, 9, 82, 1, 98,
    26, 69, 10, 13, 78, 101, 115, 116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 18, 23, 10, 7,
    113, 117, 120, 95, 105, 110, 116, 24, 1, 32, 1, 40, 3, 82, 6, 113, 117, 120, 73, 110, 116, 18,
    27, 10, 9, 99, 111, 114, 103, 101, 95, 105, 110, 116, 24, 2, 32, 3, 40, 5, 82, 8, 99, 111, 114,
    103, 101, 73, 110, 116, 34, 39, 10, 10, 78, 101, 115, 116, 101, 100, 69, 110, 117, 109, 18, 7,
    10, 3, 70, 79, 79, 16, 1, 18, 7, 10, 3, 66, 65, 82, 16, 2, 18, 7, 10, 3, 66, 65, 90, 16, 3, 66,
    5, 10, 3, 102, 111, 111, 66, 5, 10, 3, 98, 97, 114, 34, 231, 1, 10, 17, 84, 101, 115, 116, 82,
    101, 113, 117, 105, 114, 101, 100, 79, 110, 101, 111, 102, 18, 25, 10, 7, 102, 111, 111, 95,
    105, 110, 116, 24, 1, 32, 1, 40, 5, 72, 0, 82, 6, 102, 111, 111, 73, 110, 116, 18, 31, 10, 10,
    102, 111, 111, 95, 115, 116, 114, 105, 110, 103, 24, 2, 32, 1, 40, 9, 72, 0, 82, 9, 102, 111,
    111, 83, 116, 114, 105, 110, 103, 18, 85, 10, 11, 102, 111, 111, 95, 109, 101, 115, 115, 97,
    103, 101, 24, 3, 32, 1, 40, 11, 50, 50, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117,
    110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 82, 101, 113, 117, 105, 114, 101,
    100, 79, 110, 101, 111, 102, 46, 78, 101, 115, 116, 101, 100, 77, 101, 115, 115, 97, 103, 101,
    72, 0, 82, 10, 102, 111, 111, 77, 101, 115, 115, 97, 103, 101, 26, 56, 10, 13, 78, 101, 115,
    116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 18, 39, 10, 15, 114, 101, 113, 117, 105, 114,
    101, 100, 95, 100, 111, 117, 98, 108, 101, 24, 1, 32, 2, 40, 1, 82, 14, 114, 101, 113, 117,
    105, 114, 101, 100, 68, 111, 117, 98, 108, 101, 66, 5, 10, 3, 102, 111, 111, 34, 237, 4, 10,
    15, 84, 101, 115, 116, 80, 97, 99, 107, 101, 100, 84, 121, 112, 101, 115, 18, 37, 10, 12, 112,
    97, 99, 107, 101, 100, 95, 105, 110, 116, 51, 50, 24, 90, 32, 3, 40, 5, 82, 11, 112, 97, 99,
    107, 101, 100, 73, 110, 116, 51, 50, 66, 2, 16, 1, 18, 37, 10, 12, 112, 97, 99, 107, 101, 100,
    95, 105, 110, 116, 54, 52, 24, 91, 32, 3, 40, 3, 82, 11, 112, 97, 99, 107, 101, 100, 73, 110,
    116, 54, 52, 66, 2, 16, 1, 18, 39, 10, 13, 112, 97, 99, 107, 101, 100, 95, 117, 105, 110, 116,
    51, 50, 24, 92, 32, 3, 40, 13, 82, 12, 112, 97, 99, 107, 101, 100, 85, 105, 110, 116, 51, 50,
    66, 2, 16, 1, 18, 39, 10, 13, 112, 97, 99, 107, 101, 100, 95, 117, 105, 110, 116, 54, 52, 24,
    93, 32, 3, 40, 4, 82, 12, 112, 97, 99, 107, 101, 100, 85, 105, 110, 116, 54, 52, 66, 2, 16, 1,
    18, 39, 10, 13, 112, 97, 99, 107, 101, 100, 95, 115, 105, 110, 116, 51, 50, 24, 94, 32, 3, 40,
    17, 82, 12, 112, 97, 99, 107, 101, 100, 83, 105, 110, 116, 51, 50, 66, 2, 16, 1, 18, 39, 10,
    13, 112, 97, 99, 107, 101, 100, 95, 115, 105, 110, 116, 54, 52, 24, 95, 32, 3, 40, 18, 82, 12,
    112, 97, 99, 107, 101, 100, 83, 105, 110, 116, 54, 52, 66, 2, 16, 1, 18, 41, 10, 14, 112, 97,
    99, 107, 101, 100, 95, 102, 105, 120, 101, 100, 51, 50, 24, 96, 32, 3, 40, 7, 82, 13, 112, 97,
    99, 107, 101, 100, 70, 105, 120, 101, 100, 51, 50, 66, 2, 16, 1, 18, 41, 10, 14, 112, 97, 99,
    107, 101, 100, 95, 102, 105, 120, 101, 100, 54, 52, 24, 97, 32, 3, 40, 6, 82, 13, 112, 97, 99,
    107, 101, 100, 70, 105, 120, 101, 100, 54, 52, 66, 2, 16, 1, 18, 43, 10, 15, 112, 97, 99, 107,
    101, 100, 95, 115, 102, 105, 120, 101, 100, 51, 50, 24, 98, 32, 3, 40, 15, 82, 14, 112, 97, 99,
    107, 101, 100, 83, 102, 105, 120, 101, 100, 51, 50, 66, 2, 16, 1, 18, 43, 10, 15, 112, 97, 99,
    107, 101, 100, 95, 115, 102, 105, 120, 101, 100, 54, 52, 24, 99, 32, 3, 40, 16, 82, 14, 112,
    97, 99, 107, 101, 100, 83, 102, 105, 120, 101, 100, 54, 52, 66, 2, 16, 1, 18, 37, 10, 12, 112,
    97, 99, 107, 101, 100, 95, 102, 108, 111, 97, 116, 24, 100, 32, 3, 40, 2, 82, 11, 112, 97, 99,
    107, 101, 100, 70, 108, 111, 97, 116, 66, 2, 16, 1, 18, 39, 10, 13, 112, 97, 99, 107, 101, 100,
    95, 100, 111, 117, 98, 108, 101, 24, 101, 32, 3, 40, 1, 82, 12, 112, 97, 99, 107, 101, 100, 68,
    111, 117, 98, 108, 101, 66, 2, 16, 1, 18, 35, 10, 11, 112, 97, 99, 107, 101, 100, 95, 98, 111,
    111, 108, 24, 102, 32, 3, 40, 8, 82, 10, 112, 97, 99, 107, 101, 100, 66, 111, 111, 108, 66, 2,
    16, 1, 18, 67, 10, 11, 112, 97, 99, 107, 101, 100, 95, 101, 110, 117, 109, 24, 103, 32, 3, 40,
    14, 50, 30, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115,
    116, 46, 70, 111, 114, 101, 105, 103, 110, 69, 110, 117, 109, 82, 10, 112, 97, 99, 107, 101,
    100, 69, 110, 117, 109, 66, 2, 16, 1, 34, 167, 5, 10, 17, 84, 101, 115, 116, 85, 110, 112, 97,
    99, 107, 101, 100, 84, 121, 112, 101, 115, 18, 41, 10, 14, 117, 110, 112, 97, 99, 107, 101,
    100, 95, 105, 110, 116, 51, 50, 24, 90, 32, 3, 40, 5, 82, 13, 117, 110, 112, 97, 99, 107, 101,
    100, 73, 110, 116, 51, 50, 66, 2, 16, 0, 18, 41, 10, 14, 117, 110, 112, 97, 99, 107, 101, 100,
    95, 105, 110, 116, 54, 52, 24, 91, 32, 3, 40, 3, 82, 13, 117, 110, 112, 97, 99, 107, 101, 100,
    73, 110, 116, 54, 52, 66, 2, 16, 0, 18, 43, 10, 15, 117, 110, 112, 97, 99, 107, 101, 100, 95,
    117, 105, 110, 116, 51, 50, 24, 92, 32, 3, 40, 13, 82, 14, 117, 110, 112, 97, 99, 107, 101,
    100, 85, 105, 110, 116, 51, 50, 66, 2, 16, 0, 18, 43, 10, 15, 117, 110, 112, 97, 99, 107, 101,
    100, 95, 117, 105, 110, 116, 54, 52, 24, 93, 32, 3, 40, 4, 82, 14, 117, 110, 112, 97, 99, 107,
    101, 100, 85, 105, 110, 116, 54, 52, 66, 2, 16, 0, 18, 43, 10, 15, 117, 110, 112, 97, 99, 107,
    101, 100, 95, 115, 105, 110, 116, 51, 50, 24, 94, 32, 3, 40, 17, 82, 14, 117, 110, 112, 97, 99,
    107, 101, 100, 83, 105, 110, 116, 51, 50, 66, 2, 16, 0, 18, 43, 10, 15, 117, 110, 112, 97, 99,
    107, 101, 100, 95, 115, 105, 110, 116, 54, 52, 24, 95, 32, 3, 40, 18, 82, 14, 117, 110, 112,
    97, 99, 107, 101, 100, 83, 105, 110, 116, 54, 52, 66, 2, 16, 0, 18, 45, 10, 16, 117, 110, 112,
    97, 99, 107, 101, 100, 95, 102, 105, 120, 101, 100, 51, 50, 24, 96, 32, 3, 40, 7, 82, 15, 117,
    110, 112, 97, 99, 107, 101, 100, 70, 105, 120, 101, 100, 51, 50, 66, 2, 16, 0, 18, 45, 10, 16,
    117, 110, 112, 97, 99, 107, 101, 100, 95, 102, 105, 120, 101, 100, 54, 52, 24, 97, 32, 3, 40,
    6, 82, 15, 117, 110, 112, 97, 99, 107, 101, 100, 70, 105, 120, 101, 100, 54, 52, 66, 2, 16, 0,
    18, 47, 10, 17, 117, 110, 112, 97, 99, 107, 101, 100, 95, 115, 102, 105, 120, 101, 100, 51, 50,
    24, 98, 32, 3, 40, 15, 82, 16, 117, 110, 112, 97, 99, 107, 101, 100, 83, 102, 105, 120, 101,
    100, 51, 50, 66, 2, 16, 0, 18, 47, 10, 17, 117, 110, 112, 97, 99, 107, 101, 100, 95, 115, 102,
    105, 120, 101, 100, 54, 52, 24, 99, 32, 3, 40, 16, 82, 16, 117, 110, 112, 97, 99, 107, 101,
    100, 83, 102, 105, 120, 101, 100, 54, 52, 66, 2, 16, 0, 18, 41, 10, 14, 117, 110, 112, 97, 99,
    107, 101, 100, 95, 102, 108, 111, 97, 116, 24, 100, 32, 3, 40, 2, 82, 13, 117, 110, 112, 97,
    99, 107, 101, 100, 70, 108, 111, 97, 116, 66, 2, 16, 0, 18, 43, 10, 15, 117, 110, 112, 97, 99,
    107, 101, 100, 95, 100, 111, 117, 98, 108, 101, 24, 101, 32, 3, 40, 1, 82, 14, 117, 110, 112,
    97, 99, 107, 101, 100, 68, 111, 117, 98, 108, 101, 66, 2, 16, 0, 18, 39, 10, 13, 117, 110, 112,
    97, 99, 107, 101, 100, 95, 98, 111, 111, 108, 24, 102, 32, 3, 40, 8, 82, 12, 117, 110, 112, 97,
    99, 107, 101, 100, 66, 111, 111, 108, 66, 2, 16, 0, 18, 71, 10, 13, 117, 110, 112, 97, 99, 107,
    101, 100, 95, 101, 110, 117, 109, 24, 103, 32, 3, 40, 14, 50, 30, 46, 112, 114, 111, 116, 111,
    98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 70, 111, 114, 101, 105, 103, 110,
    69, 110, 117, 109, 82, 12, 117, 110, 112, 97, 99, 107, 101, 100, 69, 110, 117, 109, 66, 2, 16,
    0, 34, 32, 10, 20, 84, 101, 115, 116, 80, 97, 99, 107, 101, 100, 69, 120, 116, 101, 110, 115,
    105, 111, 110, 115, 42, 8, 8, 1, 16, 128, 128, 128, 128, 2, 34, 34, 10, 22, 84, 101, 115, 116,
    85, 110, 112, 97, 99, 107, 101, 100, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 42, 8, 8,
    1, 16, 128, 128, 128, 128, 2, 34, 172, 5, 10, 21, 84, 101, 115, 116, 68, 121, 110, 97, 109,
    105, 99, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 18, 42, 10, 16, 115, 99, 97, 108, 97,
    114, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 208, 15, 32, 1, 40, 7, 82, 15, 115,
    99, 97, 108, 97, 114, 69, 120, 116, 101, 110, 115, 105, 111, 110, 18, 70, 10, 14, 101, 110,
    117, 109, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 209, 15, 32, 1, 40, 14, 50, 30,
    46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 70,
    111, 114, 101, 105, 103, 110, 69, 110, 117, 109, 82, 13, 101, 110, 117, 109, 69, 120, 116, 101,
    110, 115, 105, 111, 110, 18, 111, 10, 22, 100, 121, 110, 97, 109, 105, 99, 95, 101, 110, 117,
    109, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 210, 15, 32, 1, 40, 14, 50, 56, 46,
    112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101,
    115, 116, 68, 121, 110, 97, 109, 105, 99, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 46,
    68, 121, 110, 97, 109, 105, 99, 69, 110, 117, 109, 84, 121, 112, 101, 82, 20, 100, 121, 110,
    97, 109, 105, 99, 69, 110, 117, 109, 69, 120, 116, 101, 110, 115, 105, 111, 110, 18, 79, 10,
    17, 109, 101, 115, 115, 97, 103, 101, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 211,
    15, 32, 1, 40, 11, 50, 33, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116,
    116, 101, 115, 116, 46, 70, 111, 114, 101, 105, 103, 110, 77, 101, 115, 115, 97, 103, 101, 82,
    16, 109, 101, 115, 115, 97, 103, 101, 69, 120, 116, 101, 110, 115, 105, 111, 110, 18, 120, 10,
    25, 100, 121, 110, 97, 109, 105, 99, 95, 109, 101, 115, 115, 97, 103, 101, 95, 101, 120, 116,
    101, 110, 115, 105, 111, 110, 24, 212, 15, 32, 1, 40, 11, 50, 59, 46, 112, 114, 111, 116, 111,
    98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 68, 121, 110,
    97, 109, 105, 99, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 46, 68, 121, 110, 97, 109,
    105, 99, 77, 101, 115, 115, 97, 103, 101, 84, 121, 112, 101, 82, 23, 100, 121, 110, 97, 109,
    105, 99, 77, 101, 115, 115, 97, 103, 101, 69, 120, 116, 101, 110, 115, 105, 111, 110, 18, 46,
    10, 18, 114, 101, 112, 101, 97, 116, 101, 100, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110,
    24, 213, 15, 32, 3, 40, 9, 82, 17, 114, 101, 112, 101, 97, 116, 101, 100, 69, 120, 116, 101,
    110, 115, 105, 111, 110, 18, 46, 10, 16, 112, 97, 99, 107, 101, 100, 95, 101, 120, 116, 101,
    110, 115, 105, 111, 110, 24, 214, 15, 32, 3, 40, 17, 82, 15, 112, 97, 99, 107, 101, 100, 69,
    120, 116, 101, 110, 115, 105, 111, 110, 66, 2, 16, 1, 26, 58, 10, 18, 68, 121, 110, 97, 109,
    105, 99, 77, 101, 115, 115, 97, 103, 101, 84, 121, 112, 101, 18, 36, 10, 13, 100, 121, 110, 97,
    109, 105, 99, 95, 102, 105, 101, 108, 100, 24, 180, 16, 32, 1, 40, 5, 82, 12, 100, 121, 110,
    97, 109, 105, 99, 70, 105, 101, 108, 100, 34, 71, 10, 15, 68, 121, 110, 97, 109, 105, 99, 69,
    110, 117, 109, 84, 121, 112, 101, 18, 16, 10, 11, 68, 89, 78, 65, 77, 73, 67, 95, 70, 79, 79,
    16, 152, 17, 18, 16, 10, 11, 68, 89, 78, 65, 77, 73, 67, 95, 66, 65, 82, 16, 153, 17, 18, 16,
    10, 11, 68, 89, 78, 65, 77, 73, 67, 95, 66, 65, 90, 16, 154, 17, 34, 159, 2, 10, 35, 84, 101,
    115, 116, 82, 101, 112, 101, 97, 116, 101, 100, 83, 99, 97, 108, 97, 114, 68, 105, 102, 102,
    101, 114, 101, 110, 116, 84, 97, 103, 83, 105, 122, 101, 115, 18, 41, 10, 16, 114, 101, 112,
    101, 97, 116, 101, 100, 95, 102, 105, 120, 101, 100, 51, 50, 24, 12, 32, 3, 40, 7, 82, 15, 114,
    101, 112, 101, 97, 116, 101, 100, 70, 105, 120, 101, 100, 51, 50, 18, 37, 10, 14, 114, 101,
    112, 101, 97, 116, 101, 100, 95, 105, 110, 116, 51, 50, 24, 13, 32, 3, 40, 5, 82, 13, 114, 101,
    112, 101, 97, 116, 101, 100, 73, 110, 116, 51, 50, 18, 42, 10, 16, 114, 101, 112, 101, 97, 116,
    101, 100, 95, 102, 105, 120, 101, 100, 54, 52, 24, 254, 15, 32, 3, 40, 6, 82, 15, 114, 101,
    112, 101, 97, 116, 101, 100, 70, 105, 120, 101, 100, 54, 52, 18, 38, 10, 14, 114, 101, 112,
    101, 97, 116, 101, 100, 95, 105, 110, 116, 54, 52, 24, 255, 15, 32, 3, 40, 3, 82, 13, 114, 101,
    112, 101, 97, 116, 101, 100, 73, 110, 116, 54, 52, 18, 39, 10, 14, 114, 101, 112, 101, 97, 116,
    101, 100, 95, 102, 108, 111, 97, 116, 24, 254, 255, 15, 32, 3, 40, 2, 82, 13, 114, 101, 112,
    101, 97, 116, 101, 100, 70, 108, 111, 97, 116, 18, 41, 10, 15, 114, 101, 112, 101, 97, 116,
    101, 100, 95, 117, 105, 110, 116, 54, 52, 24, 255, 255, 15, 32, 3, 40, 4, 82, 14, 114, 101,
    112, 101, 97, 116, 101, 100, 85, 105, 110, 116, 54, 52, 34, 215, 11, 10, 16, 84, 101, 115, 116,
    80, 97, 114, 115, 105, 110, 103, 77, 101, 114, 103, 101, 18, 77, 10, 18, 114, 101, 113, 117,
    105, 114, 101, 100, 95, 97, 108, 108, 95, 116, 121, 112, 101, 115, 24, 1, 32, 2, 40, 11, 50,
    31, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46,
    84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 82, 16, 114, 101, 113, 117, 105, 114,
    101, 100, 65, 108, 108, 84, 121, 112, 101, 115, 18, 77, 10, 18, 111, 112, 116, 105, 111, 110,
    97, 108, 95, 97, 108, 108, 95, 116, 121, 112, 101, 115, 24, 2, 32, 1, 40, 11, 50, 31, 46, 112,
    114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115,
    116, 65, 108, 108, 84, 121, 112, 101, 115, 82, 16, 111, 112, 116, 105, 111, 110, 97, 108, 65,
    108, 108, 84, 121, 112, 101, 115, 18, 77, 10, 18, 114, 101, 112, 101, 97, 116, 101, 100, 95,
    97, 108, 108, 95, 116, 121, 112, 101, 115, 24, 3, 32, 3, 40, 11, 50, 31, 46, 112, 114, 111,
    116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65,
    108, 108, 84, 121, 112, 101, 115, 82, 16, 114, 101, 112, 101, 97, 116, 101, 100, 65, 108, 108,
    84, 121, 112, 101, 115, 18, 87, 10, 13, 111, 112, 116, 105, 111, 110, 97, 108, 103, 114, 111,
    117, 112, 24, 10, 32, 1, 40, 10, 50, 49, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117,
    110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 80, 97, 114, 115, 105, 110, 103, 77,
    101, 114, 103, 101, 46, 79, 112, 116, 105, 111, 110, 97, 108, 71, 114, 111, 117, 112, 82, 13,
    111, 112, 116, 105, 111, 110, 97, 108, 103, 114, 111, 117, 112, 18, 87, 10, 13, 114, 101, 112,
    101, 97, 116, 101, 100, 103, 114, 111, 117, 112, 24, 20, 32, 3, 40, 10, 50, 49, 46, 112, 114,
    111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116,
    80, 97, 114, 115, 105, 110, 103, 77, 101, 114, 103, 101, 46, 82, 101, 112, 101, 97, 116, 101,
    100, 71, 114, 111, 117, 112, 82, 13, 114, 101, 112, 101, 97, 116, 101, 100, 103, 114, 111, 117,
    112, 50, 104, 10, 12, 111, 112, 116, 105, 111, 110, 97, 108, 95, 101, 120, 116, 24, 232, 7, 32,
    1, 40, 11, 50, 31, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101,
    115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 18, 35, 46, 112, 114,
    111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116,
    80, 97, 114, 115, 105, 110, 103, 77, 101, 114, 103, 101, 82, 11, 111, 112, 116, 105, 111, 110,
    97, 108, 69, 120, 116, 50, 104, 10, 12, 114, 101, 112, 101, 97, 116, 101, 100, 95, 101, 120,
    116, 24, 233, 7, 32, 3, 40, 11, 50, 31, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117,
    110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115,
    18, 35, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116,
    46, 84, 101, 115, 116, 80, 97, 114, 115, 105, 110, 103, 77, 101, 114, 103, 101, 82, 11, 114,
    101, 112, 101, 97, 116, 101, 100, 69, 120, 116, 26, 238, 4, 10, 23, 82, 101, 112, 101, 97, 116,
    101, 100, 70, 105, 101, 108, 100, 115, 71, 101, 110, 101, 114, 97, 116, 111, 114, 18, 55, 10,
    6, 102, 105, 101, 108, 100, 49, 24, 1, 32, 3, 40, 11, 50, 31, 46, 112, 114, 111, 116, 111, 98,
    117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84,
    121, 112, 101, 115, 82, 6, 102, 105, 101, 108, 100, 49, 18, 55, 10, 6, 102, 105, 101, 108, 100,
    50, 24, 2, 32, 3, 40, 11, 50, 31, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105,
    116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 82, 6,
    102, 105, 101, 108, 100, 50, 18, 55, 10, 6, 102, 105, 101, 108, 100, 51, 24, 3, 32, 3, 40, 11,
    50, 31, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116,
    46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 82, 6, 102, 105, 101, 108, 100,
    51, 18, 90, 10, 6, 103, 114, 111, 117, 112, 49, 24, 10, 32, 3, 40, 10, 50, 66, 46, 112, 114,
    111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116,
    80, 97, 114, 115, 105, 110, 103, 77, 101, 114, 103, 101, 46, 82, 101, 112, 101, 97, 116, 101,
    100, 70, 105, 101, 108, 100, 115, 71, 101, 110, 101, 114, 97, 116, 111, 114, 46, 71, 114, 111,
    117, 112, 49, 82, 6, 103, 114, 111, 117, 112, 49, 18, 90, 10, 6, 103, 114, 111, 117, 112, 50,
    24, 20, 32, 3, 40, 10, 50, 66, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105,
    116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 80, 97, 114, 115, 105, 110, 103, 77, 101, 114,
    103, 101, 46, 82, 101, 112, 101, 97, 116, 101, 100, 70, 105, 101, 108, 100, 115, 71, 101, 110,
    101, 114, 97, 116, 111, 114, 46, 71, 114, 111, 117, 112, 50, 82, 6, 103, 114, 111, 117, 112,
    50, 18, 52, 10, 4, 101, 120, 116, 49, 24, 232, 7, 32, 3, 40, 11, 50, 31, 46, 112, 114, 111,
    116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65,
    108, 108, 84, 121, 112, 101, 115, 82, 4, 101, 120, 116, 49, 18, 52, 10, 4, 101, 120, 116, 50,
    24, 233, 7, 32, 3, 40, 11, 50, 31, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110,
    105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 82,
    4, 101, 120, 116, 50, 26, 65, 10, 6, 71, 114, 111, 117, 112, 49, 18, 55, 10, 6, 102, 105, 101,
    108, 100, 49, 24, 11, 32, 1, 40, 11, 50, 31, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95,
    117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101,
    115, 82, 6, 102, 105, 101, 108, 100, 49, 26, 65, 10, 6, 71, 114, 111, 117, 112, 50, 18, 55, 10,
    6, 102, 105, 101, 108, 100, 49, 24, 21, 32, 1, 40, 11, 50, 31, 46, 112, 114, 111, 116, 111, 98,
    117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84,
    121, 112, 101, 115, 82, 6, 102, 105, 101, 108, 100, 49, 26, 105, 10, 13, 79, 112, 116, 105,
    111, 110, 97, 108, 71, 114, 111, 117, 112, 18, 88, 10, 24, 111, 112, 116, 105, 111, 110, 97,
    108, 95, 103, 114, 111, 117, 112, 95, 97, 108, 108, 95, 116, 121, 112, 101, 115, 24, 11, 32, 1,
    40, 11, 50, 31, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101,
    115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 82, 21, 111, 112, 116,
    105, 111, 110, 97, 108, 71, 114, 111, 117, 112, 65, 108, 108, 84, 121, 112, 101, 115, 26, 105,
    10, 13, 82, 101, 112, 101, 97, 116, 101, 100, 71, 114, 111, 117, 112, 18, 88, 10, 24, 114, 101,
    112, 101, 97, 116, 101, 100, 95, 103, 114, 111, 117, 112, 95, 97, 108, 108, 95, 116, 121, 112,
    101, 115, 24, 21, 32, 1, 40, 11, 50, 31, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117,
    110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115,
    82, 21, 114, 101, 112, 101, 97, 116, 101, 100, 71, 114, 111, 117, 112, 65, 108, 108, 84, 121,
    112, 101, 115, 42, 9, 8, 232, 7, 16, 128, 128, 128, 128, 2, 34, 71, 10, 27, 84, 101, 115, 116,
    67, 111, 109, 109, 101, 110, 116, 73, 110, 106, 101, 99, 116, 105, 111, 110, 77, 101, 115, 115,
    97, 103, 101, 18, 40, 10, 1, 97, 24, 1, 32, 1, 40, 9, 58, 26, 42, 47, 32, 60, 45, 32, 78, 101,
    105, 116, 104, 101, 114, 32, 115, 104, 111, 117, 108, 100, 32, 116, 104, 105, 115, 46, 82, 1,
    97, 34, 12, 10, 10, 70, 111, 111, 82, 101, 113, 117, 101, 115, 116, 34, 13, 10, 11, 70, 111,
    111, 82, 101, 115, 112, 111, 110, 115, 101, 34, 18, 10, 16, 70, 111, 111, 67, 108, 105, 101,
    110, 116, 77, 101, 115, 115, 97, 103, 101, 34, 18, 10, 16, 70, 111, 111, 83, 101, 114, 118,
    101, 114, 77, 101, 115, 115, 97, 103, 101, 34, 12, 10, 10, 66, 97, 114, 82, 101, 113, 117, 101,
    115, 116, 34, 13, 10, 11, 66, 97, 114, 82, 101, 115, 112, 111, 110, 115, 101, 34, 206, 1, 10,
    12, 84, 101, 115, 116, 74, 115, 111, 110, 78, 97, 109, 101, 18, 31, 10, 11, 102, 105, 101, 108,
    100, 95, 110, 97, 109, 101, 49, 24, 1, 32, 1, 40, 5, 82, 10, 102, 105, 101, 108, 100, 78, 97,
    109, 101, 49, 18, 30, 10, 10, 102, 105, 101, 108, 100, 78, 97, 109, 101, 50, 24, 2, 32, 1, 40,
    5, 82, 10, 102, 105, 101, 108, 100, 78, 97, 109, 101, 50, 18, 30, 10, 10, 70, 105, 101, 108,
    100, 78, 97, 109, 101, 51, 24, 3, 32, 1, 40, 5, 82, 10, 70, 105, 101, 108, 100, 78, 97, 109,
    101, 51, 18, 32, 10, 12, 95, 102, 105, 101, 108, 100, 95, 110, 97, 109, 101, 52, 24, 4, 32, 1,
    40, 5, 82, 10, 70, 105, 101, 108, 100, 78, 97, 109, 101, 52, 18, 31, 10, 11, 70, 73, 69, 76,
    68, 95, 78, 65, 77, 69, 53, 24, 5, 32, 1, 40, 5, 82, 10, 70, 73, 69, 76, 68, 78, 65, 77, 69,
    53, 18, 26, 10, 11, 102, 105, 101, 108, 100, 95, 110, 97, 109, 101, 54, 24, 6, 32, 1, 40, 5,
    82, 5, 64, 116, 121, 112, 101, 34, 220, 7, 10, 20, 84, 101, 115, 116, 72, 117, 103, 101, 70,
    105, 101, 108, 100, 78, 117, 109, 98, 101, 114, 115, 18, 41, 10, 14, 111, 112, 116, 105, 111,
    110, 97, 108, 95, 105, 110, 116, 51, 50, 24, 240, 248, 255, 255, 1, 32, 1, 40, 5, 82, 13, 111,
    112, 116, 105, 111, 110, 97, 108, 73, 110, 116, 51, 50, 18, 29, 10, 8, 102, 105, 120, 101, 100,
    95, 51, 50, 24, 241, 248, 255, 255, 1, 32, 1, 40, 5, 82, 7, 102, 105, 120, 101, 100, 51, 50,
    18, 45, 10, 14, 114, 101, 112, 101, 97, 116, 101, 100, 95, 105, 110, 116, 51, 50, 24, 242, 248,
    255, 255, 1, 32, 3, 40, 5, 82, 13, 114, 101, 112, 101, 97, 116, 101, 100, 73, 110, 116, 51, 50,
    66, 2, 16, 0, 18, 41, 10, 12, 112, 97, 99, 107, 101, 100, 95, 105, 110, 116, 51, 50, 24, 243,
    248, 255, 255, 1, 32, 3, 40, 5, 82, 11, 112, 97, 99, 107, 101, 100, 73, 110, 116, 51, 50, 66,
    2, 16, 1, 18, 71, 10, 13, 111, 112, 116, 105, 111, 110, 97, 108, 95, 101, 110, 117, 109, 24,
    244, 248, 255, 255, 1, 32, 1, 40, 14, 50, 30, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95,
    117, 110, 105, 116, 116, 101, 115, 116, 46, 70, 111, 114, 101, 105, 103, 110, 69, 110, 117,
    109, 82, 12, 111, 112, 116, 105, 111, 110, 97, 108, 69, 110, 117, 109, 18, 43, 10, 15, 111,
    112, 116, 105, 111, 110, 97, 108, 95, 115, 116, 114, 105, 110, 103, 24, 245, 248, 255, 255, 1,
    32, 1, 40, 9, 82, 14, 111, 112, 116, 105, 111, 110, 97, 108, 83, 116, 114, 105, 110, 103, 18,
    41, 10, 14, 111, 112, 116, 105, 111, 110, 97, 108, 95, 98, 121, 116, 101, 115, 24, 246, 248,
    255, 255, 1, 32, 1, 40, 12, 82, 13, 111, 112, 116, 105, 111, 110, 97, 108, 66, 121, 116, 101,
    115, 18, 80, 10, 16, 111, 112, 116, 105, 111, 110, 97, 108, 95, 109, 101, 115, 115, 97, 103,
    101, 24, 247, 248, 255, 255, 1, 32, 1, 40, 11, 50, 33, 46, 112, 114, 111, 116, 111, 98, 117,
    102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 70, 111, 114, 101, 105, 103, 110, 77, 101,
    115, 115, 97, 103, 101, 82, 15, 111, 112, 116, 105, 111, 110, 97, 108, 77, 101, 115, 115, 97,
    103, 101, 18, 95, 10, 13, 111, 112, 116, 105, 111, 110, 97, 108, 103, 114, 111, 117, 112, 24,
    248, 248, 255, 255, 1, 32, 1, 40, 10, 50, 53, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95,
    117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 72, 117, 103, 101, 70, 105, 101,
    108, 100, 78, 117, 109, 98, 101, 114, 115, 46, 79, 112, 116, 105, 111, 110, 97, 108, 71, 114,
    111, 117, 112, 82, 13, 111, 112, 116, 105, 111, 110, 97, 108, 103, 114, 111, 117, 112, 18, 108,
    10, 17, 115, 116, 114, 105, 110, 103, 95, 115, 116, 114, 105, 110, 103, 95, 109, 97, 112, 24,
    250, 248, 255, 255, 1, 32, 3, 40, 11, 50, 60, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95,
    117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 72, 117, 103, 101, 70, 105, 101,
    108, 100, 78, 117, 109, 98, 101, 114, 115, 46, 83, 116, 114, 105, 110, 103, 83, 116, 114, 105,
    110, 103, 77, 97, 112, 69, 110, 116, 114, 121, 82, 15, 115, 116, 114, 105, 110, 103, 83, 116,
    114, 105, 110, 103, 77, 97, 112, 18, 39, 10, 12, 111, 110, 101, 111, 102, 95, 117, 105, 110,
    116, 51, 50, 24, 251, 248, 255, 255, 1, 32, 1, 40, 13, 72, 0, 82, 11, 111, 110, 101, 111, 102,
    85, 105, 110, 116, 51, 50, 18, 86, 10, 20, 111, 110, 101, 111, 102, 95, 116, 101, 115, 116, 95,
    97, 108, 108, 95, 116, 121, 112, 101, 115, 24, 252, 248, 255, 255, 1, 32, 1, 40, 11, 50, 31,
    46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84,
    101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 72, 0, 82, 17, 111, 110, 101, 111, 102,
    84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 18, 39, 10, 12, 111, 110, 101, 111,
    102, 95, 115, 116, 114, 105, 110, 103, 24, 253, 248, 255, 255, 1, 32, 1, 40, 9, 72, 0, 82, 11,
    111, 110, 101, 111, 102, 83, 116, 114, 105, 110, 103, 18, 37, 10, 11, 111, 110, 101, 111, 102,
    95, 98, 121, 116, 101, 115, 24, 254, 248, 255, 255, 1, 32, 1, 40, 12, 72, 0, 82, 10, 111, 110,
    101, 111, 102, 66, 121, 116, 101, 115, 26, 44, 10, 13, 79, 112, 116, 105, 111, 110, 97, 108,
    71, 114, 111, 117, 112, 18, 27, 10, 7, 103, 114, 111, 117, 112, 95, 97, 24, 249, 248, 255, 255,
    1, 32, 1, 40, 5, 82, 6, 103, 114, 111, 117, 112, 65, 26, 66, 10, 20, 83, 116, 114, 105, 110,
    103, 83, 116, 114, 105, 110, 103, 77, 97, 112, 69, 110, 116, 114, 121, 18, 16, 10, 3, 107, 101,
    121, 24, 1, 32, 1, 40, 9, 82, 3, 107, 101, 121, 18, 20, 10, 5, 118, 97, 108, 117, 101, 24, 2,
    32, 1, 40, 9, 82, 5, 118, 97, 108, 117, 101, 58, 2, 56, 1, 42, 12, 8, 224, 170, 255, 255, 1,
    16, 240, 248, 255, 255, 1, 66, 13, 10, 11, 111, 110, 101, 111, 102, 95, 102, 105, 101, 108,
    100, 34, 250, 1, 10, 24, 84, 101, 115, 116, 69, 120, 116, 101, 110, 115, 105, 111, 110, 73,
    110, 115, 105, 100, 101, 84, 97, 98, 108, 101, 18, 22, 10, 6, 102, 105, 101, 108, 100, 49, 24,
    1, 32, 1, 40, 5, 82, 6, 102, 105, 101, 108, 100, 49, 18, 22, 10, 6, 102, 105, 101, 108, 100,
    50, 24, 2, 32, 1, 40, 5, 82, 6, 102, 105, 101, 108, 100, 50, 18, 22, 10, 6, 102, 105, 101, 108,
    100, 51, 24, 3, 32, 1, 40, 5, 82, 6, 102, 105, 101, 108, 100, 51, 18, 22, 10, 6, 102, 105, 101,
    108, 100, 52, 24, 4, 32, 1, 40, 5, 82, 6, 102, 105, 101, 108, 100, 52, 18, 22, 10, 6, 102, 105,
    101, 108, 100, 54, 24, 6, 32, 1, 40, 5, 82, 6, 102, 105, 101, 108, 100, 54, 18, 22, 10, 6, 102,
    105, 101, 108, 100, 55, 24, 7, 32, 1, 40, 5, 82, 6, 102, 105, 101, 108, 100, 55, 18, 22, 10, 6,
    102, 105, 101, 108, 100, 56, 24, 8, 32, 1, 40, 5, 82, 6, 102, 105, 101, 108, 100, 56, 18, 22,
    10, 6, 102, 105, 101, 108, 100, 57, 24, 9, 32, 1, 40, 5, 82, 6, 102, 105, 101, 108, 100, 57,
    18, 24, 10, 7, 102, 105, 101, 108, 100, 49, 48, 24, 10, 32, 1, 40, 5, 82, 7, 102, 105, 101,
    108, 100, 49, 48, 42, 4, 8, 5, 16, 6, 42, 64, 10, 11, 70, 111, 114, 101, 105, 103, 110, 69,
    110, 117, 109, 18, 15, 10, 11, 70, 79, 82, 69, 73, 71, 78, 95, 70, 79, 79, 16, 4, 18, 15, 10,
    11, 70, 79, 82, 69, 73, 71, 78, 95, 66, 65, 82, 16, 5, 18, 15, 10, 11, 70, 79, 82, 69, 73, 71,
    78, 95, 66, 65, 90, 16, 6, 42, 75, 10, 20, 84, 101, 115, 116, 69, 110, 117, 109, 87, 105, 116,
    104, 68, 117, 112, 86, 97, 108, 117, 101, 18, 8, 10, 4, 70, 79, 79, 49, 16, 1, 18, 8, 10, 4,
    66, 65, 82, 49, 16, 2, 18, 7, 10, 3, 66, 65, 90, 16, 3, 18, 8, 10, 4, 70, 79, 79, 50, 16, 1,
    18, 8, 10, 4, 66, 65, 82, 50, 16, 2, 26, 2, 16, 1, 42, 137, 1, 10, 14, 84, 101, 115, 116, 83,
    112, 97, 114, 115, 101, 69, 110, 117, 109, 18, 12, 10, 8, 83, 80, 65, 82, 83, 69, 95, 65, 16,
    123, 18, 14, 10, 8, 83, 80, 65, 82, 83, 69, 95, 66, 16, 166, 231, 3, 18, 15, 10, 8, 83, 80, 65,
    82, 83, 69, 95, 67, 16, 178, 177, 128, 6, 18, 21, 10, 8, 83, 80, 65, 82, 83, 69, 95, 68, 16,
    241, 255, 255, 255, 255, 255, 255, 255, 255, 1, 18, 21, 10, 8, 83, 80, 65, 82, 83, 69, 95, 69,
    16, 180, 222, 252, 255, 255, 255, 255, 255, 255, 1, 18, 12, 10, 8, 83, 80, 65, 82, 83, 69, 95,
    70, 16, 0, 18, 12, 10, 8, 83, 80, 65, 82, 83, 69, 95, 71, 16, 2, 50, 153, 1, 10, 11, 84, 101,
    115, 116, 83, 101, 114, 118, 105, 99, 101, 18, 68, 10, 3, 70, 111, 111, 18, 29, 46, 112, 114,
    111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 70, 111, 111, 82,
    101, 113, 117, 101, 115, 116, 26, 30, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110,
    105, 116, 116, 101, 115, 116, 46, 70, 111, 111, 82, 101, 115, 112, 111, 110, 115, 101, 18, 68,
    10, 3, 66, 97, 114, 18, 29, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116,
    116, 101, 115, 116, 46, 66, 97, 114, 82, 101, 113, 117, 101, 115, 116, 26, 30, 46, 112, 114,
    111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 66, 97, 114, 82,
    101, 115, 112, 111, 110, 115, 101, 58, 94, 10, 24, 111, 112, 116, 105, 111, 110, 97, 108, 95,
    105, 110, 116, 51, 50, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 1, 32, 1, 40, 5,
    18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116,
    46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 22,
    111, 112, 116, 105, 111, 110, 97, 108, 73, 110, 116, 51, 50, 69, 120, 116, 101, 110, 115, 105,
    111, 110, 58, 94, 10, 24, 111, 112, 116, 105, 111, 110, 97, 108, 95, 105, 110, 116, 54, 52, 95,
    101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 2, 32, 1, 40, 3, 18, 36, 46, 112, 114, 111,
    116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65,
    108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 22, 111, 112, 116, 105, 111,
    110, 97, 108, 73, 110, 116, 54, 52, 69, 120, 116, 101, 110, 115, 105, 111, 110, 58, 96, 10, 25,
    111, 112, 116, 105, 111, 110, 97, 108, 95, 117, 105, 110, 116, 51, 50, 95, 101, 120, 116, 101,
    110, 115, 105, 111, 110, 24, 3, 32, 1, 40, 13, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117,
    102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120,
    116, 101, 110, 115, 105, 111, 110, 115, 82, 23, 111, 112, 116, 105, 111, 110, 97, 108, 85, 105,
    110, 116, 51, 50, 69, 120, 116, 101, 110, 115, 105, 111, 110, 58, 96, 10, 25, 111, 112, 116,
    105, 111, 110, 97, 108, 95, 117, 105, 110, 116, 54, 52, 95, 101, 120, 116, 101, 110, 115, 105,
    111, 110, 24, 4, 32, 1, 40, 4, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110,
    105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115,
    105, 111, 110, 115, 82, 23, 111, 112, 116, 105, 111, 110, 97, 108, 85, 105, 110, 116, 54, 52,
    69, 120, 116, 101, 110, 115, 105, 111, 110, 58, 96, 10, 25, 111, 112, 116, 105, 111, 110, 97,
    108, 95, 115, 105, 110, 116, 51, 50, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 5,
    32, 1, 40, 17, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116,
    101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110,
    115, 82, 23, 111, 112, 116, 105, 111, 110, 97, 108, 83, 105, 110, 116, 51, 50, 69, 120, 116,
    101, 110, 115, 105, 111, 110, 58, 96, 10, 25, 111, 112, 116, 105, 111, 110, 97, 108, 95, 115,
    105, 110, 116, 54, 52, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 6, 32, 1, 40, 18,
    18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116,
    46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 23,
    111, 112, 116, 105, 111, 110, 97, 108, 83, 105, 110, 116, 54, 52, 69, 120, 116, 101, 110, 115,
    105, 111, 110, 58, 98, 10, 26, 111, 112, 116, 105, 111, 110, 97, 108, 95, 102, 105, 120, 101,
    100, 51, 50, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 7, 32, 1, 40, 7, 18, 36, 46,
    112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101,
    115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 24, 111, 112, 116,
    105, 111, 110, 97, 108, 70, 105, 120, 101, 100, 51, 50, 69, 120, 116, 101, 110, 115, 105, 111,
    110, 58, 98, 10, 26, 111, 112, 116, 105, 111, 110, 97, 108, 95, 102, 105, 120, 101, 100, 54,
    52, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 8, 32, 1, 40, 6, 18, 36, 46, 112, 114,
    111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116,
    65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 24, 111, 112, 116, 105, 111,
    110, 97, 108, 70, 105, 120, 101, 100, 54, 52, 69, 120, 116, 101, 110, 115, 105, 111, 110, 58,
    100, 10, 27, 111, 112, 116, 105, 111, 110, 97, 108, 95, 115, 102, 105, 120, 101, 100, 51, 50,
    95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 9, 32, 1, 40, 15, 18, 36, 46, 112, 114,
    111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116,
    65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 25, 111, 112, 116, 105, 111,
    110, 97, 108, 83, 102, 105, 120, 101, 100, 51, 50, 69, 120, 116, 101, 110, 115, 105, 111, 110,
    58, 100, 10, 27, 111, 112, 116, 105, 111, 110, 97, 108, 95, 115, 102, 105, 120, 101, 100, 54,
    52, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 10, 32, 1, 40, 16, 18, 36, 46, 112,
    114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115,
    116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 25, 111, 112, 116, 105,
    111, 110, 97, 108, 83, 102, 105, 120, 101, 100, 54, 52, 69, 120, 116, 101, 110, 115, 105, 111,
    110, 58, 94, 10, 24, 111, 112, 116, 105, 111, 110, 97, 108, 95, 102, 108, 111, 97, 116, 95,
    101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 11, 32, 1, 40, 2, 18, 36, 46, 112, 114, 111,
    116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65,
    108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 22, 111, 112, 116, 105, 111,
    110, 97, 108, 70, 108, 111, 97, 116, 69, 120, 116, 101, 110, 115, 105, 111, 110, 58, 96, 10,
    25, 111, 112, 116, 105, 111, 110, 97, 108, 95, 100, 111, 117, 98, 108, 101, 95, 101, 120, 116,
    101, 110, 115, 105, 111, 110, 24, 12, 32, 1, 40, 1, 18, 36, 46, 112, 114, 111, 116, 111, 98,
    117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69,
    120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 23, 111, 112, 116, 105, 111, 110, 97, 108, 68,
    111, 117, 98, 108, 101, 69, 120, 116, 101, 110, 115, 105, 111, 110, 58, 92, 10, 23, 111, 112,
    116, 105, 111, 110, 97, 108, 95, 98, 111, 111, 108, 95, 101, 120, 116, 101, 110, 115, 105, 111,
    110, 24, 13, 32, 1, 40, 8, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110,
    105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115,
    105, 111, 110, 115, 82, 21, 111, 112, 116, 105, 111, 110, 97, 108, 66, 111, 111, 108, 69, 120,
    116, 101, 110, 115, 105, 111, 110, 58, 96, 10, 25, 111, 112, 116, 105, 111, 110, 97, 108, 95,
    115, 116, 114, 105, 110, 103, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 14, 32, 1,
    40, 9, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101,
    115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115,
    82, 23, 111, 112, 116, 105, 111, 110, 97, 108, 83, 116, 114, 105, 110, 103, 69, 120, 116, 101,
    110, 115, 105, 111, 110, 58, 94, 10, 24, 111, 112, 116, 105, 111, 110, 97, 108, 95, 98, 121,
    116, 101, 115, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 15, 32, 1, 40, 12, 18, 36,
    46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84,
    101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 22, 111, 112,
    116, 105, 111, 110, 97, 108, 66, 121, 116, 101, 115, 69, 120, 116, 101, 110, 115, 105, 111,
    110, 58, 137, 1, 10, 23, 111, 112, 116, 105, 111, 110, 97, 108, 103, 114, 111, 117, 112, 95,
    101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 16, 32, 1, 40, 10, 50, 42, 46, 112, 114, 111,
    116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 79, 112, 116, 105, 111,
    110, 97, 108, 71, 114, 111, 117, 112, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 18, 36,
    46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84,
    101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 22, 111, 112,
    116, 105, 111, 110, 97, 108, 103, 114, 111, 117, 112, 69, 120, 116, 101, 110, 115, 105, 111,
    110, 58, 158, 1, 10, 33, 111, 112, 116, 105, 111, 110, 97, 108, 95, 110, 101, 115, 116, 101,
    100, 95, 109, 101, 115, 115, 97, 103, 101, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24,
    18, 32, 1, 40, 11, 50, 45, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116,
    116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 46, 78, 101,
    115, 116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 18, 36, 46, 112, 114, 111, 116, 111, 98,
    117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69,
    120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 30, 111, 112, 116, 105, 111, 110, 97, 108, 78,
    101, 115, 116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 69, 120, 116, 101, 110, 115, 105,
    111, 110, 58, 148, 1, 10, 34, 111, 112, 116, 105, 111, 110, 97, 108, 95, 102, 111, 114, 101,
    105, 103, 110, 95, 109, 101, 115, 115, 97, 103, 101, 95, 101, 120, 116, 101, 110, 115, 105,
    111, 110, 24, 19, 32, 1, 40, 11, 50, 33, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117,
    110, 105, 116, 116, 101, 115, 116, 46, 70, 111, 114, 101, 105, 103, 110, 77, 101, 115, 115, 97,
    103, 101, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101,
    115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115,
    82, 31, 111, 112, 116, 105, 111, 110, 97, 108, 70, 111, 114, 101, 105, 103, 110, 77, 101, 115,
    115, 97, 103, 101, 69, 120, 116, 101, 110, 115, 105, 111, 110, 58, 152, 1, 10, 33, 111, 112,
    116, 105, 111, 110, 97, 108, 95, 105, 109, 112, 111, 114, 116, 95, 109, 101, 115, 115, 97, 103,
    101, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 20, 32, 1, 40, 11, 50, 39, 46, 112,
    114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 95, 105, 109,
    112, 111, 114, 116, 46, 73, 109, 112, 111, 114, 116, 77, 101, 115, 115, 97, 103, 101, 18, 36,
    46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84,
    101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 30, 111, 112,
    116, 105, 111, 110, 97, 108, 73, 109, 112, 111, 114, 116, 77, 101, 115, 115, 97, 103, 101, 69,
    120, 116, 101, 110, 115, 105, 111, 110, 58, 149, 1, 10, 30, 111, 112, 116, 105, 111, 110, 97,
    108, 95, 110, 101, 115, 116, 101, 100, 95, 101, 110, 117, 109, 95, 101, 120, 116, 101, 110,
    115, 105, 111, 110, 24, 21, 32, 1, 40, 14, 50, 42, 46, 112, 114, 111, 116, 111, 98, 117, 102,
    95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112,
    101, 115, 46, 78, 101, 115, 116, 101, 100, 69, 110, 117, 109, 18, 36, 46, 112, 114, 111, 116,
    111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108,
    108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 27, 111, 112, 116, 105, 111, 110, 97,
    108, 78, 101, 115, 116, 101, 100, 69, 110, 117, 109, 69, 120, 116, 101, 110, 115, 105, 111,
    110, 58, 139, 1, 10, 31, 111, 112, 116, 105, 111, 110, 97, 108, 95, 102, 111, 114, 101, 105,
    103, 110, 95, 101, 110, 117, 109, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 22, 32,
    1, 40, 14, 50, 30, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101,
    115, 116, 46, 70, 111, 114, 101, 105, 103, 110, 69, 110, 117, 109, 18, 36, 46, 112, 114, 111,
    116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65,
    108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 28, 111, 112, 116, 105, 111,
    110, 97, 108, 70, 111, 114, 101, 105, 103, 110, 69, 110, 117, 109, 69, 120, 116, 101, 110, 115,
    105, 111, 110, 58, 143, 1, 10, 30, 111, 112, 116, 105, 111, 110, 97, 108, 95, 105, 109, 112,
    111, 114, 116, 95, 101, 110, 117, 109, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 23,
    32, 1, 40, 14, 50, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116,
    101, 115, 116, 95, 105, 109, 112, 111, 114, 116, 46, 73, 109, 112, 111, 114, 116, 69, 110, 117,
    109, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115,
    116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82,
    27, 111, 112, 116, 105, 111, 110, 97, 108, 73, 109, 112, 111, 114, 116, 69, 110, 117, 109, 69,
    120, 116, 101, 110, 115, 105, 111, 110, 58, 111, 10, 31, 111, 112, 116, 105, 111, 110, 97, 108,
    95, 115, 116, 114, 105, 110, 103, 95, 112, 105, 101, 99, 101, 95, 101, 120, 116, 101, 110, 115,
    105, 111, 110, 24, 24, 32, 1, 40, 9, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95,
    117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101,
    110, 115, 105, 111, 110, 115, 82, 28, 111, 112, 116, 105, 111, 110, 97, 108, 83, 116, 114, 105,
    110, 103, 80, 105, 101, 99, 101, 69, 120, 116, 101, 110, 115, 105, 111, 110, 66, 2, 8, 2, 58,
    96, 10, 23, 111, 112, 116, 105, 111, 110, 97, 108, 95, 99, 111, 114, 100, 95, 101, 120, 116,
    101, 110, 115, 105, 111, 110, 24, 25, 32, 1, 40, 9, 18, 36, 46, 112, 114, 111, 116, 111, 98,
    117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69,
    120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 21, 111, 112, 116, 105, 111, 110, 97, 108, 67,
    111, 114, 100, 69, 120, 116, 101, 110, 115, 105, 111, 110, 66, 2, 8, 1, 58, 171, 1, 10, 40,
    111, 112, 116, 105, 111, 110, 97, 108, 95, 112, 117, 98, 108, 105, 99, 95, 105, 109, 112, 111,
    114, 116, 95, 109, 101, 115, 115, 97, 103, 101, 95, 101, 120, 116, 101, 110, 115, 105, 111,
    110, 24, 26, 32, 1, 40, 11, 50, 45, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110,
    105, 116, 116, 101, 115, 116, 95, 105, 109, 112, 111, 114, 116, 46, 80, 117, 98, 108, 105, 99,
    73, 109, 112, 111, 114, 116, 77, 101, 115, 115, 97, 103, 101, 18, 36, 46, 112, 114, 111, 116,
    111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108,
    108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 36, 111, 112, 116, 105, 111, 110, 97,
    108, 80, 117, 98, 108, 105, 99, 73, 109, 112, 111, 114, 116, 77, 101, 115, 115, 97, 103, 101,
    69, 120, 116, 101, 110, 115, 105, 111, 110, 58, 158, 1, 10, 31, 111, 112, 116, 105, 111, 110,
    97, 108, 95, 108, 97, 122, 121, 95, 109, 101, 115, 115, 97, 103, 101, 95, 101, 120, 116, 101,
    110, 115, 105, 111, 110, 24, 27, 32, 1, 40, 11, 50, 45, 46, 112, 114, 111, 116, 111, 98, 117,
    102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121,
    112, 101, 115, 46, 78, 101, 115, 116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 18, 36, 46,
    112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101,
    115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 28, 111, 112, 116,
    105, 111, 110, 97, 108, 76, 97, 122, 121, 77, 101, 115, 115, 97, 103, 101, 69, 120, 116, 101,
    110, 115, 105, 111, 110, 66, 2, 40, 1, 58, 94, 10, 24, 114, 101, 112, 101, 97, 116, 101, 100,
    95, 105, 110, 116, 51, 50, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 31, 32, 3, 40,
    5, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115,
    116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82,
    22, 114, 101, 112, 101, 97, 116, 101, 100, 73, 110, 116, 51, 50, 69, 120, 116, 101, 110, 115,
    105, 111, 110, 58, 94, 10, 24, 114, 101, 112, 101, 97, 116, 101, 100, 95, 105, 110, 116, 54,
    52, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 32, 32, 3, 40, 3, 18, 36, 46, 112,
    114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115,
    116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 22, 114, 101, 112, 101,
    97, 116, 101, 100, 73, 110, 116, 54, 52, 69, 120, 116, 101, 110, 115, 105, 111, 110, 58, 96,
    10, 25, 114, 101, 112, 101, 97, 116, 101, 100, 95, 117, 105, 110, 116, 51, 50, 95, 101, 120,
    116, 101, 110, 115, 105, 111, 110, 24, 33, 32, 3, 40, 13, 18, 36, 46, 112, 114, 111, 116, 111,
    98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108,
    69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 23, 114, 101, 112, 101, 97, 116, 101, 100,
    85, 105, 110, 116, 51, 50, 69, 120, 116, 101, 110, 115, 105, 111, 110, 58, 96, 10, 25, 114,
    101, 112, 101, 97, 116, 101, 100, 95, 117, 105, 110, 116, 54, 52, 95, 101, 120, 116, 101, 110,
    115, 105, 111, 110, 24, 34, 32, 3, 40, 4, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102,
    95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116,
    101, 110, 115, 105, 111, 110, 115, 82, 23, 114, 101, 112, 101, 97, 116, 101, 100, 85, 105, 110,
    116, 54, 52, 69, 120, 116, 101, 110, 115, 105, 111, 110, 58, 96, 10, 25, 114, 101, 112, 101,
    97, 116, 101, 100, 95, 115, 105, 110, 116, 51, 50, 95, 101, 120, 116, 101, 110, 115, 105, 111,
    110, 24, 35, 32, 3, 40, 17, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110,
    105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115,
    105, 111, 110, 115, 82, 23, 114, 101, 112, 101, 97, 116, 101, 100, 83, 105, 110, 116, 51, 50,
    69, 120, 116, 101, 110, 115, 105, 111, 110, 58, 96, 10, 25, 114, 101, 112, 101, 97, 116, 101,
    100, 95, 115, 105, 110, 116, 54, 52, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 36,
    32, 3, 40, 18, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116,
    101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110,
    115, 82, 23, 114, 101, 112, 101, 97, 116, 101, 100, 83, 105, 110, 116, 54, 52, 69, 120, 116,
    101, 110, 115, 105, 111, 110, 58, 98, 10, 26, 114, 101, 112, 101, 97, 116, 101, 100, 95, 102,
    105, 120, 101, 100, 51, 50, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 37, 32, 3, 40,
    7, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115,
    116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82,
    24, 114, 101, 112, 101, 97, 116, 101, 100, 70, 105, 120, 101, 100, 51, 50, 69, 120, 116, 101,
    110, 115, 105, 111, 110, 58, 98, 10, 26, 114, 101, 112, 101, 97, 116, 101, 100, 95, 102, 105,
    120, 101, 100, 54, 52, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 38, 32, 3, 40, 6,
    18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116,
    46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 24,
    114, 101, 112, 101, 97, 116, 101, 100, 70, 105, 120, 101, 100, 54, 52, 69, 120, 116, 101, 110,
    115, 105, 111, 110, 58, 100, 10, 27, 114, 101, 112, 101, 97, 116, 101, 100, 95, 115, 102, 105,
    120, 101, 100, 51, 50, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 39, 32, 3, 40, 15,
    18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116,
    46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 25,
    114, 101, 112, 101, 97, 116, 101, 100, 83, 102, 105, 120, 101, 100, 51, 50, 69, 120, 116, 101,
    110, 115, 105, 111, 110, 58, 100, 10, 27, 114, 101, 112, 101, 97, 116, 101, 100, 95, 115, 102,
    105, 120, 101, 100, 54, 52, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 40, 32, 3, 40,
    16, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115,
    116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82,
    25, 114, 101, 112, 101, 97, 116, 101, 100, 83, 102, 105, 120, 101, 100, 54, 52, 69, 120, 116,
    101, 110, 115, 105, 111, 110, 58, 94, 10, 24, 114, 101, 112, 101, 97, 116, 101, 100, 95, 102,
    108, 111, 97, 116, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 41, 32, 3, 40, 2, 18,
    36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46,
    84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 22, 114,
    101, 112, 101, 97, 116, 101, 100, 70, 108, 111, 97, 116, 69, 120, 116, 101, 110, 115, 105, 111,
    110, 58, 96, 10, 25, 114, 101, 112, 101, 97, 116, 101, 100, 95, 100, 111, 117, 98, 108, 101,
    95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 42, 32, 3, 40, 1, 18, 36, 46, 112, 114,
    111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116,
    65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 23, 114, 101, 112, 101, 97,
    116, 101, 100, 68, 111, 117, 98, 108, 101, 69, 120, 116, 101, 110, 115, 105, 111, 110, 58, 92,
    10, 23, 114, 101, 112, 101, 97, 116, 101, 100, 95, 98, 111, 111, 108, 95, 101, 120, 116, 101,
    110, 115, 105, 111, 110, 24, 43, 32, 3, 40, 8, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117,
    102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120,
    116, 101, 110, 115, 105, 111, 110, 115, 82, 21, 114, 101, 112, 101, 97, 116, 101, 100, 66, 111,
    111, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 58, 96, 10, 25, 114, 101, 112, 101, 97,
    116, 101, 100, 95, 115, 116, 114, 105, 110, 103, 95, 101, 120, 116, 101, 110, 115, 105, 111,
    110, 24, 44, 32, 3, 40, 9, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110,
    105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115,
    105, 111, 110, 115, 82, 23, 114, 101, 112, 101, 97, 116, 101, 100, 83, 116, 114, 105, 110, 103,
    69, 120, 116, 101, 110, 115, 105, 111, 110, 58, 94, 10, 24, 114, 101, 112, 101, 97, 116, 101,
    100, 95, 98, 121, 116, 101, 115, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 45, 32,
    3, 40, 12, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101,
    115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115,
    82, 22, 114, 101, 112, 101, 97, 116, 101, 100, 66, 121, 116, 101, 115, 69, 120, 116, 101, 110,
    115, 105, 111, 110, 58, 137, 1, 10, 23, 114, 101, 112, 101, 97, 116, 101, 100, 103, 114, 111,
    117, 112, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 46, 32, 3, 40, 10, 50, 42, 46,
    112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 82, 101,
    112, 101, 97, 116, 101, 100, 71, 114, 111, 117, 112, 95, 101, 120, 116, 101, 110, 115, 105,
    111, 110, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101,
    115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115,
    82, 22, 114, 101, 112, 101, 97, 116, 101, 100, 103, 114, 111, 117, 112, 69, 120, 116, 101, 110,
    115, 105, 111, 110, 58, 158, 1, 10, 33, 114, 101, 112, 101, 97, 116, 101, 100, 95, 110, 101,
    115, 116, 101, 100, 95, 109, 101, 115, 115, 97, 103, 101, 95, 101, 120, 116, 101, 110, 115,
    105, 111, 110, 24, 48, 32, 3, 40, 11, 50, 45, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95,
    117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101,
    115, 46, 78, 101, 115, 116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 18, 36, 46, 112, 114,
    111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116,
    65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 30, 114, 101, 112, 101, 97,
    116, 101, 100, 78, 101, 115, 116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 69, 120, 116, 101,
    110, 115, 105, 111, 110, 58, 148, 1, 10, 34, 114, 101, 112, 101, 97, 116, 101, 100, 95, 102,
    111, 114, 101, 105, 103, 110, 95, 109, 101, 115, 115, 97, 103, 101, 95, 101, 120, 116, 101,
    110, 115, 105, 111, 110, 24, 49, 32, 3, 40, 11, 50, 33, 46, 112, 114, 111, 116, 111, 98, 117,
    102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 70, 111, 114, 101, 105, 103, 110, 77, 101,
    115, 115, 97, 103, 101, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105,
    116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105,
    111, 110, 115, 82, 31, 114, 101, 112, 101, 97, 116, 101, 100, 70, 111, 114, 101, 105, 103, 110,
    77, 101, 115, 115, 97, 103, 101, 69, 120, 116, 101, 110, 115, 105, 111, 110, 58, 152, 1, 10,
    33, 114, 101, 112, 101, 97, 116, 101, 100, 95, 105, 109, 112, 111, 114, 116, 95, 109, 101, 115,
    115, 97, 103, 101, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 50, 32, 3, 40, 11, 50,
    39, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 95,
    105, 109, 112, 111, 114, 116, 46, 73, 109, 112, 111, 114, 116, 77, 101, 115, 115, 97, 103, 101,
    18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116,
    46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 30,
    114, 101, 112, 101, 97, 116, 101, 100, 73, 109, 112, 111, 114, 116, 77, 101, 115, 115, 97, 103,
    101, 69, 120, 116, 101, 110, 115, 105, 111, 110, 58, 149, 1, 10, 30, 114, 101, 112, 101, 97,
    116, 101, 100, 95, 110, 101, 115, 116, 101, 100, 95, 101, 110, 117, 109, 95, 101, 120, 116,
    101, 110, 115, 105, 111, 110, 24, 51, 32, 3, 40, 14, 50, 42, 46, 112, 114, 111, 116, 111, 98,
    117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84,
    121, 112, 101, 115, 46, 78, 101, 115, 116, 101, 100, 69, 110, 117, 109, 18, 36, 46, 112, 114,
    111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116,
    65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 27, 114, 101, 112, 101, 97,
    116, 101, 100, 78, 101, 115, 116, 101, 100, 69, 110, 117, 109, 69, 120, 116, 101, 110, 115,
    105, 111, 110, 58, 139, 1, 10, 31, 114, 101, 112, 101, 97, 116, 101, 100, 95, 102, 111, 114,
    101, 105, 103, 110, 95, 101, 110, 117, 109, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110,
    24, 52, 32, 3, 40, 14, 50, 30, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105,
    116, 116, 101, 115, 116, 46, 70, 111, 114, 101, 105, 103, 110, 69, 110, 117, 109, 18, 36, 46,
    112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101,
    115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 28, 114, 101, 112,
    101, 97, 116, 101, 100, 70, 111, 114, 101, 105, 103, 110, 69, 110, 117, 109, 69, 120, 116, 101,
    110, 115, 105, 111, 110, 58, 143, 1, 10, 30, 114, 101, 112, 101, 97, 116, 101, 100, 95, 105,
    109, 112, 111, 114, 116, 95, 101, 110, 117, 109, 95, 101, 120, 116, 101, 110, 115, 105, 111,
    110, 24, 53, 32, 3, 40, 14, 50, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110,
    105, 116, 116, 101, 115, 116, 95, 105, 109, 112, 111, 114, 116, 46, 73, 109, 112, 111, 114,
    116, 69, 110, 117, 109, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105,
    116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105,
    111, 110, 115, 82, 27, 114, 101, 112, 101, 97, 116, 101, 100, 73, 109, 112, 111, 114, 116, 69,
    110, 117, 109, 69, 120, 116, 101, 110, 115, 105, 111, 110, 58, 111, 10, 31, 114, 101, 112, 101,
    97, 116, 101, 100, 95, 115, 116, 114, 105, 110, 103, 95, 112, 105, 101, 99, 101, 95, 101, 120,
    116, 101, 110, 115, 105, 111, 110, 24, 54, 32, 3, 40, 9, 18, 36, 46, 112, 114, 111, 116, 111,
    98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108,
    69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 28, 114, 101, 112, 101, 97, 116, 101, 100,
    83, 116, 114, 105, 110, 103, 80, 105, 101, 99, 101, 69, 120, 116, 101, 110, 115, 105, 111, 110,
    66, 2, 8, 2, 58, 96, 10, 23, 114, 101, 112, 101, 97, 116, 101, 100, 95, 99, 111, 114, 100, 95,
    101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 55, 32, 3, 40, 9, 18, 36, 46, 112, 114, 111,
    116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65,
    108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 21, 114, 101, 112, 101, 97, 116,
    101, 100, 67, 111, 114, 100, 69, 120, 116, 101, 110, 115, 105, 111, 110, 66, 2, 8, 1, 58, 158,
    1, 10, 31, 114, 101, 112, 101, 97, 116, 101, 100, 95, 108, 97, 122, 121, 95, 109, 101, 115,
    115, 97, 103, 101, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 57, 32, 3, 40, 11, 50,
    45, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46,
    84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 46, 78, 101, 115, 116, 101, 100, 77,
    101, 115, 115, 97, 103, 101, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110,
    105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115,
    105, 111, 110, 115, 82, 28, 114, 101, 112, 101, 97, 116, 101, 100, 76, 97, 122, 121, 77, 101,
    115, 115, 97, 103, 101, 69, 120, 116, 101, 110, 115, 105, 111, 110, 66, 2, 40, 1, 58, 96, 10,
    23, 100, 101, 102, 97, 117, 108, 116, 95, 105, 110, 116, 51, 50, 95, 101, 120, 116, 101, 110,
    115, 105, 111, 110, 24, 61, 32, 1, 40, 5, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102,
    95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116,
    101, 110, 115, 105, 111, 110, 115, 58, 2, 52, 49, 82, 21, 100, 101, 102, 97, 117, 108, 116, 73,
    110, 116, 51, 50, 69, 120, 116, 101, 110, 115, 105, 111, 110, 58, 96, 10, 23, 100, 101, 102,
    97, 117, 108, 116, 95, 105, 110, 116, 54, 52, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110,
    24, 62, 32, 1, 40, 3, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105,
    116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105,
    111, 110, 115, 58, 2, 52, 50, 82, 21, 100, 101, 102, 97, 117, 108, 116, 73, 110, 116, 54, 52,
    69, 120, 116, 101, 110, 115, 105, 111, 110, 58, 98, 10, 24, 100, 101, 102, 97, 117, 108, 116,
    95, 117, 105, 110, 116, 51, 50, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 63, 32, 1,
    40, 13, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101,
    115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115,
    58, 2, 52, 51, 82, 22, 100, 101, 102, 97, 117, 108, 116, 85, 105, 110, 116, 51, 50, 69, 120,
    116, 101, 110, 115, 105, 111, 110, 58, 98, 10, 24, 100, 101, 102, 97, 117, 108, 116, 95, 117,
    105, 110, 116, 54, 52, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 64, 32, 1, 40, 4,
    18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116,
    46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 58, 2,
    52, 52, 82, 22, 100, 101, 102, 97, 117, 108, 116, 85, 105, 110, 116, 54, 52, 69, 120, 116, 101,
    110, 115, 105, 111, 110, 58, 99, 10, 24, 100, 101, 102, 97, 117, 108, 116, 95, 115, 105, 110,
    116, 51, 50, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 65, 32, 1, 40, 17, 18, 36,
    46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84,
    101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 58, 3, 45, 52,
    53, 82, 22, 100, 101, 102, 97, 117, 108, 116, 83, 105, 110, 116, 51, 50, 69, 120, 116, 101,
    110, 115, 105, 111, 110, 58, 98, 10, 24, 100, 101, 102, 97, 117, 108, 116, 95, 115, 105, 110,
    116, 54, 52, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 66, 32, 1, 40, 18, 18, 36,
    46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84,
    101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 58, 2, 52, 54,
    82, 22, 100, 101, 102, 97, 117, 108, 116, 83, 105, 110, 116, 54, 52, 69, 120, 116, 101, 110,
    115, 105, 111, 110, 58, 100, 10, 25, 100, 101, 102, 97, 117, 108, 116, 95, 102, 105, 120, 101,
    100, 51, 50, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 67, 32, 1, 40, 7, 18, 36, 46,
    112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101,
    115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 58, 2, 52, 55, 82, 23,
    100, 101, 102, 97, 117, 108, 116, 70, 105, 120, 101, 100, 51, 50, 69, 120, 116, 101, 110, 115,
    105, 111, 110, 58, 100, 10, 25, 100, 101, 102, 97, 117, 108, 116, 95, 102, 105, 120, 101, 100,
    54, 52, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 68, 32, 1, 40, 6, 18, 36, 46, 112,
    114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115,
    116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 58, 2, 52, 56, 82, 23, 100,
    101, 102, 97, 117, 108, 116, 70, 105, 120, 101, 100, 54, 52, 69, 120, 116, 101, 110, 115, 105,
    111, 110, 58, 102, 10, 26, 100, 101, 102, 97, 117, 108, 116, 95, 115, 102, 105, 120, 101, 100,
    51, 50, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 69, 32, 1, 40, 15, 18, 36, 46,
    112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101,
    115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 58, 2, 52, 57, 82, 24,
    100, 101, 102, 97, 117, 108, 116, 83, 102, 105, 120, 101, 100, 51, 50, 69, 120, 116, 101, 110,
    115, 105, 111, 110, 58, 103, 10, 26, 100, 101, 102, 97, 117, 108, 116, 95, 115, 102, 105, 120,
    101, 100, 54, 52, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 70, 32, 1, 40, 16, 18,
    36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46,
    84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 58, 3, 45,
    53, 48, 82, 24, 100, 101, 102, 97, 117, 108, 116, 83, 102, 105, 120, 101, 100, 54, 52, 69, 120,
    116, 101, 110, 115, 105, 111, 110, 58, 98, 10, 23, 100, 101, 102, 97, 117, 108, 116, 95, 102,
    108, 111, 97, 116, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 71, 32, 1, 40, 2, 18,
    36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46,
    84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 58, 4, 53,
    49, 46, 53, 82, 21, 100, 101, 102, 97, 117, 108, 116, 70, 108, 111, 97, 116, 69, 120, 116, 101,
    110, 115, 105, 111, 110, 58, 101, 10, 24, 100, 101, 102, 97, 117, 108, 116, 95, 100, 111, 117,
    98, 108, 101, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 72, 32, 1, 40, 1, 18, 36,
    46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84,
    101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 58, 5, 53, 50,
    48, 48, 48, 82, 22, 100, 101, 102, 97, 117, 108, 116, 68, 111, 117, 98, 108, 101, 69, 120, 116,
    101, 110, 115, 105, 111, 110, 58, 96, 10, 22, 100, 101, 102, 97, 117, 108, 116, 95, 98, 111,
    111, 108, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 73, 32, 1, 40, 8, 18, 36, 46,
    112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101,
    115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 58, 4, 116, 114, 117,
    101, 82, 20, 100, 101, 102, 97, 117, 108, 116, 66, 111, 111, 108, 69, 120, 116, 101, 110, 115,
    105, 111, 110, 58, 101, 10, 24, 100, 101, 102, 97, 117, 108, 116, 95, 115, 116, 114, 105, 110,
    103, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 74, 32, 1, 40, 9, 18, 36, 46, 112,
    114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115,
    116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 58, 5, 104, 101, 108, 108,
    111, 82, 22, 100, 101, 102, 97, 117, 108, 116, 83, 116, 114, 105, 110, 103, 69, 120, 116, 101,
    110, 115, 105, 111, 110, 58, 99, 10, 23, 100, 101, 102, 97, 117, 108, 116, 95, 98, 121, 116,
    101, 115, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 75, 32, 1, 40, 12, 18, 36, 46,
    112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101,
    115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 58, 5, 119, 111, 114,
    108, 100, 82, 21, 100, 101, 102, 97, 117, 108, 116, 66, 121, 116, 101, 115, 69, 120, 116, 101,
    110, 115, 105, 111, 110, 58, 152, 1, 10, 29, 100, 101, 102, 97, 117, 108, 116, 95, 110, 101,
    115, 116, 101, 100, 95, 101, 110, 117, 109, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110,
    24, 81, 32, 1, 40, 14, 50, 42, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105,
    116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 46, 78,
    101, 115, 116, 101, 100, 69, 110, 117, 109, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102,
    95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116,
    101, 110, 115, 105, 111, 110, 115, 58, 3, 66, 65, 82, 82, 26, 100, 101, 102, 97, 117, 108, 116,
    78, 101, 115, 116, 101, 100, 69, 110, 117, 109, 69, 120, 116, 101, 110, 115, 105, 111, 110, 58,
    150, 1, 10, 30, 100, 101, 102, 97, 117, 108, 116, 95, 102, 111, 114, 101, 105, 103, 110, 95,
    101, 110, 117, 109, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 82, 32, 1, 40, 14, 50,
    30, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46,
    70, 111, 114, 101, 105, 103, 110, 69, 110, 117, 109, 18, 36, 46, 112, 114, 111, 116, 111, 98,
    117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69,
    120, 116, 101, 110, 115, 105, 111, 110, 115, 58, 11, 70, 79, 82, 69, 73, 71, 78, 95, 66, 65,
    82, 82, 27, 100, 101, 102, 97, 117, 108, 116, 70, 111, 114, 101, 105, 103, 110, 69, 110, 117,
    109, 69, 120, 116, 101, 110, 115, 105, 111, 110, 58, 153, 1, 10, 29, 100, 101, 102, 97, 117,
    108, 116, 95, 105, 109, 112, 111, 114, 116, 95, 101, 110, 117, 109, 95, 101, 120, 116, 101,
    110, 115, 105, 111, 110, 24, 83, 32, 1, 40, 14, 50, 36, 46, 112, 114, 111, 116, 111, 98, 117,
    102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 95, 105, 109, 112, 111, 114, 116, 46, 73, 109,
    112, 111, 114, 116, 69, 110, 117, 109, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95,
    117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101,
    110, 115, 105, 111, 110, 115, 58, 10, 73, 77, 80, 79, 82, 84, 95, 66, 65, 82, 82, 26, 100, 101,
    102, 97, 117, 108, 116, 73, 109, 112, 111, 114, 116, 69, 110, 117, 109, 69, 120, 116, 101, 110,
    115, 105, 111, 110, 58, 114, 10, 30, 100, 101, 102, 97, 117, 108, 116, 95, 115, 116, 114, 105,
    110, 103, 95, 112, 105, 101, 99, 101, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 84,
    32, 1, 40, 9, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116,
    101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110,
    115, 58, 3, 97, 98, 99, 82, 27, 100, 101, 102, 97, 117, 108, 116, 83, 116, 114, 105, 110, 103,
    80, 105, 101, 99, 101, 69, 120, 116, 101, 110, 115, 105, 111, 110, 66, 2, 8, 2, 58, 99, 10, 22,
    100, 101, 102, 97, 117, 108, 116, 95, 99, 111, 114, 100, 95, 101, 120, 116, 101, 110, 115, 105,
    111, 110, 24, 85, 32, 1, 40, 9, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117,
    110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110,
    115, 105, 111, 110, 115, 58, 3, 49, 50, 51, 82, 20, 100, 101, 102, 97, 117, 108, 116, 67, 111,
    114, 100, 69, 120, 116, 101, 110, 115, 105, 111, 110, 66, 2, 8, 1, 58, 90, 10, 22, 111, 110,
    101, 111, 102, 95, 117, 105, 110, 116, 51, 50, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110,
    24, 111, 32, 1, 40, 13, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105,
    116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105,
    111, 110, 115, 82, 20, 111, 110, 101, 111, 102, 85, 105, 110, 116, 51, 50, 69, 120, 116, 101,
    110, 115, 105, 111, 110, 58, 152, 1, 10, 30, 111, 110, 101, 111, 102, 95, 110, 101, 115, 116,
    101, 100, 95, 109, 101, 115, 115, 97, 103, 101, 95, 101, 120, 116, 101, 110, 115, 105, 111,
    110, 24, 112, 32, 1, 40, 11, 50, 45, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110,
    105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 46,
    78, 101, 115, 116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 18, 36, 46, 112, 114, 111, 116,
    111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108,
    108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 27, 111, 110, 101, 111, 102, 78, 101,
    115, 116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 69, 120, 116, 101, 110, 115, 105, 111,
    110, 58, 90, 10, 22, 111, 110, 101, 111, 102, 95, 115, 116, 114, 105, 110, 103, 95, 101, 120,
    116, 101, 110, 115, 105, 111, 110, 24, 113, 32, 1, 40, 9, 18, 36, 46, 112, 114, 111, 116, 111,
    98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108,
    69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 20, 111, 110, 101, 111, 102, 83, 116, 114,
    105, 110, 103, 69, 120, 116, 101, 110, 115, 105, 111, 110, 58, 88, 10, 21, 111, 110, 101, 111,
    102, 95, 98, 121, 116, 101, 115, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 114, 32,
    1, 40, 12, 18, 36, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101,
    115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115,
    82, 19, 111, 110, 101, 111, 102, 66, 121, 116, 101, 115, 69, 120, 116, 101, 110, 115, 105, 111,
    110, 58, 85, 10, 19, 109, 121, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 95, 115, 116,
    114, 105, 110, 103, 24, 50, 32, 1, 40, 9, 18, 37, 46, 112, 114, 111, 116, 111, 98, 117, 102,
    95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 70, 105, 101, 108, 100, 79,
    114, 100, 101, 114, 105, 110, 103, 115, 82, 17, 109, 121, 69, 120, 116, 101, 110, 115, 105,
    111, 110, 83, 116, 114, 105, 110, 103, 58, 79, 10, 16, 109, 121, 95, 101, 120, 116, 101, 110,
    115, 105, 111, 110, 95, 105, 110, 116, 24, 5, 32, 1, 40, 5, 18, 37, 46, 112, 114, 111, 116,
    111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 70, 105,
    101, 108, 100, 79, 114, 100, 101, 114, 105, 110, 103, 115, 82, 14, 109, 121, 69, 120, 116, 101,
    110, 115, 105, 111, 110, 73, 110, 116, 58, 97, 10, 22, 112, 97, 99, 107, 101, 100, 95, 105,
    110, 116, 51, 50, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 90, 32, 3, 40, 5, 18,
    39, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46,
    84, 101, 115, 116, 80, 97, 99, 107, 101, 100, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115,
    82, 20, 112, 97, 99, 107, 101, 100, 73, 110, 116, 51, 50, 69, 120, 116, 101, 110, 115, 105,
    111, 110, 66, 2, 16, 1, 58, 97, 10, 22, 112, 97, 99, 107, 101, 100, 95, 105, 110, 116, 54, 52,
    95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 91, 32, 3, 40, 3, 18, 39, 46, 112, 114,
    111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116,
    80, 97, 99, 107, 101, 100, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 20, 112, 97,
    99, 107, 101, 100, 73, 110, 116, 54, 52, 69, 120, 116, 101, 110, 115, 105, 111, 110, 66, 2, 16,
    1, 58, 99, 10, 23, 112, 97, 99, 107, 101, 100, 95, 117, 105, 110, 116, 51, 50, 95, 101, 120,
    116, 101, 110, 115, 105, 111, 110, 24, 92, 32, 3, 40, 13, 18, 39, 46, 112, 114, 111, 116, 111,
    98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 80, 97, 99,
    107, 101, 100, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 21, 112, 97, 99, 107, 101,
    100, 85, 105, 110, 116, 51, 50, 69, 120, 116, 101, 110, 115, 105, 111, 110, 66, 2, 16, 1, 58,
    99, 10, 23, 112, 97, 99, 107, 101, 100, 95, 117, 105, 110, 116, 54, 52, 95, 101, 120, 116, 101,
    110, 115, 105, 111, 110, 24, 93, 32, 3, 40, 4, 18, 39, 46, 112, 114, 111, 116, 111, 98, 117,
    102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 80, 97, 99, 107, 101,
    100, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 21, 112, 97, 99, 107, 101, 100, 85,
    105, 110, 116, 54, 52, 69, 120, 116, 101, 110, 115, 105, 111, 110, 66, 2, 16, 1, 58, 99, 10,
    23, 112, 97, 99, 107, 101, 100, 95, 115, 105, 110, 116, 51, 50, 95, 101, 120, 116, 101, 110,
    115, 105, 111, 110, 24, 94, 32, 3, 40, 17, 18, 39, 46, 112, 114, 111, 116, 111, 98, 117, 102,
    95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 80, 97, 99, 107, 101, 100,
    69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 21, 112, 97, 99, 107, 101, 100, 83, 105,
    110, 116, 51, 50, 69, 120, 116, 101, 110, 115, 105, 111, 110, 66, 2, 16, 1, 58, 99, 10, 23,
    112, 97, 99, 107, 101, 100, 95, 115, 105, 110, 116, 54, 52, 95, 101, 120, 116, 101, 110, 115,
    105, 111, 110, 24, 95, 32, 3, 40, 18, 18, 39, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95,
    117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 80, 97, 99, 107, 101, 100, 69,
    120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 21, 112, 97, 99, 107, 101, 100, 83, 105, 110,
    116, 54, 52, 69, 120, 116, 101, 110, 115, 105, 111, 110, 66, 2, 16, 1, 58, 101, 10, 24, 112,
    97, 99, 107, 101, 100, 95, 102, 105, 120, 101, 100, 51, 50, 95, 101, 120, 116, 101, 110, 115,
    105, 111, 110, 24, 96, 32, 3, 40, 7, 18, 39, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95,
    117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 80, 97, 99, 107, 101, 100, 69,
    120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 22, 112, 97, 99, 107, 101, 100, 70, 105, 120,
    101, 100, 51, 50, 69, 120, 116, 101, 110, 115, 105, 111, 110, 66, 2, 16, 1, 58, 101, 10, 24,
    112, 97, 99, 107, 101, 100, 95, 102, 105, 120, 101, 100, 54, 52, 95, 101, 120, 116, 101, 110,
    115, 105, 111, 110, 24, 97, 32, 3, 40, 6, 18, 39, 46, 112, 114, 111, 116, 111, 98, 117, 102,
    95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 80, 97, 99, 107, 101, 100,
    69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 22, 112, 97, 99, 107, 101, 100, 70, 105,
    120, 101, 100, 54, 52, 69, 120, 116, 101, 110, 115, 105, 111, 110, 66, 2, 16, 1, 58, 103, 10,
    25, 112, 97, 99, 107, 101, 100, 95, 115, 102, 105, 120, 101, 100, 51, 50, 95, 101, 120, 116,
    101, 110, 115, 105, 111, 110, 24, 98, 32, 3, 40, 15, 18, 39, 46, 112, 114, 111, 116, 111, 98,
    117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 80, 97, 99, 107,
    101, 100, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 23, 112, 97, 99, 107, 101, 100,
    83, 102, 105, 120, 101, 100, 51, 50, 69, 120, 116, 101, 110, 115, 105, 111, 110, 66, 2, 16, 1,
    58, 103, 10, 25, 112, 97, 99, 107, 101, 100, 95, 115, 102, 105, 120, 101, 100, 54, 52, 95, 101,
    120, 116, 101, 110, 115, 105, 111, 110, 24, 99, 32, 3, 40, 16, 18, 39, 46, 112, 114, 111, 116,
    111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 80, 97,
    99, 107, 101, 100, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 23, 112, 97, 99, 107,
    101, 100, 83, 102, 105, 120, 101, 100, 54, 52, 69, 120, 116, 101, 110, 115, 105, 111, 110, 66,
    2, 16, 1, 58, 97, 10, 22, 112, 97, 99, 107, 101, 100, 95, 102, 108, 111, 97, 116, 95, 101, 120,
    116, 101, 110, 115, 105, 111, 110, 24, 100, 32, 3, 40, 2, 18, 39, 46, 112, 114, 111, 116, 111,
    98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 80, 97, 99,
    107, 101, 100, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 20, 112, 97, 99, 107, 101,
    100, 70, 108, 111, 97, 116, 69, 120, 116, 101, 110, 115, 105, 111, 110, 66, 2, 16, 1, 58, 99,
    10, 23, 112, 97, 99, 107, 101, 100, 95, 100, 111, 117, 98, 108, 101, 95, 101, 120, 116, 101,
    110, 115, 105, 111, 110, 24, 101, 32, 3, 40, 1, 18, 39, 46, 112, 114, 111, 116, 111, 98, 117,
    102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 80, 97, 99, 107, 101,
    100, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 21, 112, 97, 99, 107, 101, 100, 68,
    111, 117, 98, 108, 101, 69, 120, 116, 101, 110, 115, 105, 111, 110, 66, 2, 16, 1, 58, 95, 10,
    21, 112, 97, 99, 107, 101, 100, 95, 98, 111, 111, 108, 95, 101, 120, 116, 101, 110, 115, 105,
    111, 110, 24, 102, 32, 3, 40, 8, 18, 39, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117,
    110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 80, 97, 99, 107, 101, 100, 69, 120,
    116, 101, 110, 115, 105, 111, 110, 115, 82, 19, 112, 97, 99, 107, 101, 100, 66, 111, 111, 108,
    69, 120, 116, 101, 110, 115, 105, 111, 110, 66, 2, 16, 1, 58, 127, 10, 21, 112, 97, 99, 107,
    101, 100, 95, 101, 110, 117, 109, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 103, 32,
    3, 40, 14, 50, 30, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101,
    115, 116, 46, 70, 111, 114, 101, 105, 103, 110, 69, 110, 117, 109, 18, 39, 46, 112, 114, 111,
    116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 80,
    97, 99, 107, 101, 100, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 19, 112, 97, 99,
    107, 101, 100, 69, 110, 117, 109, 69, 120, 116, 101, 110, 115, 105, 111, 110, 66, 2, 16, 1, 58,
    103, 10, 24, 117, 110, 112, 97, 99, 107, 101, 100, 95, 105, 110, 116, 51, 50, 95, 101, 120,
    116, 101, 110, 115, 105, 111, 110, 24, 90, 32, 3, 40, 5, 18, 41, 46, 112, 114, 111, 116, 111,
    98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 85, 110, 112,
    97, 99, 107, 101, 100, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 22, 117, 110, 112,
    97, 99, 107, 101, 100, 73, 110, 116, 51, 50, 69, 120, 116, 101, 110, 115, 105, 111, 110, 66, 2,
    16, 0, 58, 103, 10, 24, 117, 110, 112, 97, 99, 107, 101, 100, 95, 105, 110, 116, 54, 52, 95,
    101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 91, 32, 3, 40, 3, 18, 41, 46, 112, 114, 111,
    116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 85,
    110, 112, 97, 99, 107, 101, 100, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 22, 117,
    110, 112, 97, 99, 107, 101, 100, 73, 110, 116, 54, 52, 69, 120, 116, 101, 110, 115, 105, 111,
    110, 66, 2, 16, 0, 58, 105, 10, 25, 117, 110, 112, 97, 99, 107, 101, 100, 95, 117, 105, 110,
    116, 51, 50, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 92, 32, 3, 40, 13, 18, 41,
    46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84,
    101, 115, 116, 85, 110, 112, 97, 99, 107, 101, 100, 69, 120, 116, 101, 110, 115, 105, 111, 110,
    115, 82, 23, 117, 110, 112, 97, 99, 107, 101, 100, 85, 105, 110, 116, 51, 50, 69, 120, 116,
    101, 110, 115, 105, 111, 110, 66, 2, 16, 0, 58, 105, 10, 25, 117, 110, 112, 97, 99, 107, 101,
    100, 95, 117, 105, 110, 116, 54, 52, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 93,
    32, 3, 40, 4, 18, 41, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116,
    101, 115, 116, 46, 84, 101, 115, 116, 85, 110, 112, 97, 99, 107, 101, 100, 69, 120, 116, 101,
    110, 115, 105, 111, 110, 115, 82, 23, 117, 110, 112, 97, 99, 107, 101, 100, 85, 105, 110, 116,
    54, 52, 69, 120, 116, 101, 110, 115, 105, 111, 110, 66, 2, 16, 0, 58, 105, 10, 25, 117, 110,
    112, 97, 99, 107, 101, 100, 95, 115, 105, 110, 116, 51, 50, 95, 101, 120, 116, 101, 110, 115,
    105, 111, 110, 24, 94, 32, 3, 40, 17, 18, 41, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95,
    117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 85, 110, 112, 97, 99, 107, 101,
    100, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 23, 117, 110, 112, 97, 99, 107, 101,
    100, 83, 105, 110, 116, 51, 50, 69, 120, 116, 101, 110, 115, 105, 111, 110, 66, 2, 16, 0, 58,
    105, 10, 25, 117, 110, 112, 97, 99, 107, 101, 100, 95, 115, 105, 110, 116, 54, 52, 95, 101,
    120, 116, 101, 110, 115, 105, 111, 110, 24, 95, 32, 3, 40, 18, 18, 41, 46, 112, 114, 111, 116,
    111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 85, 110,
    112, 97, 99, 107, 101, 100, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 23, 117, 110,
    112, 97, 99, 107, 101, 100, 83, 105, 110, 116, 54, 52, 69, 120, 116, 101, 110, 115, 105, 111,
    110, 66, 2, 16, 0, 58, 107, 10, 26, 117, 110, 112, 97, 99, 107, 101, 100, 95, 102, 105, 120,
    101, 100, 51, 50, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 96, 32, 3, 40, 7, 18,
    41, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46,
    84, 101, 115, 116, 85, 110, 112, 97, 99, 107, 101, 100, 69, 120, 116, 101, 110, 115, 105, 111,
    110, 115, 82, 24, 117, 110, 112, 97, 99, 107, 101, 100, 70, 105, 120, 101, 100, 51, 50, 69,
    120, 116, 101, 110, 115, 105, 111, 110, 66, 2, 16, 0, 58, 107, 10, 26, 117, 110, 112, 97, 99,
    107, 101, 100, 95, 102, 105, 120, 101, 100, 54, 52, 95, 101, 120, 116, 101, 110, 115, 105, 111,
    110, 24, 97, 32, 3, 40, 6, 18, 41, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110,
    105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 85, 110, 112, 97, 99, 107, 101, 100, 69,
    120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 24, 117, 110, 112, 97, 99, 107, 101, 100, 70,
    105, 120, 101, 100, 54, 52, 69, 120, 116, 101, 110, 115, 105, 111, 110, 66, 2, 16, 0, 58, 109,
    10, 27, 117, 110, 112, 97, 99, 107, 101, 100, 95, 115, 102, 105, 120, 101, 100, 51, 50, 95,
    101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 98, 32, 3, 40, 15, 18, 41, 46, 112, 114, 111,
    116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 85,
    110, 112, 97, 99, 107, 101, 100, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 25, 117,
    110, 112, 97, 99, 107, 101, 100, 83, 102, 105, 120, 101, 100, 51, 50, 69, 120, 116, 101, 110,
    115, 105, 111, 110, 66, 2, 16, 0, 58, 109, 10, 27, 117, 110, 112, 97, 99, 107, 101, 100, 95,
    115, 102, 105, 120, 101, 100, 54, 52, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 99,
    32, 3, 40, 16, 18, 41, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116,
    101, 115, 116, 46, 84, 101, 115, 116, 85, 110, 112, 97, 99, 107, 101, 100, 69, 120, 116, 101,
    110, 115, 105, 111, 110, 115, 82, 25, 117, 110, 112, 97, 99, 107, 101, 100, 83, 102, 105, 120,
    101, 100, 54, 52, 69, 120, 116, 101, 110, 115, 105, 111, 110, 66, 2, 16, 0, 58, 103, 10, 24,
    117, 110, 112, 97, 99, 107, 101, 100, 95, 102, 108, 111, 97, 116, 95, 101, 120, 116, 101, 110,
    115, 105, 111, 110, 24, 100, 32, 3, 40, 2, 18, 41, 46, 112, 114, 111, 116, 111, 98, 117, 102,
    95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 85, 110, 112, 97, 99, 107,
    101, 100, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 22, 117, 110, 112, 97, 99, 107,
    101, 100, 70, 108, 111, 97, 116, 69, 120, 116, 101, 110, 115, 105, 111, 110, 66, 2, 16, 0, 58,
    105, 10, 25, 117, 110, 112, 97, 99, 107, 101, 100, 95, 100, 111, 117, 98, 108, 101, 95, 101,
    120, 116, 101, 110, 115, 105, 111, 110, 24, 101, 32, 3, 40, 1, 18, 41, 46, 112, 114, 111, 116,
    111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 85, 110,
    112, 97, 99, 107, 101, 100, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 23, 117, 110,
    112, 97, 99, 107, 101, 100, 68, 111, 117, 98, 108, 101, 69, 120, 116, 101, 110, 115, 105, 111,
    110, 66, 2, 16, 0, 58, 101, 10, 23, 117, 110, 112, 97, 99, 107, 101, 100, 95, 98, 111, 111,
    108, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 102, 32, 3, 40, 8, 18, 41, 46, 112,
    114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115,
    116, 85, 110, 112, 97, 99, 107, 101, 100, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82,
    21, 117, 110, 112, 97, 99, 107, 101, 100, 66, 111, 111, 108, 69, 120, 116, 101, 110, 115, 105,
    111, 110, 66, 2, 16, 0, 58, 133, 1, 10, 23, 117, 110, 112, 97, 99, 107, 101, 100, 95, 101, 110,
    117, 109, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 103, 32, 3, 40, 14, 50, 30, 46,
    112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 70, 111,
    114, 101, 105, 103, 110, 69, 110, 117, 109, 18, 41, 46, 112, 114, 111, 116, 111, 98, 117, 102,
    95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 85, 110, 112, 97, 99, 107,
    101, 100, 69, 120, 116, 101, 110, 115, 105, 111, 110, 115, 82, 21, 117, 110, 112, 97, 99, 107,
    101, 100, 69, 110, 117, 109, 69, 120, 116, 101, 110, 115, 105, 111, 110, 66, 2, 16, 0, 58, 114,
    10, 14, 116, 101, 115, 116, 95, 97, 108, 108, 95, 116, 121, 112, 101, 115, 24, 224, 170, 255,
    255, 1, 32, 1, 40, 11, 50, 31, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105,
    116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 18, 39,
    46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84,
    101, 115, 116, 72, 117, 103, 101, 70, 105, 101, 108, 100, 78, 117, 109, 98, 101, 114, 115, 82,
    12, 116, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 58, 125, 10, 37, 116, 101, 115,
    116, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 95, 105, 110, 115, 105, 100, 101, 95,
    116, 97, 98, 108, 101, 95, 101, 120, 116, 101, 110, 115, 105, 111, 110, 24, 5, 32, 1, 40, 5,
    18, 43, 46, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116,
    46, 84, 101, 115, 116, 69, 120, 116, 101, 110, 115, 105, 111, 110, 73, 110, 115, 105, 100, 101,
    84, 97, 98, 108, 101, 82, 33, 116, 101, 115, 116, 69, 120, 116, 101, 110, 115, 105, 111, 110,
    73, 110, 115, 105, 100, 101, 84, 97, 98, 108, 101, 69, 120, 116, 101, 110, 115, 105, 111, 110,
    66, 29, 66, 13, 85, 110, 105, 116, 116, 101, 115, 116, 80, 114, 111, 116, 111, 72, 1, 128, 1,
    1, 136, 1, 1, 144, 1, 1, 248, 1, 1,
];
pub mod unittest_proto {
    pub fn file() -> &'static ::protrust::reflect::FileDescriptor<'static> {
        super::pool().find_file_by_name("unittest.proto").unwrap()
    }
    pub static OPTIONAL_INT32_EXTENSION: ::protrust::Extension<self::TestAllExtensions, i32, i32> =
        ::protrust::Extension::int32(8, 0);
    pub static OPTIONAL_INT64_EXTENSION: ::protrust::Extension<self::TestAllExtensions, i64, i64> =
        ::protrust::Extension::int64(16, 0);
    pub static OPTIONAL_UINT32_EXTENSION: ::protrust::Extension<self::TestAllExtensions, u32, u32> =
        ::protrust::Extension::uint32(24, 0);
    pub static OPTIONAL_UINT64_EXTENSION: ::protrust::Extension<self::TestAllExtensions, u64, u64> =
        ::protrust::Extension::uint64(32, 0);
    pub static OPTIONAL_SINT32_EXTENSION: ::protrust::Extension<self::TestAllExtensions, i32, i32> =
        ::protrust::Extension::sint32(40, 0);
    pub static OPTIONAL_SINT64_EXTENSION: ::protrust::Extension<self::TestAllExtensions, i64, i64> =
        ::protrust::Extension::sint64(48, 0);
    pub static OPTIONAL_FIXED32_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        u32,
        u32,
    > = ::protrust::Extension::fixed32(61, 0);
    pub static OPTIONAL_FIXED64_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        u64,
        u64,
    > = ::protrust::Extension::fixed64(65, 0);
    pub static OPTIONAL_SFIXED32_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        i32,
        i32,
    > = ::protrust::Extension::sfixed32(77, 0);
    pub static OPTIONAL_SFIXED64_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        i64,
        i64,
    > = ::protrust::Extension::sfixed64(81, 0);
    pub static OPTIONAL_FLOAT_EXTENSION: ::protrust::Extension<self::TestAllExtensions, f32, f32> =
        ::protrust::Extension::float(93, 0.0);
    pub static OPTIONAL_DOUBLE_EXTENSION: ::protrust::Extension<self::TestAllExtensions, f64, f64> =
        ::protrust::Extension::double(97, 0.0);
    pub static OPTIONAL_BOOL_EXTENSION: ::protrust::Extension<self::TestAllExtensions, bool, bool> =
        ::protrust::Extension::bool(104, false);
    pub static OPTIONAL_STRING_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        ::std::string::String,
        &'static str,
    > = ::protrust::Extension::string(114, "");
    pub static OPTIONAL_BYTES_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        ::std::vec::Vec<u8>,
        &'static [u8],
    > = ::protrust::Extension::bytes(122, &[]);
    pub static OPTIONALGROUP_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        self::OptionalGroup_extension,
        self::OptionalGroup_extension,
    > = ::protrust::Extension::group(131, 132);
    pub static OPTIONAL_NESTED_MESSAGE_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        self::test_all_types::NestedMessage,
        self::test_all_types::NestedMessage,
    > = ::protrust::Extension::message(146);
    pub static OPTIONAL_FOREIGN_MESSAGE_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        self::ForeignMessage,
        self::ForeignMessage,
    > = ::protrust::Extension::message(154);
    pub static OPTIONAL_IMPORT_MESSAGE_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        self::super::unittest_import_proto::ImportMessage,
        self::super::unittest_import_proto::ImportMessage,
    > = ::protrust::Extension::message(162);
    pub static OPTIONAL_NESTED_ENUM_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        ::protrust::EnumValue<self::test_all_types::NestedEnum>,
        ::protrust::EnumValue<self::test_all_types::NestedEnum>,
    > = ::protrust::Extension::enum_value(168, ::protrust::EnumValue::Undefined(0));
    pub static OPTIONAL_FOREIGN_ENUM_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        ::protrust::EnumValue<self::ForeignEnum>,
        ::protrust::EnumValue<self::ForeignEnum>,
    > = ::protrust::Extension::enum_value(176, ::protrust::EnumValue::Undefined(0));
    pub static OPTIONAL_IMPORT_ENUM_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>,
        ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>,
    > = ::protrust::Extension::enum_value(184, ::protrust::EnumValue::Undefined(0));
    pub static OPTIONAL_STRING_PIECE_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        ::std::string::String,
        &'static str,
    > = ::protrust::Extension::string(194, "");
    pub static OPTIONAL_CORD_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        ::std::string::String,
        &'static str,
    > = ::protrust::Extension::string(202, "");
    pub static OPTIONAL_PUBLIC_IMPORT_MESSAGE_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        self::super::unittest_import_public_proto::PublicImportMessage,
        self::super::unittest_import_public_proto::PublicImportMessage,
    > = ::protrust::Extension::message(210);
    pub static OPTIONAL_LAZY_MESSAGE_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        self::test_all_types::NestedMessage,
        self::test_all_types::NestedMessage,
    > = ::protrust::Extension::message(218);
    pub static REPEATED_INT32_EXTENSION: ::protrust::RepeatedExtension<
        self::TestAllExtensions,
        i32,
    > = ::protrust::RepeatedExtension::int32(248);
    pub static REPEATED_INT64_EXTENSION: ::protrust::RepeatedExtension<
        self::TestAllExtensions,
        i64,
    > = ::protrust::RepeatedExtension::int64(256);
    pub static REPEATED_UINT32_EXTENSION: ::protrust::RepeatedExtension<
        self::TestAllExtensions,
        u32,
    > = ::protrust::RepeatedExtension::uint32(264);
    pub static REPEATED_UINT64_EXTENSION: ::protrust::RepeatedExtension<
        self::TestAllExtensions,
        u64,
    > = ::protrust::RepeatedExtension::uint64(272);
    pub static REPEATED_SINT32_EXTENSION: ::protrust::RepeatedExtension<
        self::TestAllExtensions,
        i32,
    > = ::protrust::RepeatedExtension::sint32(280);
    pub static REPEATED_SINT64_EXTENSION: ::protrust::RepeatedExtension<
        self::TestAllExtensions,
        i64,
    > = ::protrust::RepeatedExtension::sint64(288);
    pub static REPEATED_FIXED32_EXTENSION: ::protrust::RepeatedExtension<
        self::TestAllExtensions,
        u32,
    > = ::protrust::RepeatedExtension::fixed32(301);
    pub static REPEATED_FIXED64_EXTENSION: ::protrust::RepeatedExtension<
        self::TestAllExtensions,
        u64,
    > = ::protrust::RepeatedExtension::fixed64(305);
    pub static REPEATED_SFIXED32_EXTENSION: ::protrust::RepeatedExtension<
        self::TestAllExtensions,
        i32,
    > = ::protrust::RepeatedExtension::sfixed32(317);
    pub static REPEATED_SFIXED64_EXTENSION: ::protrust::RepeatedExtension<
        self::TestAllExtensions,
        i64,
    > = ::protrust::RepeatedExtension::sfixed64(321);
    pub static REPEATED_FLOAT_EXTENSION: ::protrust::RepeatedExtension<
        self::TestAllExtensions,
        f32,
    > = ::protrust::RepeatedExtension::float(333);
    pub static REPEATED_DOUBLE_EXTENSION: ::protrust::RepeatedExtension<
        self::TestAllExtensions,
        f64,
    > = ::protrust::RepeatedExtension::double(337);
    pub static REPEATED_BOOL_EXTENSION: ::protrust::RepeatedExtension<
        self::TestAllExtensions,
        bool,
    > = ::protrust::RepeatedExtension::bool(344);
    pub static REPEATED_STRING_EXTENSION: ::protrust::RepeatedExtension<
        self::TestAllExtensions,
        ::std::string::String,
    > = ::protrust::RepeatedExtension::string(354);
    pub static REPEATED_BYTES_EXTENSION: ::protrust::RepeatedExtension<
        self::TestAllExtensions,
        ::std::vec::Vec<u8>,
    > = ::protrust::RepeatedExtension::bytes(362);
    pub static REPEATEDGROUP_EXTENSION: ::protrust::RepeatedExtension<
        self::TestAllExtensions,
        self::RepeatedGroup_extension,
    > = ::protrust::RepeatedExtension::group(371, 372);
    pub static REPEATED_NESTED_MESSAGE_EXTENSION: ::protrust::RepeatedExtension<
        self::TestAllExtensions,
        self::test_all_types::NestedMessage,
    > = ::protrust::RepeatedExtension::message(386);
    pub static REPEATED_FOREIGN_MESSAGE_EXTENSION: ::protrust::RepeatedExtension<
        self::TestAllExtensions,
        self::ForeignMessage,
    > = ::protrust::RepeatedExtension::message(394);
    pub static REPEATED_IMPORT_MESSAGE_EXTENSION: ::protrust::RepeatedExtension<
        self::TestAllExtensions,
        self::super::unittest_import_proto::ImportMessage,
    > = ::protrust::RepeatedExtension::message(402);
    pub static REPEATED_NESTED_ENUM_EXTENSION: ::protrust::RepeatedExtension<
        self::TestAllExtensions,
        ::protrust::EnumValue<self::test_all_types::NestedEnum>,
    > = ::protrust::RepeatedExtension::enum_value(408);
    pub static REPEATED_FOREIGN_ENUM_EXTENSION: ::protrust::RepeatedExtension<
        self::TestAllExtensions,
        ::protrust::EnumValue<self::ForeignEnum>,
    > = ::protrust::RepeatedExtension::enum_value(416);
    pub static REPEATED_IMPORT_ENUM_EXTENSION: ::protrust::RepeatedExtension<
        self::TestAllExtensions,
        ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>,
    > = ::protrust::RepeatedExtension::enum_value(424);
    pub static REPEATED_STRING_PIECE_EXTENSION: ::protrust::RepeatedExtension<
        self::TestAllExtensions,
        ::std::string::String,
    > = ::protrust::RepeatedExtension::string(434);
    pub static REPEATED_CORD_EXTENSION: ::protrust::RepeatedExtension<
        self::TestAllExtensions,
        ::std::string::String,
    > = ::protrust::RepeatedExtension::string(442);
    pub static REPEATED_LAZY_MESSAGE_EXTENSION: ::protrust::RepeatedExtension<
        self::TestAllExtensions,
        self::test_all_types::NestedMessage,
    > = ::protrust::RepeatedExtension::message(458);
    pub static DEFAULT_INT32_EXTENSION: ::protrust::Extension<self::TestAllExtensions, i32, i32> =
        ::protrust::Extension::int32(488, 41);
    pub static DEFAULT_INT64_EXTENSION: ::protrust::Extension<self::TestAllExtensions, i64, i64> =
        ::protrust::Extension::int64(496, 42);
    pub static DEFAULT_UINT32_EXTENSION: ::protrust::Extension<self::TestAllExtensions, u32, u32> =
        ::protrust::Extension::uint32(504, 43);
    pub static DEFAULT_UINT64_EXTENSION: ::protrust::Extension<self::TestAllExtensions, u64, u64> =
        ::protrust::Extension::uint64(512, 44);
    pub static DEFAULT_SINT32_EXTENSION: ::protrust::Extension<self::TestAllExtensions, i32, i32> =
        ::protrust::Extension::sint32(520, -45);
    pub static DEFAULT_SINT64_EXTENSION: ::protrust::Extension<self::TestAllExtensions, i64, i64> =
        ::protrust::Extension::sint64(528, 46);
    pub static DEFAULT_FIXED32_EXTENSION: ::protrust::Extension<self::TestAllExtensions, u32, u32> =
        ::protrust::Extension::fixed32(541, 47);
    pub static DEFAULT_FIXED64_EXTENSION: ::protrust::Extension<self::TestAllExtensions, u64, u64> =
        ::protrust::Extension::fixed64(545, 48);
    pub static DEFAULT_SFIXED32_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        i32,
        i32,
    > = ::protrust::Extension::sfixed32(557, 49);
    pub static DEFAULT_SFIXED64_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        i64,
        i64,
    > = ::protrust::Extension::sfixed64(561, -50);
    pub static DEFAULT_FLOAT_EXTENSION: ::protrust::Extension<self::TestAllExtensions, f32, f32> =
        ::protrust::Extension::float(573, 51.5);
    pub static DEFAULT_DOUBLE_EXTENSION: ::protrust::Extension<self::TestAllExtensions, f64, f64> =
        ::protrust::Extension::double(577, 52000.0);
    pub static DEFAULT_BOOL_EXTENSION: ::protrust::Extension<self::TestAllExtensions, bool, bool> =
        ::protrust::Extension::bool(584, true);
    pub static DEFAULT_STRING_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        ::std::string::String,
        &'static str,
    > = ::protrust::Extension::string(594, "hello");
    pub static DEFAULT_BYTES_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        ::std::vec::Vec<u8>,
        &'static [u8],
    > = ::protrust::Extension::bytes(602, &[119, 111, 114, 108, 100]);
    pub static DEFAULT_NESTED_ENUM_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        ::protrust::EnumValue<self::test_all_types::NestedEnum>,
        ::protrust::EnumValue<self::test_all_types::NestedEnum>,
    > = ::protrust::Extension::enum_value(
        648,
        ::protrust::EnumValue::Defined(self::test_all_types::NestedEnum::Bar),
    );
    pub static DEFAULT_FOREIGN_ENUM_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        ::protrust::EnumValue<self::ForeignEnum>,
        ::protrust::EnumValue<self::ForeignEnum>,
    > = ::protrust::Extension::enum_value(
        656,
        ::protrust::EnumValue::Defined(self::ForeignEnum::ForeignBar),
    );
    pub static DEFAULT_IMPORT_ENUM_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>,
        ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>,
    > = ::protrust::Extension::enum_value(
        664,
        ::protrust::EnumValue::Defined(self::super::unittest_import_proto::ImportEnum::ImportBar),
    );
    pub static DEFAULT_STRING_PIECE_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        ::std::string::String,
        &'static str,
    > = ::protrust::Extension::string(674, "abc");
    pub static DEFAULT_CORD_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        ::std::string::String,
        &'static str,
    > = ::protrust::Extension::string(682, "123");
    pub static ONEOF_UINT32_EXTENSION: ::protrust::Extension<self::TestAllExtensions, u32, u32> =
        ::protrust::Extension::uint32(888, 0);
    pub static ONEOF_NESTED_MESSAGE_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        self::test_all_types::NestedMessage,
        self::test_all_types::NestedMessage,
    > = ::protrust::Extension::message(898);
    pub static ONEOF_STRING_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        ::std::string::String,
        &'static str,
    > = ::protrust::Extension::string(906, "");
    pub static ONEOF_BYTES_EXTENSION: ::protrust::Extension<
        self::TestAllExtensions,
        ::std::vec::Vec<u8>,
        &'static [u8],
    > = ::protrust::Extension::bytes(914, &[]);
    pub static MY_EXTENSION_STRING: ::protrust::Extension<
        self::TestFieldOrderings,
        ::std::string::String,
        &'static str,
    > = ::protrust::Extension::string(402, "");
    pub static MY_EXTENSION_INT: ::protrust::Extension<self::TestFieldOrderings, i32, i32> =
        ::protrust::Extension::int32(40, 0);
    pub static PACKED_INT32_EXTENSION: ::protrust::RepeatedExtension<
        self::TestPackedExtensions,
        i32,
    > = ::protrust::RepeatedExtension::int32(722);
    pub static PACKED_INT64_EXTENSION: ::protrust::RepeatedExtension<
        self::TestPackedExtensions,
        i64,
    > = ::protrust::RepeatedExtension::int64(730);
    pub static PACKED_UINT32_EXTENSION: ::protrust::RepeatedExtension<
        self::TestPackedExtensions,
        u32,
    > = ::protrust::RepeatedExtension::uint32(738);
    pub static PACKED_UINT64_EXTENSION: ::protrust::RepeatedExtension<
        self::TestPackedExtensions,
        u64,
    > = ::protrust::RepeatedExtension::uint64(746);
    pub static PACKED_SINT32_EXTENSION: ::protrust::RepeatedExtension<
        self::TestPackedExtensions,
        i32,
    > = ::protrust::RepeatedExtension::sint32(754);
    pub static PACKED_SINT64_EXTENSION: ::protrust::RepeatedExtension<
        self::TestPackedExtensions,
        i64,
    > = ::protrust::RepeatedExtension::sint64(762);
    pub static PACKED_FIXED32_EXTENSION: ::protrust::RepeatedExtension<
        self::TestPackedExtensions,
        u32,
    > = ::protrust::RepeatedExtension::fixed32(770);
    pub static PACKED_FIXED64_EXTENSION: ::protrust::RepeatedExtension<
        self::TestPackedExtensions,
        u64,
    > = ::protrust::RepeatedExtension::fixed64(778);
    pub static PACKED_SFIXED32_EXTENSION: ::protrust::RepeatedExtension<
        self::TestPackedExtensions,
        i32,
    > = ::protrust::RepeatedExtension::sfixed32(786);
    pub static PACKED_SFIXED64_EXTENSION: ::protrust::RepeatedExtension<
        self::TestPackedExtensions,
        i64,
    > = ::protrust::RepeatedExtension::sfixed64(794);
    pub static PACKED_FLOAT_EXTENSION: ::protrust::RepeatedExtension<
        self::TestPackedExtensions,
        f32,
    > = ::protrust::RepeatedExtension::float(802);
    pub static PACKED_DOUBLE_EXTENSION: ::protrust::RepeatedExtension<
        self::TestPackedExtensions,
        f64,
    > = ::protrust::RepeatedExtension::double(810);
    pub static PACKED_BOOL_EXTENSION: ::protrust::RepeatedExtension<
        self::TestPackedExtensions,
        bool,
    > = ::protrust::RepeatedExtension::bool(818);
    pub static PACKED_ENUM_EXTENSION: ::protrust::RepeatedExtension<
        self::TestPackedExtensions,
        ::protrust::EnumValue<self::ForeignEnum>,
    > = ::protrust::RepeatedExtension::enum_value(826);
    pub static UNPACKED_INT32_EXTENSION: ::protrust::RepeatedExtension<
        self::TestUnpackedExtensions,
        i32,
    > = ::protrust::RepeatedExtension::int32(720);
    pub static UNPACKED_INT64_EXTENSION: ::protrust::RepeatedExtension<
        self::TestUnpackedExtensions,
        i64,
    > = ::protrust::RepeatedExtension::int64(728);
    pub static UNPACKED_UINT32_EXTENSION: ::protrust::RepeatedExtension<
        self::TestUnpackedExtensions,
        u32,
    > = ::protrust::RepeatedExtension::uint32(736);
    pub static UNPACKED_UINT64_EXTENSION: ::protrust::RepeatedExtension<
        self::TestUnpackedExtensions,
        u64,
    > = ::protrust::RepeatedExtension::uint64(744);
    pub static UNPACKED_SINT32_EXTENSION: ::protrust::RepeatedExtension<
        self::TestUnpackedExtensions,
        i32,
    > = ::protrust::RepeatedExtension::sint32(752);
    pub static UNPACKED_SINT64_EXTENSION: ::protrust::RepeatedExtension<
        self::TestUnpackedExtensions,
        i64,
    > = ::protrust::RepeatedExtension::sint64(760);
    pub static UNPACKED_FIXED32_EXTENSION: ::protrust::RepeatedExtension<
        self::TestUnpackedExtensions,
        u32,
    > = ::protrust::RepeatedExtension::fixed32(773);
    pub static UNPACKED_FIXED64_EXTENSION: ::protrust::RepeatedExtension<
        self::TestUnpackedExtensions,
        u64,
    > = ::protrust::RepeatedExtension::fixed64(777);
    pub static UNPACKED_SFIXED32_EXTENSION: ::protrust::RepeatedExtension<
        self::TestUnpackedExtensions,
        i32,
    > = ::protrust::RepeatedExtension::sfixed32(789);
    pub static UNPACKED_SFIXED64_EXTENSION: ::protrust::RepeatedExtension<
        self::TestUnpackedExtensions,
        i64,
    > = ::protrust::RepeatedExtension::sfixed64(793);
    pub static UNPACKED_FLOAT_EXTENSION: ::protrust::RepeatedExtension<
        self::TestUnpackedExtensions,
        f32,
    > = ::protrust::RepeatedExtension::float(805);
    pub static UNPACKED_DOUBLE_EXTENSION: ::protrust::RepeatedExtension<
        self::TestUnpackedExtensions,
        f64,
    > = ::protrust::RepeatedExtension::double(809);
    pub static UNPACKED_BOOL_EXTENSION: ::protrust::RepeatedExtension<
        self::TestUnpackedExtensions,
        bool,
    > = ::protrust::RepeatedExtension::bool(816);
    pub static UNPACKED_ENUM_EXTENSION: ::protrust::RepeatedExtension<
        self::TestUnpackedExtensions,
        ::protrust::EnumValue<self::ForeignEnum>,
    > = ::protrust::RepeatedExtension::enum_value(824);
    pub static TEST_ALL_TYPES: ::protrust::Extension<
        self::TestHugeFieldNumbers,
        self::TestAllTypes,
        self::TestAllTypes,
    > = ::protrust::Extension::message(4294880002);
    pub static TEST_EXTENSION_INSIDE_TABLE_EXTENSION: ::protrust::Extension<
        self::TestExtensionInsideTable,
        i32,
        i32,
    > = ::protrust::Extension::int32(40, 0);
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestAllTypes {
        optional_int32: ::std::option::Option<i32>,
        optional_int64: ::std::option::Option<i64>,
        optional_uint32: ::std::option::Option<u32>,
        optional_uint64: ::std::option::Option<u64>,
        optional_sint32: ::std::option::Option<i32>,
        optional_sint64: ::std::option::Option<i64>,
        optional_fixed32: ::std::option::Option<u32>,
        optional_fixed64: ::std::option::Option<u64>,
        optional_sfixed32: ::std::option::Option<i32>,
        optional_sfixed64: ::std::option::Option<i64>,
        optional_float: ::std::option::Option<f32>,
        optional_double: ::std::option::Option<f64>,
        optional_bool: ::std::option::Option<bool>,
        optional_string: ::std::option::Option<::std::string::String>,
        optional_bytes: ::std::option::Option<::std::vec::Vec<u8>>,
        optionalgroup:
            ::std::option::Option<::std::boxed::Box<self::test_all_types::OptionalGroup>>,
        optional_nested_message:
            ::std::option::Option<::std::boxed::Box<self::test_all_types::NestedMessage>>,
        optional_foreign_message: ::std::option::Option<::std::boxed::Box<self::ForeignMessage>>,
        optional_import_message: ::std::option::Option<
            ::std::boxed::Box<self::super::unittest_import_proto::ImportMessage>,
        >,
        optional_nested_enum:
            ::std::option::Option<::protrust::EnumValue<self::test_all_types::NestedEnum>>,
        optional_foreign_enum: ::std::option::Option<::protrust::EnumValue<self::ForeignEnum>>,
        optional_import_enum: ::std::option::Option<
            ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>,
        >,
        optional_string_piece: ::std::option::Option<::std::string::String>,
        optional_cord: ::std::option::Option<::std::string::String>,
        optional_public_import_message: ::std::option::Option<
            ::std::boxed::Box<self::super::unittest_import_public_proto::PublicImportMessage>,
        >,
        optional_lazy_message:
            ::std::option::Option<::std::boxed::Box<self::test_all_types::NestedMessage>>,
        repeated_int32: ::protrust::collections::RepeatedField<i32>,
        repeated_int64: ::protrust::collections::RepeatedField<i64>,
        repeated_uint32: ::protrust::collections::RepeatedField<u32>,
        repeated_uint64: ::protrust::collections::RepeatedField<u64>,
        repeated_sint32: ::protrust::collections::RepeatedField<i32>,
        repeated_sint64: ::protrust::collections::RepeatedField<i64>,
        repeated_fixed32: ::protrust::collections::RepeatedField<u32>,
        repeated_fixed64: ::protrust::collections::RepeatedField<u64>,
        repeated_sfixed32: ::protrust::collections::RepeatedField<i32>,
        repeated_sfixed64: ::protrust::collections::RepeatedField<i64>,
        repeated_float: ::protrust::collections::RepeatedField<f32>,
        repeated_double: ::protrust::collections::RepeatedField<f64>,
        repeated_bool: ::protrust::collections::RepeatedField<bool>,
        repeated_string: ::protrust::collections::RepeatedField<::std::string::String>,
        repeated_bytes: ::protrust::collections::RepeatedField<::std::vec::Vec<u8>>,
        repeatedgroup: ::protrust::collections::RepeatedField<self::test_all_types::RepeatedGroup>,
        repeated_nested_message:
            ::protrust::collections::RepeatedField<self::test_all_types::NestedMessage>,
        repeated_foreign_message: ::protrust::collections::RepeatedField<self::ForeignMessage>,
        repeated_import_message: ::protrust::collections::RepeatedField<
            self::super::unittest_import_proto::ImportMessage,
        >,
        repeated_nested_enum: ::protrust::collections::RepeatedField<
            ::protrust::EnumValue<self::test_all_types::NestedEnum>,
        >,
        repeated_foreign_enum:
            ::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>>,
        repeated_import_enum: ::protrust::collections::RepeatedField<
            ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>,
        >,
        repeated_string_piece: ::protrust::collections::RepeatedField<::std::string::String>,
        repeated_cord: ::protrust::collections::RepeatedField<::std::string::String>,
        repeated_lazy_message:
            ::protrust::collections::RepeatedField<self::test_all_types::NestedMessage>,
        default_int32: ::std::option::Option<i32>,
        default_int64: ::std::option::Option<i64>,
        default_uint32: ::std::option::Option<u32>,
        default_uint64: ::std::option::Option<u64>,
        default_sint32: ::std::option::Option<i32>,
        default_sint64: ::std::option::Option<i64>,
        default_fixed32: ::std::option::Option<u32>,
        default_fixed64: ::std::option::Option<u64>,
        default_sfixed32: ::std::option::Option<i32>,
        default_sfixed64: ::std::option::Option<i64>,
        default_float: ::std::option::Option<f32>,
        default_double: ::std::option::Option<f64>,
        default_bool: ::std::option::Option<bool>,
        default_string: ::std::option::Option<::std::string::String>,
        default_bytes: ::std::option::Option<::std::vec::Vec<u8>>,
        default_nested_enum:
            ::std::option::Option<::protrust::EnumValue<self::test_all_types::NestedEnum>>,
        default_foreign_enum: ::std::option::Option<::protrust::EnumValue<self::ForeignEnum>>,
        default_import_enum: ::std::option::Option<
            ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>,
        >,
        default_string_piece: ::std::option::Option<::std::string::String>,
        default_cord: ::std::option::Option<::std::string::String>,
        oneof_field: self::test_all_types::OneofField,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestAllTypes {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.set_optional_int32(input.read_int32()?),
                    16 | 18 => self.set_optional_int64(input.read_int64()?),
                    24 | 26 => self.set_optional_uint32(input.read_uint32()?),
                    32 | 34 => self.set_optional_uint64(input.read_uint64()?),
                    40 | 42 => self.set_optional_sint32(input.read_sint32()?),
                    48 | 50 => self.set_optional_sint64(input.read_sint64()?),
                    61 | 58 => self.set_optional_fixed32(input.read_fixed32()?),
                    65 | 66 => self.set_optional_fixed64(input.read_fixed64()?),
                    77 | 74 => self.set_optional_sfixed32(input.read_sfixed32()?),
                    81 | 82 => self.set_optional_sfixed64(input.read_sfixed64()?),
                    93 | 90 => self.set_optional_float(input.read_float()?),
                    97 | 98 => self.set_optional_double(input.read_double()?),
                    104 | 106 => self.set_optional_bool(input.read_bool()?),
                    114 => self.set_optional_string(input.read_string()?),
                    122 => self.set_optional_bytes(input.read_bytes()?),
                    131 => input.read_group(self.optionalgroup_mut())?,
                    146 => input.read_message(self.optional_nested_message_mut())?,
                    154 => input.read_message(self.optional_foreign_message_mut())?,
                    162 => input.read_message(self.optional_import_message_mut())?,
                    168 | 170 => self.set_optional_nested_enum(input.read_enum_value()?),
                    176 | 178 => self.set_optional_foreign_enum(input.read_enum_value()?),
                    184 | 186 => self.set_optional_import_enum(input.read_enum_value()?),
                    194 => self.set_optional_string_piece(input.read_string()?),
                    202 => self.set_optional_cord(input.read_string()?),
                    210 => input.read_message(self.optional_public_import_message_mut())?,
                    218 => input.read_message(self.optional_lazy_message_mut())?,
                    248 | 250 => self
                        .repeated_int32
                        .add_entries(input, &self::test_all_types::REPEATED_INT32_CODEC)?,
                    256 | 258 => self
                        .repeated_int64
                        .add_entries(input, &self::test_all_types::REPEATED_INT64_CODEC)?,
                    264 | 266 => self
                        .repeated_uint32
                        .add_entries(input, &self::test_all_types::REPEATED_UINT32_CODEC)?,
                    272 | 274 => self
                        .repeated_uint64
                        .add_entries(input, &self::test_all_types::REPEATED_UINT64_CODEC)?,
                    280 | 282 => self
                        .repeated_sint32
                        .add_entries(input, &self::test_all_types::REPEATED_SINT32_CODEC)?,
                    288 | 290 => self
                        .repeated_sint64
                        .add_entries(input, &self::test_all_types::REPEATED_SINT64_CODEC)?,
                    301 | 298 => self
                        .repeated_fixed32
                        .add_entries(input, &self::test_all_types::REPEATED_FIXED32_CODEC)?,
                    305 | 306 => self
                        .repeated_fixed64
                        .add_entries(input, &self::test_all_types::REPEATED_FIXED64_CODEC)?,
                    317 | 314 => self
                        .repeated_sfixed32
                        .add_entries(input, &self::test_all_types::REPEATED_SFIXED32_CODEC)?,
                    321 | 322 => self
                        .repeated_sfixed64
                        .add_entries(input, &self::test_all_types::REPEATED_SFIXED64_CODEC)?,
                    333 | 330 => self
                        .repeated_float
                        .add_entries(input, &self::test_all_types::REPEATED_FLOAT_CODEC)?,
                    337 | 338 => self
                        .repeated_double
                        .add_entries(input, &self::test_all_types::REPEATED_DOUBLE_CODEC)?,
                    344 | 346 => self
                        .repeated_bool
                        .add_entries(input, &self::test_all_types::REPEATED_BOOL_CODEC)?,
                    354 => self
                        .repeated_string
                        .add_entries(input, &self::test_all_types::REPEATED_STRING_CODEC)?,
                    362 => self
                        .repeated_bytes
                        .add_entries(input, &self::test_all_types::REPEATED_BYTES_CODEC)?,
                    371 => self
                        .repeatedgroup
                        .add_entries(input, &self::test_all_types::REPEATEDGROUP_CODEC)?,
                    386 => self
                        .repeated_nested_message
                        .add_entries(input, &self::test_all_types::REPEATED_NESTED_MESSAGE_CODEC)?,
                    394 => self.repeated_foreign_message.add_entries(
                        input,
                        &self::test_all_types::REPEATED_FOREIGN_MESSAGE_CODEC,
                    )?,
                    402 => self
                        .repeated_import_message
                        .add_entries(input, &self::test_all_types::REPEATED_IMPORT_MESSAGE_CODEC)?,
                    408 | 410 => self
                        .repeated_nested_enum
                        .add_entries(input, &self::test_all_types::REPEATED_NESTED_ENUM_CODEC)?,
                    416 | 418 => self
                        .repeated_foreign_enum
                        .add_entries(input, &self::test_all_types::REPEATED_FOREIGN_ENUM_CODEC)?,
                    424 | 426 => self
                        .repeated_import_enum
                        .add_entries(input, &self::test_all_types::REPEATED_IMPORT_ENUM_CODEC)?,
                    434 => self
                        .repeated_string_piece
                        .add_entries(input, &self::test_all_types::REPEATED_STRING_PIECE_CODEC)?,
                    442 => self
                        .repeated_cord
                        .add_entries(input, &self::test_all_types::REPEATED_CORD_CODEC)?,
                    458 => self
                        .repeated_lazy_message
                        .add_entries(input, &self::test_all_types::REPEATED_LAZY_MESSAGE_CODEC)?,
                    488 | 490 => self.set_default_int32(input.read_int32()?),
                    496 | 498 => self.set_default_int64(input.read_int64()?),
                    504 | 506 => self.set_default_uint32(input.read_uint32()?),
                    512 | 514 => self.set_default_uint64(input.read_uint64()?),
                    520 | 522 => self.set_default_sint32(input.read_sint32()?),
                    528 | 530 => self.set_default_sint64(input.read_sint64()?),
                    541 | 538 => self.set_default_fixed32(input.read_fixed32()?),
                    545 | 546 => self.set_default_fixed64(input.read_fixed64()?),
                    557 | 554 => self.set_default_sfixed32(input.read_sfixed32()?),
                    561 | 562 => self.set_default_sfixed64(input.read_sfixed64()?),
                    573 | 570 => self.set_default_float(input.read_float()?),
                    577 | 578 => self.set_default_double(input.read_double()?),
                    584 | 586 => self.set_default_bool(input.read_bool()?),
                    594 => self.set_default_string(input.read_string()?),
                    602 => self.set_default_bytes(input.read_bytes()?),
                    648 | 650 => self.set_default_nested_enum(input.read_enum_value()?),
                    656 | 658 => self.set_default_foreign_enum(input.read_enum_value()?),
                    664 | 666 => self.set_default_import_enum(input.read_enum_value()?),
                    674 => self.set_default_string_piece(input.read_string()?),
                    682 => self.set_default_cord(input.read_string()?),
                    888 | 890 => self.set_oneof_uint32(input.read_uint32()?),
                    898 => input.read_message(self.oneof_nested_message_mut())?,
                    906 => self.set_oneof_string(input.read_string()?),
                    914 => self.set_oneof_bytes(input.read_bytes()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(optional_int32) = self.optional_int32_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*optional_int32);
            }
            if let ::std::option::Option::Some(optional_int64) = self.optional_int64_option() {
                size += 1;
                size += ::protrust::io::sizes::int64(*optional_int64);
            }
            if let ::std::option::Option::Some(optional_uint32) = self.optional_uint32_option() {
                size += 1;
                size += ::protrust::io::sizes::uint32(*optional_uint32);
            }
            if let ::std::option::Option::Some(optional_uint64) = self.optional_uint64_option() {
                size += 1;
                size += ::protrust::io::sizes::uint64(*optional_uint64);
            }
            if let ::std::option::Option::Some(optional_sint32) = self.optional_sint32_option() {
                size += 1;
                size += ::protrust::io::sizes::sint32(*optional_sint32);
            }
            if let ::std::option::Option::Some(optional_sint64) = self.optional_sint64_option() {
                size += 1;
                size += ::protrust::io::sizes::sint64(*optional_sint64);
            }
            if let ::std::option::Option::Some(optional_fixed32) = self.optional_fixed32_option() {
                size += 1;
                size += ::protrust::io::sizes::fixed32(*optional_fixed32);
            }
            if let ::std::option::Option::Some(optional_fixed64) = self.optional_fixed64_option() {
                size += 1;
                size += ::protrust::io::sizes::fixed64(*optional_fixed64);
            }
            if let ::std::option::Option::Some(optional_sfixed32) = self.optional_sfixed32_option()
            {
                size += 1;
                size += ::protrust::io::sizes::sfixed32(*optional_sfixed32);
            }
            if let ::std::option::Option::Some(optional_sfixed64) = self.optional_sfixed64_option()
            {
                size += 1;
                size += ::protrust::io::sizes::sfixed64(*optional_sfixed64);
            }
            if let ::std::option::Option::Some(optional_float) = self.optional_float_option() {
                size += 1;
                size += ::protrust::io::sizes::float(*optional_float);
            }
            if let ::std::option::Option::Some(optional_double) = self.optional_double_option() {
                size += 1;
                size += ::protrust::io::sizes::double(*optional_double);
            }
            if let ::std::option::Option::Some(optional_bool) = self.optional_bool_option() {
                size += 1;
                size += ::protrust::io::sizes::bool(*optional_bool);
            }
            if let ::std::option::Option::Some(optional_string) = self.optional_string_option() {
                size += 1;
                size += ::protrust::io::sizes::string(optional_string);
            }
            if let ::std::option::Option::Some(optional_bytes) = self.optional_bytes_option() {
                size += 1;
                size += ::protrust::io::sizes::bytes(optional_bytes);
            }
            if let ::std::option::Option::Some(optionalgroup) = self.optionalgroup() {
                size += 2;
                size += ::protrust::io::sizes::group(optionalgroup);
                size += 2;
            }
            if let ::std::option::Option::Some(optional_nested_message) =
                self.optional_nested_message()
            {
                size += 2;
                size += ::protrust::io::sizes::message(optional_nested_message);
            }
            if let ::std::option::Option::Some(optional_foreign_message) =
                self.optional_foreign_message()
            {
                size += 2;
                size += ::protrust::io::sizes::message(optional_foreign_message);
            }
            if let ::std::option::Option::Some(optional_import_message) =
                self.optional_import_message()
            {
                size += 2;
                size += ::protrust::io::sizes::message(optional_import_message);
            }
            if let ::std::option::Option::Some(optional_nested_enum) =
                self.optional_nested_enum_option()
            {
                size += 2;
                size += ::protrust::io::sizes::enum_value(*optional_nested_enum);
            }
            if let ::std::option::Option::Some(optional_foreign_enum) =
                self.optional_foreign_enum_option()
            {
                size += 2;
                size += ::protrust::io::sizes::enum_value(*optional_foreign_enum);
            }
            if let ::std::option::Option::Some(optional_import_enum) =
                self.optional_import_enum_option()
            {
                size += 2;
                size += ::protrust::io::sizes::enum_value(*optional_import_enum);
            }
            if let ::std::option::Option::Some(optional_string_piece) =
                self.optional_string_piece_option()
            {
                size += 2;
                size += ::protrust::io::sizes::string(optional_string_piece);
            }
            if let ::std::option::Option::Some(optional_cord) = self.optional_cord_option() {
                size += 2;
                size += ::protrust::io::sizes::string(optional_cord);
            }
            if let ::std::option::Option::Some(optional_public_import_message) =
                self.optional_public_import_message()
            {
                size += 2;
                size += ::protrust::io::sizes::message(optional_public_import_message);
            }
            if let ::std::option::Option::Some(optional_lazy_message) = self.optional_lazy_message()
            {
                size += 2;
                size += ::protrust::io::sizes::message(optional_lazy_message);
            }
            size += self
                .repeated_int32()
                .calculate_size(&self::test_all_types::REPEATED_INT32_CODEC);
            size += self
                .repeated_int64()
                .calculate_size(&self::test_all_types::REPEATED_INT64_CODEC);
            size += self
                .repeated_uint32()
                .calculate_size(&self::test_all_types::REPEATED_UINT32_CODEC);
            size += self
                .repeated_uint64()
                .calculate_size(&self::test_all_types::REPEATED_UINT64_CODEC);
            size += self
                .repeated_sint32()
                .calculate_size(&self::test_all_types::REPEATED_SINT32_CODEC);
            size += self
                .repeated_sint64()
                .calculate_size(&self::test_all_types::REPEATED_SINT64_CODEC);
            size += self
                .repeated_fixed32()
                .calculate_size(&self::test_all_types::REPEATED_FIXED32_CODEC);
            size += self
                .repeated_fixed64()
                .calculate_size(&self::test_all_types::REPEATED_FIXED64_CODEC);
            size += self
                .repeated_sfixed32()
                .calculate_size(&self::test_all_types::REPEATED_SFIXED32_CODEC);
            size += self
                .repeated_sfixed64()
                .calculate_size(&self::test_all_types::REPEATED_SFIXED64_CODEC);
            size += self
                .repeated_float()
                .calculate_size(&self::test_all_types::REPEATED_FLOAT_CODEC);
            size += self
                .repeated_double()
                .calculate_size(&self::test_all_types::REPEATED_DOUBLE_CODEC);
            size += self
                .repeated_bool()
                .calculate_size(&self::test_all_types::REPEATED_BOOL_CODEC);
            size += self
                .repeated_string()
                .calculate_size(&self::test_all_types::REPEATED_STRING_CODEC);
            size += self
                .repeated_bytes()
                .calculate_size(&self::test_all_types::REPEATED_BYTES_CODEC);
            size += self
                .repeatedgroup()
                .calculate_size(&self::test_all_types::REPEATEDGROUP_CODEC);
            size += self
                .repeated_nested_message()
                .calculate_size(&self::test_all_types::REPEATED_NESTED_MESSAGE_CODEC);
            size += self
                .repeated_foreign_message()
                .calculate_size(&self::test_all_types::REPEATED_FOREIGN_MESSAGE_CODEC);
            size += self
                .repeated_import_message()
                .calculate_size(&self::test_all_types::REPEATED_IMPORT_MESSAGE_CODEC);
            size += self
                .repeated_nested_enum()
                .calculate_size(&self::test_all_types::REPEATED_NESTED_ENUM_CODEC);
            size += self
                .repeated_foreign_enum()
                .calculate_size(&self::test_all_types::REPEATED_FOREIGN_ENUM_CODEC);
            size += self
                .repeated_import_enum()
                .calculate_size(&self::test_all_types::REPEATED_IMPORT_ENUM_CODEC);
            size += self
                .repeated_string_piece()
                .calculate_size(&self::test_all_types::REPEATED_STRING_PIECE_CODEC);
            size += self
                .repeated_cord()
                .calculate_size(&self::test_all_types::REPEATED_CORD_CODEC);
            size += self
                .repeated_lazy_message()
                .calculate_size(&self::test_all_types::REPEATED_LAZY_MESSAGE_CODEC);
            if let ::std::option::Option::Some(default_int32) = self.default_int32_option() {
                size += 2;
                size += ::protrust::io::sizes::int32(*default_int32);
            }
            if let ::std::option::Option::Some(default_int64) = self.default_int64_option() {
                size += 2;
                size += ::protrust::io::sizes::int64(*default_int64);
            }
            if let ::std::option::Option::Some(default_uint32) = self.default_uint32_option() {
                size += 2;
                size += ::protrust::io::sizes::uint32(*default_uint32);
            }
            if let ::std::option::Option::Some(default_uint64) = self.default_uint64_option() {
                size += 2;
                size += ::protrust::io::sizes::uint64(*default_uint64);
            }
            if let ::std::option::Option::Some(default_sint32) = self.default_sint32_option() {
                size += 2;
                size += ::protrust::io::sizes::sint32(*default_sint32);
            }
            if let ::std::option::Option::Some(default_sint64) = self.default_sint64_option() {
                size += 2;
                size += ::protrust::io::sizes::sint64(*default_sint64);
            }
            if let ::std::option::Option::Some(default_fixed32) = self.default_fixed32_option() {
                size += 2;
                size += ::protrust::io::sizes::fixed32(*default_fixed32);
            }
            if let ::std::option::Option::Some(default_fixed64) = self.default_fixed64_option() {
                size += 2;
                size += ::protrust::io::sizes::fixed64(*default_fixed64);
            }
            if let ::std::option::Option::Some(default_sfixed32) = self.default_sfixed32_option() {
                size += 2;
                size += ::protrust::io::sizes::sfixed32(*default_sfixed32);
            }
            if let ::std::option::Option::Some(default_sfixed64) = self.default_sfixed64_option() {
                size += 2;
                size += ::protrust::io::sizes::sfixed64(*default_sfixed64);
            }
            if let ::std::option::Option::Some(default_float) = self.default_float_option() {
                size += 2;
                size += ::protrust::io::sizes::float(*default_float);
            }
            if let ::std::option::Option::Some(default_double) = self.default_double_option() {
                size += 2;
                size += ::protrust::io::sizes::double(*default_double);
            }
            if let ::std::option::Option::Some(default_bool) = self.default_bool_option() {
                size += 2;
                size += ::protrust::io::sizes::bool(*default_bool);
            }
            if let ::std::option::Option::Some(default_string) = self.default_string_option() {
                size += 2;
                size += ::protrust::io::sizes::string(default_string);
            }
            if let ::std::option::Option::Some(default_bytes) = self.default_bytes_option() {
                size += 2;
                size += ::protrust::io::sizes::bytes(default_bytes);
            }
            if let ::std::option::Option::Some(default_nested_enum) =
                self.default_nested_enum_option()
            {
                size += 2;
                size += ::protrust::io::sizes::enum_value(*default_nested_enum);
            }
            if let ::std::option::Option::Some(default_foreign_enum) =
                self.default_foreign_enum_option()
            {
                size += 2;
                size += ::protrust::io::sizes::enum_value(*default_foreign_enum);
            }
            if let ::std::option::Option::Some(default_import_enum) =
                self.default_import_enum_option()
            {
                size += 2;
                size += ::protrust::io::sizes::enum_value(*default_import_enum);
            }
            if let ::std::option::Option::Some(default_string_piece) =
                self.default_string_piece_option()
            {
                size += 2;
                size += ::protrust::io::sizes::string(default_string_piece);
            }
            if let ::std::option::Option::Some(default_cord) = self.default_cord_option() {
                size += 2;
                size += ::protrust::io::sizes::string(default_cord);
            }
            if let ::std::option::Option::Some(oneof_uint32) = self.oneof_uint32() {
                size += 2;
                size += ::protrust::io::sizes::uint32(*oneof_uint32);
            }
            if let ::std::option::Option::Some(oneof_nested_message) = self.oneof_nested_message() {
                size += 2;
                size += ::protrust::io::sizes::message(oneof_nested_message);
            }
            if let ::std::option::Option::Some(oneof_string) = self.oneof_string() {
                size += 2;
                size += ::protrust::io::sizes::string(oneof_string);
            }
            if let ::std::option::Option::Some(oneof_bytes) = self.oneof_bytes() {
                size += 2;
                size += ::protrust::io::sizes::bytes(oneof_bytes);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(optional_int32) = self.optional_int32_option() {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(*optional_int32)?;
            }
            if let ::std::option::Option::Some(optional_int64) = self.optional_int64_option() {
                output.write_raw_tag_bytes(&[16])?;
                output.write_int64(*optional_int64)?;
            }
            if let ::std::option::Option::Some(optional_uint32) = self.optional_uint32_option() {
                output.write_raw_tag_bytes(&[24])?;
                output.write_uint32(*optional_uint32)?;
            }
            if let ::std::option::Option::Some(optional_uint64) = self.optional_uint64_option() {
                output.write_raw_tag_bytes(&[32])?;
                output.write_uint64(*optional_uint64)?;
            }
            if let ::std::option::Option::Some(optional_sint32) = self.optional_sint32_option() {
                output.write_raw_tag_bytes(&[40])?;
                output.write_sint32(*optional_sint32)?;
            }
            if let ::std::option::Option::Some(optional_sint64) = self.optional_sint64_option() {
                output.write_raw_tag_bytes(&[48])?;
                output.write_sint64(*optional_sint64)?;
            }
            if let ::std::option::Option::Some(optional_fixed32) = self.optional_fixed32_option() {
                output.write_raw_tag_bytes(&[61])?;
                output.write_fixed32(*optional_fixed32)?;
            }
            if let ::std::option::Option::Some(optional_fixed64) = self.optional_fixed64_option() {
                output.write_raw_tag_bytes(&[65])?;
                output.write_fixed64(*optional_fixed64)?;
            }
            if let ::std::option::Option::Some(optional_sfixed32) = self.optional_sfixed32_option()
            {
                output.write_raw_tag_bytes(&[77])?;
                output.write_sfixed32(*optional_sfixed32)?;
            }
            if let ::std::option::Option::Some(optional_sfixed64) = self.optional_sfixed64_option()
            {
                output.write_raw_tag_bytes(&[81])?;
                output.write_sfixed64(*optional_sfixed64)?;
            }
            if let ::std::option::Option::Some(optional_float) = self.optional_float_option() {
                output.write_raw_tag_bytes(&[93])?;
                output.write_float(*optional_float)?;
            }
            if let ::std::option::Option::Some(optional_double) = self.optional_double_option() {
                output.write_raw_tag_bytes(&[97])?;
                output.write_double(*optional_double)?;
            }
            if let ::std::option::Option::Some(optional_bool) = self.optional_bool_option() {
                output.write_raw_tag_bytes(&[104])?;
                output.write_bool(*optional_bool)?;
            }
            if let ::std::option::Option::Some(optional_string) = self.optional_string_option() {
                output.write_raw_tag_bytes(&[114])?;
                output.write_string(optional_string)?;
            }
            if let ::std::option::Option::Some(optional_bytes) = self.optional_bytes_option() {
                output.write_raw_tag_bytes(&[122])?;
                output.write_bytes(optional_bytes)?;
            }
            if let ::std::option::Option::Some(optionalgroup) = self.optionalgroup() {
                output.write_raw_tag_bytes(&[131, 1])?;
                output.write_group(optionalgroup)?;
                output.write_raw_tag_bytes(&[132, 1])?;
            }
            if let ::std::option::Option::Some(optional_nested_message) =
                self.optional_nested_message()
            {
                output.write_raw_tag_bytes(&[146, 1])?;
                output.write_message(optional_nested_message)?;
            }
            if let ::std::option::Option::Some(optional_foreign_message) =
                self.optional_foreign_message()
            {
                output.write_raw_tag_bytes(&[154, 1])?;
                output.write_message(optional_foreign_message)?;
            }
            if let ::std::option::Option::Some(optional_import_message) =
                self.optional_import_message()
            {
                output.write_raw_tag_bytes(&[162, 1])?;
                output.write_message(optional_import_message)?;
            }
            if let ::std::option::Option::Some(optional_nested_enum) =
                self.optional_nested_enum_option()
            {
                output.write_raw_tag_bytes(&[168, 1])?;
                output.write_enum_value(*optional_nested_enum)?;
            }
            if let ::std::option::Option::Some(optional_foreign_enum) =
                self.optional_foreign_enum_option()
            {
                output.write_raw_tag_bytes(&[176, 1])?;
                output.write_enum_value(*optional_foreign_enum)?;
            }
            if let ::std::option::Option::Some(optional_import_enum) =
                self.optional_import_enum_option()
            {
                output.write_raw_tag_bytes(&[184, 1])?;
                output.write_enum_value(*optional_import_enum)?;
            }
            if let ::std::option::Option::Some(optional_string_piece) =
                self.optional_string_piece_option()
            {
                output.write_raw_tag_bytes(&[194, 1])?;
                output.write_string(optional_string_piece)?;
            }
            if let ::std::option::Option::Some(optional_cord) = self.optional_cord_option() {
                output.write_raw_tag_bytes(&[202, 1])?;
                output.write_string(optional_cord)?;
            }
            if let ::std::option::Option::Some(optional_public_import_message) =
                self.optional_public_import_message()
            {
                output.write_raw_tag_bytes(&[210, 1])?;
                output.write_message(optional_public_import_message)?;
            }
            if let ::std::option::Option::Some(optional_lazy_message) = self.optional_lazy_message()
            {
                output.write_raw_tag_bytes(&[218, 1])?;
                output.write_message(optional_lazy_message)?;
            }
            self.repeated_int32()
                .write_to(output, &self::test_all_types::REPEATED_INT32_CODEC)?;
            self.repeated_int64()
                .write_to(output, &self::test_all_types::REPEATED_INT64_CODEC)?;
            self.repeated_uint32()
                .write_to(output, &self::test_all_types::REPEATED_UINT32_CODEC)?;
            self.repeated_uint64()
                .write_to(output, &self::test_all_types::REPEATED_UINT64_CODEC)?;
            self.repeated_sint32()
                .write_to(output, &self::test_all_types::REPEATED_SINT32_CODEC)?;
            self.repeated_sint64()
                .write_to(output, &self::test_all_types::REPEATED_SINT64_CODEC)?;
            self.repeated_fixed32()
                .write_to(output, &self::test_all_types::REPEATED_FIXED32_CODEC)?;
            self.repeated_fixed64()
                .write_to(output, &self::test_all_types::REPEATED_FIXED64_CODEC)?;
            self.repeated_sfixed32()
                .write_to(output, &self::test_all_types::REPEATED_SFIXED32_CODEC)?;
            self.repeated_sfixed64()
                .write_to(output, &self::test_all_types::REPEATED_SFIXED64_CODEC)?;
            self.repeated_float()
                .write_to(output, &self::test_all_types::REPEATED_FLOAT_CODEC)?;
            self.repeated_double()
                .write_to(output, &self::test_all_types::REPEATED_DOUBLE_CODEC)?;
            self.repeated_bool()
                .write_to(output, &self::test_all_types::REPEATED_BOOL_CODEC)?;
            self.repeated_string()
                .write_to(output, &self::test_all_types::REPEATED_STRING_CODEC)?;
            self.repeated_bytes()
                .write_to(output, &self::test_all_types::REPEATED_BYTES_CODEC)?;
            self.repeatedgroup()
                .write_to(output, &self::test_all_types::REPEATEDGROUP_CODEC)?;
            self.repeated_nested_message()
                .write_to(output, &self::test_all_types::REPEATED_NESTED_MESSAGE_CODEC)?;
            self.repeated_foreign_message().write_to(
                output,
                &self::test_all_types::REPEATED_FOREIGN_MESSAGE_CODEC,
            )?;
            self.repeated_import_message()
                .write_to(output, &self::test_all_types::REPEATED_IMPORT_MESSAGE_CODEC)?;
            self.repeated_nested_enum()
                .write_to(output, &self::test_all_types::REPEATED_NESTED_ENUM_CODEC)?;
            self.repeated_foreign_enum()
                .write_to(output, &self::test_all_types::REPEATED_FOREIGN_ENUM_CODEC)?;
            self.repeated_import_enum()
                .write_to(output, &self::test_all_types::REPEATED_IMPORT_ENUM_CODEC)?;
            self.repeated_string_piece()
                .write_to(output, &self::test_all_types::REPEATED_STRING_PIECE_CODEC)?;
            self.repeated_cord()
                .write_to(output, &self::test_all_types::REPEATED_CORD_CODEC)?;
            self.repeated_lazy_message()
                .write_to(output, &self::test_all_types::REPEATED_LAZY_MESSAGE_CODEC)?;
            if let ::std::option::Option::Some(default_int32) = self.default_int32_option() {
                output.write_raw_tag_bytes(&[232, 3])?;
                output.write_int32(*default_int32)?;
            }
            if let ::std::option::Option::Some(default_int64) = self.default_int64_option() {
                output.write_raw_tag_bytes(&[240, 3])?;
                output.write_int64(*default_int64)?;
            }
            if let ::std::option::Option::Some(default_uint32) = self.default_uint32_option() {
                output.write_raw_tag_bytes(&[248, 3])?;
                output.write_uint32(*default_uint32)?;
            }
            if let ::std::option::Option::Some(default_uint64) = self.default_uint64_option() {
                output.write_raw_tag_bytes(&[128, 4])?;
                output.write_uint64(*default_uint64)?;
            }
            if let ::std::option::Option::Some(default_sint32) = self.default_sint32_option() {
                output.write_raw_tag_bytes(&[136, 4])?;
                output.write_sint32(*default_sint32)?;
            }
            if let ::std::option::Option::Some(default_sint64) = self.default_sint64_option() {
                output.write_raw_tag_bytes(&[144, 4])?;
                output.write_sint64(*default_sint64)?;
            }
            if let ::std::option::Option::Some(default_fixed32) = self.default_fixed32_option() {
                output.write_raw_tag_bytes(&[157, 4])?;
                output.write_fixed32(*default_fixed32)?;
            }
            if let ::std::option::Option::Some(default_fixed64) = self.default_fixed64_option() {
                output.write_raw_tag_bytes(&[161, 4])?;
                output.write_fixed64(*default_fixed64)?;
            }
            if let ::std::option::Option::Some(default_sfixed32) = self.default_sfixed32_option() {
                output.write_raw_tag_bytes(&[173, 4])?;
                output.write_sfixed32(*default_sfixed32)?;
            }
            if let ::std::option::Option::Some(default_sfixed64) = self.default_sfixed64_option() {
                output.write_raw_tag_bytes(&[177, 4])?;
                output.write_sfixed64(*default_sfixed64)?;
            }
            if let ::std::option::Option::Some(default_float) = self.default_float_option() {
                output.write_raw_tag_bytes(&[189, 4])?;
                output.write_float(*default_float)?;
            }
            if let ::std::option::Option::Some(default_double) = self.default_double_option() {
                output.write_raw_tag_bytes(&[193, 4])?;
                output.write_double(*default_double)?;
            }
            if let ::std::option::Option::Some(default_bool) = self.default_bool_option() {
                output.write_raw_tag_bytes(&[200, 4])?;
                output.write_bool(*default_bool)?;
            }
            if let ::std::option::Option::Some(default_string) = self.default_string_option() {
                output.write_raw_tag_bytes(&[210, 4])?;
                output.write_string(default_string)?;
            }
            if let ::std::option::Option::Some(default_bytes) = self.default_bytes_option() {
                output.write_raw_tag_bytes(&[218, 4])?;
                output.write_bytes(default_bytes)?;
            }
            if let ::std::option::Option::Some(default_nested_enum) =
                self.default_nested_enum_option()
            {
                output.write_raw_tag_bytes(&[136, 5])?;
                output.write_enum_value(*default_nested_enum)?;
            }
            if let ::std::option::Option::Some(default_foreign_enum) =
                self.default_foreign_enum_option()
            {
                output.write_raw_tag_bytes(&[144, 5])?;
                output.write_enum_value(*default_foreign_enum)?;
            }
            if let ::std::option::Option::Some(default_import_enum) =
                self.default_import_enum_option()
            {
                output.write_raw_tag_bytes(&[152, 5])?;
                output.write_enum_value(*default_import_enum)?;
            }
            if let ::std::option::Option::Some(default_string_piece) =
                self.default_string_piece_option()
            {
                output.write_raw_tag_bytes(&[162, 5])?;
                output.write_string(default_string_piece)?;
            }
            if let ::std::option::Option::Some(default_cord) = self.default_cord_option() {
                output.write_raw_tag_bytes(&[170, 5])?;
                output.write_string(default_cord)?;
            }
            if let ::std::option::Option::Some(oneof_uint32) = self.oneof_uint32() {
                output.write_raw_tag_bytes(&[248, 6])?;
                output.write_uint32(*oneof_uint32)?;
            }
            if let ::std::option::Option::Some(oneof_nested_message) = self.oneof_nested_message() {
                output.write_raw_tag_bytes(&[130, 7])?;
                output.write_message(oneof_nested_message)?;
            }
            if let ::std::option::Option::Some(oneof_string) = self.oneof_string() {
                output.write_raw_tag_bytes(&[138, 7])?;
                output.write_string(oneof_string)?;
            }
            if let ::std::option::Option::Some(oneof_bytes) = self.oneof_bytes() {
                output.write_raw_tag_bytes(&[146, 7])?;
                output.write_bytes(oneof_bytes)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(optionalgroup) = self.optionalgroup() {
                if !::protrust::CodedMessage::is_initialized(optionalgroup) {
                    return false;
                }
            }
            if let ::std::option::Option::Some(optional_nested_message) =
                self.optional_nested_message()
            {
                if !::protrust::CodedMessage::is_initialized(optional_nested_message) {
                    return false;
                }
            }
            if let ::std::option::Option::Some(optional_foreign_message) =
                self.optional_foreign_message()
            {
                if !::protrust::CodedMessage::is_initialized(optional_foreign_message) {
                    return false;
                }
            }
            if let ::std::option::Option::Some(optional_import_message) =
                self.optional_import_message()
            {
                if !::protrust::CodedMessage::is_initialized(optional_import_message) {
                    return false;
                }
            }
            if let ::std::option::Option::Some(optional_public_import_message) =
                self.optional_public_import_message()
            {
                if !::protrust::CodedMessage::is_initialized(optional_public_import_message) {
                    return false;
                }
            }
            if let ::std::option::Option::Some(optional_lazy_message) = self.optional_lazy_message()
            {
                if !::protrust::CodedMessage::is_initialized(optional_lazy_message) {
                    return false;
                }
            }
            if !self.repeated_nested_message.is_initialized() {
                return false;
            }
            if !self.repeated_foreign_message.is_initialized() {
                return false;
            }
            if !self.repeated_import_message.is_initialized() {
                return false;
            }
            if !self.repeated_lazy_message.is_initialized() {
                return false;
            }
            if let ::std::option::Option::Some(oneof_nested_message) = self.oneof_nested_message() {
                if !::protrust::CodedMessage::is_initialized(oneof_nested_message) {
                    return false;
                }
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestAllTypes {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(optional_int32) = other.optional_int32_option() {
                self.set_optional_int32(*optional_int32);
            }
            if let ::std::option::Option::Some(optional_int64) = other.optional_int64_option() {
                self.set_optional_int64(*optional_int64);
            }
            if let ::std::option::Option::Some(optional_uint32) = other.optional_uint32_option() {
                self.set_optional_uint32(*optional_uint32);
            }
            if let ::std::option::Option::Some(optional_uint64) = other.optional_uint64_option() {
                self.set_optional_uint64(*optional_uint64);
            }
            if let ::std::option::Option::Some(optional_sint32) = other.optional_sint32_option() {
                self.set_optional_sint32(*optional_sint32);
            }
            if let ::std::option::Option::Some(optional_sint64) = other.optional_sint64_option() {
                self.set_optional_sint64(*optional_sint64);
            }
            if let ::std::option::Option::Some(optional_fixed32) = other.optional_fixed32_option() {
                self.set_optional_fixed32(*optional_fixed32);
            }
            if let ::std::option::Option::Some(optional_fixed64) = other.optional_fixed64_option() {
                self.set_optional_fixed64(*optional_fixed64);
            }
            if let ::std::option::Option::Some(optional_sfixed32) = other.optional_sfixed32_option()
            {
                self.set_optional_sfixed32(*optional_sfixed32);
            }
            if let ::std::option::Option::Some(optional_sfixed64) = other.optional_sfixed64_option()
            {
                self.set_optional_sfixed64(*optional_sfixed64);
            }
            if let ::std::option::Option::Some(optional_float) = other.optional_float_option() {
                self.set_optional_float(*optional_float);
            }
            if let ::std::option::Option::Some(optional_double) = other.optional_double_option() {
                self.set_optional_double(*optional_double);
            }
            if let ::std::option::Option::Some(optional_bool) = other.optional_bool_option() {
                self.set_optional_bool(*optional_bool);
            }
            if let ::std::option::Option::Some(optional_string) = other.optional_string_option() {
                self.set_optional_string(::std::clone::Clone::clone(optional_string));
            }
            if let ::std::option::Option::Some(optional_bytes) = other.optional_bytes_option() {
                self.set_optional_bytes(::std::clone::Clone::clone(optional_bytes));
            }
            if let ::std::option::Option::Some(optionalgroup) = &other.optionalgroup() {
                ::protrust::LiteMessage::merge(self.optionalgroup_mut(), optionalgroup);
            }
            if let ::std::option::Option::Some(optional_nested_message) =
                &other.optional_nested_message()
            {
                ::protrust::LiteMessage::merge(
                    self.optional_nested_message_mut(),
                    optional_nested_message,
                );
            }
            if let ::std::option::Option::Some(optional_foreign_message) =
                &other.optional_foreign_message()
            {
                ::protrust::LiteMessage::merge(
                    self.optional_foreign_message_mut(),
                    optional_foreign_message,
                );
            }
            if let ::std::option::Option::Some(optional_import_message) =
                &other.optional_import_message()
            {
                ::protrust::LiteMessage::merge(
                    self.optional_import_message_mut(),
                    optional_import_message,
                );
            }
            if let ::std::option::Option::Some(optional_nested_enum) =
                other.optional_nested_enum_option()
            {
                self.set_optional_nested_enum(*optional_nested_enum);
            }
            if let ::std::option::Option::Some(optional_foreign_enum) =
                other.optional_foreign_enum_option()
            {
                self.set_optional_foreign_enum(*optional_foreign_enum);
            }
            if let ::std::option::Option::Some(optional_import_enum) =
                other.optional_import_enum_option()
            {
                self.set_optional_import_enum(*optional_import_enum);
            }
            if let ::std::option::Option::Some(optional_string_piece) =
                other.optional_string_piece_option()
            {
                self.set_optional_string_piece(::std::clone::Clone::clone(optional_string_piece));
            }
            if let ::std::option::Option::Some(optional_cord) = other.optional_cord_option() {
                self.set_optional_cord(::std::clone::Clone::clone(optional_cord));
            }
            if let ::std::option::Option::Some(optional_public_import_message) =
                &other.optional_public_import_message()
            {
                ::protrust::LiteMessage::merge(
                    self.optional_public_import_message_mut(),
                    optional_public_import_message,
                );
            }
            if let ::std::option::Option::Some(optional_lazy_message) =
                &other.optional_lazy_message()
            {
                ::protrust::LiteMessage::merge(
                    self.optional_lazy_message_mut(),
                    optional_lazy_message,
                );
            }
            self.repeated_int32.merge(&other.repeated_int32);
            self.repeated_int64.merge(&other.repeated_int64);
            self.repeated_uint32.merge(&other.repeated_uint32);
            self.repeated_uint64.merge(&other.repeated_uint64);
            self.repeated_sint32.merge(&other.repeated_sint32);
            self.repeated_sint64.merge(&other.repeated_sint64);
            self.repeated_fixed32.merge(&other.repeated_fixed32);
            self.repeated_fixed64.merge(&other.repeated_fixed64);
            self.repeated_sfixed32.merge(&other.repeated_sfixed32);
            self.repeated_sfixed64.merge(&other.repeated_sfixed64);
            self.repeated_float.merge(&other.repeated_float);
            self.repeated_double.merge(&other.repeated_double);
            self.repeated_bool.merge(&other.repeated_bool);
            self.repeated_string.merge(&other.repeated_string);
            self.repeated_bytes.merge(&other.repeated_bytes);
            self.repeatedgroup.merge(&other.repeatedgroup);
            self.repeated_nested_message
                .merge(&other.repeated_nested_message);
            self.repeated_foreign_message
                .merge(&other.repeated_foreign_message);
            self.repeated_import_message
                .merge(&other.repeated_import_message);
            self.repeated_nested_enum.merge(&other.repeated_nested_enum);
            self.repeated_foreign_enum
                .merge(&other.repeated_foreign_enum);
            self.repeated_import_enum.merge(&other.repeated_import_enum);
            self.repeated_string_piece
                .merge(&other.repeated_string_piece);
            self.repeated_cord.merge(&other.repeated_cord);
            self.repeated_lazy_message
                .merge(&other.repeated_lazy_message);
            if let ::std::option::Option::Some(default_int32) = other.default_int32_option() {
                self.set_default_int32(*default_int32);
            }
            if let ::std::option::Option::Some(default_int64) = other.default_int64_option() {
                self.set_default_int64(*default_int64);
            }
            if let ::std::option::Option::Some(default_uint32) = other.default_uint32_option() {
                self.set_default_uint32(*default_uint32);
            }
            if let ::std::option::Option::Some(default_uint64) = other.default_uint64_option() {
                self.set_default_uint64(*default_uint64);
            }
            if let ::std::option::Option::Some(default_sint32) = other.default_sint32_option() {
                self.set_default_sint32(*default_sint32);
            }
            if let ::std::option::Option::Some(default_sint64) = other.default_sint64_option() {
                self.set_default_sint64(*default_sint64);
            }
            if let ::std::option::Option::Some(default_fixed32) = other.default_fixed32_option() {
                self.set_default_fixed32(*default_fixed32);
            }
            if let ::std::option::Option::Some(default_fixed64) = other.default_fixed64_option() {
                self.set_default_fixed64(*default_fixed64);
            }
            if let ::std::option::Option::Some(default_sfixed32) = other.default_sfixed32_option() {
                self.set_default_sfixed32(*default_sfixed32);
            }
            if let ::std::option::Option::Some(default_sfixed64) = other.default_sfixed64_option() {
                self.set_default_sfixed64(*default_sfixed64);
            }
            if let ::std::option::Option::Some(default_float) = other.default_float_option() {
                self.set_default_float(*default_float);
            }
            if let ::std::option::Option::Some(default_double) = other.default_double_option() {
                self.set_default_double(*default_double);
            }
            if let ::std::option::Option::Some(default_bool) = other.default_bool_option() {
                self.set_default_bool(*default_bool);
            }
            if let ::std::option::Option::Some(default_string) = other.default_string_option() {
                self.set_default_string(::std::clone::Clone::clone(default_string));
            }
            if let ::std::option::Option::Some(default_bytes) = other.default_bytes_option() {
                self.set_default_bytes(::std::clone::Clone::clone(default_bytes));
            }
            if let ::std::option::Option::Some(default_nested_enum) =
                other.default_nested_enum_option()
            {
                self.set_default_nested_enum(*default_nested_enum);
            }
            if let ::std::option::Option::Some(default_foreign_enum) =
                other.default_foreign_enum_option()
            {
                self.set_default_foreign_enum(*default_foreign_enum);
            }
            if let ::std::option::Option::Some(default_import_enum) =
                other.default_import_enum_option()
            {
                self.set_default_import_enum(*default_import_enum);
            }
            if let ::std::option::Option::Some(default_string_piece) =
                other.default_string_piece_option()
            {
                self.set_default_string_piece(::std::clone::Clone::clone(default_string_piece));
            }
            if let ::std::option::Option::Some(default_cord) = other.default_cord_option() {
                self.set_default_cord(::std::clone::Clone::clone(default_cord));
            }
            if let ::std::option::Option::Some(oneof_uint32) = other.oneof_uint32() {
                self.set_oneof_uint32(*oneof_uint32);
            }
            if let ::std::option::Option::Some(oneof_nested_message) = &other.oneof_nested_message()
            {
                ::protrust::LiteMessage::merge(
                    self.oneof_nested_message_mut(),
                    oneof_nested_message,
                );
            }
            if let ::std::option::Option::Some(oneof_string) = other.oneof_string() {
                self.set_oneof_string(::std::clone::Clone::clone(oneof_string));
            }
            if let ::std::option::Option::Some(oneof_bytes) = other.oneof_bytes() {
                self.set_oneof_bytes(::std::clone::Clone::clone(oneof_bytes));
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestAllTypes {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[0]
        }
    }
    impl self::TestAllTypes {
        pub const OPTIONAL_INT32_FIELD_NUMBER: i32 = 1;
        pub const OPTIONAL_INT32_DEFAULT_VALUE: i32 = 0;
        pub fn optional_int32(&self) -> i32 {
            self.optional_int32
                .unwrap_or(Self::OPTIONAL_INT32_DEFAULT_VALUE)
        }
        pub fn optional_int32_option(&self) -> ::std::option::Option<&i32> {
            self.optional_int32.as_ref()
        }
        pub fn optional_int32_mut(&mut self) -> &mut i32 {
            self.optional_int32
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_int32(&self) -> bool {
            self.optional_int32.is_some()
        }
        pub fn set_optional_int32(&mut self, value: i32) {
            self.optional_int32 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_int32(&mut self) -> ::std::option::Option<i32> {
            self.optional_int32.take()
        }
        pub fn clear_optional_int32(&mut self) {
            self.optional_int32 = ::std::option::Option::None;
        }
        pub const OPTIONAL_INT64_FIELD_NUMBER: i32 = 2;
        pub const OPTIONAL_INT64_DEFAULT_VALUE: i64 = 0;
        pub fn optional_int64(&self) -> i64 {
            self.optional_int64
                .unwrap_or(Self::OPTIONAL_INT64_DEFAULT_VALUE)
        }
        pub fn optional_int64_option(&self) -> ::std::option::Option<&i64> {
            self.optional_int64.as_ref()
        }
        pub fn optional_int64_mut(&mut self) -> &mut i64 {
            self.optional_int64
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_int64(&self) -> bool {
            self.optional_int64.is_some()
        }
        pub fn set_optional_int64(&mut self, value: i64) {
            self.optional_int64 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_int64(&mut self) -> ::std::option::Option<i64> {
            self.optional_int64.take()
        }
        pub fn clear_optional_int64(&mut self) {
            self.optional_int64 = ::std::option::Option::None;
        }
        pub const OPTIONAL_UINT32_FIELD_NUMBER: i32 = 3;
        pub const OPTIONAL_UINT32_DEFAULT_VALUE: u32 = 0;
        pub fn optional_uint32(&self) -> u32 {
            self.optional_uint32
                .unwrap_or(Self::OPTIONAL_UINT32_DEFAULT_VALUE)
        }
        pub fn optional_uint32_option(&self) -> ::std::option::Option<&u32> {
            self.optional_uint32.as_ref()
        }
        pub fn optional_uint32_mut(&mut self) -> &mut u32 {
            self.optional_uint32
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_uint32(&self) -> bool {
            self.optional_uint32.is_some()
        }
        pub fn set_optional_uint32(&mut self, value: u32) {
            self.optional_uint32 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_uint32(&mut self) -> ::std::option::Option<u32> {
            self.optional_uint32.take()
        }
        pub fn clear_optional_uint32(&mut self) {
            self.optional_uint32 = ::std::option::Option::None;
        }
        pub const OPTIONAL_UINT64_FIELD_NUMBER: i32 = 4;
        pub const OPTIONAL_UINT64_DEFAULT_VALUE: u64 = 0;
        pub fn optional_uint64(&self) -> u64 {
            self.optional_uint64
                .unwrap_or(Self::OPTIONAL_UINT64_DEFAULT_VALUE)
        }
        pub fn optional_uint64_option(&self) -> ::std::option::Option<&u64> {
            self.optional_uint64.as_ref()
        }
        pub fn optional_uint64_mut(&mut self) -> &mut u64 {
            self.optional_uint64
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_uint64(&self) -> bool {
            self.optional_uint64.is_some()
        }
        pub fn set_optional_uint64(&mut self, value: u64) {
            self.optional_uint64 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_uint64(&mut self) -> ::std::option::Option<u64> {
            self.optional_uint64.take()
        }
        pub fn clear_optional_uint64(&mut self) {
            self.optional_uint64 = ::std::option::Option::None;
        }
        pub const OPTIONAL_SINT32_FIELD_NUMBER: i32 = 5;
        pub const OPTIONAL_SINT32_DEFAULT_VALUE: i32 = 0;
        pub fn optional_sint32(&self) -> i32 {
            self.optional_sint32
                .unwrap_or(Self::OPTIONAL_SINT32_DEFAULT_VALUE)
        }
        pub fn optional_sint32_option(&self) -> ::std::option::Option<&i32> {
            self.optional_sint32.as_ref()
        }
        pub fn optional_sint32_mut(&mut self) -> &mut i32 {
            self.optional_sint32
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_sint32(&self) -> bool {
            self.optional_sint32.is_some()
        }
        pub fn set_optional_sint32(&mut self, value: i32) {
            self.optional_sint32 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_sint32(&mut self) -> ::std::option::Option<i32> {
            self.optional_sint32.take()
        }
        pub fn clear_optional_sint32(&mut self) {
            self.optional_sint32 = ::std::option::Option::None;
        }
        pub const OPTIONAL_SINT64_FIELD_NUMBER: i32 = 6;
        pub const OPTIONAL_SINT64_DEFAULT_VALUE: i64 = 0;
        pub fn optional_sint64(&self) -> i64 {
            self.optional_sint64
                .unwrap_or(Self::OPTIONAL_SINT64_DEFAULT_VALUE)
        }
        pub fn optional_sint64_option(&self) -> ::std::option::Option<&i64> {
            self.optional_sint64.as_ref()
        }
        pub fn optional_sint64_mut(&mut self) -> &mut i64 {
            self.optional_sint64
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_sint64(&self) -> bool {
            self.optional_sint64.is_some()
        }
        pub fn set_optional_sint64(&mut self, value: i64) {
            self.optional_sint64 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_sint64(&mut self) -> ::std::option::Option<i64> {
            self.optional_sint64.take()
        }
        pub fn clear_optional_sint64(&mut self) {
            self.optional_sint64 = ::std::option::Option::None;
        }
        pub const OPTIONAL_FIXED32_FIELD_NUMBER: i32 = 7;
        pub const OPTIONAL_FIXED32_DEFAULT_VALUE: u32 = 0;
        pub fn optional_fixed32(&self) -> u32 {
            self.optional_fixed32
                .unwrap_or(Self::OPTIONAL_FIXED32_DEFAULT_VALUE)
        }
        pub fn optional_fixed32_option(&self) -> ::std::option::Option<&u32> {
            self.optional_fixed32.as_ref()
        }
        pub fn optional_fixed32_mut(&mut self) -> &mut u32 {
            self.optional_fixed32
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_fixed32(&self) -> bool {
            self.optional_fixed32.is_some()
        }
        pub fn set_optional_fixed32(&mut self, value: u32) {
            self.optional_fixed32 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_fixed32(&mut self) -> ::std::option::Option<u32> {
            self.optional_fixed32.take()
        }
        pub fn clear_optional_fixed32(&mut self) {
            self.optional_fixed32 = ::std::option::Option::None;
        }
        pub const OPTIONAL_FIXED64_FIELD_NUMBER: i32 = 8;
        pub const OPTIONAL_FIXED64_DEFAULT_VALUE: u64 = 0;
        pub fn optional_fixed64(&self) -> u64 {
            self.optional_fixed64
                .unwrap_or(Self::OPTIONAL_FIXED64_DEFAULT_VALUE)
        }
        pub fn optional_fixed64_option(&self) -> ::std::option::Option<&u64> {
            self.optional_fixed64.as_ref()
        }
        pub fn optional_fixed64_mut(&mut self) -> &mut u64 {
            self.optional_fixed64
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_fixed64(&self) -> bool {
            self.optional_fixed64.is_some()
        }
        pub fn set_optional_fixed64(&mut self, value: u64) {
            self.optional_fixed64 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_fixed64(&mut self) -> ::std::option::Option<u64> {
            self.optional_fixed64.take()
        }
        pub fn clear_optional_fixed64(&mut self) {
            self.optional_fixed64 = ::std::option::Option::None;
        }
        pub const OPTIONAL_SFIXED32_FIELD_NUMBER: i32 = 9;
        pub const OPTIONAL_SFIXED32_DEFAULT_VALUE: i32 = 0;
        pub fn optional_sfixed32(&self) -> i32 {
            self.optional_sfixed32
                .unwrap_or(Self::OPTIONAL_SFIXED32_DEFAULT_VALUE)
        }
        pub fn optional_sfixed32_option(&self) -> ::std::option::Option<&i32> {
            self.optional_sfixed32.as_ref()
        }
        pub fn optional_sfixed32_mut(&mut self) -> &mut i32 {
            self.optional_sfixed32
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_sfixed32(&self) -> bool {
            self.optional_sfixed32.is_some()
        }
        pub fn set_optional_sfixed32(&mut self, value: i32) {
            self.optional_sfixed32 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_sfixed32(&mut self) -> ::std::option::Option<i32> {
            self.optional_sfixed32.take()
        }
        pub fn clear_optional_sfixed32(&mut self) {
            self.optional_sfixed32 = ::std::option::Option::None;
        }
        pub const OPTIONAL_SFIXED64_FIELD_NUMBER: i32 = 10;
        pub const OPTIONAL_SFIXED64_DEFAULT_VALUE: i64 = 0;
        pub fn optional_sfixed64(&self) -> i64 {
            self.optional_sfixed64
                .unwrap_or(Self::OPTIONAL_SFIXED64_DEFAULT_VALUE)
        }
        pub fn optional_sfixed64_option(&self) -> ::std::option::Option<&i64> {
            self.optional_sfixed64.as_ref()
        }
        pub fn optional_sfixed64_mut(&mut self) -> &mut i64 {
            self.optional_sfixed64
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_sfixed64(&self) -> bool {
            self.optional_sfixed64.is_some()
        }
        pub fn set_optional_sfixed64(&mut self, value: i64) {
            self.optional_sfixed64 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_sfixed64(&mut self) -> ::std::option::Option<i64> {
            self.optional_sfixed64.take()
        }
        pub fn clear_optional_sfixed64(&mut self) {
            self.optional_sfixed64 = ::std::option::Option::None;
        }
        pub const OPTIONAL_FLOAT_FIELD_NUMBER: i32 = 11;
        pub const OPTIONAL_FLOAT_DEFAULT_VALUE: f32 = 0.0;
        pub fn optional_float(&self) -> f32 {
            self.optional_float
                .unwrap_or(Self::OPTIONAL_FLOAT_DEFAULT_VALUE)
        }
        pub fn optional_float_option(&self) -> ::std::option::Option<&f32> {
            self.optional_float.as_ref()
        }
        pub fn optional_float_mut(&mut self) -> &mut f32 {
            self.optional_float
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_float(&self) -> bool {
            self.optional_float.is_some()
        }
        pub fn set_optional_float(&mut self, value: f32) {
            self.optional_float = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_float(&mut self) -> ::std::option::Option<f32> {
            self.optional_float.take()
        }
        pub fn clear_optional_float(&mut self) {
            self.optional_float = ::std::option::Option::None;
        }
        pub const OPTIONAL_DOUBLE_FIELD_NUMBER: i32 = 12;
        pub const OPTIONAL_DOUBLE_DEFAULT_VALUE: f64 = 0.0;
        pub fn optional_double(&self) -> f64 {
            self.optional_double
                .unwrap_or(Self::OPTIONAL_DOUBLE_DEFAULT_VALUE)
        }
        pub fn optional_double_option(&self) -> ::std::option::Option<&f64> {
            self.optional_double.as_ref()
        }
        pub fn optional_double_mut(&mut self) -> &mut f64 {
            self.optional_double
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_double(&self) -> bool {
            self.optional_double.is_some()
        }
        pub fn set_optional_double(&mut self, value: f64) {
            self.optional_double = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_double(&mut self) -> ::std::option::Option<f64> {
            self.optional_double.take()
        }
        pub fn clear_optional_double(&mut self) {
            self.optional_double = ::std::option::Option::None;
        }
        pub const OPTIONAL_BOOL_FIELD_NUMBER: i32 = 13;
        pub const OPTIONAL_BOOL_DEFAULT_VALUE: bool = false;
        pub fn optional_bool(&self) -> bool {
            self.optional_bool
                .unwrap_or(Self::OPTIONAL_BOOL_DEFAULT_VALUE)
        }
        pub fn optional_bool_option(&self) -> ::std::option::Option<&bool> {
            self.optional_bool.as_ref()
        }
        pub fn optional_bool_mut(&mut self) -> &mut bool {
            self.optional_bool
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_bool(&self) -> bool {
            self.optional_bool.is_some()
        }
        pub fn set_optional_bool(&mut self, value: bool) {
            self.optional_bool = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_bool(&mut self) -> ::std::option::Option<bool> {
            self.optional_bool.take()
        }
        pub fn clear_optional_bool(&mut self) {
            self.optional_bool = ::std::option::Option::None;
        }
        pub const OPTIONAL_STRING_FIELD_NUMBER: i32 = 14;
        pub const OPTIONAL_STRING_DEFAULT_VALUE: &'static str = "";
        pub fn optional_string(&self) -> &str {
            self.optional_string
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::OPTIONAL_STRING_DEFAULT_VALUE)
        }
        pub fn optional_string_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.optional_string.as_ref()
        }
        pub fn optional_string_mut(&mut self) -> &mut ::std::string::String {
            self.optional_string
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_string(&self) -> bool {
            self.optional_string.is_some()
        }
        pub fn set_optional_string(&mut self, value: ::std::string::String) {
            self.optional_string = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_string(&mut self) -> ::std::option::Option<::std::string::String> {
            self.optional_string.take()
        }
        pub fn clear_optional_string(&mut self) {
            self.optional_string = ::std::option::Option::None;
        }
        pub const OPTIONAL_BYTES_FIELD_NUMBER: i32 = 15;
        pub const OPTIONAL_BYTES_DEFAULT_VALUE: &'static [u8] = &[];
        pub fn optional_bytes(&self) -> &[u8] {
            self.optional_bytes
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::OPTIONAL_BYTES_DEFAULT_VALUE)
        }
        pub fn optional_bytes_option(&self) -> ::std::option::Option<&::std::vec::Vec<u8>> {
            self.optional_bytes.as_ref()
        }
        pub fn optional_bytes_mut(&mut self) -> &mut ::std::vec::Vec<u8> {
            self.optional_bytes
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_bytes(&self) -> bool {
            self.optional_bytes.is_some()
        }
        pub fn set_optional_bytes(&mut self, value: ::std::vec::Vec<u8>) {
            self.optional_bytes = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_bytes(&mut self) -> ::std::option::Option<::std::vec::Vec<u8>> {
            self.optional_bytes.take()
        }
        pub fn clear_optional_bytes(&mut self) {
            self.optional_bytes = ::std::option::Option::None;
        }
        pub const OPTIONALGROUP_FIELD_NUMBER: i32 = 16;
        pub fn optionalgroup(&self) -> ::std::option::Option<&self::test_all_types::OptionalGroup> {
            self.optionalgroup.as_ref().map(|v| &**v)
        }
        pub fn optionalgroup_mut(&mut self) -> &mut self::test_all_types::OptionalGroup {
            self.optionalgroup
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optionalgroup(&self) -> bool {
            self.optionalgroup.is_some()
        }
        pub fn set_optionalgroup(&mut self, value: self::test_all_types::OptionalGroup) {
            self.optionalgroup = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optionalgroup(
            &mut self,
        ) -> ::std::option::Option<self::test_all_types::OptionalGroup> {
            self.optionalgroup.take().map(|v| *v)
        }
        pub fn clear_optionalgroup(&mut self) {
            self.optionalgroup = ::std::option::Option::None;
        }
        pub const OPTIONAL_NESTED_MESSAGE_FIELD_NUMBER: i32 = 18;
        pub fn optional_nested_message(
            &self,
        ) -> ::std::option::Option<&self::test_all_types::NestedMessage> {
            self.optional_nested_message.as_ref().map(|v| &**v)
        }
        pub fn optional_nested_message_mut(&mut self) -> &mut self::test_all_types::NestedMessage {
            self.optional_nested_message
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_nested_message(&self) -> bool {
            self.optional_nested_message.is_some()
        }
        pub fn set_optional_nested_message(&mut self, value: self::test_all_types::NestedMessage) {
            self.optional_nested_message =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_nested_message(
            &mut self,
        ) -> ::std::option::Option<self::test_all_types::NestedMessage> {
            self.optional_nested_message.take().map(|v| *v)
        }
        pub fn clear_optional_nested_message(&mut self) {
            self.optional_nested_message = ::std::option::Option::None;
        }
        pub const OPTIONAL_FOREIGN_MESSAGE_FIELD_NUMBER: i32 = 19;
        pub fn optional_foreign_message(&self) -> ::std::option::Option<&self::ForeignMessage> {
            self.optional_foreign_message.as_ref().map(|v| &**v)
        }
        pub fn optional_foreign_message_mut(&mut self) -> &mut self::ForeignMessage {
            self.optional_foreign_message
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_foreign_message(&self) -> bool {
            self.optional_foreign_message.is_some()
        }
        pub fn set_optional_foreign_message(&mut self, value: self::ForeignMessage) {
            self.optional_foreign_message =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_foreign_message(
            &mut self,
        ) -> ::std::option::Option<self::ForeignMessage> {
            self.optional_foreign_message.take().map(|v| *v)
        }
        pub fn clear_optional_foreign_message(&mut self) {
            self.optional_foreign_message = ::std::option::Option::None;
        }
        pub const OPTIONAL_IMPORT_MESSAGE_FIELD_NUMBER: i32 = 20;
        pub fn optional_import_message(
            &self,
        ) -> ::std::option::Option<&self::super::unittest_import_proto::ImportMessage> {
            self.optional_import_message.as_ref().map(|v| &**v)
        }
        pub fn optional_import_message_mut(
            &mut self,
        ) -> &mut self::super::unittest_import_proto::ImportMessage {
            self.optional_import_message
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_import_message(&self) -> bool {
            self.optional_import_message.is_some()
        }
        pub fn set_optional_import_message(
            &mut self,
            value: self::super::unittest_import_proto::ImportMessage,
        ) {
            self.optional_import_message =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_import_message(
            &mut self,
        ) -> ::std::option::Option<self::super::unittest_import_proto::ImportMessage> {
            self.optional_import_message.take().map(|v| *v)
        }
        pub fn clear_optional_import_message(&mut self) {
            self.optional_import_message = ::std::option::Option::None;
        }
        pub const OPTIONAL_NESTED_ENUM_FIELD_NUMBER: i32 = 21;
        pub const OPTIONAL_NESTED_ENUM_DEFAULT_VALUE: ::protrust::EnumValue<
            self::test_all_types::NestedEnum,
        > = ::protrust::EnumValue::Undefined(0);
        pub fn optional_nested_enum(
            &self,
        ) -> ::protrust::EnumValue<self::test_all_types::NestedEnum> {
            self.optional_nested_enum
                .unwrap_or(Self::OPTIONAL_NESTED_ENUM_DEFAULT_VALUE)
        }
        pub fn optional_nested_enum_option(
            &self,
        ) -> ::std::option::Option<&::protrust::EnumValue<self::test_all_types::NestedEnum>>
        {
            self.optional_nested_enum.as_ref()
        }
        pub fn optional_nested_enum_mut(
            &mut self,
        ) -> &mut ::protrust::EnumValue<self::test_all_types::NestedEnum> {
            self.optional_nested_enum
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_nested_enum(&self) -> bool {
            self.optional_nested_enum.is_some()
        }
        pub fn set_optional_nested_enum(
            &mut self,
            value: ::protrust::EnumValue<self::test_all_types::NestedEnum>,
        ) {
            self.optional_nested_enum =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_nested_enum(
            &mut self,
        ) -> ::std::option::Option<::protrust::EnumValue<self::test_all_types::NestedEnum>>
        {
            self.optional_nested_enum.take()
        }
        pub fn clear_optional_nested_enum(&mut self) {
            self.optional_nested_enum = ::std::option::Option::None;
        }
        pub const OPTIONAL_FOREIGN_ENUM_FIELD_NUMBER: i32 = 22;
        pub const OPTIONAL_FOREIGN_ENUM_DEFAULT_VALUE: ::protrust::EnumValue<self::ForeignEnum> =
            ::protrust::EnumValue::Undefined(0);
        pub fn optional_foreign_enum(&self) -> ::protrust::EnumValue<self::ForeignEnum> {
            self.optional_foreign_enum
                .unwrap_or(Self::OPTIONAL_FOREIGN_ENUM_DEFAULT_VALUE)
        }
        pub fn optional_foreign_enum_option(
            &self,
        ) -> ::std::option::Option<&::protrust::EnumValue<self::ForeignEnum>> {
            self.optional_foreign_enum.as_ref()
        }
        pub fn optional_foreign_enum_mut(
            &mut self,
        ) -> &mut ::protrust::EnumValue<self::ForeignEnum> {
            self.optional_foreign_enum
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_foreign_enum(&self) -> bool {
            self.optional_foreign_enum.is_some()
        }
        pub fn set_optional_foreign_enum(
            &mut self,
            value: ::protrust::EnumValue<self::ForeignEnum>,
        ) {
            self.optional_foreign_enum =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_foreign_enum(
            &mut self,
        ) -> ::std::option::Option<::protrust::EnumValue<self::ForeignEnum>> {
            self.optional_foreign_enum.take()
        }
        pub fn clear_optional_foreign_enum(&mut self) {
            self.optional_foreign_enum = ::std::option::Option::None;
        }
        pub const OPTIONAL_IMPORT_ENUM_FIELD_NUMBER: i32 = 23;
        pub const OPTIONAL_IMPORT_ENUM_DEFAULT_VALUE: ::protrust::EnumValue<
            self::super::unittest_import_proto::ImportEnum,
        > = ::protrust::EnumValue::Undefined(0);
        pub fn optional_import_enum(
            &self,
        ) -> ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum> {
            self.optional_import_enum
                .unwrap_or(Self::OPTIONAL_IMPORT_ENUM_DEFAULT_VALUE)
        }
        pub fn optional_import_enum_option(
            &self,
        ) -> ::std::option::Option<
            &::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>,
        > {
            self.optional_import_enum.as_ref()
        }
        pub fn optional_import_enum_mut(
            &mut self,
        ) -> &mut ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum> {
            self.optional_import_enum
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_import_enum(&self) -> bool {
            self.optional_import_enum.is_some()
        }
        pub fn set_optional_import_enum(
            &mut self,
            value: ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>,
        ) {
            self.optional_import_enum =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_import_enum(
            &mut self,
        ) -> ::std::option::Option<
            ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>,
        > {
            self.optional_import_enum.take()
        }
        pub fn clear_optional_import_enum(&mut self) {
            self.optional_import_enum = ::std::option::Option::None;
        }
        pub const OPTIONAL_STRING_PIECE_FIELD_NUMBER: i32 = 24;
        pub const OPTIONAL_STRING_PIECE_DEFAULT_VALUE: &'static str = "";
        pub fn optional_string_piece(&self) -> &str {
            self.optional_string_piece
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::OPTIONAL_STRING_PIECE_DEFAULT_VALUE)
        }
        pub fn optional_string_piece_option(
            &self,
        ) -> ::std::option::Option<&::std::string::String> {
            self.optional_string_piece.as_ref()
        }
        pub fn optional_string_piece_mut(&mut self) -> &mut ::std::string::String {
            self.optional_string_piece
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_string_piece(&self) -> bool {
            self.optional_string_piece.is_some()
        }
        pub fn set_optional_string_piece(&mut self, value: ::std::string::String) {
            self.optional_string_piece =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_string_piece(
            &mut self,
        ) -> ::std::option::Option<::std::string::String> {
            self.optional_string_piece.take()
        }
        pub fn clear_optional_string_piece(&mut self) {
            self.optional_string_piece = ::std::option::Option::None;
        }
        pub const OPTIONAL_CORD_FIELD_NUMBER: i32 = 25;
        pub const OPTIONAL_CORD_DEFAULT_VALUE: &'static str = "";
        pub fn optional_cord(&self) -> &str {
            self.optional_cord
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::OPTIONAL_CORD_DEFAULT_VALUE)
        }
        pub fn optional_cord_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.optional_cord.as_ref()
        }
        pub fn optional_cord_mut(&mut self) -> &mut ::std::string::String {
            self.optional_cord
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_cord(&self) -> bool {
            self.optional_cord.is_some()
        }
        pub fn set_optional_cord(&mut self, value: ::std::string::String) {
            self.optional_cord = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_cord(&mut self) -> ::std::option::Option<::std::string::String> {
            self.optional_cord.take()
        }
        pub fn clear_optional_cord(&mut self) {
            self.optional_cord = ::std::option::Option::None;
        }
        pub const OPTIONAL_PUBLIC_IMPORT_MESSAGE_FIELD_NUMBER: i32 = 26;
        pub fn optional_public_import_message(
            &self,
        ) -> ::std::option::Option<&self::super::unittest_import_public_proto::PublicImportMessage>
        {
            self.optional_public_import_message.as_ref().map(|v| &**v)
        }
        pub fn optional_public_import_message_mut(
            &mut self,
        ) -> &mut self::super::unittest_import_public_proto::PublicImportMessage {
            self.optional_public_import_message
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_public_import_message(&self) -> bool {
            self.optional_public_import_message.is_some()
        }
        pub fn set_optional_public_import_message(
            &mut self,
            value: self::super::unittest_import_public_proto::PublicImportMessage,
        ) {
            self.optional_public_import_message =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_public_import_message(
            &mut self,
        ) -> ::std::option::Option<self::super::unittest_import_public_proto::PublicImportMessage>
        {
            self.optional_public_import_message.take().map(|v| *v)
        }
        pub fn clear_optional_public_import_message(&mut self) {
            self.optional_public_import_message = ::std::option::Option::None;
        }
        pub const OPTIONAL_LAZY_MESSAGE_FIELD_NUMBER: i32 = 27;
        pub fn optional_lazy_message(
            &self,
        ) -> ::std::option::Option<&self::test_all_types::NestedMessage> {
            self.optional_lazy_message.as_ref().map(|v| &**v)
        }
        pub fn optional_lazy_message_mut(&mut self) -> &mut self::test_all_types::NestedMessage {
            self.optional_lazy_message
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_lazy_message(&self) -> bool {
            self.optional_lazy_message.is_some()
        }
        pub fn set_optional_lazy_message(&mut self, value: self::test_all_types::NestedMessage) {
            self.optional_lazy_message =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_lazy_message(
            &mut self,
        ) -> ::std::option::Option<self::test_all_types::NestedMessage> {
            self.optional_lazy_message.take().map(|v| *v)
        }
        pub fn clear_optional_lazy_message(&mut self) {
            self.optional_lazy_message = ::std::option::Option::None;
        }
        pub const REPEATED_INT32_FIELD_NUMBER: i32 = 31;
        pub fn repeated_int32(&self) -> &::protrust::collections::RepeatedField<i32> {
            &self.repeated_int32
        }
        pub fn repeated_int32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
            &mut self.repeated_int32
        }
        pub const REPEATED_INT64_FIELD_NUMBER: i32 = 32;
        pub fn repeated_int64(&self) -> &::protrust::collections::RepeatedField<i64> {
            &self.repeated_int64
        }
        pub fn repeated_int64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
            &mut self.repeated_int64
        }
        pub const REPEATED_UINT32_FIELD_NUMBER: i32 = 33;
        pub fn repeated_uint32(&self) -> &::protrust::collections::RepeatedField<u32> {
            &self.repeated_uint32
        }
        pub fn repeated_uint32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u32> {
            &mut self.repeated_uint32
        }
        pub const REPEATED_UINT64_FIELD_NUMBER: i32 = 34;
        pub fn repeated_uint64(&self) -> &::protrust::collections::RepeatedField<u64> {
            &self.repeated_uint64
        }
        pub fn repeated_uint64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u64> {
            &mut self.repeated_uint64
        }
        pub const REPEATED_SINT32_FIELD_NUMBER: i32 = 35;
        pub fn repeated_sint32(&self) -> &::protrust::collections::RepeatedField<i32> {
            &self.repeated_sint32
        }
        pub fn repeated_sint32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
            &mut self.repeated_sint32
        }
        pub const REPEATED_SINT64_FIELD_NUMBER: i32 = 36;
        pub fn repeated_sint64(&self) -> &::protrust::collections::RepeatedField<i64> {
            &self.repeated_sint64
        }
        pub fn repeated_sint64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
            &mut self.repeated_sint64
        }
        pub const REPEATED_FIXED32_FIELD_NUMBER: i32 = 37;
        pub fn repeated_fixed32(&self) -> &::protrust::collections::RepeatedField<u32> {
            &self.repeated_fixed32
        }
        pub fn repeated_fixed32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u32> {
            &mut self.repeated_fixed32
        }
        pub const REPEATED_FIXED64_FIELD_NUMBER: i32 = 38;
        pub fn repeated_fixed64(&self) -> &::protrust::collections::RepeatedField<u64> {
            &self.repeated_fixed64
        }
        pub fn repeated_fixed64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u64> {
            &mut self.repeated_fixed64
        }
        pub const REPEATED_SFIXED32_FIELD_NUMBER: i32 = 39;
        pub fn repeated_sfixed32(&self) -> &::protrust::collections::RepeatedField<i32> {
            &self.repeated_sfixed32
        }
        pub fn repeated_sfixed32_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<i32> {
            &mut self.repeated_sfixed32
        }
        pub const REPEATED_SFIXED64_FIELD_NUMBER: i32 = 40;
        pub fn repeated_sfixed64(&self) -> &::protrust::collections::RepeatedField<i64> {
            &self.repeated_sfixed64
        }
        pub fn repeated_sfixed64_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<i64> {
            &mut self.repeated_sfixed64
        }
        pub const REPEATED_FLOAT_FIELD_NUMBER: i32 = 41;
        pub fn repeated_float(&self) -> &::protrust::collections::RepeatedField<f32> {
            &self.repeated_float
        }
        pub fn repeated_float_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<f32> {
            &mut self.repeated_float
        }
        pub const REPEATED_DOUBLE_FIELD_NUMBER: i32 = 42;
        pub fn repeated_double(&self) -> &::protrust::collections::RepeatedField<f64> {
            &self.repeated_double
        }
        pub fn repeated_double_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<f64> {
            &mut self.repeated_double
        }
        pub const REPEATED_BOOL_FIELD_NUMBER: i32 = 43;
        pub fn repeated_bool(&self) -> &::protrust::collections::RepeatedField<bool> {
            &self.repeated_bool
        }
        pub fn repeated_bool_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<bool> {
            &mut self.repeated_bool
        }
        pub const REPEATED_STRING_FIELD_NUMBER: i32 = 44;
        pub fn repeated_string(
            &self,
        ) -> &::protrust::collections::RepeatedField<::std::string::String> {
            &self.repeated_string
        }
        pub fn repeated_string_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<::std::string::String> {
            &mut self.repeated_string
        }
        pub const REPEATED_BYTES_FIELD_NUMBER: i32 = 45;
        pub fn repeated_bytes(
            &self,
        ) -> &::protrust::collections::RepeatedField<::std::vec::Vec<u8>> {
            &self.repeated_bytes
        }
        pub fn repeated_bytes_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<::std::vec::Vec<u8>> {
            &mut self.repeated_bytes
        }
        pub const REPEATEDGROUP_FIELD_NUMBER: i32 = 46;
        pub fn repeatedgroup(
            &self,
        ) -> &::protrust::collections::RepeatedField<self::test_all_types::RepeatedGroup> {
            &self.repeatedgroup
        }
        pub fn repeatedgroup_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<self::test_all_types::RepeatedGroup>
        {
            &mut self.repeatedgroup
        }
        pub const REPEATED_NESTED_MESSAGE_FIELD_NUMBER: i32 = 48;
        pub fn repeated_nested_message(
            &self,
        ) -> &::protrust::collections::RepeatedField<self::test_all_types::NestedMessage> {
            &self.repeated_nested_message
        }
        pub fn repeated_nested_message_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<self::test_all_types::NestedMessage>
        {
            &mut self.repeated_nested_message
        }
        pub const REPEATED_FOREIGN_MESSAGE_FIELD_NUMBER: i32 = 49;
        pub fn repeated_foreign_message(
            &self,
        ) -> &::protrust::collections::RepeatedField<self::ForeignMessage> {
            &self.repeated_foreign_message
        }
        pub fn repeated_foreign_message_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<self::ForeignMessage> {
            &mut self.repeated_foreign_message
        }
        pub const REPEATED_IMPORT_MESSAGE_FIELD_NUMBER: i32 = 50;
        pub fn repeated_import_message(
            &self,
        ) -> &::protrust::collections::RepeatedField<
            self::super::unittest_import_proto::ImportMessage,
        > {
            &self.repeated_import_message
        }
        pub fn repeated_import_message_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<
            self::super::unittest_import_proto::ImportMessage,
        > {
            &mut self.repeated_import_message
        }
        pub const REPEATED_NESTED_ENUM_FIELD_NUMBER: i32 = 51;
        pub fn repeated_nested_enum(
            &self,
        ) -> &::protrust::collections::RepeatedField<
            ::protrust::EnumValue<self::test_all_types::NestedEnum>,
        > {
            &self.repeated_nested_enum
        }
        pub fn repeated_nested_enum_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<
            ::protrust::EnumValue<self::test_all_types::NestedEnum>,
        > {
            &mut self.repeated_nested_enum
        }
        pub const REPEATED_FOREIGN_ENUM_FIELD_NUMBER: i32 = 52;
        pub fn repeated_foreign_enum(
            &self,
        ) -> &::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>>
        {
            &self.repeated_foreign_enum
        }
        pub fn repeated_foreign_enum_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>>
        {
            &mut self.repeated_foreign_enum
        }
        pub const REPEATED_IMPORT_ENUM_FIELD_NUMBER: i32 = 53;
        pub fn repeated_import_enum(
            &self,
        ) -> &::protrust::collections::RepeatedField<
            ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>,
        > {
            &self.repeated_import_enum
        }
        pub fn repeated_import_enum_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<
            ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>,
        > {
            &mut self.repeated_import_enum
        }
        pub const REPEATED_STRING_PIECE_FIELD_NUMBER: i32 = 54;
        pub fn repeated_string_piece(
            &self,
        ) -> &::protrust::collections::RepeatedField<::std::string::String> {
            &self.repeated_string_piece
        }
        pub fn repeated_string_piece_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<::std::string::String> {
            &mut self.repeated_string_piece
        }
        pub const REPEATED_CORD_FIELD_NUMBER: i32 = 55;
        pub fn repeated_cord(
            &self,
        ) -> &::protrust::collections::RepeatedField<::std::string::String> {
            &self.repeated_cord
        }
        pub fn repeated_cord_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<::std::string::String> {
            &mut self.repeated_cord
        }
        pub const REPEATED_LAZY_MESSAGE_FIELD_NUMBER: i32 = 57;
        pub fn repeated_lazy_message(
            &self,
        ) -> &::protrust::collections::RepeatedField<self::test_all_types::NestedMessage> {
            &self.repeated_lazy_message
        }
        pub fn repeated_lazy_message_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<self::test_all_types::NestedMessage>
        {
            &mut self.repeated_lazy_message
        }
        pub const DEFAULT_INT32_FIELD_NUMBER: i32 = 61;
        pub const DEFAULT_INT32_DEFAULT_VALUE: i32 = 41;
        pub fn default_int32(&self) -> i32 {
            self.default_int32
                .unwrap_or(Self::DEFAULT_INT32_DEFAULT_VALUE)
        }
        pub fn default_int32_option(&self) -> ::std::option::Option<&i32> {
            self.default_int32.as_ref()
        }
        pub fn default_int32_mut(&mut self) -> &mut i32 {
            self.default_int32
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_default_int32(&self) -> bool {
            self.default_int32.is_some()
        }
        pub fn set_default_int32(&mut self, value: i32) {
            self.default_int32 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_default_int32(&mut self) -> ::std::option::Option<i32> {
            self.default_int32.take()
        }
        pub fn clear_default_int32(&mut self) {
            self.default_int32 = ::std::option::Option::None;
        }
        pub const DEFAULT_INT64_FIELD_NUMBER: i32 = 62;
        pub const DEFAULT_INT64_DEFAULT_VALUE: i64 = 42;
        pub fn default_int64(&self) -> i64 {
            self.default_int64
                .unwrap_or(Self::DEFAULT_INT64_DEFAULT_VALUE)
        }
        pub fn default_int64_option(&self) -> ::std::option::Option<&i64> {
            self.default_int64.as_ref()
        }
        pub fn default_int64_mut(&mut self) -> &mut i64 {
            self.default_int64
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_default_int64(&self) -> bool {
            self.default_int64.is_some()
        }
        pub fn set_default_int64(&mut self, value: i64) {
            self.default_int64 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_default_int64(&mut self) -> ::std::option::Option<i64> {
            self.default_int64.take()
        }
        pub fn clear_default_int64(&mut self) {
            self.default_int64 = ::std::option::Option::None;
        }
        pub const DEFAULT_UINT32_FIELD_NUMBER: i32 = 63;
        pub const DEFAULT_UINT32_DEFAULT_VALUE: u32 = 43;
        pub fn default_uint32(&self) -> u32 {
            self.default_uint32
                .unwrap_or(Self::DEFAULT_UINT32_DEFAULT_VALUE)
        }
        pub fn default_uint32_option(&self) -> ::std::option::Option<&u32> {
            self.default_uint32.as_ref()
        }
        pub fn default_uint32_mut(&mut self) -> &mut u32 {
            self.default_uint32
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_default_uint32(&self) -> bool {
            self.default_uint32.is_some()
        }
        pub fn set_default_uint32(&mut self, value: u32) {
            self.default_uint32 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_default_uint32(&mut self) -> ::std::option::Option<u32> {
            self.default_uint32.take()
        }
        pub fn clear_default_uint32(&mut self) {
            self.default_uint32 = ::std::option::Option::None;
        }
        pub const DEFAULT_UINT64_FIELD_NUMBER: i32 = 64;
        pub const DEFAULT_UINT64_DEFAULT_VALUE: u64 = 44;
        pub fn default_uint64(&self) -> u64 {
            self.default_uint64
                .unwrap_or(Self::DEFAULT_UINT64_DEFAULT_VALUE)
        }
        pub fn default_uint64_option(&self) -> ::std::option::Option<&u64> {
            self.default_uint64.as_ref()
        }
        pub fn default_uint64_mut(&mut self) -> &mut u64 {
            self.default_uint64
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_default_uint64(&self) -> bool {
            self.default_uint64.is_some()
        }
        pub fn set_default_uint64(&mut self, value: u64) {
            self.default_uint64 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_default_uint64(&mut self) -> ::std::option::Option<u64> {
            self.default_uint64.take()
        }
        pub fn clear_default_uint64(&mut self) {
            self.default_uint64 = ::std::option::Option::None;
        }
        pub const DEFAULT_SINT32_FIELD_NUMBER: i32 = 65;
        pub const DEFAULT_SINT32_DEFAULT_VALUE: i32 = -45;
        pub fn default_sint32(&self) -> i32 {
            self.default_sint32
                .unwrap_or(Self::DEFAULT_SINT32_DEFAULT_VALUE)
        }
        pub fn default_sint32_option(&self) -> ::std::option::Option<&i32> {
            self.default_sint32.as_ref()
        }
        pub fn default_sint32_mut(&mut self) -> &mut i32 {
            self.default_sint32
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_default_sint32(&self) -> bool {
            self.default_sint32.is_some()
        }
        pub fn set_default_sint32(&mut self, value: i32) {
            self.default_sint32 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_default_sint32(&mut self) -> ::std::option::Option<i32> {
            self.default_sint32.take()
        }
        pub fn clear_default_sint32(&mut self) {
            self.default_sint32 = ::std::option::Option::None;
        }
        pub const DEFAULT_SINT64_FIELD_NUMBER: i32 = 66;
        pub const DEFAULT_SINT64_DEFAULT_VALUE: i64 = 46;
        pub fn default_sint64(&self) -> i64 {
            self.default_sint64
                .unwrap_or(Self::DEFAULT_SINT64_DEFAULT_VALUE)
        }
        pub fn default_sint64_option(&self) -> ::std::option::Option<&i64> {
            self.default_sint64.as_ref()
        }
        pub fn default_sint64_mut(&mut self) -> &mut i64 {
            self.default_sint64
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_default_sint64(&self) -> bool {
            self.default_sint64.is_some()
        }
        pub fn set_default_sint64(&mut self, value: i64) {
            self.default_sint64 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_default_sint64(&mut self) -> ::std::option::Option<i64> {
            self.default_sint64.take()
        }
        pub fn clear_default_sint64(&mut self) {
            self.default_sint64 = ::std::option::Option::None;
        }
        pub const DEFAULT_FIXED32_FIELD_NUMBER: i32 = 67;
        pub const DEFAULT_FIXED32_DEFAULT_VALUE: u32 = 47;
        pub fn default_fixed32(&self) -> u32 {
            self.default_fixed32
                .unwrap_or(Self::DEFAULT_FIXED32_DEFAULT_VALUE)
        }
        pub fn default_fixed32_option(&self) -> ::std::option::Option<&u32> {
            self.default_fixed32.as_ref()
        }
        pub fn default_fixed32_mut(&mut self) -> &mut u32 {
            self.default_fixed32
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_default_fixed32(&self) -> bool {
            self.default_fixed32.is_some()
        }
        pub fn set_default_fixed32(&mut self, value: u32) {
            self.default_fixed32 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_default_fixed32(&mut self) -> ::std::option::Option<u32> {
            self.default_fixed32.take()
        }
        pub fn clear_default_fixed32(&mut self) {
            self.default_fixed32 = ::std::option::Option::None;
        }
        pub const DEFAULT_FIXED64_FIELD_NUMBER: i32 = 68;
        pub const DEFAULT_FIXED64_DEFAULT_VALUE: u64 = 48;
        pub fn default_fixed64(&self) -> u64 {
            self.default_fixed64
                .unwrap_or(Self::DEFAULT_FIXED64_DEFAULT_VALUE)
        }
        pub fn default_fixed64_option(&self) -> ::std::option::Option<&u64> {
            self.default_fixed64.as_ref()
        }
        pub fn default_fixed64_mut(&mut self) -> &mut u64 {
            self.default_fixed64
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_default_fixed64(&self) -> bool {
            self.default_fixed64.is_some()
        }
        pub fn set_default_fixed64(&mut self, value: u64) {
            self.default_fixed64 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_default_fixed64(&mut self) -> ::std::option::Option<u64> {
            self.default_fixed64.take()
        }
        pub fn clear_default_fixed64(&mut self) {
            self.default_fixed64 = ::std::option::Option::None;
        }
        pub const DEFAULT_SFIXED32_FIELD_NUMBER: i32 = 69;
        pub const DEFAULT_SFIXED32_DEFAULT_VALUE: i32 = 49;
        pub fn default_sfixed32(&self) -> i32 {
            self.default_sfixed32
                .unwrap_or(Self::DEFAULT_SFIXED32_DEFAULT_VALUE)
        }
        pub fn default_sfixed32_option(&self) -> ::std::option::Option<&i32> {
            self.default_sfixed32.as_ref()
        }
        pub fn default_sfixed32_mut(&mut self) -> &mut i32 {
            self.default_sfixed32
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_default_sfixed32(&self) -> bool {
            self.default_sfixed32.is_some()
        }
        pub fn set_default_sfixed32(&mut self, value: i32) {
            self.default_sfixed32 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_default_sfixed32(&mut self) -> ::std::option::Option<i32> {
            self.default_sfixed32.take()
        }
        pub fn clear_default_sfixed32(&mut self) {
            self.default_sfixed32 = ::std::option::Option::None;
        }
        pub const DEFAULT_SFIXED64_FIELD_NUMBER: i32 = 70;
        pub const DEFAULT_SFIXED64_DEFAULT_VALUE: i64 = -50;
        pub fn default_sfixed64(&self) -> i64 {
            self.default_sfixed64
                .unwrap_or(Self::DEFAULT_SFIXED64_DEFAULT_VALUE)
        }
        pub fn default_sfixed64_option(&self) -> ::std::option::Option<&i64> {
            self.default_sfixed64.as_ref()
        }
        pub fn default_sfixed64_mut(&mut self) -> &mut i64 {
            self.default_sfixed64
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_default_sfixed64(&self) -> bool {
            self.default_sfixed64.is_some()
        }
        pub fn set_default_sfixed64(&mut self, value: i64) {
            self.default_sfixed64 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_default_sfixed64(&mut self) -> ::std::option::Option<i64> {
            self.default_sfixed64.take()
        }
        pub fn clear_default_sfixed64(&mut self) {
            self.default_sfixed64 = ::std::option::Option::None;
        }
        pub const DEFAULT_FLOAT_FIELD_NUMBER: i32 = 71;
        pub const DEFAULT_FLOAT_DEFAULT_VALUE: f32 = 51.5;
        pub fn default_float(&self) -> f32 {
            self.default_float
                .unwrap_or(Self::DEFAULT_FLOAT_DEFAULT_VALUE)
        }
        pub fn default_float_option(&self) -> ::std::option::Option<&f32> {
            self.default_float.as_ref()
        }
        pub fn default_float_mut(&mut self) -> &mut f32 {
            self.default_float
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_default_float(&self) -> bool {
            self.default_float.is_some()
        }
        pub fn set_default_float(&mut self, value: f32) {
            self.default_float = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_default_float(&mut self) -> ::std::option::Option<f32> {
            self.default_float.take()
        }
        pub fn clear_default_float(&mut self) {
            self.default_float = ::std::option::Option::None;
        }
        pub const DEFAULT_DOUBLE_FIELD_NUMBER: i32 = 72;
        pub const DEFAULT_DOUBLE_DEFAULT_VALUE: f64 = 52000.0;
        pub fn default_double(&self) -> f64 {
            self.default_double
                .unwrap_or(Self::DEFAULT_DOUBLE_DEFAULT_VALUE)
        }
        pub fn default_double_option(&self) -> ::std::option::Option<&f64> {
            self.default_double.as_ref()
        }
        pub fn default_double_mut(&mut self) -> &mut f64 {
            self.default_double
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_default_double(&self) -> bool {
            self.default_double.is_some()
        }
        pub fn set_default_double(&mut self, value: f64) {
            self.default_double = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_default_double(&mut self) -> ::std::option::Option<f64> {
            self.default_double.take()
        }
        pub fn clear_default_double(&mut self) {
            self.default_double = ::std::option::Option::None;
        }
        pub const DEFAULT_BOOL_FIELD_NUMBER: i32 = 73;
        pub const DEFAULT_BOOL_DEFAULT_VALUE: bool = true;
        pub fn default_bool(&self) -> bool {
            self.default_bool
                .unwrap_or(Self::DEFAULT_BOOL_DEFAULT_VALUE)
        }
        pub fn default_bool_option(&self) -> ::std::option::Option<&bool> {
            self.default_bool.as_ref()
        }
        pub fn default_bool_mut(&mut self) -> &mut bool {
            self.default_bool
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_default_bool(&self) -> bool {
            self.default_bool.is_some()
        }
        pub fn set_default_bool(&mut self, value: bool) {
            self.default_bool = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_default_bool(&mut self) -> ::std::option::Option<bool> {
            self.default_bool.take()
        }
        pub fn clear_default_bool(&mut self) {
            self.default_bool = ::std::option::Option::None;
        }
        pub const DEFAULT_STRING_FIELD_NUMBER: i32 = 74;
        pub const DEFAULT_STRING_DEFAULT_VALUE: &'static str = "hello";
        pub fn default_string(&self) -> &str {
            self.default_string
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::DEFAULT_STRING_DEFAULT_VALUE)
        }
        pub fn default_string_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.default_string.as_ref()
        }
        pub fn default_string_mut(&mut self) -> &mut ::std::string::String {
            self.default_string
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_default_string(&self) -> bool {
            self.default_string.is_some()
        }
        pub fn set_default_string(&mut self, value: ::std::string::String) {
            self.default_string = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_default_string(&mut self) -> ::std::option::Option<::std::string::String> {
            self.default_string.take()
        }
        pub fn clear_default_string(&mut self) {
            self.default_string = ::std::option::Option::None;
        }
        pub const DEFAULT_BYTES_FIELD_NUMBER: i32 = 75;
        pub const DEFAULT_BYTES_DEFAULT_VALUE: &'static [u8] = &[119, 111, 114, 108, 100];
        pub fn default_bytes(&self) -> &[u8] {
            self.default_bytes
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::DEFAULT_BYTES_DEFAULT_VALUE)
        }
        pub fn default_bytes_option(&self) -> ::std::option::Option<&::std::vec::Vec<u8>> {
            self.default_bytes.as_ref()
        }
        pub fn default_bytes_mut(&mut self) -> &mut ::std::vec::Vec<u8> {
            self.default_bytes
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_default_bytes(&self) -> bool {
            self.default_bytes.is_some()
        }
        pub fn set_default_bytes(&mut self, value: ::std::vec::Vec<u8>) {
            self.default_bytes = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_default_bytes(&mut self) -> ::std::option::Option<::std::vec::Vec<u8>> {
            self.default_bytes.take()
        }
        pub fn clear_default_bytes(&mut self) {
            self.default_bytes = ::std::option::Option::None;
        }
        pub const DEFAULT_NESTED_ENUM_FIELD_NUMBER: i32 = 81;
        pub const DEFAULT_NESTED_ENUM_DEFAULT_VALUE: ::protrust::EnumValue<
            self::test_all_types::NestedEnum,
        > = ::protrust::EnumValue::Defined(self::test_all_types::NestedEnum::Bar);
        pub fn default_nested_enum(
            &self,
        ) -> ::protrust::EnumValue<self::test_all_types::NestedEnum> {
            self.default_nested_enum
                .unwrap_or(Self::DEFAULT_NESTED_ENUM_DEFAULT_VALUE)
        }
        pub fn default_nested_enum_option(
            &self,
        ) -> ::std::option::Option<&::protrust::EnumValue<self::test_all_types::NestedEnum>>
        {
            self.default_nested_enum.as_ref()
        }
        pub fn default_nested_enum_mut(
            &mut self,
        ) -> &mut ::protrust::EnumValue<self::test_all_types::NestedEnum> {
            self.default_nested_enum
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_default_nested_enum(&self) -> bool {
            self.default_nested_enum.is_some()
        }
        pub fn set_default_nested_enum(
            &mut self,
            value: ::protrust::EnumValue<self::test_all_types::NestedEnum>,
        ) {
            self.default_nested_enum =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_default_nested_enum(
            &mut self,
        ) -> ::std::option::Option<::protrust::EnumValue<self::test_all_types::NestedEnum>>
        {
            self.default_nested_enum.take()
        }
        pub fn clear_default_nested_enum(&mut self) {
            self.default_nested_enum = ::std::option::Option::None;
        }
        pub const DEFAULT_FOREIGN_ENUM_FIELD_NUMBER: i32 = 82;
        pub const DEFAULT_FOREIGN_ENUM_DEFAULT_VALUE: ::protrust::EnumValue<self::ForeignEnum> =
            ::protrust::EnumValue::Defined(self::ForeignEnum::ForeignBar);
        pub fn default_foreign_enum(&self) -> ::protrust::EnumValue<self::ForeignEnum> {
            self.default_foreign_enum
                .unwrap_or(Self::DEFAULT_FOREIGN_ENUM_DEFAULT_VALUE)
        }
        pub fn default_foreign_enum_option(
            &self,
        ) -> ::std::option::Option<&::protrust::EnumValue<self::ForeignEnum>> {
            self.default_foreign_enum.as_ref()
        }
        pub fn default_foreign_enum_mut(
            &mut self,
        ) -> &mut ::protrust::EnumValue<self::ForeignEnum> {
            self.default_foreign_enum
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_default_foreign_enum(&self) -> bool {
            self.default_foreign_enum.is_some()
        }
        pub fn set_default_foreign_enum(
            &mut self,
            value: ::protrust::EnumValue<self::ForeignEnum>,
        ) {
            self.default_foreign_enum =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_default_foreign_enum(
            &mut self,
        ) -> ::std::option::Option<::protrust::EnumValue<self::ForeignEnum>> {
            self.default_foreign_enum.take()
        }
        pub fn clear_default_foreign_enum(&mut self) {
            self.default_foreign_enum = ::std::option::Option::None;
        }
        pub const DEFAULT_IMPORT_ENUM_FIELD_NUMBER: i32 = 83;
        pub const DEFAULT_IMPORT_ENUM_DEFAULT_VALUE: ::protrust::EnumValue<
            self::super::unittest_import_proto::ImportEnum,
        > = ::protrust::EnumValue::Defined(
            self::super::unittest_import_proto::ImportEnum::ImportBar,
        );
        pub fn default_import_enum(
            &self,
        ) -> ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum> {
            self.default_import_enum
                .unwrap_or(Self::DEFAULT_IMPORT_ENUM_DEFAULT_VALUE)
        }
        pub fn default_import_enum_option(
            &self,
        ) -> ::std::option::Option<
            &::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>,
        > {
            self.default_import_enum.as_ref()
        }
        pub fn default_import_enum_mut(
            &mut self,
        ) -> &mut ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum> {
            self.default_import_enum
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_default_import_enum(&self) -> bool {
            self.default_import_enum.is_some()
        }
        pub fn set_default_import_enum(
            &mut self,
            value: ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>,
        ) {
            self.default_import_enum =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_default_import_enum(
            &mut self,
        ) -> ::std::option::Option<
            ::protrust::EnumValue<self::super::unittest_import_proto::ImportEnum>,
        > {
            self.default_import_enum.take()
        }
        pub fn clear_default_import_enum(&mut self) {
            self.default_import_enum = ::std::option::Option::None;
        }
        pub const DEFAULT_STRING_PIECE_FIELD_NUMBER: i32 = 84;
        pub const DEFAULT_STRING_PIECE_DEFAULT_VALUE: &'static str = "abc";
        pub fn default_string_piece(&self) -> &str {
            self.default_string_piece
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::DEFAULT_STRING_PIECE_DEFAULT_VALUE)
        }
        pub fn default_string_piece_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.default_string_piece.as_ref()
        }
        pub fn default_string_piece_mut(&mut self) -> &mut ::std::string::String {
            self.default_string_piece
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_default_string_piece(&self) -> bool {
            self.default_string_piece.is_some()
        }
        pub fn set_default_string_piece(&mut self, value: ::std::string::String) {
            self.default_string_piece =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_default_string_piece(
            &mut self,
        ) -> ::std::option::Option<::std::string::String> {
            self.default_string_piece.take()
        }
        pub fn clear_default_string_piece(&mut self) {
            self.default_string_piece = ::std::option::Option::None;
        }
        pub const DEFAULT_CORD_FIELD_NUMBER: i32 = 85;
        pub const DEFAULT_CORD_DEFAULT_VALUE: &'static str = "123";
        pub fn default_cord(&self) -> &str {
            self.default_cord
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::DEFAULT_CORD_DEFAULT_VALUE)
        }
        pub fn default_cord_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.default_cord.as_ref()
        }
        pub fn default_cord_mut(&mut self) -> &mut ::std::string::String {
            self.default_cord
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_default_cord(&self) -> bool {
            self.default_cord.is_some()
        }
        pub fn set_default_cord(&mut self, value: ::std::string::String) {
            self.default_cord = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_default_cord(&mut self) -> ::std::option::Option<::std::string::String> {
            self.default_cord.take()
        }
        pub fn clear_default_cord(&mut self) {
            self.default_cord = ::std::option::Option::None;
        }
        pub const ONEOF_UINT32_FIELD_NUMBER: i32 = 111;
        pub const ONEOF_UINT32_DEFAULT_VALUE: u32 = 0;
        pub fn oneof_uint32(&self) -> ::std::option::Option<&u32> {
            match &self.oneof_field {
                self::test_all_types::OneofField::OneofUint32(oneof_field) => {
                    ::std::option::Option::Some(oneof_field)
                }
                _ => ::std::option::Option::None,
            }
        }
        pub fn oneof_uint32_mut(&mut self) -> &mut u32 {
            match self.oneof_field {
                self::test_all_types::OneofField::OneofUint32(_) => (),
                _ => {
                    self.oneof_field = self::test_all_types::OneofField::OneofUint32(
                        ::std::default::Default::default(),
                    )
                }
            }
            match self.oneof_field {
                self::test_all_types::OneofField::OneofUint32(ref mut oneof_field) => oneof_field,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_oneof_uint32(&self) -> bool {
            match self.oneof_field {
                self::test_all_types::OneofField::OneofUint32(_) => true,
                _ => false,
            }
        }
        pub fn set_oneof_uint32(&mut self, value: u32) {
            self.oneof_field =
                self::test_all_types::OneofField::OneofUint32(::std::convert::From::from(value))
        }
        pub fn take_oneof_uint32(&mut self) -> ::std::option::Option<u32> {
            let oneof_field = ::std::mem::replace(
                &mut self.oneof_field,
                self::test_all_types::OneofField::None,
            );
            match oneof_field {
                self::test_all_types::OneofField::OneofUint32(oneof_field) => {
                    ::std::option::Option::Some(oneof_field)
                }
                mut oneof_field => {
                    ::std::mem::swap(&mut self.oneof_field, &mut oneof_field);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_oneof_uint32(&mut self) {
            let oneof_field = ::std::mem::replace(
                &mut self.oneof_field,
                self::test_all_types::OneofField::None,
            );
            match oneof_field {
                self::test_all_types::OneofField::OneofUint32(_) => {}
                mut oneof_field => ::std::mem::swap(&mut self.oneof_field, &mut oneof_field),
            }
        }
        pub const ONEOF_NESTED_MESSAGE_FIELD_NUMBER: i32 = 112;
        pub fn oneof_nested_message(
            &self,
        ) -> ::std::option::Option<&self::test_all_types::NestedMessage> {
            match &self.oneof_field {
                self::test_all_types::OneofField::OneofNestedMessage(oneof_field) => {
                    ::std::option::Option::Some(&**oneof_field)
                }
                _ => ::std::option::Option::None,
            }
        }
        pub fn oneof_nested_message_mut(&mut self) -> &mut self::test_all_types::NestedMessage {
            match self.oneof_field {
                self::test_all_types::OneofField::OneofNestedMessage(_) => (),
                _ => {
                    self.oneof_field = self::test_all_types::OneofField::OneofNestedMessage(
                        ::std::default::Default::default(),
                    )
                }
            }
            match self.oneof_field {
                self::test_all_types::OneofField::OneofNestedMessage(ref mut oneof_field) => {
                    &mut **oneof_field
                }
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_oneof_nested_message(&self) -> bool {
            match self.oneof_field {
                self::test_all_types::OneofField::OneofNestedMessage(_) => true,
                _ => false,
            }
        }
        pub fn set_oneof_nested_message(&mut self, value: self::test_all_types::NestedMessage) {
            self.oneof_field = self::test_all_types::OneofField::OneofNestedMessage(
                ::std::convert::From::from(value),
            )
        }
        pub fn take_oneof_nested_message(
            &mut self,
        ) -> ::std::option::Option<self::test_all_types::NestedMessage> {
            let oneof_field = ::std::mem::replace(
                &mut self.oneof_field,
                self::test_all_types::OneofField::None,
            );
            match oneof_field {
                self::test_all_types::OneofField::OneofNestedMessage(oneof_field) => {
                    ::std::option::Option::Some(*oneof_field)
                }
                mut oneof_field => {
                    ::std::mem::swap(&mut self.oneof_field, &mut oneof_field);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_oneof_nested_message(&mut self) {
            let oneof_field = ::std::mem::replace(
                &mut self.oneof_field,
                self::test_all_types::OneofField::None,
            );
            match oneof_field {
                self::test_all_types::OneofField::OneofNestedMessage(_) => {}
                mut oneof_field => ::std::mem::swap(&mut self.oneof_field, &mut oneof_field),
            }
        }
        pub const ONEOF_STRING_FIELD_NUMBER: i32 = 113;
        pub const ONEOF_STRING_DEFAULT_VALUE: &'static str = "";
        pub fn oneof_string(&self) -> ::std::option::Option<&::std::string::String> {
            match &self.oneof_field {
                self::test_all_types::OneofField::OneofString(oneof_field) => {
                    ::std::option::Option::Some(oneof_field)
                }
                _ => ::std::option::Option::None,
            }
        }
        pub fn oneof_string_mut(&mut self) -> &mut ::std::string::String {
            match self.oneof_field {
                self::test_all_types::OneofField::OneofString(_) => (),
                _ => {
                    self.oneof_field = self::test_all_types::OneofField::OneofString(
                        ::std::default::Default::default(),
                    )
                }
            }
            match self.oneof_field {
                self::test_all_types::OneofField::OneofString(ref mut oneof_field) => oneof_field,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_oneof_string(&self) -> bool {
            match self.oneof_field {
                self::test_all_types::OneofField::OneofString(_) => true,
                _ => false,
            }
        }
        pub fn set_oneof_string(&mut self, value: ::std::string::String) {
            self.oneof_field =
                self::test_all_types::OneofField::OneofString(::std::convert::From::from(value))
        }
        pub fn take_oneof_string(&mut self) -> ::std::option::Option<::std::string::String> {
            let oneof_field = ::std::mem::replace(
                &mut self.oneof_field,
                self::test_all_types::OneofField::None,
            );
            match oneof_field {
                self::test_all_types::OneofField::OneofString(oneof_field) => {
                    ::std::option::Option::Some(oneof_field)
                }
                mut oneof_field => {
                    ::std::mem::swap(&mut self.oneof_field, &mut oneof_field);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_oneof_string(&mut self) {
            let oneof_field = ::std::mem::replace(
                &mut self.oneof_field,
                self::test_all_types::OneofField::None,
            );
            match oneof_field {
                self::test_all_types::OneofField::OneofString(_) => {}
                mut oneof_field => ::std::mem::swap(&mut self.oneof_field, &mut oneof_field),
            }
        }
        pub const ONEOF_BYTES_FIELD_NUMBER: i32 = 114;
        pub const ONEOF_BYTES_DEFAULT_VALUE: &'static [u8] = &[];
        pub fn oneof_bytes(&self) -> ::std::option::Option<&::std::vec::Vec<u8>> {
            match &self.oneof_field {
                self::test_all_types::OneofField::OneofBytes(oneof_field) => {
                    ::std::option::Option::Some(oneof_field)
                }
                _ => ::std::option::Option::None,
            }
        }
        pub fn oneof_bytes_mut(&mut self) -> &mut ::std::vec::Vec<u8> {
            match self.oneof_field {
                self::test_all_types::OneofField::OneofBytes(_) => (),
                _ => {
                    self.oneof_field = self::test_all_types::OneofField::OneofBytes(
                        ::std::default::Default::default(),
                    )
                }
            }
            match self.oneof_field {
                self::test_all_types::OneofField::OneofBytes(ref mut oneof_field) => oneof_field,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_oneof_bytes(&self) -> bool {
            match self.oneof_field {
                self::test_all_types::OneofField::OneofBytes(_) => true,
                _ => false,
            }
        }
        pub fn set_oneof_bytes(&mut self, value: ::std::vec::Vec<u8>) {
            self.oneof_field =
                self::test_all_types::OneofField::OneofBytes(::std::convert::From::from(value))
        }
        pub fn take_oneof_bytes(&mut self) -> ::std::option::Option<::std::vec::Vec<u8>> {
            let oneof_field = ::std::mem::replace(
                &mut self.oneof_field,
                self::test_all_types::OneofField::None,
            );
            match oneof_field {
                self::test_all_types::OneofField::OneofBytes(oneof_field) => {
                    ::std::option::Option::Some(oneof_field)
                }
                mut oneof_field => {
                    ::std::mem::swap(&mut self.oneof_field, &mut oneof_field);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_oneof_bytes(&mut self) {
            let oneof_field = ::std::mem::replace(
                &mut self.oneof_field,
                self::test_all_types::OneofField::None,
            );
            match oneof_field {
                self::test_all_types::OneofField::OneofBytes(_) => {}
                mut oneof_field => ::std::mem::swap(&mut self.oneof_field, &mut oneof_field),
            }
        }
        pub fn oneof_field(&self) -> &self::test_all_types::OneofField {
            &self.oneof_field
        }
        pub fn oneof_field_mut(&mut self) -> &mut self::test_all_types::OneofField {
            &mut self.oneof_field
        }
    }
    pub mod test_all_types {
        #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
        pub enum NestedEnum {
            Foo,
            Bar,
            Baz,
            Neg,
        }
        impl ::protrust::Enum for self::NestedEnum {
            fn descriptor() -> &'static ::protrust::reflect::EnumDescriptor<'static> {
                &<self::super::TestAllTypes as ::protrust::Message>::descriptor().enums()[0]
            }
        }
        impl ::std::convert::TryFrom<i32> for self::NestedEnum {
            type Error = ::protrust::VariantUndefinedError;
            fn try_from(
                value: i32,
            ) -> ::std::result::Result<Self, ::protrust::VariantUndefinedError> {
                #[allow(unreachable_patterns)]
                match value {
                    1 => ::std::result::Result::Ok(self::NestedEnum::Foo),
                    2 => ::std::result::Result::Ok(self::NestedEnum::Bar),
                    3 => ::std::result::Result::Ok(self::NestedEnum::Baz),
                    -1 => ::std::result::Result::Ok(self::NestedEnum::Neg),
                    _ => ::std::result::Result::Err(::protrust::VariantUndefinedError),
                }
            }
        }
        impl ::std::convert::From<self::NestedEnum> for i32 {
            fn from(value: self::NestedEnum) -> i32 {
                match value {
                    self::NestedEnum::Foo => 1,
                    self::NestedEnum::Bar => 2,
                    self::NestedEnum::Baz => 3,
                    self::NestedEnum::Neg => -1,
                }
            }
        }
        #[derive(Clone, Debug, PartialEq)]
        pub enum OneofField {
            None,
            OneofUint32(u32),
            OneofNestedMessage(::std::boxed::Box<self::NestedMessage>),
            OneofString(::std::string::String),
            OneofBytes(::std::vec::Vec<u8>),
        }
        impl ::std::default::Default for self::OneofField {
            fn default() -> Self {
                self::OneofField::None
            }
        }
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct NestedMessage {
            bb: ::std::option::Option<i32>,
            unknown_fields: ::protrust::UnknownFieldSet,
        }
        impl ::protrust::CodedMessage for self::NestedMessage {
            fn merge_from(
                &mut self,
                input: &mut ::protrust::io::CodedInput,
            ) -> ::protrust::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        8 | 10 => self.set_bb(input.read_int32()?),
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> i32 {
                let mut size = 0i32;
                if let ::std::option::Option::Some(bb) = self.bb_option() {
                    size += 1;
                    size += ::protrust::io::sizes::int32(*bb);
                }
                size += self.unknown_fields.calculate_size();
                size
            }
            fn write_to(
                &self,
                output: &mut ::protrust::io::CodedOutput,
            ) -> ::protrust::io::OutputResult {
                if let ::std::option::Option::Some(bb) = self.bb_option() {
                    output.write_raw_tag_bytes(&[8])?;
                    output.write_int32(*bb)?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                true
            }
        }
        impl ::protrust::LiteMessage for self::NestedMessage {
            fn merge(&mut self, other: &Self) {
                if let ::std::option::Option::Some(bb) = other.bb_option() {
                    self.set_bb(*bb);
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl ::protrust::Message for self::NestedMessage {
            fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
                &<self::super::TestAllTypes as ::protrust::Message>::descriptor().messages()[0]
            }
        }
        impl self::NestedMessage {
            pub const BB_FIELD_NUMBER: i32 = 1;
            pub const BB_DEFAULT_VALUE: i32 = 0;
            pub fn bb(&self) -> i32 {
                self.bb.unwrap_or(Self::BB_DEFAULT_VALUE)
            }
            pub fn bb_option(&self) -> ::std::option::Option<&i32> {
                self.bb.as_ref()
            }
            pub fn bb_mut(&mut self) -> &mut i32 {
                self.bb.get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_bb(&self) -> bool {
                self.bb.is_some()
            }
            pub fn set_bb(&mut self, value: i32) {
                self.bb = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_bb(&mut self) -> ::std::option::Option<i32> {
                self.bb.take()
            }
            pub fn clear_bb(&mut self) {
                self.bb = ::std::option::Option::None;
            }
        }
        pub(in super::super::super) mod nested_message {
            pub(in super::super::super) static BB_REFLECTOR:
                ::protrust::reflect::access::VerboseFieldAccessor<self::super::NestedMessage, i32> =
                ::protrust::reflect::access::VerboseFieldAccessor {
                    get_option: self::super::NestedMessage::bb_option,
                    get_mut: self::super::NestedMessage::bb_mut,
                    set: self::super::NestedMessage::set_bb,
                    take: self::super::NestedMessage::take_bb,
                    clear: self::super::NestedMessage::clear_bb,
                };
        }
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct OptionalGroup {
            a: ::std::option::Option<i32>,
            unknown_fields: ::protrust::UnknownFieldSet,
        }
        impl ::protrust::CodedMessage for self::OptionalGroup {
            fn merge_from(
                &mut self,
                input: &mut ::protrust::io::CodedInput,
            ) -> ::protrust::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        136 | 138 => self.set_a(input.read_int32()?),
                        132 => break,
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> i32 {
                let mut size = 0i32;
                if let ::std::option::Option::Some(a) = self.a_option() {
                    size += 2;
                    size += ::protrust::io::sizes::int32(*a);
                }
                size += self.unknown_fields.calculate_size();
                size
            }
            fn write_to(
                &self,
                output: &mut ::protrust::io::CodedOutput,
            ) -> ::protrust::io::OutputResult {
                if let ::std::option::Option::Some(a) = self.a_option() {
                    output.write_raw_tag_bytes(&[136, 1])?;
                    output.write_int32(*a)?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                true
            }
        }
        impl ::protrust::LiteMessage for self::OptionalGroup {
            fn merge(&mut self, other: &Self) {
                if let ::std::option::Option::Some(a) = other.a_option() {
                    self.set_a(*a);
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl ::protrust::Message for self::OptionalGroup {
            fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
                &<self::super::TestAllTypes as ::protrust::Message>::descriptor().messages()[1]
            }
        }
        impl self::OptionalGroup {
            pub const A_FIELD_NUMBER: i32 = 17;
            pub const A_DEFAULT_VALUE: i32 = 0;
            pub fn a(&self) -> i32 {
                self.a.unwrap_or(Self::A_DEFAULT_VALUE)
            }
            pub fn a_option(&self) -> ::std::option::Option<&i32> {
                self.a.as_ref()
            }
            pub fn a_mut(&mut self) -> &mut i32 {
                self.a.get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_a(&self) -> bool {
                self.a.is_some()
            }
            pub fn set_a(&mut self, value: i32) {
                self.a = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_a(&mut self) -> ::std::option::Option<i32> {
                self.a.take()
            }
            pub fn clear_a(&mut self) {
                self.a = ::std::option::Option::None;
            }
        }
        pub(in super::super::super) mod optional_group {
            pub(in super::super::super) static A_REFLECTOR:
                ::protrust::reflect::access::VerboseFieldAccessor<self::super::OptionalGroup, i32> =
                ::protrust::reflect::access::VerboseFieldAccessor {
                    get_option: self::super::OptionalGroup::a_option,
                    get_mut: self::super::OptionalGroup::a_mut,
                    set: self::super::OptionalGroup::set_a,
                    take: self::super::OptionalGroup::take_a,
                    clear: self::super::OptionalGroup::clear_a,
                };
        }
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct RepeatedGroup {
            a: ::std::option::Option<i32>,
            unknown_fields: ::protrust::UnknownFieldSet,
        }
        impl ::protrust::CodedMessage for self::RepeatedGroup {
            fn merge_from(
                &mut self,
                input: &mut ::protrust::io::CodedInput,
            ) -> ::protrust::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        376 | 378 => self.set_a(input.read_int32()?),
                        372 => break,
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> i32 {
                let mut size = 0i32;
                if let ::std::option::Option::Some(a) = self.a_option() {
                    size += 2;
                    size += ::protrust::io::sizes::int32(*a);
                }
                size += self.unknown_fields.calculate_size();
                size
            }
            fn write_to(
                &self,
                output: &mut ::protrust::io::CodedOutput,
            ) -> ::protrust::io::OutputResult {
                if let ::std::option::Option::Some(a) = self.a_option() {
                    output.write_raw_tag_bytes(&[248, 2])?;
                    output.write_int32(*a)?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                true
            }
        }
        impl ::protrust::LiteMessage for self::RepeatedGroup {
            fn merge(&mut self, other: &Self) {
                if let ::std::option::Option::Some(a) = other.a_option() {
                    self.set_a(*a);
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl ::protrust::Message for self::RepeatedGroup {
            fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
                &<self::super::TestAllTypes as ::protrust::Message>::descriptor().messages()[2]
            }
        }
        impl self::RepeatedGroup {
            pub const A_FIELD_NUMBER: i32 = 47;
            pub const A_DEFAULT_VALUE: i32 = 0;
            pub fn a(&self) -> i32 {
                self.a.unwrap_or(Self::A_DEFAULT_VALUE)
            }
            pub fn a_option(&self) -> ::std::option::Option<&i32> {
                self.a.as_ref()
            }
            pub fn a_mut(&mut self) -> &mut i32 {
                self.a.get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_a(&self) -> bool {
                self.a.is_some()
            }
            pub fn set_a(&mut self, value: i32) {
                self.a = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_a(&mut self) -> ::std::option::Option<i32> {
                self.a.take()
            }
            pub fn clear_a(&mut self) {
                self.a = ::std::option::Option::None;
            }
        }
        pub(in super::super::super) mod repeated_group {
            pub(in super::super::super) static A_REFLECTOR:
                ::protrust::reflect::access::VerboseFieldAccessor<self::super::RepeatedGroup, i32> =
                ::protrust::reflect::access::VerboseFieldAccessor {
                    get_option: self::super::RepeatedGroup::a_option,
                    get_mut: self::super::RepeatedGroup::a_mut,
                    set: self::super::RepeatedGroup::set_a,
                    take: self::super::RepeatedGroup::take_a,
                    clear: self::super::RepeatedGroup::clear_a,
                };
        }
        pub(super) static REPEATED_INT32_CODEC: ::protrust::Codec<i32> =
            ::protrust::Codec::int32(248);
        pub(super) static REPEATED_INT64_CODEC: ::protrust::Codec<i64> =
            ::protrust::Codec::int64(256);
        pub(super) static REPEATED_UINT32_CODEC: ::protrust::Codec<u32> =
            ::protrust::Codec::uint32(264);
        pub(super) static REPEATED_UINT64_CODEC: ::protrust::Codec<u64> =
            ::protrust::Codec::uint64(272);
        pub(super) static REPEATED_SINT32_CODEC: ::protrust::Codec<i32> =
            ::protrust::Codec::sint32(280);
        pub(super) static REPEATED_SINT64_CODEC: ::protrust::Codec<i64> =
            ::protrust::Codec::sint64(288);
        pub(super) static REPEATED_FIXED32_CODEC: ::protrust::Codec<u32> =
            ::protrust::Codec::fixed32(301);
        pub(super) static REPEATED_FIXED64_CODEC: ::protrust::Codec<u64> =
            ::protrust::Codec::fixed64(305);
        pub(super) static REPEATED_SFIXED32_CODEC: ::protrust::Codec<i32> =
            ::protrust::Codec::sfixed32(317);
        pub(super) static REPEATED_SFIXED64_CODEC: ::protrust::Codec<i64> =
            ::protrust::Codec::sfixed64(321);
        pub(super) static REPEATED_FLOAT_CODEC: ::protrust::Codec<f32> =
            ::protrust::Codec::float(333);
        pub(super) static REPEATED_DOUBLE_CODEC: ::protrust::Codec<f64> =
            ::protrust::Codec::double(337);
        pub(super) static REPEATED_BOOL_CODEC: ::protrust::Codec<bool> =
            ::protrust::Codec::bool(344);
        pub(super) static REPEATED_STRING_CODEC: ::protrust::Codec<::std::string::String> =
            ::protrust::Codec::string(354);
        pub(super) static REPEATED_BYTES_CODEC: ::protrust::Codec<::std::vec::Vec<u8>> =
            ::protrust::Codec::bytes(362);
        pub(super) static REPEATEDGROUP_CODEC: ::protrust::Codec<self::RepeatedGroup> =
            ::protrust::Codec::group(371, 372);
        pub(super) static REPEATED_NESTED_MESSAGE_CODEC: ::protrust::Codec<self::NestedMessage> =
            ::protrust::Codec::message(386);
        pub(super) static REPEATED_FOREIGN_MESSAGE_CODEC: ::protrust::Codec<
            self::super::ForeignMessage,
        > = ::protrust::Codec::message(394);
        pub(super) static REPEATED_IMPORT_MESSAGE_CODEC: ::protrust::Codec<
            self::super::super::unittest_import_proto::ImportMessage,
        > = ::protrust::Codec::message(402);
        pub(super) static REPEATED_NESTED_ENUM_CODEC: ::protrust::Codec<
            ::protrust::EnumValue<self::NestedEnum>,
        > = ::protrust::Codec::enum_value(408);
        pub(super) static REPEATED_FOREIGN_ENUM_CODEC: ::protrust::Codec<
            ::protrust::EnumValue<self::super::ForeignEnum>,
        > = ::protrust::Codec::enum_value(416);
        pub(super) static REPEATED_IMPORT_ENUM_CODEC: ::protrust::Codec<
            ::protrust::EnumValue<self::super::super::unittest_import_proto::ImportEnum>,
        > = ::protrust::Codec::enum_value(424);
        pub(super) static REPEATED_STRING_PIECE_CODEC: ::protrust::Codec<::std::string::String> =
            ::protrust::Codec::string(434);
        pub(super) static REPEATED_CORD_CODEC: ::protrust::Codec<::std::string::String> =
            ::protrust::Codec::string(442);
        pub(super) static REPEATED_LAZY_MESSAGE_CODEC: ::protrust::Codec<self::NestedMessage> =
            ::protrust::Codec::message(458);
        pub(in super::super) static OPTIONAL_INT32_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestAllTypes, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestAllTypes::optional_int32_option,
                get_mut: self::super::TestAllTypes::optional_int32_mut,
                set: self::super::TestAllTypes::set_optional_int32,
                take: self::super::TestAllTypes::take_optional_int32,
                clear: self::super::TestAllTypes::clear_optional_int32,
            };
        pub(in super::super) static OPTIONAL_INT64_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestAllTypes, i64> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestAllTypes::optional_int64_option,
                get_mut: self::super::TestAllTypes::optional_int64_mut,
                set: self::super::TestAllTypes::set_optional_int64,
                take: self::super::TestAllTypes::take_optional_int64,
                clear: self::super::TestAllTypes::clear_optional_int64,
            };
        pub(in super::super) static OPTIONAL_UINT32_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestAllTypes, u32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestAllTypes::optional_uint32_option,
                get_mut: self::super::TestAllTypes::optional_uint32_mut,
                set: self::super::TestAllTypes::set_optional_uint32,
                take: self::super::TestAllTypes::take_optional_uint32,
                clear: self::super::TestAllTypes::clear_optional_uint32,
            };
        pub(in super::super) static OPTIONAL_UINT64_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestAllTypes, u64> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestAllTypes::optional_uint64_option,
                get_mut: self::super::TestAllTypes::optional_uint64_mut,
                set: self::super::TestAllTypes::set_optional_uint64,
                take: self::super::TestAllTypes::take_optional_uint64,
                clear: self::super::TestAllTypes::clear_optional_uint64,
            };
        pub(in super::super) static OPTIONAL_SINT32_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestAllTypes, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestAllTypes::optional_sint32_option,
                get_mut: self::super::TestAllTypes::optional_sint32_mut,
                set: self::super::TestAllTypes::set_optional_sint32,
                take: self::super::TestAllTypes::take_optional_sint32,
                clear: self::super::TestAllTypes::clear_optional_sint32,
            };
        pub(in super::super) static OPTIONAL_SINT64_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestAllTypes, i64> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestAllTypes::optional_sint64_option,
                get_mut: self::super::TestAllTypes::optional_sint64_mut,
                set: self::super::TestAllTypes::set_optional_sint64,
                take: self::super::TestAllTypes::take_optional_sint64,
                clear: self::super::TestAllTypes::clear_optional_sint64,
            };
        pub(in super::super) static OPTIONAL_FIXED32_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestAllTypes, u32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestAllTypes::optional_fixed32_option,
                get_mut: self::super::TestAllTypes::optional_fixed32_mut,
                set: self::super::TestAllTypes::set_optional_fixed32,
                take: self::super::TestAllTypes::take_optional_fixed32,
                clear: self::super::TestAllTypes::clear_optional_fixed32,
            };
        pub(in super::super) static OPTIONAL_FIXED64_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestAllTypes, u64> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestAllTypes::optional_fixed64_option,
                get_mut: self::super::TestAllTypes::optional_fixed64_mut,
                set: self::super::TestAllTypes::set_optional_fixed64,
                take: self::super::TestAllTypes::take_optional_fixed64,
                clear: self::super::TestAllTypes::clear_optional_fixed64,
            };
        pub(in super::super) static OPTIONAL_SFIXED32_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestAllTypes, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestAllTypes::optional_sfixed32_option,
                get_mut: self::super::TestAllTypes::optional_sfixed32_mut,
                set: self::super::TestAllTypes::set_optional_sfixed32,
                take: self::super::TestAllTypes::take_optional_sfixed32,
                clear: self::super::TestAllTypes::clear_optional_sfixed32,
            };
        pub(in super::super) static OPTIONAL_SFIXED64_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestAllTypes, i64> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestAllTypes::optional_sfixed64_option,
                get_mut: self::super::TestAllTypes::optional_sfixed64_mut,
                set: self::super::TestAllTypes::set_optional_sfixed64,
                take: self::super::TestAllTypes::take_optional_sfixed64,
                clear: self::super::TestAllTypes::clear_optional_sfixed64,
            };
        pub(in super::super) static OPTIONAL_FLOAT_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestAllTypes, f32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestAllTypes::optional_float_option,
                get_mut: self::super::TestAllTypes::optional_float_mut,
                set: self::super::TestAllTypes::set_optional_float,
                take: self::super::TestAllTypes::take_optional_float,
                clear: self::super::TestAllTypes::clear_optional_float,
            };
        pub(in super::super) static OPTIONAL_DOUBLE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestAllTypes, f64> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestAllTypes::optional_double_option,
                get_mut: self::super::TestAllTypes::optional_double_mut,
                set: self::super::TestAllTypes::set_optional_double,
                take: self::super::TestAllTypes::take_optional_double,
                clear: self::super::TestAllTypes::clear_optional_double,
            };
        pub(in super::super) static OPTIONAL_BOOL_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestAllTypes, bool> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestAllTypes::optional_bool_option,
                get_mut: self::super::TestAllTypes::optional_bool_mut,
                set: self::super::TestAllTypes::set_optional_bool,
                take: self::super::TestAllTypes::take_optional_bool,
                clear: self::super::TestAllTypes::clear_optional_bool,
            };
        pub(in super::super) static OPTIONAL_STRING_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::optional_string_option,
            get_mut: self::super::TestAllTypes::optional_string_mut,
            set: self::super::TestAllTypes::set_optional_string,
            take: self::super::TestAllTypes::take_optional_string,
            clear: self::super::TestAllTypes::clear_optional_string,
        };
        pub(in super::super) static OPTIONAL_BYTES_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                ::std::vec::Vec<u8>,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::optional_bytes_option,
            get_mut: self::super::TestAllTypes::optional_bytes_mut,
            set: self::super::TestAllTypes::set_optional_bytes,
            take: self::super::TestAllTypes::take_optional_bytes,
            clear: self::super::TestAllTypes::clear_optional_bytes,
        };
        pub(in super::super) static OPTIONALGROUP_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                self::OptionalGroup,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::optionalgroup,
            get_mut: self::super::TestAllTypes::optionalgroup_mut,
            set: self::super::TestAllTypes::set_optionalgroup,
            take: self::super::TestAllTypes::take_optionalgroup,
            clear: self::super::TestAllTypes::clear_optionalgroup,
        };
        pub(in super::super) static OPTIONAL_NESTED_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                self::NestedMessage,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::optional_nested_message,
            get_mut: self::super::TestAllTypes::optional_nested_message_mut,
            set: self::super::TestAllTypes::set_optional_nested_message,
            take: self::super::TestAllTypes::take_optional_nested_message,
            clear: self::super::TestAllTypes::clear_optional_nested_message,
        };
        pub(in super::super) static OPTIONAL_FOREIGN_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                self::super::ForeignMessage,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::optional_foreign_message,
            get_mut: self::super::TestAllTypes::optional_foreign_message_mut,
            set: self::super::TestAllTypes::set_optional_foreign_message,
            take: self::super::TestAllTypes::take_optional_foreign_message,
            clear: self::super::TestAllTypes::clear_optional_foreign_message,
        };
        pub(in super::super) static OPTIONAL_IMPORT_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                self::super::super::unittest_import_proto::ImportMessage,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::optional_import_message,
            get_mut: self::super::TestAllTypes::optional_import_message_mut,
            set: self::super::TestAllTypes::set_optional_import_message,
            take: self::super::TestAllTypes::take_optional_import_message,
            clear: self::super::TestAllTypes::clear_optional_import_message,
        };
        pub(in super::super) static OPTIONAL_NESTED_ENUM_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::EnumValue<self::NestedEnum>,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::optional_nested_enum_option,
            get_mut: self::super::TestAllTypes::optional_nested_enum_mut,
            set: self::super::TestAllTypes::set_optional_nested_enum,
            take: self::super::TestAllTypes::take_optional_nested_enum,
            clear: self::super::TestAllTypes::clear_optional_nested_enum,
        };
        pub(in super::super) static OPTIONAL_FOREIGN_ENUM_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::EnumValue<self::super::ForeignEnum>,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::optional_foreign_enum_option,
            get_mut: self::super::TestAllTypes::optional_foreign_enum_mut,
            set: self::super::TestAllTypes::set_optional_foreign_enum,
            take: self::super::TestAllTypes::take_optional_foreign_enum,
            clear: self::super::TestAllTypes::clear_optional_foreign_enum,
        };
        pub(in super::super) static OPTIONAL_IMPORT_ENUM_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::EnumValue<self::super::super::unittest_import_proto::ImportEnum>,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::optional_import_enum_option,
            get_mut: self::super::TestAllTypes::optional_import_enum_mut,
            set: self::super::TestAllTypes::set_optional_import_enum,
            take: self::super::TestAllTypes::take_optional_import_enum,
            clear: self::super::TestAllTypes::clear_optional_import_enum,
        };
        pub(in super::super) static OPTIONAL_STRING_PIECE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::optional_string_piece_option,
            get_mut: self::super::TestAllTypes::optional_string_piece_mut,
            set: self::super::TestAllTypes::set_optional_string_piece,
            take: self::super::TestAllTypes::take_optional_string_piece,
            clear: self::super::TestAllTypes::clear_optional_string_piece,
        };
        pub(in super::super) static OPTIONAL_CORD_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::optional_cord_option,
            get_mut: self::super::TestAllTypes::optional_cord_mut,
            set: self::super::TestAllTypes::set_optional_cord,
            take: self::super::TestAllTypes::take_optional_cord,
            clear: self::super::TestAllTypes::clear_optional_cord,
        };
        pub(in super::super) static OPTIONAL_PUBLIC_IMPORT_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                self::super::super::unittest_import_public_proto::PublicImportMessage,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::optional_public_import_message,
            get_mut: self::super::TestAllTypes::optional_public_import_message_mut,
            set: self::super::TestAllTypes::set_optional_public_import_message,
            take: self::super::TestAllTypes::take_optional_public_import_message,
            clear: self::super::TestAllTypes::clear_optional_public_import_message,
        };
        pub(in super::super) static OPTIONAL_LAZY_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                self::NestedMessage,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::optional_lazy_message,
            get_mut: self::super::TestAllTypes::optional_lazy_message_mut,
            set: self::super::TestAllTypes::set_optional_lazy_message,
            take: self::super::TestAllTypes::take_optional_lazy_message,
            clear: self::super::TestAllTypes::clear_optional_lazy_message,
        };
        pub(in super::super) static REPEATED_INT32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<i32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_int32,
            get_mut: self::super::TestAllTypes::repeated_int32_mut,
        };
        pub(in super::super) static REPEATED_INT64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<i64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_int64,
            get_mut: self::super::TestAllTypes::repeated_int64_mut,
        };
        pub(in super::super) static REPEATED_UINT32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<u32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_uint32,
            get_mut: self::super::TestAllTypes::repeated_uint32_mut,
        };
        pub(in super::super) static REPEATED_UINT64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<u64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_uint64,
            get_mut: self::super::TestAllTypes::repeated_uint64_mut,
        };
        pub(in super::super) static REPEATED_SINT32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<i32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_sint32,
            get_mut: self::super::TestAllTypes::repeated_sint32_mut,
        };
        pub(in super::super) static REPEATED_SINT64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<i64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_sint64,
            get_mut: self::super::TestAllTypes::repeated_sint64_mut,
        };
        pub(in super::super) static REPEATED_FIXED32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<u32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_fixed32,
            get_mut: self::super::TestAllTypes::repeated_fixed32_mut,
        };
        pub(in super::super) static REPEATED_FIXED64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<u64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_fixed64,
            get_mut: self::super::TestAllTypes::repeated_fixed64_mut,
        };
        pub(in super::super) static REPEATED_SFIXED32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<i32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_sfixed32,
            get_mut: self::super::TestAllTypes::repeated_sfixed32_mut,
        };
        pub(in super::super) static REPEATED_SFIXED64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<i64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_sfixed64,
            get_mut: self::super::TestAllTypes::repeated_sfixed64_mut,
        };
        pub(in super::super) static REPEATED_FLOAT_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<f32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_float,
            get_mut: self::super::TestAllTypes::repeated_float_mut,
        };
        pub(in super::super) static REPEATED_DOUBLE_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<f64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_double,
            get_mut: self::super::TestAllTypes::repeated_double_mut,
        };
        pub(in super::super) static REPEATED_BOOL_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<bool>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_bool,
            get_mut: self::super::TestAllTypes::repeated_bool_mut,
        };
        pub(in super::super) static REPEATED_STRING_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<::std::string::String>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_string,
            get_mut: self::super::TestAllTypes::repeated_string_mut,
        };
        pub(in super::super) static REPEATED_BYTES_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<::std::vec::Vec<u8>>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_bytes,
            get_mut: self::super::TestAllTypes::repeated_bytes_mut,
        };
        pub(in super::super) static REPEATEDGROUP_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<self::RepeatedGroup>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeatedgroup,
            get_mut: self::super::TestAllTypes::repeatedgroup_mut,
        };
        pub(in super::super) static REPEATED_NESTED_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<self::NestedMessage>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_nested_message,
            get_mut: self::super::TestAllTypes::repeated_nested_message_mut,
        };
        pub(in super::super) static REPEATED_FOREIGN_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<self::super::ForeignMessage>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_foreign_message,
            get_mut: self::super::TestAllTypes::repeated_foreign_message_mut,
        };
        pub(in super::super) static REPEATED_IMPORT_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<
                    self::super::super::unittest_import_proto::ImportMessage,
                >,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_import_message,
            get_mut: self::super::TestAllTypes::repeated_import_message_mut,
        };
        pub(in super::super) static REPEATED_NESTED_ENUM_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<::protrust::EnumValue<self::NestedEnum>>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_nested_enum,
            get_mut: self::super::TestAllTypes::repeated_nested_enum_mut,
        };
        pub(in super::super) static REPEATED_FOREIGN_ENUM_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<
                    ::protrust::EnumValue<self::super::ForeignEnum>,
                >,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_foreign_enum,
            get_mut: self::super::TestAllTypes::repeated_foreign_enum_mut,
        };
        pub(in super::super) static REPEATED_IMPORT_ENUM_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<
                    ::protrust::EnumValue<self::super::super::unittest_import_proto::ImportEnum>,
                >,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_import_enum,
            get_mut: self::super::TestAllTypes::repeated_import_enum_mut,
        };
        pub(in super::super) static REPEATED_STRING_PIECE_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<::std::string::String>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_string_piece,
            get_mut: self::super::TestAllTypes::repeated_string_piece_mut,
        };
        pub(in super::super) static REPEATED_CORD_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<::std::string::String>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_cord,
            get_mut: self::super::TestAllTypes::repeated_cord_mut,
        };
        pub(in super::super) static REPEATED_LAZY_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<self::NestedMessage>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_lazy_message,
            get_mut: self::super::TestAllTypes::repeated_lazy_message_mut,
        };
        pub(in super::super) static DEFAULT_INT32_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestAllTypes, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestAllTypes::default_int32_option,
                get_mut: self::super::TestAllTypes::default_int32_mut,
                set: self::super::TestAllTypes::set_default_int32,
                take: self::super::TestAllTypes::take_default_int32,
                clear: self::super::TestAllTypes::clear_default_int32,
            };
        pub(in super::super) static DEFAULT_INT64_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestAllTypes, i64> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestAllTypes::default_int64_option,
                get_mut: self::super::TestAllTypes::default_int64_mut,
                set: self::super::TestAllTypes::set_default_int64,
                take: self::super::TestAllTypes::take_default_int64,
                clear: self::super::TestAllTypes::clear_default_int64,
            };
        pub(in super::super) static DEFAULT_UINT32_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestAllTypes, u32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestAllTypes::default_uint32_option,
                get_mut: self::super::TestAllTypes::default_uint32_mut,
                set: self::super::TestAllTypes::set_default_uint32,
                take: self::super::TestAllTypes::take_default_uint32,
                clear: self::super::TestAllTypes::clear_default_uint32,
            };
        pub(in super::super) static DEFAULT_UINT64_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestAllTypes, u64> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestAllTypes::default_uint64_option,
                get_mut: self::super::TestAllTypes::default_uint64_mut,
                set: self::super::TestAllTypes::set_default_uint64,
                take: self::super::TestAllTypes::take_default_uint64,
                clear: self::super::TestAllTypes::clear_default_uint64,
            };
        pub(in super::super) static DEFAULT_SINT32_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestAllTypes, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestAllTypes::default_sint32_option,
                get_mut: self::super::TestAllTypes::default_sint32_mut,
                set: self::super::TestAllTypes::set_default_sint32,
                take: self::super::TestAllTypes::take_default_sint32,
                clear: self::super::TestAllTypes::clear_default_sint32,
            };
        pub(in super::super) static DEFAULT_SINT64_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestAllTypes, i64> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestAllTypes::default_sint64_option,
                get_mut: self::super::TestAllTypes::default_sint64_mut,
                set: self::super::TestAllTypes::set_default_sint64,
                take: self::super::TestAllTypes::take_default_sint64,
                clear: self::super::TestAllTypes::clear_default_sint64,
            };
        pub(in super::super) static DEFAULT_FIXED32_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestAllTypes, u32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestAllTypes::default_fixed32_option,
                get_mut: self::super::TestAllTypes::default_fixed32_mut,
                set: self::super::TestAllTypes::set_default_fixed32,
                take: self::super::TestAllTypes::take_default_fixed32,
                clear: self::super::TestAllTypes::clear_default_fixed32,
            };
        pub(in super::super) static DEFAULT_FIXED64_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestAllTypes, u64> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestAllTypes::default_fixed64_option,
                get_mut: self::super::TestAllTypes::default_fixed64_mut,
                set: self::super::TestAllTypes::set_default_fixed64,
                take: self::super::TestAllTypes::take_default_fixed64,
                clear: self::super::TestAllTypes::clear_default_fixed64,
            };
        pub(in super::super) static DEFAULT_SFIXED32_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestAllTypes, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestAllTypes::default_sfixed32_option,
                get_mut: self::super::TestAllTypes::default_sfixed32_mut,
                set: self::super::TestAllTypes::set_default_sfixed32,
                take: self::super::TestAllTypes::take_default_sfixed32,
                clear: self::super::TestAllTypes::clear_default_sfixed32,
            };
        pub(in super::super) static DEFAULT_SFIXED64_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestAllTypes, i64> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestAllTypes::default_sfixed64_option,
                get_mut: self::super::TestAllTypes::default_sfixed64_mut,
                set: self::super::TestAllTypes::set_default_sfixed64,
                take: self::super::TestAllTypes::take_default_sfixed64,
                clear: self::super::TestAllTypes::clear_default_sfixed64,
            };
        pub(in super::super) static DEFAULT_FLOAT_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestAllTypes, f32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestAllTypes::default_float_option,
                get_mut: self::super::TestAllTypes::default_float_mut,
                set: self::super::TestAllTypes::set_default_float,
                take: self::super::TestAllTypes::take_default_float,
                clear: self::super::TestAllTypes::clear_default_float,
            };
        pub(in super::super) static DEFAULT_DOUBLE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestAllTypes, f64> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestAllTypes::default_double_option,
                get_mut: self::super::TestAllTypes::default_double_mut,
                set: self::super::TestAllTypes::set_default_double,
                take: self::super::TestAllTypes::take_default_double,
                clear: self::super::TestAllTypes::clear_default_double,
            };
        pub(in super::super) static DEFAULT_BOOL_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestAllTypes, bool> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestAllTypes::default_bool_option,
                get_mut: self::super::TestAllTypes::default_bool_mut,
                set: self::super::TestAllTypes::set_default_bool,
                take: self::super::TestAllTypes::take_default_bool,
                clear: self::super::TestAllTypes::clear_default_bool,
            };
        pub(in super::super) static DEFAULT_STRING_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::default_string_option,
            get_mut: self::super::TestAllTypes::default_string_mut,
            set: self::super::TestAllTypes::set_default_string,
            take: self::super::TestAllTypes::take_default_string,
            clear: self::super::TestAllTypes::clear_default_string,
        };
        pub(in super::super) static DEFAULT_BYTES_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                ::std::vec::Vec<u8>,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::default_bytes_option,
            get_mut: self::super::TestAllTypes::default_bytes_mut,
            set: self::super::TestAllTypes::set_default_bytes,
            take: self::super::TestAllTypes::take_default_bytes,
            clear: self::super::TestAllTypes::clear_default_bytes,
        };
        pub(in super::super) static DEFAULT_NESTED_ENUM_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::EnumValue<self::NestedEnum>,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::default_nested_enum_option,
            get_mut: self::super::TestAllTypes::default_nested_enum_mut,
            set: self::super::TestAllTypes::set_default_nested_enum,
            take: self::super::TestAllTypes::take_default_nested_enum,
            clear: self::super::TestAllTypes::clear_default_nested_enum,
        };
        pub(in super::super) static DEFAULT_FOREIGN_ENUM_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::EnumValue<self::super::ForeignEnum>,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::default_foreign_enum_option,
            get_mut: self::super::TestAllTypes::default_foreign_enum_mut,
            set: self::super::TestAllTypes::set_default_foreign_enum,
            take: self::super::TestAllTypes::take_default_foreign_enum,
            clear: self::super::TestAllTypes::clear_default_foreign_enum,
        };
        pub(in super::super) static DEFAULT_IMPORT_ENUM_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::EnumValue<self::super::super::unittest_import_proto::ImportEnum>,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::default_import_enum_option,
            get_mut: self::super::TestAllTypes::default_import_enum_mut,
            set: self::super::TestAllTypes::set_default_import_enum,
            take: self::super::TestAllTypes::take_default_import_enum,
            clear: self::super::TestAllTypes::clear_default_import_enum,
        };
        pub(in super::super) static DEFAULT_STRING_PIECE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::default_string_piece_option,
            get_mut: self::super::TestAllTypes::default_string_piece_mut,
            set: self::super::TestAllTypes::set_default_string_piece,
            take: self::super::TestAllTypes::take_default_string_piece,
            clear: self::super::TestAllTypes::clear_default_string_piece,
        };
        pub(in super::super) static DEFAULT_CORD_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::default_cord_option,
            get_mut: self::super::TestAllTypes::default_cord_mut,
            set: self::super::TestAllTypes::set_default_cord,
            take: self::super::TestAllTypes::take_default_cord,
            clear: self::super::TestAllTypes::clear_default_cord,
        };
        pub(in super::super) static ONEOF_UINT32_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestAllTypes, u32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestAllTypes::oneof_uint32,
                get_mut: self::super::TestAllTypes::oneof_uint32_mut,
                set: self::super::TestAllTypes::set_oneof_uint32,
                take: self::super::TestAllTypes::take_oneof_uint32,
                clear: self::super::TestAllTypes::clear_oneof_uint32,
            };
        pub(in super::super) static ONEOF_NESTED_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                self::NestedMessage,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::oneof_nested_message,
            get_mut: self::super::TestAllTypes::oneof_nested_message_mut,
            set: self::super::TestAllTypes::set_oneof_nested_message,
            take: self::super::TestAllTypes::take_oneof_nested_message,
            clear: self::super::TestAllTypes::clear_oneof_nested_message,
        };
        pub(in super::super) static ONEOF_STRING_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::oneof_string,
            get_mut: self::super::TestAllTypes::oneof_string_mut,
            set: self::super::TestAllTypes::set_oneof_string,
            take: self::super::TestAllTypes::take_oneof_string,
            clear: self::super::TestAllTypes::clear_oneof_string,
        };
        pub(in super::super) static ONEOF_BYTES_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                ::std::vec::Vec<u8>,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::oneof_bytes,
            get_mut: self::super::TestAllTypes::oneof_bytes_mut,
            set: self::super::TestAllTypes::set_oneof_bytes,
            take: self::super::TestAllTypes::take_oneof_bytes,
            clear: self::super::TestAllTypes::clear_oneof_bytes,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct NestedTestAllTypes {
        child: ::std::option::Option<::std::boxed::Box<self::NestedTestAllTypes>>,
        payload: ::std::option::Option<::std::boxed::Box<self::TestAllTypes>>,
        repeated_child: ::protrust::collections::RepeatedField<self::NestedTestAllTypes>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::NestedTestAllTypes {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => input.read_message(self.child_mut())?,
                    18 => input.read_message(self.payload_mut())?,
                    26 => self
                        .repeated_child
                        .add_entries(input, &self::nested_test_all_types::REPEATED_CHILD_CODEC)?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(child) = self.child() {
                size += 1;
                size += ::protrust::io::sizes::message(child);
            }
            if let ::std::option::Option::Some(payload) = self.payload() {
                size += 1;
                size += ::protrust::io::sizes::message(payload);
            }
            size += self
                .repeated_child()
                .calculate_size(&self::nested_test_all_types::REPEATED_CHILD_CODEC);
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(child) = self.child() {
                output.write_raw_tag_bytes(&[10])?;
                output.write_message(child)?;
            }
            if let ::std::option::Option::Some(payload) = self.payload() {
                output.write_raw_tag_bytes(&[18])?;
                output.write_message(payload)?;
            }
            self.repeated_child()
                .write_to(output, &self::nested_test_all_types::REPEATED_CHILD_CODEC)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(child) = self.child() {
                if !::protrust::CodedMessage::is_initialized(child) {
                    return false;
                }
            }
            if let ::std::option::Option::Some(payload) = self.payload() {
                if !::protrust::CodedMessage::is_initialized(payload) {
                    return false;
                }
            }
            if !self.repeated_child.is_initialized() {
                return false;
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::NestedTestAllTypes {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(child) = &other.child() {
                ::protrust::LiteMessage::merge(self.child_mut(), child);
            }
            if let ::std::option::Option::Some(payload) = &other.payload() {
                ::protrust::LiteMessage::merge(self.payload_mut(), payload);
            }
            self.repeated_child.merge(&other.repeated_child);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::NestedTestAllTypes {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[1]
        }
    }
    impl self::NestedTestAllTypes {
        pub const CHILD_FIELD_NUMBER: i32 = 1;
        pub fn child(&self) -> ::std::option::Option<&self::NestedTestAllTypes> {
            self.child.as_ref().map(|v| &**v)
        }
        pub fn child_mut(&mut self) -> &mut self::NestedTestAllTypes {
            self.child
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_child(&self) -> bool {
            self.child.is_some()
        }
        pub fn set_child(&mut self, value: self::NestedTestAllTypes) {
            self.child = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_child(&mut self) -> ::std::option::Option<self::NestedTestAllTypes> {
            self.child.take().map(|v| *v)
        }
        pub fn clear_child(&mut self) {
            self.child = ::std::option::Option::None;
        }
        pub const PAYLOAD_FIELD_NUMBER: i32 = 2;
        pub fn payload(&self) -> ::std::option::Option<&self::TestAllTypes> {
            self.payload.as_ref().map(|v| &**v)
        }
        pub fn payload_mut(&mut self) -> &mut self::TestAllTypes {
            self.payload
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_payload(&self) -> bool {
            self.payload.is_some()
        }
        pub fn set_payload(&mut self, value: self::TestAllTypes) {
            self.payload = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_payload(&mut self) -> ::std::option::Option<self::TestAllTypes> {
            self.payload.take().map(|v| *v)
        }
        pub fn clear_payload(&mut self) {
            self.payload = ::std::option::Option::None;
        }
        pub const REPEATED_CHILD_FIELD_NUMBER: i32 = 3;
        pub fn repeated_child(
            &self,
        ) -> &::protrust::collections::RepeatedField<self::NestedTestAllTypes> {
            &self.repeated_child
        }
        pub fn repeated_child_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<self::NestedTestAllTypes> {
            &mut self.repeated_child
        }
    }
    pub(in super::super) mod nested_test_all_types {
        pub(super) static REPEATED_CHILD_CODEC: ::protrust::Codec<self::super::NestedTestAllTypes> =
            ::protrust::Codec::message(26);
        pub(in super::super) static CHILD_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::NestedTestAllTypes,
                self::super::NestedTestAllTypes,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::NestedTestAllTypes::child,
            get_mut: self::super::NestedTestAllTypes::child_mut,
            set: self::super::NestedTestAllTypes::set_child,
            take: self::super::NestedTestAllTypes::take_child,
            clear: self::super::NestedTestAllTypes::clear_child,
        };
        pub(in super::super) static PAYLOAD_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::NestedTestAllTypes,
                self::super::TestAllTypes,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::NestedTestAllTypes::payload,
            get_mut: self::super::NestedTestAllTypes::payload_mut,
            set: self::super::NestedTestAllTypes::set_payload,
            take: self::super::NestedTestAllTypes::take_payload,
            clear: self::super::NestedTestAllTypes::clear_payload,
        };
        pub(in super::super) static REPEATED_CHILD_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::NestedTestAllTypes,
                ::protrust::collections::RepeatedField<self::super::NestedTestAllTypes>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::NestedTestAllTypes::repeated_child,
            get_mut: self::super::NestedTestAllTypes::repeated_child_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestDeprecatedFields {
        deprecated_int32: ::std::option::Option<i32>,
        oneof_fields: self::test_deprecated_fields::OneofFields,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestDeprecatedFields {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.set_deprecated_int32(input.read_int32()?),
                    16 | 18 => self.set_deprecated_int32_in_oneof(input.read_int32()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(deprecated_int32) = self.deprecated_int32_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*deprecated_int32);
            }
            if let ::std::option::Option::Some(deprecated_int32_in_oneof) =
                self.deprecated_int32_in_oneof()
            {
                size += 1;
                size += ::protrust::io::sizes::int32(*deprecated_int32_in_oneof);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(deprecated_int32) = self.deprecated_int32_option() {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(*deprecated_int32)?;
            }
            if let ::std::option::Option::Some(deprecated_int32_in_oneof) =
                self.deprecated_int32_in_oneof()
            {
                output.write_raw_tag_bytes(&[16])?;
                output.write_int32(*deprecated_int32_in_oneof)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestDeprecatedFields {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(deprecated_int32) = other.deprecated_int32_option() {
                self.set_deprecated_int32(*deprecated_int32);
            }
            if let ::std::option::Option::Some(deprecated_int32_in_oneof) =
                other.deprecated_int32_in_oneof()
            {
                self.set_deprecated_int32_in_oneof(*deprecated_int32_in_oneof);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestDeprecatedFields {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[2]
        }
    }
    impl self::TestDeprecatedFields {
        pub const DEPRECATED_INT32_FIELD_NUMBER: i32 = 1;
        pub const DEPRECATED_INT32_DEFAULT_VALUE: i32 = 0;
        pub fn deprecated_int32(&self) -> i32 {
            self.deprecated_int32
                .unwrap_or(Self::DEPRECATED_INT32_DEFAULT_VALUE)
        }
        pub fn deprecated_int32_option(&self) -> ::std::option::Option<&i32> {
            self.deprecated_int32.as_ref()
        }
        pub fn deprecated_int32_mut(&mut self) -> &mut i32 {
            self.deprecated_int32
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_deprecated_int32(&self) -> bool {
            self.deprecated_int32.is_some()
        }
        pub fn set_deprecated_int32(&mut self, value: i32) {
            self.deprecated_int32 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_deprecated_int32(&mut self) -> ::std::option::Option<i32> {
            self.deprecated_int32.take()
        }
        pub fn clear_deprecated_int32(&mut self) {
            self.deprecated_int32 = ::std::option::Option::None;
        }
        pub const DEPRECATED_INT32_IN_ONEOF_FIELD_NUMBER: i32 = 2;
        pub const DEPRECATED_INT32_IN_ONEOF_DEFAULT_VALUE: i32 = 0;
        pub fn deprecated_int32_in_oneof(&self) -> ::std::option::Option<&i32> {
            match &self.oneof_fields {
                self::test_deprecated_fields::OneofFields::DeprecatedInt32InOneof(oneof_fields) => {
                    ::std::option::Option::Some(oneof_fields)
                }
                _ => ::std::option::Option::None,
            }
        }
        pub fn deprecated_int32_in_oneof_mut(&mut self) -> &mut i32 {
            match self.oneof_fields {
                self::test_deprecated_fields::OneofFields::DeprecatedInt32InOneof(_) => (),
                _ => {
                    self.oneof_fields =
                        self::test_deprecated_fields::OneofFields::DeprecatedInt32InOneof(
                            ::std::default::Default::default(),
                        )
                }
            }
            match self.oneof_fields {
                self::test_deprecated_fields::OneofFields::DeprecatedInt32InOneof(
                    ref mut oneof_fields,
                ) => oneof_fields,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_deprecated_int32_in_oneof(&self) -> bool {
            match self.oneof_fields {
                self::test_deprecated_fields::OneofFields::DeprecatedInt32InOneof(_) => true,
                _ => false,
            }
        }
        pub fn set_deprecated_int32_in_oneof(&mut self, value: i32) {
            self.oneof_fields = self::test_deprecated_fields::OneofFields::DeprecatedInt32InOneof(
                ::std::convert::From::from(value),
            )
        }
        pub fn take_deprecated_int32_in_oneof(&mut self) -> ::std::option::Option<i32> {
            let oneof_fields = ::std::mem::replace(
                &mut self.oneof_fields,
                self::test_deprecated_fields::OneofFields::None,
            );
            match oneof_fields {
                self::test_deprecated_fields::OneofFields::DeprecatedInt32InOneof(oneof_fields) => {
                    ::std::option::Option::Some(oneof_fields)
                }
                mut oneof_fields => {
                    ::std::mem::swap(&mut self.oneof_fields, &mut oneof_fields);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_deprecated_int32_in_oneof(&mut self) {
            let oneof_fields = ::std::mem::replace(
                &mut self.oneof_fields,
                self::test_deprecated_fields::OneofFields::None,
            );
            match oneof_fields {
                self::test_deprecated_fields::OneofFields::DeprecatedInt32InOneof(_) => {}
                mut oneof_fields => ::std::mem::swap(&mut self.oneof_fields, &mut oneof_fields),
            }
        }
        pub fn oneof_fields(&self) -> &self::test_deprecated_fields::OneofFields {
            &self.oneof_fields
        }
        pub fn oneof_fields_mut(&mut self) -> &mut self::test_deprecated_fields::OneofFields {
            &mut self.oneof_fields
        }
    }
    pub mod test_deprecated_fields {
        #[derive(Clone, Debug, PartialEq)]
        pub enum OneofFields {
            None,
            DeprecatedInt32InOneof(i32),
        }
        impl ::std::default::Default for self::OneofFields {
            fn default() -> Self {
                self::OneofFields::None
            }
        }
        pub(in super::super) static DEPRECATED_INT32_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestDeprecatedFields,
                i32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestDeprecatedFields::deprecated_int32_option,
            get_mut: self::super::TestDeprecatedFields::deprecated_int32_mut,
            set: self::super::TestDeprecatedFields::set_deprecated_int32,
            take: self::super::TestDeprecatedFields::take_deprecated_int32,
            clear: self::super::TestDeprecatedFields::clear_deprecated_int32,
        };
        pub(in super::super) static DEPRECATED_INT32_IN_ONEOF_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestDeprecatedFields,
                i32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestDeprecatedFields::deprecated_int32_in_oneof,
            get_mut: self::super::TestDeprecatedFields::deprecated_int32_in_oneof_mut,
            set: self::super::TestDeprecatedFields::set_deprecated_int32_in_oneof,
            take: self::super::TestDeprecatedFields::take_deprecated_int32_in_oneof,
            clear: self::super::TestDeprecatedFields::clear_deprecated_int32_in_oneof,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestDeprecatedMessage {
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestDeprecatedMessage {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestDeprecatedMessage {
        fn merge(&mut self, other: &Self) {
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestDeprecatedMessage {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[3]
        }
    }
    impl self::TestDeprecatedMessage {}
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct ForeignMessage {
        c: ::std::option::Option<i32>,
        d: ::std::option::Option<i32>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::ForeignMessage {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.set_c(input.read_int32()?),
                    16 | 18 => self.set_d(input.read_int32()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(c) = self.c_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*c);
            }
            if let ::std::option::Option::Some(d) = self.d_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*d);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(c) = self.c_option() {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(*c)?;
            }
            if let ::std::option::Option::Some(d) = self.d_option() {
                output.write_raw_tag_bytes(&[16])?;
                output.write_int32(*d)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::ForeignMessage {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(c) = other.c_option() {
                self.set_c(*c);
            }
            if let ::std::option::Option::Some(d) = other.d_option() {
                self.set_d(*d);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::ForeignMessage {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[4]
        }
    }
    impl self::ForeignMessage {
        pub const C_FIELD_NUMBER: i32 = 1;
        pub const C_DEFAULT_VALUE: i32 = 0;
        pub fn c(&self) -> i32 {
            self.c.unwrap_or(Self::C_DEFAULT_VALUE)
        }
        pub fn c_option(&self) -> ::std::option::Option<&i32> {
            self.c.as_ref()
        }
        pub fn c_mut(&mut self) -> &mut i32 {
            self.c.get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_c(&self) -> bool {
            self.c.is_some()
        }
        pub fn set_c(&mut self, value: i32) {
            self.c = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_c(&mut self) -> ::std::option::Option<i32> {
            self.c.take()
        }
        pub fn clear_c(&mut self) {
            self.c = ::std::option::Option::None;
        }
        pub const D_FIELD_NUMBER: i32 = 2;
        pub const D_DEFAULT_VALUE: i32 = 0;
        pub fn d(&self) -> i32 {
            self.d.unwrap_or(Self::D_DEFAULT_VALUE)
        }
        pub fn d_option(&self) -> ::std::option::Option<&i32> {
            self.d.as_ref()
        }
        pub fn d_mut(&mut self) -> &mut i32 {
            self.d.get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_d(&self) -> bool {
            self.d.is_some()
        }
        pub fn set_d(&mut self, value: i32) {
            self.d = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_d(&mut self) -> ::std::option::Option<i32> {
            self.d.take()
        }
        pub fn clear_d(&mut self) {
            self.d = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod foreign_message {
        pub(in super::super) static C_REFLECTOR: ::protrust::reflect::access::VerboseFieldAccessor<
            self::super::ForeignMessage,
            i32,
        > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::ForeignMessage::c_option,
            get_mut: self::super::ForeignMessage::c_mut,
            set: self::super::ForeignMessage::set_c,
            take: self::super::ForeignMessage::take_c,
            clear: self::super::ForeignMessage::clear_c,
        };
        pub(in super::super) static D_REFLECTOR: ::protrust::reflect::access::VerboseFieldAccessor<
            self::super::ForeignMessage,
            i32,
        > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::ForeignMessage::d_option,
            get_mut: self::super::ForeignMessage::d_mut,
            set: self::super::ForeignMessage::set_d,
            take: self::super::ForeignMessage::take_d,
            clear: self::super::ForeignMessage::clear_d,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestReservedFields {
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestReservedFields {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestReservedFields {
        fn merge(&mut self, other: &Self) {
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestReservedFields {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[5]
        }
    }
    impl self::TestReservedFields {}
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestAllExtensions {
        unknown_fields: ::protrust::UnknownFieldSet,
        extensions: ::protrust::ExtensionSet<Self>,
    }
    impl ::protrust::CodedMessage for self::TestAllExtensions {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    _ => {
                        if !self.extensions.merge_from(input)? {
                            self.unknown_fields.merge_from(tag, input)?
                        }
                    }
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            size += self.extensions.calculate_size();
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            self.extensions.write_to(output)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestAllExtensions {
        fn merge(&mut self, other: &Self) {
            self.extensions.merge(&other.extensions);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::ExtendableMessage for self::TestAllExtensions {
        fn registry(&self) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> {
            self.extensions.registry()
        }
        fn replace_registry(
            &mut self,
            extensions: ::std::option::Option<&'static ::protrust::ExtensionRegistry>,
        ) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> {
            self.extensions.replace_registry(extensions)
        }
        fn has_extension<T: ::protrust::ExtensionIdentifier>(&self, extension: &'static T) -> bool {
            self.extensions.has_extension(extension)
        }
        fn has_extension_unchecked<T: ::protrust::ExtensionIdentifier>(
            &self,
            extension: &'static T,
        ) -> bool {
            self.extensions.has_extension_unchecked(extension)
        }
        fn get_value<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> Option<&V> {
            self.extensions.get_value(extension)
        }
        fn get_value_or_default<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync
                + ::std::ops::Deref<Target = L>,
            D: ::std::marker::Sync + ::std::ops::Deref<Target = L>,
            L,
        >(
            &self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> Option<&L> {
            self.extensions.get_value_or_default(extension)
        }
        fn get_repeated_value<
            V: ::std::cmp::PartialEq
                + ::std::clone::Clone
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &self,
            extension: &'static ::protrust::RepeatedExtension<Self, V>,
        ) -> Option<&::protrust::collections::RepeatedField<V>> {
            self.extensions.get_repeated_value(extension)
        }
        fn field<
            V: ::std::default::Default
                + ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> ::std::option::Option<::protrust::ExtensionField<Self, V, D>> {
            self.extensions.field(extension)
        }
        fn repeated_field<
            V: ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static ::protrust::RepeatedExtension<Self, V>,
        ) -> ::std::option::Option<::protrust::RepeatedExtensionField<Self, V>> {
            self.extensions.repeated_field(extension)
        }
    }
    impl ::protrust::Message for self::TestAllExtensions {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[6]
        }
    }
    impl self::TestAllExtensions {}
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct OptionalGroup_extension {
        a: ::std::option::Option<i32>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::OptionalGroup_extension {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    136 | 138 => self.set_a(input.read_int32()?),
                    132 => break,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(a) = self.a_option() {
                size += 2;
                size += ::protrust::io::sizes::int32(*a);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(a) = self.a_option() {
                output.write_raw_tag_bytes(&[136, 1])?;
                output.write_int32(*a)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::OptionalGroup_extension {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(a) = other.a_option() {
                self.set_a(*a);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::OptionalGroup_extension {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[7]
        }
    }
    impl self::OptionalGroup_extension {
        pub const A_FIELD_NUMBER: i32 = 17;
        pub const A_DEFAULT_VALUE: i32 = 0;
        pub fn a(&self) -> i32 {
            self.a.unwrap_or(Self::A_DEFAULT_VALUE)
        }
        pub fn a_option(&self) -> ::std::option::Option<&i32> {
            self.a.as_ref()
        }
        pub fn a_mut(&mut self) -> &mut i32 {
            self.a.get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_a(&self) -> bool {
            self.a.is_some()
        }
        pub fn set_a(&mut self, value: i32) {
            self.a = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_a(&mut self) -> ::std::option::Option<i32> {
            self.a.take()
        }
        pub fn clear_a(&mut self) {
            self.a = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod optional_group_extension {
        pub(in super::super) static A_REFLECTOR: ::protrust::reflect::access::VerboseFieldAccessor<
            self::super::OptionalGroup_extension,
            i32,
        > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::OptionalGroup_extension::a_option,
            get_mut: self::super::OptionalGroup_extension::a_mut,
            set: self::super::OptionalGroup_extension::set_a,
            take: self::super::OptionalGroup_extension::take_a,
            clear: self::super::OptionalGroup_extension::clear_a,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct RepeatedGroup_extension {
        a: ::std::option::Option<i32>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::RepeatedGroup_extension {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    376 | 378 => self.set_a(input.read_int32()?),
                    372 => break,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(a) = self.a_option() {
                size += 2;
                size += ::protrust::io::sizes::int32(*a);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(a) = self.a_option() {
                output.write_raw_tag_bytes(&[248, 2])?;
                output.write_int32(*a)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::RepeatedGroup_extension {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(a) = other.a_option() {
                self.set_a(*a);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::RepeatedGroup_extension {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[8]
        }
    }
    impl self::RepeatedGroup_extension {
        pub const A_FIELD_NUMBER: i32 = 47;
        pub const A_DEFAULT_VALUE: i32 = 0;
        pub fn a(&self) -> i32 {
            self.a.unwrap_or(Self::A_DEFAULT_VALUE)
        }
        pub fn a_option(&self) -> ::std::option::Option<&i32> {
            self.a.as_ref()
        }
        pub fn a_mut(&mut self) -> &mut i32 {
            self.a.get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_a(&self) -> bool {
            self.a.is_some()
        }
        pub fn set_a(&mut self, value: i32) {
            self.a = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_a(&mut self) -> ::std::option::Option<i32> {
            self.a.take()
        }
        pub fn clear_a(&mut self) {
            self.a = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod repeated_group_extension {
        pub(in super::super) static A_REFLECTOR: ::protrust::reflect::access::VerboseFieldAccessor<
            self::super::RepeatedGroup_extension,
            i32,
        > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::RepeatedGroup_extension::a_option,
            get_mut: self::super::RepeatedGroup_extension::a_mut,
            set: self::super::RepeatedGroup_extension::set_a,
            take: self::super::RepeatedGroup_extension::take_a,
            clear: self::super::RepeatedGroup_extension::clear_a,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestGroup {
        optionalgroup: ::std::option::Option<::std::boxed::Box<self::test_group::OptionalGroup>>,
        optional_foreign_enum: ::std::option::Option<::protrust::EnumValue<self::ForeignEnum>>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestGroup {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    131 => input.read_group(self.optionalgroup_mut())?,
                    176 | 178 => self.set_optional_foreign_enum(input.read_enum_value()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(optionalgroup) = self.optionalgroup() {
                size += 2;
                size += ::protrust::io::sizes::group(optionalgroup);
                size += 2;
            }
            if let ::std::option::Option::Some(optional_foreign_enum) =
                self.optional_foreign_enum_option()
            {
                size += 2;
                size += ::protrust::io::sizes::enum_value(*optional_foreign_enum);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(optionalgroup) = self.optionalgroup() {
                output.write_raw_tag_bytes(&[131, 1])?;
                output.write_group(optionalgroup)?;
                output.write_raw_tag_bytes(&[132, 1])?;
            }
            if let ::std::option::Option::Some(optional_foreign_enum) =
                self.optional_foreign_enum_option()
            {
                output.write_raw_tag_bytes(&[176, 1])?;
                output.write_enum_value(*optional_foreign_enum)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(optionalgroup) = self.optionalgroup() {
                if !::protrust::CodedMessage::is_initialized(optionalgroup) {
                    return false;
                }
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestGroup {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(optionalgroup) = &other.optionalgroup() {
                ::protrust::LiteMessage::merge(self.optionalgroup_mut(), optionalgroup);
            }
            if let ::std::option::Option::Some(optional_foreign_enum) =
                other.optional_foreign_enum_option()
            {
                self.set_optional_foreign_enum(*optional_foreign_enum);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestGroup {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[9]
        }
    }
    impl self::TestGroup {
        pub const OPTIONALGROUP_FIELD_NUMBER: i32 = 16;
        pub fn optionalgroup(&self) -> ::std::option::Option<&self::test_group::OptionalGroup> {
            self.optionalgroup.as_ref().map(|v| &**v)
        }
        pub fn optionalgroup_mut(&mut self) -> &mut self::test_group::OptionalGroup {
            self.optionalgroup
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optionalgroup(&self) -> bool {
            self.optionalgroup.is_some()
        }
        pub fn set_optionalgroup(&mut self, value: self::test_group::OptionalGroup) {
            self.optionalgroup = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optionalgroup(
            &mut self,
        ) -> ::std::option::Option<self::test_group::OptionalGroup> {
            self.optionalgroup.take().map(|v| *v)
        }
        pub fn clear_optionalgroup(&mut self) {
            self.optionalgroup = ::std::option::Option::None;
        }
        pub const OPTIONAL_FOREIGN_ENUM_FIELD_NUMBER: i32 = 22;
        pub const OPTIONAL_FOREIGN_ENUM_DEFAULT_VALUE: ::protrust::EnumValue<self::ForeignEnum> =
            ::protrust::EnumValue::Undefined(0);
        pub fn optional_foreign_enum(&self) -> ::protrust::EnumValue<self::ForeignEnum> {
            self.optional_foreign_enum
                .unwrap_or(Self::OPTIONAL_FOREIGN_ENUM_DEFAULT_VALUE)
        }
        pub fn optional_foreign_enum_option(
            &self,
        ) -> ::std::option::Option<&::protrust::EnumValue<self::ForeignEnum>> {
            self.optional_foreign_enum.as_ref()
        }
        pub fn optional_foreign_enum_mut(
            &mut self,
        ) -> &mut ::protrust::EnumValue<self::ForeignEnum> {
            self.optional_foreign_enum
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_foreign_enum(&self) -> bool {
            self.optional_foreign_enum.is_some()
        }
        pub fn set_optional_foreign_enum(
            &mut self,
            value: ::protrust::EnumValue<self::ForeignEnum>,
        ) {
            self.optional_foreign_enum =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_foreign_enum(
            &mut self,
        ) -> ::std::option::Option<::protrust::EnumValue<self::ForeignEnum>> {
            self.optional_foreign_enum.take()
        }
        pub fn clear_optional_foreign_enum(&mut self) {
            self.optional_foreign_enum = ::std::option::Option::None;
        }
    }
    pub mod test_group {
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct OptionalGroup {
            a: ::std::option::Option<i32>,
            unknown_fields: ::protrust::UnknownFieldSet,
        }
        impl ::protrust::CodedMessage for self::OptionalGroup {
            fn merge_from(
                &mut self,
                input: &mut ::protrust::io::CodedInput,
            ) -> ::protrust::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        136 | 138 => self.set_a(input.read_int32()?),
                        132 => break,
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> i32 {
                let mut size = 0i32;
                if let ::std::option::Option::Some(a) = self.a_option() {
                    size += 2;
                    size += ::protrust::io::sizes::int32(*a);
                }
                size += self.unknown_fields.calculate_size();
                size
            }
            fn write_to(
                &self,
                output: &mut ::protrust::io::CodedOutput,
            ) -> ::protrust::io::OutputResult {
                if let ::std::option::Option::Some(a) = self.a_option() {
                    output.write_raw_tag_bytes(&[136, 1])?;
                    output.write_int32(*a)?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                true
            }
        }
        impl ::protrust::LiteMessage for self::OptionalGroup {
            fn merge(&mut self, other: &Self) {
                if let ::std::option::Option::Some(a) = other.a_option() {
                    self.set_a(*a);
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl ::protrust::Message for self::OptionalGroup {
            fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
                &<self::super::TestGroup as ::protrust::Message>::descriptor().messages()[0]
            }
        }
        impl self::OptionalGroup {
            pub const A_FIELD_NUMBER: i32 = 17;
            pub const A_DEFAULT_VALUE: i32 = 0;
            pub fn a(&self) -> i32 {
                self.a.unwrap_or(Self::A_DEFAULT_VALUE)
            }
            pub fn a_option(&self) -> ::std::option::Option<&i32> {
                self.a.as_ref()
            }
            pub fn a_mut(&mut self) -> &mut i32 {
                self.a.get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_a(&self) -> bool {
                self.a.is_some()
            }
            pub fn set_a(&mut self, value: i32) {
                self.a = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_a(&mut self) -> ::std::option::Option<i32> {
                self.a.take()
            }
            pub fn clear_a(&mut self) {
                self.a = ::std::option::Option::None;
            }
        }
        pub(in super::super::super) mod optional_group {
            pub(in super::super::super) static A_REFLECTOR:
                ::protrust::reflect::access::VerboseFieldAccessor<self::super::OptionalGroup, i32> =
                ::protrust::reflect::access::VerboseFieldAccessor {
                    get_option: self::super::OptionalGroup::a_option,
                    get_mut: self::super::OptionalGroup::a_mut,
                    set: self::super::OptionalGroup::set_a,
                    take: self::super::OptionalGroup::take_a,
                    clear: self::super::OptionalGroup::clear_a,
                };
        }
        pub(in super::super) static OPTIONALGROUP_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestGroup,
                self::OptionalGroup,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestGroup::optionalgroup,
            get_mut: self::super::TestGroup::optionalgroup_mut,
            set: self::super::TestGroup::set_optionalgroup,
            take: self::super::TestGroup::take_optionalgroup,
            clear: self::super::TestGroup::clear_optionalgroup,
        };
        pub(in super::super) static OPTIONAL_FOREIGN_ENUM_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestGroup,
                ::protrust::EnumValue<self::super::ForeignEnum>,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestGroup::optional_foreign_enum_option,
            get_mut: self::super::TestGroup::optional_foreign_enum_mut,
            set: self::super::TestGroup::set_optional_foreign_enum,
            take: self::super::TestGroup::take_optional_foreign_enum,
            clear: self::super::TestGroup::clear_optional_foreign_enum,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestGroupExtension {
        unknown_fields: ::protrust::UnknownFieldSet,
        extensions: ::protrust::ExtensionSet<Self>,
    }
    impl ::protrust::CodedMessage for self::TestGroupExtension {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    _ => {
                        if !self.extensions.merge_from(input)? {
                            self.unknown_fields.merge_from(tag, input)?
                        }
                    }
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            size += self.extensions.calculate_size();
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            self.extensions.write_to(output)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestGroupExtension {
        fn merge(&mut self, other: &Self) {
            self.extensions.merge(&other.extensions);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::ExtendableMessage for self::TestGroupExtension {
        fn registry(&self) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> {
            self.extensions.registry()
        }
        fn replace_registry(
            &mut self,
            extensions: ::std::option::Option<&'static ::protrust::ExtensionRegistry>,
        ) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> {
            self.extensions.replace_registry(extensions)
        }
        fn has_extension<T: ::protrust::ExtensionIdentifier>(&self, extension: &'static T) -> bool {
            self.extensions.has_extension(extension)
        }
        fn has_extension_unchecked<T: ::protrust::ExtensionIdentifier>(
            &self,
            extension: &'static T,
        ) -> bool {
            self.extensions.has_extension_unchecked(extension)
        }
        fn get_value<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> Option<&V> {
            self.extensions.get_value(extension)
        }
        fn get_value_or_default<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync
                + ::std::ops::Deref<Target = L>,
            D: ::std::marker::Sync + ::std::ops::Deref<Target = L>,
            L,
        >(
            &self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> Option<&L> {
            self.extensions.get_value_or_default(extension)
        }
        fn get_repeated_value<
            V: ::std::cmp::PartialEq
                + ::std::clone::Clone
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &self,
            extension: &'static ::protrust::RepeatedExtension<Self, V>,
        ) -> Option<&::protrust::collections::RepeatedField<V>> {
            self.extensions.get_repeated_value(extension)
        }
        fn field<
            V: ::std::default::Default
                + ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> ::std::option::Option<::protrust::ExtensionField<Self, V, D>> {
            self.extensions.field(extension)
        }
        fn repeated_field<
            V: ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static ::protrust::RepeatedExtension<Self, V>,
        ) -> ::std::option::Option<::protrust::RepeatedExtensionField<Self, V>> {
            self.extensions.repeated_field(extension)
        }
    }
    impl ::protrust::Message for self::TestGroupExtension {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[10]
        }
    }
    impl self::TestGroupExtension {}
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestNestedExtension {
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestNestedExtension {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestNestedExtension {
        fn merge(&mut self, other: &Self) {
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestNestedExtension {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[11]
        }
    }
    impl self::TestNestedExtension {}
    pub mod test_nested_extension {
        pub static TEST: ::protrust::Extension<
            self::super::TestAllExtensions,
            ::std::string::String,
            &'static str,
        > = ::protrust::Extension::string(8018, "test");
        pub static NESTED_STRING_EXTENSION: ::protrust::Extension<
            self::super::TestAllExtensions,
            ::std::string::String,
            &'static str,
        > = ::protrust::Extension::string(8026, "");
        pub static OPTIONALGROUP_EXTENSION: ::protrust::Extension<
            self::super::TestGroupExtension,
            self::OptionalGroup_extension,
            self::OptionalGroup_extension,
        > = ::protrust::Extension::group(131, 132);
        pub static OPTIONAL_FOREIGN_ENUM_EXTENSION: ::protrust::Extension<
            self::super::TestGroupExtension,
            ::protrust::EnumValue<self::super::ForeignEnum>,
            ::protrust::EnumValue<self::super::ForeignEnum>,
        > = ::protrust::Extension::enum_value(176, ::protrust::EnumValue::Undefined(0));
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct OptionalGroup_extension {
            a: ::std::option::Option<i32>,
            unknown_fields: ::protrust::UnknownFieldSet,
        }
        impl ::protrust::CodedMessage for self::OptionalGroup_extension {
            fn merge_from(
                &mut self,
                input: &mut ::protrust::io::CodedInput,
            ) -> ::protrust::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        136 | 138 => self.set_a(input.read_int32()?),
                        132 => break,
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> i32 {
                let mut size = 0i32;
                if let ::std::option::Option::Some(a) = self.a_option() {
                    size += 2;
                    size += ::protrust::io::sizes::int32(*a);
                }
                size += self.unknown_fields.calculate_size();
                size
            }
            fn write_to(
                &self,
                output: &mut ::protrust::io::CodedOutput,
            ) -> ::protrust::io::OutputResult {
                if let ::std::option::Option::Some(a) = self.a_option() {
                    output.write_raw_tag_bytes(&[136, 1])?;
                    output.write_int32(*a)?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                true
            }
        }
        impl ::protrust::LiteMessage for self::OptionalGroup_extension {
            fn merge(&mut self, other: &Self) {
                if let ::std::option::Option::Some(a) = other.a_option() {
                    self.set_a(*a);
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl ::protrust::Message for self::OptionalGroup_extension {
            fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
                &<self::super::TestNestedExtension as ::protrust::Message>::descriptor().messages()
                    [0]
            }
        }
        impl self::OptionalGroup_extension {
            pub const A_FIELD_NUMBER: i32 = 17;
            pub const A_DEFAULT_VALUE: i32 = 0;
            pub fn a(&self) -> i32 {
                self.a.unwrap_or(Self::A_DEFAULT_VALUE)
            }
            pub fn a_option(&self) -> ::std::option::Option<&i32> {
                self.a.as_ref()
            }
            pub fn a_mut(&mut self) -> &mut i32 {
                self.a.get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_a(&self) -> bool {
                self.a.is_some()
            }
            pub fn set_a(&mut self, value: i32) {
                self.a = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_a(&mut self) -> ::std::option::Option<i32> {
                self.a.take()
            }
            pub fn clear_a(&mut self) {
                self.a = ::std::option::Option::None;
            }
        }
        pub(in super::super::super) mod optional_group_extension {
            pub(in super::super::super) static A_REFLECTOR:
                ::protrust::reflect::access::VerboseFieldAccessor<
                    self::super::OptionalGroup_extension,
                    i32,
                > = ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::OptionalGroup_extension::a_option,
                get_mut: self::super::OptionalGroup_extension::a_mut,
                set: self::super::OptionalGroup_extension::set_a,
                take: self::super::OptionalGroup_extension::take_a,
                clear: self::super::OptionalGroup_extension::clear_a,
            };
        }
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestRequired {
        a: ::std::option::Option<i32>,
        dummy2: ::std::option::Option<i32>,
        b: ::std::option::Option<i32>,
        dummy4: ::std::option::Option<i32>,
        dummy5: ::std::option::Option<i32>,
        dummy6: ::std::option::Option<i32>,
        dummy7: ::std::option::Option<i32>,
        dummy8: ::std::option::Option<i32>,
        dummy9: ::std::option::Option<i32>,
        dummy10: ::std::option::Option<i32>,
        dummy11: ::std::option::Option<i32>,
        dummy12: ::std::option::Option<i32>,
        dummy13: ::std::option::Option<i32>,
        dummy14: ::std::option::Option<i32>,
        dummy15: ::std::option::Option<i32>,
        dummy16: ::std::option::Option<i32>,
        dummy17: ::std::option::Option<i32>,
        dummy18: ::std::option::Option<i32>,
        dummy19: ::std::option::Option<i32>,
        dummy20: ::std::option::Option<i32>,
        dummy21: ::std::option::Option<i32>,
        dummy22: ::std::option::Option<i32>,
        dummy23: ::std::option::Option<i32>,
        dummy24: ::std::option::Option<i32>,
        dummy25: ::std::option::Option<i32>,
        dummy26: ::std::option::Option<i32>,
        dummy27: ::std::option::Option<i32>,
        dummy28: ::std::option::Option<i32>,
        dummy29: ::std::option::Option<i32>,
        dummy30: ::std::option::Option<i32>,
        dummy31: ::std::option::Option<i32>,
        dummy32: ::std::option::Option<i32>,
        c: ::std::option::Option<i32>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestRequired {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.set_a(input.read_int32()?),
                    16 | 18 => self.set_dummy2(input.read_int32()?),
                    24 | 26 => self.set_b(input.read_int32()?),
                    32 | 34 => self.set_dummy4(input.read_int32()?),
                    40 | 42 => self.set_dummy5(input.read_int32()?),
                    48 | 50 => self.set_dummy6(input.read_int32()?),
                    56 | 58 => self.set_dummy7(input.read_int32()?),
                    64 | 66 => self.set_dummy8(input.read_int32()?),
                    72 | 74 => self.set_dummy9(input.read_int32()?),
                    80 | 82 => self.set_dummy10(input.read_int32()?),
                    88 | 90 => self.set_dummy11(input.read_int32()?),
                    96 | 98 => self.set_dummy12(input.read_int32()?),
                    104 | 106 => self.set_dummy13(input.read_int32()?),
                    112 | 114 => self.set_dummy14(input.read_int32()?),
                    120 | 122 => self.set_dummy15(input.read_int32()?),
                    128 | 130 => self.set_dummy16(input.read_int32()?),
                    136 | 138 => self.set_dummy17(input.read_int32()?),
                    144 | 146 => self.set_dummy18(input.read_int32()?),
                    152 | 154 => self.set_dummy19(input.read_int32()?),
                    160 | 162 => self.set_dummy20(input.read_int32()?),
                    168 | 170 => self.set_dummy21(input.read_int32()?),
                    176 | 178 => self.set_dummy22(input.read_int32()?),
                    184 | 186 => self.set_dummy23(input.read_int32()?),
                    192 | 194 => self.set_dummy24(input.read_int32()?),
                    200 | 202 => self.set_dummy25(input.read_int32()?),
                    208 | 210 => self.set_dummy26(input.read_int32()?),
                    216 | 218 => self.set_dummy27(input.read_int32()?),
                    224 | 226 => self.set_dummy28(input.read_int32()?),
                    232 | 234 => self.set_dummy29(input.read_int32()?),
                    240 | 242 => self.set_dummy30(input.read_int32()?),
                    248 | 250 => self.set_dummy31(input.read_int32()?),
                    256 | 258 => self.set_dummy32(input.read_int32()?),
                    264 | 266 => self.set_c(input.read_int32()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(a) = self.a_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*a);
            }
            if let ::std::option::Option::Some(dummy2) = self.dummy2_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*dummy2);
            }
            if let ::std::option::Option::Some(b) = self.b_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*b);
            }
            if let ::std::option::Option::Some(dummy4) = self.dummy4_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*dummy4);
            }
            if let ::std::option::Option::Some(dummy5) = self.dummy5_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*dummy5);
            }
            if let ::std::option::Option::Some(dummy6) = self.dummy6_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*dummy6);
            }
            if let ::std::option::Option::Some(dummy7) = self.dummy7_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*dummy7);
            }
            if let ::std::option::Option::Some(dummy8) = self.dummy8_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*dummy8);
            }
            if let ::std::option::Option::Some(dummy9) = self.dummy9_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*dummy9);
            }
            if let ::std::option::Option::Some(dummy10) = self.dummy10_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*dummy10);
            }
            if let ::std::option::Option::Some(dummy11) = self.dummy11_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*dummy11);
            }
            if let ::std::option::Option::Some(dummy12) = self.dummy12_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*dummy12);
            }
            if let ::std::option::Option::Some(dummy13) = self.dummy13_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*dummy13);
            }
            if let ::std::option::Option::Some(dummy14) = self.dummy14_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*dummy14);
            }
            if let ::std::option::Option::Some(dummy15) = self.dummy15_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*dummy15);
            }
            if let ::std::option::Option::Some(dummy16) = self.dummy16_option() {
                size += 2;
                size += ::protrust::io::sizes::int32(*dummy16);
            }
            if let ::std::option::Option::Some(dummy17) = self.dummy17_option() {
                size += 2;
                size += ::protrust::io::sizes::int32(*dummy17);
            }
            if let ::std::option::Option::Some(dummy18) = self.dummy18_option() {
                size += 2;
                size += ::protrust::io::sizes::int32(*dummy18);
            }
            if let ::std::option::Option::Some(dummy19) = self.dummy19_option() {
                size += 2;
                size += ::protrust::io::sizes::int32(*dummy19);
            }
            if let ::std::option::Option::Some(dummy20) = self.dummy20_option() {
                size += 2;
                size += ::protrust::io::sizes::int32(*dummy20);
            }
            if let ::std::option::Option::Some(dummy21) = self.dummy21_option() {
                size += 2;
                size += ::protrust::io::sizes::int32(*dummy21);
            }
            if let ::std::option::Option::Some(dummy22) = self.dummy22_option() {
                size += 2;
                size += ::protrust::io::sizes::int32(*dummy22);
            }
            if let ::std::option::Option::Some(dummy23) = self.dummy23_option() {
                size += 2;
                size += ::protrust::io::sizes::int32(*dummy23);
            }
            if let ::std::option::Option::Some(dummy24) = self.dummy24_option() {
                size += 2;
                size += ::protrust::io::sizes::int32(*dummy24);
            }
            if let ::std::option::Option::Some(dummy25) = self.dummy25_option() {
                size += 2;
                size += ::protrust::io::sizes::int32(*dummy25);
            }
            if let ::std::option::Option::Some(dummy26) = self.dummy26_option() {
                size += 2;
                size += ::protrust::io::sizes::int32(*dummy26);
            }
            if let ::std::option::Option::Some(dummy27) = self.dummy27_option() {
                size += 2;
                size += ::protrust::io::sizes::int32(*dummy27);
            }
            if let ::std::option::Option::Some(dummy28) = self.dummy28_option() {
                size += 2;
                size += ::protrust::io::sizes::int32(*dummy28);
            }
            if let ::std::option::Option::Some(dummy29) = self.dummy29_option() {
                size += 2;
                size += ::protrust::io::sizes::int32(*dummy29);
            }
            if let ::std::option::Option::Some(dummy30) = self.dummy30_option() {
                size += 2;
                size += ::protrust::io::sizes::int32(*dummy30);
            }
            if let ::std::option::Option::Some(dummy31) = self.dummy31_option() {
                size += 2;
                size += ::protrust::io::sizes::int32(*dummy31);
            }
            if let ::std::option::Option::Some(dummy32) = self.dummy32_option() {
                size += 2;
                size += ::protrust::io::sizes::int32(*dummy32);
            }
            if let ::std::option::Option::Some(c) = self.c_option() {
                size += 2;
                size += ::protrust::io::sizes::int32(*c);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(a) = self.a_option() {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(*a)?;
            }
            if let ::std::option::Option::Some(dummy2) = self.dummy2_option() {
                output.write_raw_tag_bytes(&[16])?;
                output.write_int32(*dummy2)?;
            }
            if let ::std::option::Option::Some(b) = self.b_option() {
                output.write_raw_tag_bytes(&[24])?;
                output.write_int32(*b)?;
            }
            if let ::std::option::Option::Some(dummy4) = self.dummy4_option() {
                output.write_raw_tag_bytes(&[32])?;
                output.write_int32(*dummy4)?;
            }
            if let ::std::option::Option::Some(dummy5) = self.dummy5_option() {
                output.write_raw_tag_bytes(&[40])?;
                output.write_int32(*dummy5)?;
            }
            if let ::std::option::Option::Some(dummy6) = self.dummy6_option() {
                output.write_raw_tag_bytes(&[48])?;
                output.write_int32(*dummy6)?;
            }
            if let ::std::option::Option::Some(dummy7) = self.dummy7_option() {
                output.write_raw_tag_bytes(&[56])?;
                output.write_int32(*dummy7)?;
            }
            if let ::std::option::Option::Some(dummy8) = self.dummy8_option() {
                output.write_raw_tag_bytes(&[64])?;
                output.write_int32(*dummy8)?;
            }
            if let ::std::option::Option::Some(dummy9) = self.dummy9_option() {
                output.write_raw_tag_bytes(&[72])?;
                output.write_int32(*dummy9)?;
            }
            if let ::std::option::Option::Some(dummy10) = self.dummy10_option() {
                output.write_raw_tag_bytes(&[80])?;
                output.write_int32(*dummy10)?;
            }
            if let ::std::option::Option::Some(dummy11) = self.dummy11_option() {
                output.write_raw_tag_bytes(&[88])?;
                output.write_int32(*dummy11)?;
            }
            if let ::std::option::Option::Some(dummy12) = self.dummy12_option() {
                output.write_raw_tag_bytes(&[96])?;
                output.write_int32(*dummy12)?;
            }
            if let ::std::option::Option::Some(dummy13) = self.dummy13_option() {
                output.write_raw_tag_bytes(&[104])?;
                output.write_int32(*dummy13)?;
            }
            if let ::std::option::Option::Some(dummy14) = self.dummy14_option() {
                output.write_raw_tag_bytes(&[112])?;
                output.write_int32(*dummy14)?;
            }
            if let ::std::option::Option::Some(dummy15) = self.dummy15_option() {
                output.write_raw_tag_bytes(&[120])?;
                output.write_int32(*dummy15)?;
            }
            if let ::std::option::Option::Some(dummy16) = self.dummy16_option() {
                output.write_raw_tag_bytes(&[128, 1])?;
                output.write_int32(*dummy16)?;
            }
            if let ::std::option::Option::Some(dummy17) = self.dummy17_option() {
                output.write_raw_tag_bytes(&[136, 1])?;
                output.write_int32(*dummy17)?;
            }
            if let ::std::option::Option::Some(dummy18) = self.dummy18_option() {
                output.write_raw_tag_bytes(&[144, 1])?;
                output.write_int32(*dummy18)?;
            }
            if let ::std::option::Option::Some(dummy19) = self.dummy19_option() {
                output.write_raw_tag_bytes(&[152, 1])?;
                output.write_int32(*dummy19)?;
            }
            if let ::std::option::Option::Some(dummy20) = self.dummy20_option() {
                output.write_raw_tag_bytes(&[160, 1])?;
                output.write_int32(*dummy20)?;
            }
            if let ::std::option::Option::Some(dummy21) = self.dummy21_option() {
                output.write_raw_tag_bytes(&[168, 1])?;
                output.write_int32(*dummy21)?;
            }
            if let ::std::option::Option::Some(dummy22) = self.dummy22_option() {
                output.write_raw_tag_bytes(&[176, 1])?;
                output.write_int32(*dummy22)?;
            }
            if let ::std::option::Option::Some(dummy23) = self.dummy23_option() {
                output.write_raw_tag_bytes(&[184, 1])?;
                output.write_int32(*dummy23)?;
            }
            if let ::std::option::Option::Some(dummy24) = self.dummy24_option() {
                output.write_raw_tag_bytes(&[192, 1])?;
                output.write_int32(*dummy24)?;
            }
            if let ::std::option::Option::Some(dummy25) = self.dummy25_option() {
                output.write_raw_tag_bytes(&[200, 1])?;
                output.write_int32(*dummy25)?;
            }
            if let ::std::option::Option::Some(dummy26) = self.dummy26_option() {
                output.write_raw_tag_bytes(&[208, 1])?;
                output.write_int32(*dummy26)?;
            }
            if let ::std::option::Option::Some(dummy27) = self.dummy27_option() {
                output.write_raw_tag_bytes(&[216, 1])?;
                output.write_int32(*dummy27)?;
            }
            if let ::std::option::Option::Some(dummy28) = self.dummy28_option() {
                output.write_raw_tag_bytes(&[224, 1])?;
                output.write_int32(*dummy28)?;
            }
            if let ::std::option::Option::Some(dummy29) = self.dummy29_option() {
                output.write_raw_tag_bytes(&[232, 1])?;
                output.write_int32(*dummy29)?;
            }
            if let ::std::option::Option::Some(dummy30) = self.dummy30_option() {
                output.write_raw_tag_bytes(&[240, 1])?;
                output.write_int32(*dummy30)?;
            }
            if let ::std::option::Option::Some(dummy31) = self.dummy31_option() {
                output.write_raw_tag_bytes(&[248, 1])?;
                output.write_int32(*dummy31)?;
            }
            if let ::std::option::Option::Some(dummy32) = self.dummy32_option() {
                output.write_raw_tag_bytes(&[128, 2])?;
                output.write_int32(*dummy32)?;
            }
            if let ::std::option::Option::Some(c) = self.c_option() {
                output.write_raw_tag_bytes(&[136, 2])?;
                output.write_int32(*c)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if !self.has_a() {
                return false;
            }
            if !self.has_b() {
                return false;
            }
            if !self.has_c() {
                return false;
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestRequired {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(a) = other.a_option() {
                self.set_a(*a);
            }
            if let ::std::option::Option::Some(dummy2) = other.dummy2_option() {
                self.set_dummy2(*dummy2);
            }
            if let ::std::option::Option::Some(b) = other.b_option() {
                self.set_b(*b);
            }
            if let ::std::option::Option::Some(dummy4) = other.dummy4_option() {
                self.set_dummy4(*dummy4);
            }
            if let ::std::option::Option::Some(dummy5) = other.dummy5_option() {
                self.set_dummy5(*dummy5);
            }
            if let ::std::option::Option::Some(dummy6) = other.dummy6_option() {
                self.set_dummy6(*dummy6);
            }
            if let ::std::option::Option::Some(dummy7) = other.dummy7_option() {
                self.set_dummy7(*dummy7);
            }
            if let ::std::option::Option::Some(dummy8) = other.dummy8_option() {
                self.set_dummy8(*dummy8);
            }
            if let ::std::option::Option::Some(dummy9) = other.dummy9_option() {
                self.set_dummy9(*dummy9);
            }
            if let ::std::option::Option::Some(dummy10) = other.dummy10_option() {
                self.set_dummy10(*dummy10);
            }
            if let ::std::option::Option::Some(dummy11) = other.dummy11_option() {
                self.set_dummy11(*dummy11);
            }
            if let ::std::option::Option::Some(dummy12) = other.dummy12_option() {
                self.set_dummy12(*dummy12);
            }
            if let ::std::option::Option::Some(dummy13) = other.dummy13_option() {
                self.set_dummy13(*dummy13);
            }
            if let ::std::option::Option::Some(dummy14) = other.dummy14_option() {
                self.set_dummy14(*dummy14);
            }
            if let ::std::option::Option::Some(dummy15) = other.dummy15_option() {
                self.set_dummy15(*dummy15);
            }
            if let ::std::option::Option::Some(dummy16) = other.dummy16_option() {
                self.set_dummy16(*dummy16);
            }
            if let ::std::option::Option::Some(dummy17) = other.dummy17_option() {
                self.set_dummy17(*dummy17);
            }
            if let ::std::option::Option::Some(dummy18) = other.dummy18_option() {
                self.set_dummy18(*dummy18);
            }
            if let ::std::option::Option::Some(dummy19) = other.dummy19_option() {
                self.set_dummy19(*dummy19);
            }
            if let ::std::option::Option::Some(dummy20) = other.dummy20_option() {
                self.set_dummy20(*dummy20);
            }
            if let ::std::option::Option::Some(dummy21) = other.dummy21_option() {
                self.set_dummy21(*dummy21);
            }
            if let ::std::option::Option::Some(dummy22) = other.dummy22_option() {
                self.set_dummy22(*dummy22);
            }
            if let ::std::option::Option::Some(dummy23) = other.dummy23_option() {
                self.set_dummy23(*dummy23);
            }
            if let ::std::option::Option::Some(dummy24) = other.dummy24_option() {
                self.set_dummy24(*dummy24);
            }
            if let ::std::option::Option::Some(dummy25) = other.dummy25_option() {
                self.set_dummy25(*dummy25);
            }
            if let ::std::option::Option::Some(dummy26) = other.dummy26_option() {
                self.set_dummy26(*dummy26);
            }
            if let ::std::option::Option::Some(dummy27) = other.dummy27_option() {
                self.set_dummy27(*dummy27);
            }
            if let ::std::option::Option::Some(dummy28) = other.dummy28_option() {
                self.set_dummy28(*dummy28);
            }
            if let ::std::option::Option::Some(dummy29) = other.dummy29_option() {
                self.set_dummy29(*dummy29);
            }
            if let ::std::option::Option::Some(dummy30) = other.dummy30_option() {
                self.set_dummy30(*dummy30);
            }
            if let ::std::option::Option::Some(dummy31) = other.dummy31_option() {
                self.set_dummy31(*dummy31);
            }
            if let ::std::option::Option::Some(dummy32) = other.dummy32_option() {
                self.set_dummy32(*dummy32);
            }
            if let ::std::option::Option::Some(c) = other.c_option() {
                self.set_c(*c);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestRequired {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[12]
        }
    }
    impl self::TestRequired {
        pub const A_FIELD_NUMBER: i32 = 1;
        pub const A_DEFAULT_VALUE: i32 = 0;
        pub fn a(&self) -> i32 {
            self.a.unwrap_or(Self::A_DEFAULT_VALUE)
        }
        pub fn a_option(&self) -> ::std::option::Option<&i32> {
            self.a.as_ref()
        }
        pub fn a_mut(&mut self) -> &mut i32 {
            self.a.get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_a(&self) -> bool {
            self.a.is_some()
        }
        pub fn set_a(&mut self, value: i32) {
            self.a = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_a(&mut self) -> ::std::option::Option<i32> {
            self.a.take()
        }
        pub fn clear_a(&mut self) {
            self.a = ::std::option::Option::None;
        }
        pub const DUMMY2_FIELD_NUMBER: i32 = 2;
        pub const DUMMY2_DEFAULT_VALUE: i32 = 0;
        pub fn dummy2(&self) -> i32 {
            self.dummy2.unwrap_or(Self::DUMMY2_DEFAULT_VALUE)
        }
        pub fn dummy2_option(&self) -> ::std::option::Option<&i32> {
            self.dummy2.as_ref()
        }
        pub fn dummy2_mut(&mut self) -> &mut i32 {
            self.dummy2
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy2(&self) -> bool {
            self.dummy2.is_some()
        }
        pub fn set_dummy2(&mut self, value: i32) {
            self.dummy2 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy2(&mut self) -> ::std::option::Option<i32> {
            self.dummy2.take()
        }
        pub fn clear_dummy2(&mut self) {
            self.dummy2 = ::std::option::Option::None;
        }
        pub const B_FIELD_NUMBER: i32 = 3;
        pub const B_DEFAULT_VALUE: i32 = 0;
        pub fn b(&self) -> i32 {
            self.b.unwrap_or(Self::B_DEFAULT_VALUE)
        }
        pub fn b_option(&self) -> ::std::option::Option<&i32> {
            self.b.as_ref()
        }
        pub fn b_mut(&mut self) -> &mut i32 {
            self.b.get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_b(&self) -> bool {
            self.b.is_some()
        }
        pub fn set_b(&mut self, value: i32) {
            self.b = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_b(&mut self) -> ::std::option::Option<i32> {
            self.b.take()
        }
        pub fn clear_b(&mut self) {
            self.b = ::std::option::Option::None;
        }
        pub const DUMMY4_FIELD_NUMBER: i32 = 4;
        pub const DUMMY4_DEFAULT_VALUE: i32 = 0;
        pub fn dummy4(&self) -> i32 {
            self.dummy4.unwrap_or(Self::DUMMY4_DEFAULT_VALUE)
        }
        pub fn dummy4_option(&self) -> ::std::option::Option<&i32> {
            self.dummy4.as_ref()
        }
        pub fn dummy4_mut(&mut self) -> &mut i32 {
            self.dummy4
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy4(&self) -> bool {
            self.dummy4.is_some()
        }
        pub fn set_dummy4(&mut self, value: i32) {
            self.dummy4 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy4(&mut self) -> ::std::option::Option<i32> {
            self.dummy4.take()
        }
        pub fn clear_dummy4(&mut self) {
            self.dummy4 = ::std::option::Option::None;
        }
        pub const DUMMY5_FIELD_NUMBER: i32 = 5;
        pub const DUMMY5_DEFAULT_VALUE: i32 = 0;
        pub fn dummy5(&self) -> i32 {
            self.dummy5.unwrap_or(Self::DUMMY5_DEFAULT_VALUE)
        }
        pub fn dummy5_option(&self) -> ::std::option::Option<&i32> {
            self.dummy5.as_ref()
        }
        pub fn dummy5_mut(&mut self) -> &mut i32 {
            self.dummy5
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy5(&self) -> bool {
            self.dummy5.is_some()
        }
        pub fn set_dummy5(&mut self, value: i32) {
            self.dummy5 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy5(&mut self) -> ::std::option::Option<i32> {
            self.dummy5.take()
        }
        pub fn clear_dummy5(&mut self) {
            self.dummy5 = ::std::option::Option::None;
        }
        pub const DUMMY6_FIELD_NUMBER: i32 = 6;
        pub const DUMMY6_DEFAULT_VALUE: i32 = 0;
        pub fn dummy6(&self) -> i32 {
            self.dummy6.unwrap_or(Self::DUMMY6_DEFAULT_VALUE)
        }
        pub fn dummy6_option(&self) -> ::std::option::Option<&i32> {
            self.dummy6.as_ref()
        }
        pub fn dummy6_mut(&mut self) -> &mut i32 {
            self.dummy6
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy6(&self) -> bool {
            self.dummy6.is_some()
        }
        pub fn set_dummy6(&mut self, value: i32) {
            self.dummy6 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy6(&mut self) -> ::std::option::Option<i32> {
            self.dummy6.take()
        }
        pub fn clear_dummy6(&mut self) {
            self.dummy6 = ::std::option::Option::None;
        }
        pub const DUMMY7_FIELD_NUMBER: i32 = 7;
        pub const DUMMY7_DEFAULT_VALUE: i32 = 0;
        pub fn dummy7(&self) -> i32 {
            self.dummy7.unwrap_or(Self::DUMMY7_DEFAULT_VALUE)
        }
        pub fn dummy7_option(&self) -> ::std::option::Option<&i32> {
            self.dummy7.as_ref()
        }
        pub fn dummy7_mut(&mut self) -> &mut i32 {
            self.dummy7
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy7(&self) -> bool {
            self.dummy7.is_some()
        }
        pub fn set_dummy7(&mut self, value: i32) {
            self.dummy7 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy7(&mut self) -> ::std::option::Option<i32> {
            self.dummy7.take()
        }
        pub fn clear_dummy7(&mut self) {
            self.dummy7 = ::std::option::Option::None;
        }
        pub const DUMMY8_FIELD_NUMBER: i32 = 8;
        pub const DUMMY8_DEFAULT_VALUE: i32 = 0;
        pub fn dummy8(&self) -> i32 {
            self.dummy8.unwrap_or(Self::DUMMY8_DEFAULT_VALUE)
        }
        pub fn dummy8_option(&self) -> ::std::option::Option<&i32> {
            self.dummy8.as_ref()
        }
        pub fn dummy8_mut(&mut self) -> &mut i32 {
            self.dummy8
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy8(&self) -> bool {
            self.dummy8.is_some()
        }
        pub fn set_dummy8(&mut self, value: i32) {
            self.dummy8 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy8(&mut self) -> ::std::option::Option<i32> {
            self.dummy8.take()
        }
        pub fn clear_dummy8(&mut self) {
            self.dummy8 = ::std::option::Option::None;
        }
        pub const DUMMY9_FIELD_NUMBER: i32 = 9;
        pub const DUMMY9_DEFAULT_VALUE: i32 = 0;
        pub fn dummy9(&self) -> i32 {
            self.dummy9.unwrap_or(Self::DUMMY9_DEFAULT_VALUE)
        }
        pub fn dummy9_option(&self) -> ::std::option::Option<&i32> {
            self.dummy9.as_ref()
        }
        pub fn dummy9_mut(&mut self) -> &mut i32 {
            self.dummy9
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy9(&self) -> bool {
            self.dummy9.is_some()
        }
        pub fn set_dummy9(&mut self, value: i32) {
            self.dummy9 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy9(&mut self) -> ::std::option::Option<i32> {
            self.dummy9.take()
        }
        pub fn clear_dummy9(&mut self) {
            self.dummy9 = ::std::option::Option::None;
        }
        pub const DUMMY10_FIELD_NUMBER: i32 = 10;
        pub const DUMMY10_DEFAULT_VALUE: i32 = 0;
        pub fn dummy10(&self) -> i32 {
            self.dummy10.unwrap_or(Self::DUMMY10_DEFAULT_VALUE)
        }
        pub fn dummy10_option(&self) -> ::std::option::Option<&i32> {
            self.dummy10.as_ref()
        }
        pub fn dummy10_mut(&mut self) -> &mut i32 {
            self.dummy10
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy10(&self) -> bool {
            self.dummy10.is_some()
        }
        pub fn set_dummy10(&mut self, value: i32) {
            self.dummy10 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy10(&mut self) -> ::std::option::Option<i32> {
            self.dummy10.take()
        }
        pub fn clear_dummy10(&mut self) {
            self.dummy10 = ::std::option::Option::None;
        }
        pub const DUMMY11_FIELD_NUMBER: i32 = 11;
        pub const DUMMY11_DEFAULT_VALUE: i32 = 0;
        pub fn dummy11(&self) -> i32 {
            self.dummy11.unwrap_or(Self::DUMMY11_DEFAULT_VALUE)
        }
        pub fn dummy11_option(&self) -> ::std::option::Option<&i32> {
            self.dummy11.as_ref()
        }
        pub fn dummy11_mut(&mut self) -> &mut i32 {
            self.dummy11
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy11(&self) -> bool {
            self.dummy11.is_some()
        }
        pub fn set_dummy11(&mut self, value: i32) {
            self.dummy11 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy11(&mut self) -> ::std::option::Option<i32> {
            self.dummy11.take()
        }
        pub fn clear_dummy11(&mut self) {
            self.dummy11 = ::std::option::Option::None;
        }
        pub const DUMMY12_FIELD_NUMBER: i32 = 12;
        pub const DUMMY12_DEFAULT_VALUE: i32 = 0;
        pub fn dummy12(&self) -> i32 {
            self.dummy12.unwrap_or(Self::DUMMY12_DEFAULT_VALUE)
        }
        pub fn dummy12_option(&self) -> ::std::option::Option<&i32> {
            self.dummy12.as_ref()
        }
        pub fn dummy12_mut(&mut self) -> &mut i32 {
            self.dummy12
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy12(&self) -> bool {
            self.dummy12.is_some()
        }
        pub fn set_dummy12(&mut self, value: i32) {
            self.dummy12 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy12(&mut self) -> ::std::option::Option<i32> {
            self.dummy12.take()
        }
        pub fn clear_dummy12(&mut self) {
            self.dummy12 = ::std::option::Option::None;
        }
        pub const DUMMY13_FIELD_NUMBER: i32 = 13;
        pub const DUMMY13_DEFAULT_VALUE: i32 = 0;
        pub fn dummy13(&self) -> i32 {
            self.dummy13.unwrap_or(Self::DUMMY13_DEFAULT_VALUE)
        }
        pub fn dummy13_option(&self) -> ::std::option::Option<&i32> {
            self.dummy13.as_ref()
        }
        pub fn dummy13_mut(&mut self) -> &mut i32 {
            self.dummy13
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy13(&self) -> bool {
            self.dummy13.is_some()
        }
        pub fn set_dummy13(&mut self, value: i32) {
            self.dummy13 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy13(&mut self) -> ::std::option::Option<i32> {
            self.dummy13.take()
        }
        pub fn clear_dummy13(&mut self) {
            self.dummy13 = ::std::option::Option::None;
        }
        pub const DUMMY14_FIELD_NUMBER: i32 = 14;
        pub const DUMMY14_DEFAULT_VALUE: i32 = 0;
        pub fn dummy14(&self) -> i32 {
            self.dummy14.unwrap_or(Self::DUMMY14_DEFAULT_VALUE)
        }
        pub fn dummy14_option(&self) -> ::std::option::Option<&i32> {
            self.dummy14.as_ref()
        }
        pub fn dummy14_mut(&mut self) -> &mut i32 {
            self.dummy14
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy14(&self) -> bool {
            self.dummy14.is_some()
        }
        pub fn set_dummy14(&mut self, value: i32) {
            self.dummy14 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy14(&mut self) -> ::std::option::Option<i32> {
            self.dummy14.take()
        }
        pub fn clear_dummy14(&mut self) {
            self.dummy14 = ::std::option::Option::None;
        }
        pub const DUMMY15_FIELD_NUMBER: i32 = 15;
        pub const DUMMY15_DEFAULT_VALUE: i32 = 0;
        pub fn dummy15(&self) -> i32 {
            self.dummy15.unwrap_or(Self::DUMMY15_DEFAULT_VALUE)
        }
        pub fn dummy15_option(&self) -> ::std::option::Option<&i32> {
            self.dummy15.as_ref()
        }
        pub fn dummy15_mut(&mut self) -> &mut i32 {
            self.dummy15
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy15(&self) -> bool {
            self.dummy15.is_some()
        }
        pub fn set_dummy15(&mut self, value: i32) {
            self.dummy15 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy15(&mut self) -> ::std::option::Option<i32> {
            self.dummy15.take()
        }
        pub fn clear_dummy15(&mut self) {
            self.dummy15 = ::std::option::Option::None;
        }
        pub const DUMMY16_FIELD_NUMBER: i32 = 16;
        pub const DUMMY16_DEFAULT_VALUE: i32 = 0;
        pub fn dummy16(&self) -> i32 {
            self.dummy16.unwrap_or(Self::DUMMY16_DEFAULT_VALUE)
        }
        pub fn dummy16_option(&self) -> ::std::option::Option<&i32> {
            self.dummy16.as_ref()
        }
        pub fn dummy16_mut(&mut self) -> &mut i32 {
            self.dummy16
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy16(&self) -> bool {
            self.dummy16.is_some()
        }
        pub fn set_dummy16(&mut self, value: i32) {
            self.dummy16 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy16(&mut self) -> ::std::option::Option<i32> {
            self.dummy16.take()
        }
        pub fn clear_dummy16(&mut self) {
            self.dummy16 = ::std::option::Option::None;
        }
        pub const DUMMY17_FIELD_NUMBER: i32 = 17;
        pub const DUMMY17_DEFAULT_VALUE: i32 = 0;
        pub fn dummy17(&self) -> i32 {
            self.dummy17.unwrap_or(Self::DUMMY17_DEFAULT_VALUE)
        }
        pub fn dummy17_option(&self) -> ::std::option::Option<&i32> {
            self.dummy17.as_ref()
        }
        pub fn dummy17_mut(&mut self) -> &mut i32 {
            self.dummy17
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy17(&self) -> bool {
            self.dummy17.is_some()
        }
        pub fn set_dummy17(&mut self, value: i32) {
            self.dummy17 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy17(&mut self) -> ::std::option::Option<i32> {
            self.dummy17.take()
        }
        pub fn clear_dummy17(&mut self) {
            self.dummy17 = ::std::option::Option::None;
        }
        pub const DUMMY18_FIELD_NUMBER: i32 = 18;
        pub const DUMMY18_DEFAULT_VALUE: i32 = 0;
        pub fn dummy18(&self) -> i32 {
            self.dummy18.unwrap_or(Self::DUMMY18_DEFAULT_VALUE)
        }
        pub fn dummy18_option(&self) -> ::std::option::Option<&i32> {
            self.dummy18.as_ref()
        }
        pub fn dummy18_mut(&mut self) -> &mut i32 {
            self.dummy18
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy18(&self) -> bool {
            self.dummy18.is_some()
        }
        pub fn set_dummy18(&mut self, value: i32) {
            self.dummy18 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy18(&mut self) -> ::std::option::Option<i32> {
            self.dummy18.take()
        }
        pub fn clear_dummy18(&mut self) {
            self.dummy18 = ::std::option::Option::None;
        }
        pub const DUMMY19_FIELD_NUMBER: i32 = 19;
        pub const DUMMY19_DEFAULT_VALUE: i32 = 0;
        pub fn dummy19(&self) -> i32 {
            self.dummy19.unwrap_or(Self::DUMMY19_DEFAULT_VALUE)
        }
        pub fn dummy19_option(&self) -> ::std::option::Option<&i32> {
            self.dummy19.as_ref()
        }
        pub fn dummy19_mut(&mut self) -> &mut i32 {
            self.dummy19
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy19(&self) -> bool {
            self.dummy19.is_some()
        }
        pub fn set_dummy19(&mut self, value: i32) {
            self.dummy19 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy19(&mut self) -> ::std::option::Option<i32> {
            self.dummy19.take()
        }
        pub fn clear_dummy19(&mut self) {
            self.dummy19 = ::std::option::Option::None;
        }
        pub const DUMMY20_FIELD_NUMBER: i32 = 20;
        pub const DUMMY20_DEFAULT_VALUE: i32 = 0;
        pub fn dummy20(&self) -> i32 {
            self.dummy20.unwrap_or(Self::DUMMY20_DEFAULT_VALUE)
        }
        pub fn dummy20_option(&self) -> ::std::option::Option<&i32> {
            self.dummy20.as_ref()
        }
        pub fn dummy20_mut(&mut self) -> &mut i32 {
            self.dummy20
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy20(&self) -> bool {
            self.dummy20.is_some()
        }
        pub fn set_dummy20(&mut self, value: i32) {
            self.dummy20 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy20(&mut self) -> ::std::option::Option<i32> {
            self.dummy20.take()
        }
        pub fn clear_dummy20(&mut self) {
            self.dummy20 = ::std::option::Option::None;
        }
        pub const DUMMY21_FIELD_NUMBER: i32 = 21;
        pub const DUMMY21_DEFAULT_VALUE: i32 = 0;
        pub fn dummy21(&self) -> i32 {
            self.dummy21.unwrap_or(Self::DUMMY21_DEFAULT_VALUE)
        }
        pub fn dummy21_option(&self) -> ::std::option::Option<&i32> {
            self.dummy21.as_ref()
        }
        pub fn dummy21_mut(&mut self) -> &mut i32 {
            self.dummy21
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy21(&self) -> bool {
            self.dummy21.is_some()
        }
        pub fn set_dummy21(&mut self, value: i32) {
            self.dummy21 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy21(&mut self) -> ::std::option::Option<i32> {
            self.dummy21.take()
        }
        pub fn clear_dummy21(&mut self) {
            self.dummy21 = ::std::option::Option::None;
        }
        pub const DUMMY22_FIELD_NUMBER: i32 = 22;
        pub const DUMMY22_DEFAULT_VALUE: i32 = 0;
        pub fn dummy22(&self) -> i32 {
            self.dummy22.unwrap_or(Self::DUMMY22_DEFAULT_VALUE)
        }
        pub fn dummy22_option(&self) -> ::std::option::Option<&i32> {
            self.dummy22.as_ref()
        }
        pub fn dummy22_mut(&mut self) -> &mut i32 {
            self.dummy22
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy22(&self) -> bool {
            self.dummy22.is_some()
        }
        pub fn set_dummy22(&mut self, value: i32) {
            self.dummy22 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy22(&mut self) -> ::std::option::Option<i32> {
            self.dummy22.take()
        }
        pub fn clear_dummy22(&mut self) {
            self.dummy22 = ::std::option::Option::None;
        }
        pub const DUMMY23_FIELD_NUMBER: i32 = 23;
        pub const DUMMY23_DEFAULT_VALUE: i32 = 0;
        pub fn dummy23(&self) -> i32 {
            self.dummy23.unwrap_or(Self::DUMMY23_DEFAULT_VALUE)
        }
        pub fn dummy23_option(&self) -> ::std::option::Option<&i32> {
            self.dummy23.as_ref()
        }
        pub fn dummy23_mut(&mut self) -> &mut i32 {
            self.dummy23
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy23(&self) -> bool {
            self.dummy23.is_some()
        }
        pub fn set_dummy23(&mut self, value: i32) {
            self.dummy23 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy23(&mut self) -> ::std::option::Option<i32> {
            self.dummy23.take()
        }
        pub fn clear_dummy23(&mut self) {
            self.dummy23 = ::std::option::Option::None;
        }
        pub const DUMMY24_FIELD_NUMBER: i32 = 24;
        pub const DUMMY24_DEFAULT_VALUE: i32 = 0;
        pub fn dummy24(&self) -> i32 {
            self.dummy24.unwrap_or(Self::DUMMY24_DEFAULT_VALUE)
        }
        pub fn dummy24_option(&self) -> ::std::option::Option<&i32> {
            self.dummy24.as_ref()
        }
        pub fn dummy24_mut(&mut self) -> &mut i32 {
            self.dummy24
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy24(&self) -> bool {
            self.dummy24.is_some()
        }
        pub fn set_dummy24(&mut self, value: i32) {
            self.dummy24 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy24(&mut self) -> ::std::option::Option<i32> {
            self.dummy24.take()
        }
        pub fn clear_dummy24(&mut self) {
            self.dummy24 = ::std::option::Option::None;
        }
        pub const DUMMY25_FIELD_NUMBER: i32 = 25;
        pub const DUMMY25_DEFAULT_VALUE: i32 = 0;
        pub fn dummy25(&self) -> i32 {
            self.dummy25.unwrap_or(Self::DUMMY25_DEFAULT_VALUE)
        }
        pub fn dummy25_option(&self) -> ::std::option::Option<&i32> {
            self.dummy25.as_ref()
        }
        pub fn dummy25_mut(&mut self) -> &mut i32 {
            self.dummy25
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy25(&self) -> bool {
            self.dummy25.is_some()
        }
        pub fn set_dummy25(&mut self, value: i32) {
            self.dummy25 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy25(&mut self) -> ::std::option::Option<i32> {
            self.dummy25.take()
        }
        pub fn clear_dummy25(&mut self) {
            self.dummy25 = ::std::option::Option::None;
        }
        pub const DUMMY26_FIELD_NUMBER: i32 = 26;
        pub const DUMMY26_DEFAULT_VALUE: i32 = 0;
        pub fn dummy26(&self) -> i32 {
            self.dummy26.unwrap_or(Self::DUMMY26_DEFAULT_VALUE)
        }
        pub fn dummy26_option(&self) -> ::std::option::Option<&i32> {
            self.dummy26.as_ref()
        }
        pub fn dummy26_mut(&mut self) -> &mut i32 {
            self.dummy26
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy26(&self) -> bool {
            self.dummy26.is_some()
        }
        pub fn set_dummy26(&mut self, value: i32) {
            self.dummy26 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy26(&mut self) -> ::std::option::Option<i32> {
            self.dummy26.take()
        }
        pub fn clear_dummy26(&mut self) {
            self.dummy26 = ::std::option::Option::None;
        }
        pub const DUMMY27_FIELD_NUMBER: i32 = 27;
        pub const DUMMY27_DEFAULT_VALUE: i32 = 0;
        pub fn dummy27(&self) -> i32 {
            self.dummy27.unwrap_or(Self::DUMMY27_DEFAULT_VALUE)
        }
        pub fn dummy27_option(&self) -> ::std::option::Option<&i32> {
            self.dummy27.as_ref()
        }
        pub fn dummy27_mut(&mut self) -> &mut i32 {
            self.dummy27
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy27(&self) -> bool {
            self.dummy27.is_some()
        }
        pub fn set_dummy27(&mut self, value: i32) {
            self.dummy27 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy27(&mut self) -> ::std::option::Option<i32> {
            self.dummy27.take()
        }
        pub fn clear_dummy27(&mut self) {
            self.dummy27 = ::std::option::Option::None;
        }
        pub const DUMMY28_FIELD_NUMBER: i32 = 28;
        pub const DUMMY28_DEFAULT_VALUE: i32 = 0;
        pub fn dummy28(&self) -> i32 {
            self.dummy28.unwrap_or(Self::DUMMY28_DEFAULT_VALUE)
        }
        pub fn dummy28_option(&self) -> ::std::option::Option<&i32> {
            self.dummy28.as_ref()
        }
        pub fn dummy28_mut(&mut self) -> &mut i32 {
            self.dummy28
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy28(&self) -> bool {
            self.dummy28.is_some()
        }
        pub fn set_dummy28(&mut self, value: i32) {
            self.dummy28 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy28(&mut self) -> ::std::option::Option<i32> {
            self.dummy28.take()
        }
        pub fn clear_dummy28(&mut self) {
            self.dummy28 = ::std::option::Option::None;
        }
        pub const DUMMY29_FIELD_NUMBER: i32 = 29;
        pub const DUMMY29_DEFAULT_VALUE: i32 = 0;
        pub fn dummy29(&self) -> i32 {
            self.dummy29.unwrap_or(Self::DUMMY29_DEFAULT_VALUE)
        }
        pub fn dummy29_option(&self) -> ::std::option::Option<&i32> {
            self.dummy29.as_ref()
        }
        pub fn dummy29_mut(&mut self) -> &mut i32 {
            self.dummy29
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy29(&self) -> bool {
            self.dummy29.is_some()
        }
        pub fn set_dummy29(&mut self, value: i32) {
            self.dummy29 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy29(&mut self) -> ::std::option::Option<i32> {
            self.dummy29.take()
        }
        pub fn clear_dummy29(&mut self) {
            self.dummy29 = ::std::option::Option::None;
        }
        pub const DUMMY30_FIELD_NUMBER: i32 = 30;
        pub const DUMMY30_DEFAULT_VALUE: i32 = 0;
        pub fn dummy30(&self) -> i32 {
            self.dummy30.unwrap_or(Self::DUMMY30_DEFAULT_VALUE)
        }
        pub fn dummy30_option(&self) -> ::std::option::Option<&i32> {
            self.dummy30.as_ref()
        }
        pub fn dummy30_mut(&mut self) -> &mut i32 {
            self.dummy30
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy30(&self) -> bool {
            self.dummy30.is_some()
        }
        pub fn set_dummy30(&mut self, value: i32) {
            self.dummy30 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy30(&mut self) -> ::std::option::Option<i32> {
            self.dummy30.take()
        }
        pub fn clear_dummy30(&mut self) {
            self.dummy30 = ::std::option::Option::None;
        }
        pub const DUMMY31_FIELD_NUMBER: i32 = 31;
        pub const DUMMY31_DEFAULT_VALUE: i32 = 0;
        pub fn dummy31(&self) -> i32 {
            self.dummy31.unwrap_or(Self::DUMMY31_DEFAULT_VALUE)
        }
        pub fn dummy31_option(&self) -> ::std::option::Option<&i32> {
            self.dummy31.as_ref()
        }
        pub fn dummy31_mut(&mut self) -> &mut i32 {
            self.dummy31
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy31(&self) -> bool {
            self.dummy31.is_some()
        }
        pub fn set_dummy31(&mut self, value: i32) {
            self.dummy31 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy31(&mut self) -> ::std::option::Option<i32> {
            self.dummy31.take()
        }
        pub fn clear_dummy31(&mut self) {
            self.dummy31 = ::std::option::Option::None;
        }
        pub const DUMMY32_FIELD_NUMBER: i32 = 32;
        pub const DUMMY32_DEFAULT_VALUE: i32 = 0;
        pub fn dummy32(&self) -> i32 {
            self.dummy32.unwrap_or(Self::DUMMY32_DEFAULT_VALUE)
        }
        pub fn dummy32_option(&self) -> ::std::option::Option<&i32> {
            self.dummy32.as_ref()
        }
        pub fn dummy32_mut(&mut self) -> &mut i32 {
            self.dummy32
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy32(&self) -> bool {
            self.dummy32.is_some()
        }
        pub fn set_dummy32(&mut self, value: i32) {
            self.dummy32 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy32(&mut self) -> ::std::option::Option<i32> {
            self.dummy32.take()
        }
        pub fn clear_dummy32(&mut self) {
            self.dummy32 = ::std::option::Option::None;
        }
        pub const C_FIELD_NUMBER: i32 = 33;
        pub const C_DEFAULT_VALUE: i32 = 0;
        pub fn c(&self) -> i32 {
            self.c.unwrap_or(Self::C_DEFAULT_VALUE)
        }
        pub fn c_option(&self) -> ::std::option::Option<&i32> {
            self.c.as_ref()
        }
        pub fn c_mut(&mut self) -> &mut i32 {
            self.c.get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_c(&self) -> bool {
            self.c.is_some()
        }
        pub fn set_c(&mut self, value: i32) {
            self.c = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_c(&mut self) -> ::std::option::Option<i32> {
            self.c.take()
        }
        pub fn clear_c(&mut self) {
            self.c = ::std::option::Option::None;
        }
    }
    pub mod test_required {
        pub static SINGLE: ::protrust::Extension<
            self::super::TestAllExtensions,
            self::super::TestRequired,
            self::super::TestRequired,
        > = ::protrust::Extension::message(8002);
        pub static MULTI: ::protrust::RepeatedExtension<
            self::super::TestAllExtensions,
            self::super::TestRequired,
        > = ::protrust::RepeatedExtension::message(8010);
        pub(in super::super) static A_REFLECTOR: ::protrust::reflect::access::VerboseFieldAccessor<
            self::super::TestRequired,
            i32,
        > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestRequired::a_option,
            get_mut: self::super::TestRequired::a_mut,
            set: self::super::TestRequired::set_a,
            take: self::super::TestRequired::take_a,
            clear: self::super::TestRequired::clear_a,
        };
        pub(in super::super) static DUMMY2_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy2_option,
                get_mut: self::super::TestRequired::dummy2_mut,
                set: self::super::TestRequired::set_dummy2,
                take: self::super::TestRequired::take_dummy2,
                clear: self::super::TestRequired::clear_dummy2,
            };
        pub(in super::super) static B_REFLECTOR: ::protrust::reflect::access::VerboseFieldAccessor<
            self::super::TestRequired,
            i32,
        > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestRequired::b_option,
            get_mut: self::super::TestRequired::b_mut,
            set: self::super::TestRequired::set_b,
            take: self::super::TestRequired::take_b,
            clear: self::super::TestRequired::clear_b,
        };
        pub(in super::super) static DUMMY4_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy4_option,
                get_mut: self::super::TestRequired::dummy4_mut,
                set: self::super::TestRequired::set_dummy4,
                take: self::super::TestRequired::take_dummy4,
                clear: self::super::TestRequired::clear_dummy4,
            };
        pub(in super::super) static DUMMY5_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy5_option,
                get_mut: self::super::TestRequired::dummy5_mut,
                set: self::super::TestRequired::set_dummy5,
                take: self::super::TestRequired::take_dummy5,
                clear: self::super::TestRequired::clear_dummy5,
            };
        pub(in super::super) static DUMMY6_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy6_option,
                get_mut: self::super::TestRequired::dummy6_mut,
                set: self::super::TestRequired::set_dummy6,
                take: self::super::TestRequired::take_dummy6,
                clear: self::super::TestRequired::clear_dummy6,
            };
        pub(in super::super) static DUMMY7_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy7_option,
                get_mut: self::super::TestRequired::dummy7_mut,
                set: self::super::TestRequired::set_dummy7,
                take: self::super::TestRequired::take_dummy7,
                clear: self::super::TestRequired::clear_dummy7,
            };
        pub(in super::super) static DUMMY8_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy8_option,
                get_mut: self::super::TestRequired::dummy8_mut,
                set: self::super::TestRequired::set_dummy8,
                take: self::super::TestRequired::take_dummy8,
                clear: self::super::TestRequired::clear_dummy8,
            };
        pub(in super::super) static DUMMY9_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy9_option,
                get_mut: self::super::TestRequired::dummy9_mut,
                set: self::super::TestRequired::set_dummy9,
                take: self::super::TestRequired::take_dummy9,
                clear: self::super::TestRequired::clear_dummy9,
            };
        pub(in super::super) static DUMMY10_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy10_option,
                get_mut: self::super::TestRequired::dummy10_mut,
                set: self::super::TestRequired::set_dummy10,
                take: self::super::TestRequired::take_dummy10,
                clear: self::super::TestRequired::clear_dummy10,
            };
        pub(in super::super) static DUMMY11_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy11_option,
                get_mut: self::super::TestRequired::dummy11_mut,
                set: self::super::TestRequired::set_dummy11,
                take: self::super::TestRequired::take_dummy11,
                clear: self::super::TestRequired::clear_dummy11,
            };
        pub(in super::super) static DUMMY12_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy12_option,
                get_mut: self::super::TestRequired::dummy12_mut,
                set: self::super::TestRequired::set_dummy12,
                take: self::super::TestRequired::take_dummy12,
                clear: self::super::TestRequired::clear_dummy12,
            };
        pub(in super::super) static DUMMY13_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy13_option,
                get_mut: self::super::TestRequired::dummy13_mut,
                set: self::super::TestRequired::set_dummy13,
                take: self::super::TestRequired::take_dummy13,
                clear: self::super::TestRequired::clear_dummy13,
            };
        pub(in super::super) static DUMMY14_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy14_option,
                get_mut: self::super::TestRequired::dummy14_mut,
                set: self::super::TestRequired::set_dummy14,
                take: self::super::TestRequired::take_dummy14,
                clear: self::super::TestRequired::clear_dummy14,
            };
        pub(in super::super) static DUMMY15_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy15_option,
                get_mut: self::super::TestRequired::dummy15_mut,
                set: self::super::TestRequired::set_dummy15,
                take: self::super::TestRequired::take_dummy15,
                clear: self::super::TestRequired::clear_dummy15,
            };
        pub(in super::super) static DUMMY16_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy16_option,
                get_mut: self::super::TestRequired::dummy16_mut,
                set: self::super::TestRequired::set_dummy16,
                take: self::super::TestRequired::take_dummy16,
                clear: self::super::TestRequired::clear_dummy16,
            };
        pub(in super::super) static DUMMY17_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy17_option,
                get_mut: self::super::TestRequired::dummy17_mut,
                set: self::super::TestRequired::set_dummy17,
                take: self::super::TestRequired::take_dummy17,
                clear: self::super::TestRequired::clear_dummy17,
            };
        pub(in super::super) static DUMMY18_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy18_option,
                get_mut: self::super::TestRequired::dummy18_mut,
                set: self::super::TestRequired::set_dummy18,
                take: self::super::TestRequired::take_dummy18,
                clear: self::super::TestRequired::clear_dummy18,
            };
        pub(in super::super) static DUMMY19_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy19_option,
                get_mut: self::super::TestRequired::dummy19_mut,
                set: self::super::TestRequired::set_dummy19,
                take: self::super::TestRequired::take_dummy19,
                clear: self::super::TestRequired::clear_dummy19,
            };
        pub(in super::super) static DUMMY20_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy20_option,
                get_mut: self::super::TestRequired::dummy20_mut,
                set: self::super::TestRequired::set_dummy20,
                take: self::super::TestRequired::take_dummy20,
                clear: self::super::TestRequired::clear_dummy20,
            };
        pub(in super::super) static DUMMY21_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy21_option,
                get_mut: self::super::TestRequired::dummy21_mut,
                set: self::super::TestRequired::set_dummy21,
                take: self::super::TestRequired::take_dummy21,
                clear: self::super::TestRequired::clear_dummy21,
            };
        pub(in super::super) static DUMMY22_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy22_option,
                get_mut: self::super::TestRequired::dummy22_mut,
                set: self::super::TestRequired::set_dummy22,
                take: self::super::TestRequired::take_dummy22,
                clear: self::super::TestRequired::clear_dummy22,
            };
        pub(in super::super) static DUMMY23_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy23_option,
                get_mut: self::super::TestRequired::dummy23_mut,
                set: self::super::TestRequired::set_dummy23,
                take: self::super::TestRequired::take_dummy23,
                clear: self::super::TestRequired::clear_dummy23,
            };
        pub(in super::super) static DUMMY24_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy24_option,
                get_mut: self::super::TestRequired::dummy24_mut,
                set: self::super::TestRequired::set_dummy24,
                take: self::super::TestRequired::take_dummy24,
                clear: self::super::TestRequired::clear_dummy24,
            };
        pub(in super::super) static DUMMY25_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy25_option,
                get_mut: self::super::TestRequired::dummy25_mut,
                set: self::super::TestRequired::set_dummy25,
                take: self::super::TestRequired::take_dummy25,
                clear: self::super::TestRequired::clear_dummy25,
            };
        pub(in super::super) static DUMMY26_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy26_option,
                get_mut: self::super::TestRequired::dummy26_mut,
                set: self::super::TestRequired::set_dummy26,
                take: self::super::TestRequired::take_dummy26,
                clear: self::super::TestRequired::clear_dummy26,
            };
        pub(in super::super) static DUMMY27_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy27_option,
                get_mut: self::super::TestRequired::dummy27_mut,
                set: self::super::TestRequired::set_dummy27,
                take: self::super::TestRequired::take_dummy27,
                clear: self::super::TestRequired::clear_dummy27,
            };
        pub(in super::super) static DUMMY28_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy28_option,
                get_mut: self::super::TestRequired::dummy28_mut,
                set: self::super::TestRequired::set_dummy28,
                take: self::super::TestRequired::take_dummy28,
                clear: self::super::TestRequired::clear_dummy28,
            };
        pub(in super::super) static DUMMY29_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy29_option,
                get_mut: self::super::TestRequired::dummy29_mut,
                set: self::super::TestRequired::set_dummy29,
                take: self::super::TestRequired::take_dummy29,
                clear: self::super::TestRequired::clear_dummy29,
            };
        pub(in super::super) static DUMMY30_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy30_option,
                get_mut: self::super::TestRequired::dummy30_mut,
                set: self::super::TestRequired::set_dummy30,
                take: self::super::TestRequired::take_dummy30,
                clear: self::super::TestRequired::clear_dummy30,
            };
        pub(in super::super) static DUMMY31_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy31_option,
                get_mut: self::super::TestRequired::dummy31_mut,
                set: self::super::TestRequired::set_dummy31,
                take: self::super::TestRequired::take_dummy31,
                clear: self::super::TestRequired::clear_dummy31,
            };
        pub(in super::super) static DUMMY32_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequired, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequired::dummy32_option,
                get_mut: self::super::TestRequired::dummy32_mut,
                set: self::super::TestRequired::set_dummy32,
                take: self::super::TestRequired::take_dummy32,
                clear: self::super::TestRequired::clear_dummy32,
            };
        pub(in super::super) static C_REFLECTOR: ::protrust::reflect::access::VerboseFieldAccessor<
            self::super::TestRequired,
            i32,
        > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestRequired::c_option,
            get_mut: self::super::TestRequired::c_mut,
            set: self::super::TestRequired::set_c,
            take: self::super::TestRequired::take_c,
            clear: self::super::TestRequired::clear_c,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestRequiredForeign {
        optional_message: ::std::option::Option<::std::boxed::Box<self::TestRequired>>,
        repeated_message: ::protrust::collections::RepeatedField<self::TestRequired>,
        dummy: ::std::option::Option<i32>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestRequiredForeign {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => input.read_message(self.optional_message_mut())?,
                    18 => self
                        .repeated_message
                        .add_entries(input, &self::test_required_foreign::REPEATED_MESSAGE_CODEC)?,
                    24 | 26 => self.set_dummy(input.read_int32()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(optional_message) = self.optional_message() {
                size += 1;
                size += ::protrust::io::sizes::message(optional_message);
            }
            size += self
                .repeated_message()
                .calculate_size(&self::test_required_foreign::REPEATED_MESSAGE_CODEC);
            if let ::std::option::Option::Some(dummy) = self.dummy_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*dummy);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(optional_message) = self.optional_message() {
                output.write_raw_tag_bytes(&[10])?;
                output.write_message(optional_message)?;
            }
            self.repeated_message()
                .write_to(output, &self::test_required_foreign::REPEATED_MESSAGE_CODEC)?;
            if let ::std::option::Option::Some(dummy) = self.dummy_option() {
                output.write_raw_tag_bytes(&[24])?;
                output.write_int32(*dummy)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(optional_message) = self.optional_message() {
                if !::protrust::CodedMessage::is_initialized(optional_message) {
                    return false;
                }
            }
            if !self.repeated_message.is_initialized() {
                return false;
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestRequiredForeign {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(optional_message) = &other.optional_message() {
                ::protrust::LiteMessage::merge(self.optional_message_mut(), optional_message);
            }
            self.repeated_message.merge(&other.repeated_message);
            if let ::std::option::Option::Some(dummy) = other.dummy_option() {
                self.set_dummy(*dummy);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestRequiredForeign {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[13]
        }
    }
    impl self::TestRequiredForeign {
        pub const OPTIONAL_MESSAGE_FIELD_NUMBER: i32 = 1;
        pub fn optional_message(&self) -> ::std::option::Option<&self::TestRequired> {
            self.optional_message.as_ref().map(|v| &**v)
        }
        pub fn optional_message_mut(&mut self) -> &mut self::TestRequired {
            self.optional_message
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_message(&self) -> bool {
            self.optional_message.is_some()
        }
        pub fn set_optional_message(&mut self, value: self::TestRequired) {
            self.optional_message = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_message(&mut self) -> ::std::option::Option<self::TestRequired> {
            self.optional_message.take().map(|v| *v)
        }
        pub fn clear_optional_message(&mut self) {
            self.optional_message = ::std::option::Option::None;
        }
        pub const REPEATED_MESSAGE_FIELD_NUMBER: i32 = 2;
        pub fn repeated_message(
            &self,
        ) -> &::protrust::collections::RepeatedField<self::TestRequired> {
            &self.repeated_message
        }
        pub fn repeated_message_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<self::TestRequired> {
            &mut self.repeated_message
        }
        pub const DUMMY_FIELD_NUMBER: i32 = 3;
        pub const DUMMY_DEFAULT_VALUE: i32 = 0;
        pub fn dummy(&self) -> i32 {
            self.dummy.unwrap_or(Self::DUMMY_DEFAULT_VALUE)
        }
        pub fn dummy_option(&self) -> ::std::option::Option<&i32> {
            self.dummy.as_ref()
        }
        pub fn dummy_mut(&mut self) -> &mut i32 {
            self.dummy
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dummy(&self) -> bool {
            self.dummy.is_some()
        }
        pub fn set_dummy(&mut self, value: i32) {
            self.dummy = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dummy(&mut self) -> ::std::option::Option<i32> {
            self.dummy.take()
        }
        pub fn clear_dummy(&mut self) {
            self.dummy = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod test_required_foreign {
        pub(super) static REPEATED_MESSAGE_CODEC: ::protrust::Codec<self::super::TestRequired> =
            ::protrust::Codec::message(18);
        pub(in super::super) static OPTIONAL_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestRequiredForeign,
                self::super::TestRequired,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestRequiredForeign::optional_message,
            get_mut: self::super::TestRequiredForeign::optional_message_mut,
            set: self::super::TestRequiredForeign::set_optional_message,
            take: self::super::TestRequiredForeign::take_optional_message,
            clear: self::super::TestRequiredForeign::clear_optional_message,
        };
        pub(in super::super) static REPEATED_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestRequiredForeign,
                ::protrust::collections::RepeatedField<self::super::TestRequired>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestRequiredForeign::repeated_message,
            get_mut: self::super::TestRequiredForeign::repeated_message_mut,
        };
        pub(in super::super) static DUMMY_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequiredForeign, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequiredForeign::dummy_option,
                get_mut: self::super::TestRequiredForeign::dummy_mut,
                set: self::super::TestRequiredForeign::set_dummy,
                take: self::super::TestRequiredForeign::take_dummy,
                clear: self::super::TestRequiredForeign::clear_dummy,
            };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestRequiredMessage {
        optional_message: ::std::option::Option<::std::boxed::Box<self::TestRequired>>,
        repeated_message: ::protrust::collections::RepeatedField<self::TestRequired>,
        required_message: ::std::option::Option<::std::boxed::Box<self::TestRequired>>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestRequiredMessage {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => input.read_message(self.optional_message_mut())?,
                    18 => self
                        .repeated_message
                        .add_entries(input, &self::test_required_message::REPEATED_MESSAGE_CODEC)?,
                    26 => input.read_message(self.required_message_mut())?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(optional_message) = self.optional_message() {
                size += 1;
                size += ::protrust::io::sizes::message(optional_message);
            }
            size += self
                .repeated_message()
                .calculate_size(&self::test_required_message::REPEATED_MESSAGE_CODEC);
            if let ::std::option::Option::Some(required_message) = self.required_message() {
                size += 1;
                size += ::protrust::io::sizes::message(required_message);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(optional_message) = self.optional_message() {
                output.write_raw_tag_bytes(&[10])?;
                output.write_message(optional_message)?;
            }
            self.repeated_message()
                .write_to(output, &self::test_required_message::REPEATED_MESSAGE_CODEC)?;
            if let ::std::option::Option::Some(required_message) = self.required_message() {
                output.write_raw_tag_bytes(&[26])?;
                output.write_message(required_message)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(optional_message) = self.optional_message() {
                if !::protrust::CodedMessage::is_initialized(optional_message) {
                    return false;
                }
            }
            if !self.repeated_message.is_initialized() {
                return false;
            }
            if let ::std::option::Option::Some(required_message) = self.required_message() {
                if !::protrust::CodedMessage::is_initialized(required_message) {
                    return false;
                }
            } else {
                return false;
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestRequiredMessage {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(optional_message) = &other.optional_message() {
                ::protrust::LiteMessage::merge(self.optional_message_mut(), optional_message);
            }
            self.repeated_message.merge(&other.repeated_message);
            if let ::std::option::Option::Some(required_message) = &other.required_message() {
                ::protrust::LiteMessage::merge(self.required_message_mut(), required_message);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestRequiredMessage {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[14]
        }
    }
    impl self::TestRequiredMessage {
        pub const OPTIONAL_MESSAGE_FIELD_NUMBER: i32 = 1;
        pub fn optional_message(&self) -> ::std::option::Option<&self::TestRequired> {
            self.optional_message.as_ref().map(|v| &**v)
        }
        pub fn optional_message_mut(&mut self) -> &mut self::TestRequired {
            self.optional_message
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_message(&self) -> bool {
            self.optional_message.is_some()
        }
        pub fn set_optional_message(&mut self, value: self::TestRequired) {
            self.optional_message = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_message(&mut self) -> ::std::option::Option<self::TestRequired> {
            self.optional_message.take().map(|v| *v)
        }
        pub fn clear_optional_message(&mut self) {
            self.optional_message = ::std::option::Option::None;
        }
        pub const REPEATED_MESSAGE_FIELD_NUMBER: i32 = 2;
        pub fn repeated_message(
            &self,
        ) -> &::protrust::collections::RepeatedField<self::TestRequired> {
            &self.repeated_message
        }
        pub fn repeated_message_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<self::TestRequired> {
            &mut self.repeated_message
        }
        pub const REQUIRED_MESSAGE_FIELD_NUMBER: i32 = 3;
        pub fn required_message(&self) -> ::std::option::Option<&self::TestRequired> {
            self.required_message.as_ref().map(|v| &**v)
        }
        pub fn required_message_mut(&mut self) -> &mut self::TestRequired {
            self.required_message
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_required_message(&self) -> bool {
            self.required_message.is_some()
        }
        pub fn set_required_message(&mut self, value: self::TestRequired) {
            self.required_message = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_required_message(&mut self) -> ::std::option::Option<self::TestRequired> {
            self.required_message.take().map(|v| *v)
        }
        pub fn clear_required_message(&mut self) {
            self.required_message = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod test_required_message {
        pub(super) static REPEATED_MESSAGE_CODEC: ::protrust::Codec<self::super::TestRequired> =
            ::protrust::Codec::message(18);
        pub(in super::super) static OPTIONAL_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestRequiredMessage,
                self::super::TestRequired,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestRequiredMessage::optional_message,
            get_mut: self::super::TestRequiredMessage::optional_message_mut,
            set: self::super::TestRequiredMessage::set_optional_message,
            take: self::super::TestRequiredMessage::take_optional_message,
            clear: self::super::TestRequiredMessage::clear_optional_message,
        };
        pub(in super::super) static REPEATED_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestRequiredMessage,
                ::protrust::collections::RepeatedField<self::super::TestRequired>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestRequiredMessage::repeated_message,
            get_mut: self::super::TestRequiredMessage::repeated_message_mut,
        };
        pub(in super::super) static REQUIRED_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestRequiredMessage,
                self::super::TestRequired,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestRequiredMessage::required_message,
            get_mut: self::super::TestRequiredMessage::required_message_mut,
            set: self::super::TestRequiredMessage::set_required_message,
            take: self::super::TestRequiredMessage::take_required_message,
            clear: self::super::TestRequiredMessage::clear_required_message,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestForeignNested {
        foreign_nested:
            ::std::option::Option<::std::boxed::Box<self::test_all_types::NestedMessage>>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestForeignNested {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => input.read_message(self.foreign_nested_mut())?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(foreign_nested) = self.foreign_nested() {
                size += 1;
                size += ::protrust::io::sizes::message(foreign_nested);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(foreign_nested) = self.foreign_nested() {
                output.write_raw_tag_bytes(&[10])?;
                output.write_message(foreign_nested)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(foreign_nested) = self.foreign_nested() {
                if !::protrust::CodedMessage::is_initialized(foreign_nested) {
                    return false;
                }
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestForeignNested {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(foreign_nested) = &other.foreign_nested() {
                ::protrust::LiteMessage::merge(self.foreign_nested_mut(), foreign_nested);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestForeignNested {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[15]
        }
    }
    impl self::TestForeignNested {
        pub const FOREIGN_NESTED_FIELD_NUMBER: i32 = 1;
        pub fn foreign_nested(
            &self,
        ) -> ::std::option::Option<&self::test_all_types::NestedMessage> {
            self.foreign_nested.as_ref().map(|v| &**v)
        }
        pub fn foreign_nested_mut(&mut self) -> &mut self::test_all_types::NestedMessage {
            self.foreign_nested
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_foreign_nested(&self) -> bool {
            self.foreign_nested.is_some()
        }
        pub fn set_foreign_nested(&mut self, value: self::test_all_types::NestedMessage) {
            self.foreign_nested = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_foreign_nested(
            &mut self,
        ) -> ::std::option::Option<self::test_all_types::NestedMessage> {
            self.foreign_nested.take().map(|v| *v)
        }
        pub fn clear_foreign_nested(&mut self) {
            self.foreign_nested = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod test_foreign_nested {
        pub(in super::super) static FOREIGN_NESTED_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestForeignNested,
                self::super::test_all_types::NestedMessage,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestForeignNested::foreign_nested,
            get_mut: self::super::TestForeignNested::foreign_nested_mut,
            set: self::super::TestForeignNested::set_foreign_nested,
            take: self::super::TestForeignNested::take_foreign_nested,
            clear: self::super::TestForeignNested::clear_foreign_nested,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestEmptyMessage {
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestEmptyMessage {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestEmptyMessage {
        fn merge(&mut self, other: &Self) {
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestEmptyMessage {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[16]
        }
    }
    impl self::TestEmptyMessage {}
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestEmptyMessageWithExtensions {
        unknown_fields: ::protrust::UnknownFieldSet,
        extensions: ::protrust::ExtensionSet<Self>,
    }
    impl ::protrust::CodedMessage for self::TestEmptyMessageWithExtensions {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    _ => {
                        if !self.extensions.merge_from(input)? {
                            self.unknown_fields.merge_from(tag, input)?
                        }
                    }
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            size += self.extensions.calculate_size();
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            self.extensions.write_to(output)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestEmptyMessageWithExtensions {
        fn merge(&mut self, other: &Self) {
            self.extensions.merge(&other.extensions);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::ExtendableMessage for self::TestEmptyMessageWithExtensions {
        fn registry(&self) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> {
            self.extensions.registry()
        }
        fn replace_registry(
            &mut self,
            extensions: ::std::option::Option<&'static ::protrust::ExtensionRegistry>,
        ) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> {
            self.extensions.replace_registry(extensions)
        }
        fn has_extension<T: ::protrust::ExtensionIdentifier>(&self, extension: &'static T) -> bool {
            self.extensions.has_extension(extension)
        }
        fn has_extension_unchecked<T: ::protrust::ExtensionIdentifier>(
            &self,
            extension: &'static T,
        ) -> bool {
            self.extensions.has_extension_unchecked(extension)
        }
        fn get_value<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> Option<&V> {
            self.extensions.get_value(extension)
        }
        fn get_value_or_default<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync
                + ::std::ops::Deref<Target = L>,
            D: ::std::marker::Sync + ::std::ops::Deref<Target = L>,
            L,
        >(
            &self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> Option<&L> {
            self.extensions.get_value_or_default(extension)
        }
        fn get_repeated_value<
            V: ::std::cmp::PartialEq
                + ::std::clone::Clone
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &self,
            extension: &'static ::protrust::RepeatedExtension<Self, V>,
        ) -> Option<&::protrust::collections::RepeatedField<V>> {
            self.extensions.get_repeated_value(extension)
        }
        fn field<
            V: ::std::default::Default
                + ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> ::std::option::Option<::protrust::ExtensionField<Self, V, D>> {
            self.extensions.field(extension)
        }
        fn repeated_field<
            V: ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static ::protrust::RepeatedExtension<Self, V>,
        ) -> ::std::option::Option<::protrust::RepeatedExtensionField<Self, V>> {
            self.extensions.repeated_field(extension)
        }
    }
    impl ::protrust::Message for self::TestEmptyMessageWithExtensions {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[17]
        }
    }
    impl self::TestEmptyMessageWithExtensions {}
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestMultipleExtensionRanges {
        unknown_fields: ::protrust::UnknownFieldSet,
        extensions: ::protrust::ExtensionSet<Self>,
    }
    impl ::protrust::CodedMessage for self::TestMultipleExtensionRanges {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    _ => {
                        if !self.extensions.merge_from(input)? {
                            self.unknown_fields.merge_from(tag, input)?
                        }
                    }
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            size += self.extensions.calculate_size();
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            self.extensions.write_to(output)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestMultipleExtensionRanges {
        fn merge(&mut self, other: &Self) {
            self.extensions.merge(&other.extensions);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::ExtendableMessage for self::TestMultipleExtensionRanges {
        fn registry(&self) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> {
            self.extensions.registry()
        }
        fn replace_registry(
            &mut self,
            extensions: ::std::option::Option<&'static ::protrust::ExtensionRegistry>,
        ) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> {
            self.extensions.replace_registry(extensions)
        }
        fn has_extension<T: ::protrust::ExtensionIdentifier>(&self, extension: &'static T) -> bool {
            self.extensions.has_extension(extension)
        }
        fn has_extension_unchecked<T: ::protrust::ExtensionIdentifier>(
            &self,
            extension: &'static T,
        ) -> bool {
            self.extensions.has_extension_unchecked(extension)
        }
        fn get_value<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> Option<&V> {
            self.extensions.get_value(extension)
        }
        fn get_value_or_default<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync
                + ::std::ops::Deref<Target = L>,
            D: ::std::marker::Sync + ::std::ops::Deref<Target = L>,
            L,
        >(
            &self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> Option<&L> {
            self.extensions.get_value_or_default(extension)
        }
        fn get_repeated_value<
            V: ::std::cmp::PartialEq
                + ::std::clone::Clone
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &self,
            extension: &'static ::protrust::RepeatedExtension<Self, V>,
        ) -> Option<&::protrust::collections::RepeatedField<V>> {
            self.extensions.get_repeated_value(extension)
        }
        fn field<
            V: ::std::default::Default
                + ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> ::std::option::Option<::protrust::ExtensionField<Self, V, D>> {
            self.extensions.field(extension)
        }
        fn repeated_field<
            V: ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static ::protrust::RepeatedExtension<Self, V>,
        ) -> ::std::option::Option<::protrust::RepeatedExtensionField<Self, V>> {
            self.extensions.repeated_field(extension)
        }
    }
    impl ::protrust::Message for self::TestMultipleExtensionRanges {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[18]
        }
    }
    impl self::TestMultipleExtensionRanges {}
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestReallyLargeTagNumber {
        a: ::std::option::Option<i32>,
        bb: ::std::option::Option<i32>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestReallyLargeTagNumber {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.set_a(input.read_int32()?),
                    2147483640 | 2147483642 => self.set_bb(input.read_int32()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(a) = self.a_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*a);
            }
            if let ::std::option::Option::Some(bb) = self.bb_option() {
                size += 5;
                size += ::protrust::io::sizes::int32(*bb);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(a) = self.a_option() {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(*a)?;
            }
            if let ::std::option::Option::Some(bb) = self.bb_option() {
                output.write_raw_tag_bytes(&[248, 255, 255, 255, 7])?;
                output.write_int32(*bb)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestReallyLargeTagNumber {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(a) = other.a_option() {
                self.set_a(*a);
            }
            if let ::std::option::Option::Some(bb) = other.bb_option() {
                self.set_bb(*bb);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestReallyLargeTagNumber {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[19]
        }
    }
    impl self::TestReallyLargeTagNumber {
        pub const A_FIELD_NUMBER: i32 = 1;
        pub const A_DEFAULT_VALUE: i32 = 0;
        pub fn a(&self) -> i32 {
            self.a.unwrap_or(Self::A_DEFAULT_VALUE)
        }
        pub fn a_option(&self) -> ::std::option::Option<&i32> {
            self.a.as_ref()
        }
        pub fn a_mut(&mut self) -> &mut i32 {
            self.a.get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_a(&self) -> bool {
            self.a.is_some()
        }
        pub fn set_a(&mut self, value: i32) {
            self.a = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_a(&mut self) -> ::std::option::Option<i32> {
            self.a.take()
        }
        pub fn clear_a(&mut self) {
            self.a = ::std::option::Option::None;
        }
        pub const BB_FIELD_NUMBER: i32 = 268435455;
        pub const BB_DEFAULT_VALUE: i32 = 0;
        pub fn bb(&self) -> i32 {
            self.bb.unwrap_or(Self::BB_DEFAULT_VALUE)
        }
        pub fn bb_option(&self) -> ::std::option::Option<&i32> {
            self.bb.as_ref()
        }
        pub fn bb_mut(&mut self) -> &mut i32 {
            self.bb.get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_bb(&self) -> bool {
            self.bb.is_some()
        }
        pub fn set_bb(&mut self, value: i32) {
            self.bb = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_bb(&mut self) -> ::std::option::Option<i32> {
            self.bb.take()
        }
        pub fn clear_bb(&mut self) {
            self.bb = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod test_really_large_tag_number {
        pub(in super::super) static A_REFLECTOR: ::protrust::reflect::access::VerboseFieldAccessor<
            self::super::TestReallyLargeTagNumber,
            i32,
        > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestReallyLargeTagNumber::a_option,
            get_mut: self::super::TestReallyLargeTagNumber::a_mut,
            set: self::super::TestReallyLargeTagNumber::set_a,
            take: self::super::TestReallyLargeTagNumber::take_a,
            clear: self::super::TestReallyLargeTagNumber::clear_a,
        };
        pub(in super::super) static BB_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestReallyLargeTagNumber,
                i32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestReallyLargeTagNumber::bb_option,
            get_mut: self::super::TestReallyLargeTagNumber::bb_mut,
            set: self::super::TestReallyLargeTagNumber::set_bb,
            take: self::super::TestReallyLargeTagNumber::take_bb,
            clear: self::super::TestReallyLargeTagNumber::clear_bb,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestRecursiveMessage {
        a: ::std::option::Option<::std::boxed::Box<self::TestRecursiveMessage>>,
        i: ::std::option::Option<i32>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestRecursiveMessage {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => input.read_message(self.a_mut())?,
                    16 | 18 => self.set_i(input.read_int32()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(a) = self.a() {
                size += 1;
                size += ::protrust::io::sizes::message(a);
            }
            if let ::std::option::Option::Some(i) = self.i_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*i);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(a) = self.a() {
                output.write_raw_tag_bytes(&[10])?;
                output.write_message(a)?;
            }
            if let ::std::option::Option::Some(i) = self.i_option() {
                output.write_raw_tag_bytes(&[16])?;
                output.write_int32(*i)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(a) = self.a() {
                if !::protrust::CodedMessage::is_initialized(a) {
                    return false;
                }
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestRecursiveMessage {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(a) = &other.a() {
                ::protrust::LiteMessage::merge(self.a_mut(), a);
            }
            if let ::std::option::Option::Some(i) = other.i_option() {
                self.set_i(*i);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestRecursiveMessage {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[20]
        }
    }
    impl self::TestRecursiveMessage {
        pub const A_FIELD_NUMBER: i32 = 1;
        pub fn a(&self) -> ::std::option::Option<&self::TestRecursiveMessage> {
            self.a.as_ref().map(|v| &**v)
        }
        pub fn a_mut(&mut self) -> &mut self::TestRecursiveMessage {
            self.a.get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_a(&self) -> bool {
            self.a.is_some()
        }
        pub fn set_a(&mut self, value: self::TestRecursiveMessage) {
            self.a = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_a(&mut self) -> ::std::option::Option<self::TestRecursiveMessage> {
            self.a.take().map(|v| *v)
        }
        pub fn clear_a(&mut self) {
            self.a = ::std::option::Option::None;
        }
        pub const I_FIELD_NUMBER: i32 = 2;
        pub const I_DEFAULT_VALUE: i32 = 0;
        pub fn i(&self) -> i32 {
            self.i.unwrap_or(Self::I_DEFAULT_VALUE)
        }
        pub fn i_option(&self) -> ::std::option::Option<&i32> {
            self.i.as_ref()
        }
        pub fn i_mut(&mut self) -> &mut i32 {
            self.i.get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_i(&self) -> bool {
            self.i.is_some()
        }
        pub fn set_i(&mut self, value: i32) {
            self.i = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_i(&mut self) -> ::std::option::Option<i32> {
            self.i.take()
        }
        pub fn clear_i(&mut self) {
            self.i = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod test_recursive_message {
        pub(in super::super) static A_REFLECTOR: ::protrust::reflect::access::VerboseFieldAccessor<
            self::super::TestRecursiveMessage,
            self::super::TestRecursiveMessage,
        > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestRecursiveMessage::a,
            get_mut: self::super::TestRecursiveMessage::a_mut,
            set: self::super::TestRecursiveMessage::set_a,
            take: self::super::TestRecursiveMessage::take_a,
            clear: self::super::TestRecursiveMessage::clear_a,
        };
        pub(in super::super) static I_REFLECTOR: ::protrust::reflect::access::VerboseFieldAccessor<
            self::super::TestRecursiveMessage,
            i32,
        > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestRecursiveMessage::i_option,
            get_mut: self::super::TestRecursiveMessage::i_mut,
            set: self::super::TestRecursiveMessage::set_i,
            take: self::super::TestRecursiveMessage::take_i,
            clear: self::super::TestRecursiveMessage::clear_i,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestMutualRecursionA {
        bb: ::std::option::Option<::std::boxed::Box<self::TestMutualRecursionB>>,
        subgroup: ::std::option::Option<::std::boxed::Box<self::test_mutual_recursion_a::SubGroup>>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestMutualRecursionA {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => input.read_message(self.bb_mut())?,
                    19 => input.read_group(self.subgroup_mut())?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(bb) = self.bb() {
                size += 1;
                size += ::protrust::io::sizes::message(bb);
            }
            if let ::std::option::Option::Some(subgroup) = self.subgroup() {
                size += 1;
                size += ::protrust::io::sizes::group(subgroup);
                size += 1;
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(bb) = self.bb() {
                output.write_raw_tag_bytes(&[10])?;
                output.write_message(bb)?;
            }
            if let ::std::option::Option::Some(subgroup) = self.subgroup() {
                output.write_raw_tag_bytes(&[19])?;
                output.write_group(subgroup)?;
                output.write_raw_tag_bytes(&[20])?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(bb) = self.bb() {
                if !::protrust::CodedMessage::is_initialized(bb) {
                    return false;
                }
            }
            if let ::std::option::Option::Some(subgroup) = self.subgroup() {
                if !::protrust::CodedMessage::is_initialized(subgroup) {
                    return false;
                }
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestMutualRecursionA {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(bb) = &other.bb() {
                ::protrust::LiteMessage::merge(self.bb_mut(), bb);
            }
            if let ::std::option::Option::Some(subgroup) = &other.subgroup() {
                ::protrust::LiteMessage::merge(self.subgroup_mut(), subgroup);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestMutualRecursionA {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[21]
        }
    }
    impl self::TestMutualRecursionA {
        pub const BB_FIELD_NUMBER: i32 = 1;
        pub fn bb(&self) -> ::std::option::Option<&self::TestMutualRecursionB> {
            self.bb.as_ref().map(|v| &**v)
        }
        pub fn bb_mut(&mut self) -> &mut self::TestMutualRecursionB {
            self.bb.get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_bb(&self) -> bool {
            self.bb.is_some()
        }
        pub fn set_bb(&mut self, value: self::TestMutualRecursionB) {
            self.bb = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_bb(&mut self) -> ::std::option::Option<self::TestMutualRecursionB> {
            self.bb.take().map(|v| *v)
        }
        pub fn clear_bb(&mut self) {
            self.bb = ::std::option::Option::None;
        }
        pub const SUBGROUP_FIELD_NUMBER: i32 = 2;
        pub fn subgroup(&self) -> ::std::option::Option<&self::test_mutual_recursion_a::SubGroup> {
            self.subgroup.as_ref().map(|v| &**v)
        }
        pub fn subgroup_mut(&mut self) -> &mut self::test_mutual_recursion_a::SubGroup {
            self.subgroup
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_subgroup(&self) -> bool {
            self.subgroup.is_some()
        }
        pub fn set_subgroup(&mut self, value: self::test_mutual_recursion_a::SubGroup) {
            self.subgroup = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_subgroup(
            &mut self,
        ) -> ::std::option::Option<self::test_mutual_recursion_a::SubGroup> {
            self.subgroup.take().map(|v| *v)
        }
        pub fn clear_subgroup(&mut self) {
            self.subgroup = ::std::option::Option::None;
        }
    }
    pub mod test_mutual_recursion_a {
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct SubMessage {
            b: ::std::option::Option<::std::boxed::Box<self::super::TestMutualRecursionB>>,
            unknown_fields: ::protrust::UnknownFieldSet,
        }
        impl ::protrust::CodedMessage for self::SubMessage {
            fn merge_from(
                &mut self,
                input: &mut ::protrust::io::CodedInput,
            ) -> ::protrust::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        10 => input.read_message(self.b_mut())?,
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> i32 {
                let mut size = 0i32;
                if let ::std::option::Option::Some(b) = self.b() {
                    size += 1;
                    size += ::protrust::io::sizes::message(b);
                }
                size += self.unknown_fields.calculate_size();
                size
            }
            fn write_to(
                &self,
                output: &mut ::protrust::io::CodedOutput,
            ) -> ::protrust::io::OutputResult {
                if let ::std::option::Option::Some(b) = self.b() {
                    output.write_raw_tag_bytes(&[10])?;
                    output.write_message(b)?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                if let ::std::option::Option::Some(b) = self.b() {
                    if !::protrust::CodedMessage::is_initialized(b) {
                        return false;
                    }
                }
                true
            }
        }
        impl ::protrust::LiteMessage for self::SubMessage {
            fn merge(&mut self, other: &Self) {
                if let ::std::option::Option::Some(b) = &other.b() {
                    ::protrust::LiteMessage::merge(self.b_mut(), b);
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl ::protrust::Message for self::SubMessage {
            fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
                &<self::super::TestMutualRecursionA as ::protrust::Message>::descriptor().messages()
                    [0]
            }
        }
        impl self::SubMessage {
            pub const B_FIELD_NUMBER: i32 = 1;
            pub fn b(&self) -> ::std::option::Option<&self::super::TestMutualRecursionB> {
                self.b.as_ref().map(|v| &**v)
            }
            pub fn b_mut(&mut self) -> &mut self::super::TestMutualRecursionB {
                self.b.get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_b(&self) -> bool {
                self.b.is_some()
            }
            pub fn set_b(&mut self, value: self::super::TestMutualRecursionB) {
                self.b = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_b(&mut self) -> ::std::option::Option<self::super::TestMutualRecursionB> {
                self.b.take().map(|v| *v)
            }
            pub fn clear_b(&mut self) {
                self.b = ::std::option::Option::None;
            }
        }
        pub(in super::super::super) mod sub_message {
            pub(in super::super::super) static B_REFLECTOR:
                ::protrust::reflect::access::VerboseFieldAccessor<
                    self::super::SubMessage,
                    self::super::super::TestMutualRecursionB,
                > = ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::SubMessage::b,
                get_mut: self::super::SubMessage::b_mut,
                set: self::super::SubMessage::set_b,
                take: self::super::SubMessage::take_b,
                clear: self::super::SubMessage::clear_b,
            };
        }
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct SubGroup {
            sub_message: ::std::option::Option<::std::boxed::Box<self::SubMessage>>,
            not_in_this_scc: ::std::option::Option<::std::boxed::Box<self::super::TestAllTypes>>,
            unknown_fields: ::protrust::UnknownFieldSet,
        }
        impl ::protrust::CodedMessage for self::SubGroup {
            fn merge_from(
                &mut self,
                input: &mut ::protrust::io::CodedInput,
            ) -> ::protrust::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        26 => input.read_message(self.sub_message_mut())?,
                        34 => input.read_message(self.not_in_this_scc_mut())?,
                        20 => break,
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> i32 {
                let mut size = 0i32;
                if let ::std::option::Option::Some(sub_message) = self.sub_message() {
                    size += 1;
                    size += ::protrust::io::sizes::message(sub_message);
                }
                if let ::std::option::Option::Some(not_in_this_scc) = self.not_in_this_scc() {
                    size += 1;
                    size += ::protrust::io::sizes::message(not_in_this_scc);
                }
                size += self.unknown_fields.calculate_size();
                size
            }
            fn write_to(
                &self,
                output: &mut ::protrust::io::CodedOutput,
            ) -> ::protrust::io::OutputResult {
                if let ::std::option::Option::Some(sub_message) = self.sub_message() {
                    output.write_raw_tag_bytes(&[26])?;
                    output.write_message(sub_message)?;
                }
                if let ::std::option::Option::Some(not_in_this_scc) = self.not_in_this_scc() {
                    output.write_raw_tag_bytes(&[34])?;
                    output.write_message(not_in_this_scc)?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                if let ::std::option::Option::Some(sub_message) = self.sub_message() {
                    if !::protrust::CodedMessage::is_initialized(sub_message) {
                        return false;
                    }
                }
                if let ::std::option::Option::Some(not_in_this_scc) = self.not_in_this_scc() {
                    if !::protrust::CodedMessage::is_initialized(not_in_this_scc) {
                        return false;
                    }
                }
                true
            }
        }
        impl ::protrust::LiteMessage for self::SubGroup {
            fn merge(&mut self, other: &Self) {
                if let ::std::option::Option::Some(sub_message) = &other.sub_message() {
                    ::protrust::LiteMessage::merge(self.sub_message_mut(), sub_message);
                }
                if let ::std::option::Option::Some(not_in_this_scc) = &other.not_in_this_scc() {
                    ::protrust::LiteMessage::merge(self.not_in_this_scc_mut(), not_in_this_scc);
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl ::protrust::Message for self::SubGroup {
            fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
                &<self::super::TestMutualRecursionA as ::protrust::Message>::descriptor().messages()
                    [1]
            }
        }
        impl self::SubGroup {
            pub const SUB_MESSAGE_FIELD_NUMBER: i32 = 3;
            pub fn sub_message(&self) -> ::std::option::Option<&self::SubMessage> {
                self.sub_message.as_ref().map(|v| &**v)
            }
            pub fn sub_message_mut(&mut self) -> &mut self::SubMessage {
                self.sub_message
                    .get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_sub_message(&self) -> bool {
                self.sub_message.is_some()
            }
            pub fn set_sub_message(&mut self, value: self::SubMessage) {
                self.sub_message = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_sub_message(&mut self) -> ::std::option::Option<self::SubMessage> {
                self.sub_message.take().map(|v| *v)
            }
            pub fn clear_sub_message(&mut self) {
                self.sub_message = ::std::option::Option::None;
            }
            pub const NOT_IN_THIS_SCC_FIELD_NUMBER: i32 = 4;
            pub fn not_in_this_scc(&self) -> ::std::option::Option<&self::super::TestAllTypes> {
                self.not_in_this_scc.as_ref().map(|v| &**v)
            }
            pub fn not_in_this_scc_mut(&mut self) -> &mut self::super::TestAllTypes {
                self.not_in_this_scc
                    .get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_not_in_this_scc(&self) -> bool {
                self.not_in_this_scc.is_some()
            }
            pub fn set_not_in_this_scc(&mut self, value: self::super::TestAllTypes) {
                self.not_in_this_scc =
                    ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_not_in_this_scc(
                &mut self,
            ) -> ::std::option::Option<self::super::TestAllTypes> {
                self.not_in_this_scc.take().map(|v| *v)
            }
            pub fn clear_not_in_this_scc(&mut self) {
                self.not_in_this_scc = ::std::option::Option::None;
            }
        }
        pub(in super::super::super) mod sub_group {
            pub(in super::super::super) static SUB_MESSAGE_REFLECTOR:
                ::protrust::reflect::access::VerboseFieldAccessor<
                    self::super::SubGroup,
                    self::super::SubMessage,
                > = ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::SubGroup::sub_message,
                get_mut: self::super::SubGroup::sub_message_mut,
                set: self::super::SubGroup::set_sub_message,
                take: self::super::SubGroup::take_sub_message,
                clear: self::super::SubGroup::clear_sub_message,
            };
            pub(in super::super::super) static NOT_IN_THIS_SCC_REFLECTOR:
                ::protrust::reflect::access::VerboseFieldAccessor<
                    self::super::SubGroup,
                    self::super::super::TestAllTypes,
                > = ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::SubGroup::not_in_this_scc,
                get_mut: self::super::SubGroup::not_in_this_scc_mut,
                set: self::super::SubGroup::set_not_in_this_scc,
                take: self::super::SubGroup::take_not_in_this_scc,
                clear: self::super::SubGroup::clear_not_in_this_scc,
            };
        }
        pub(in super::super) static BB_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestMutualRecursionA,
                self::super::TestMutualRecursionB,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestMutualRecursionA::bb,
            get_mut: self::super::TestMutualRecursionA::bb_mut,
            set: self::super::TestMutualRecursionA::set_bb,
            take: self::super::TestMutualRecursionA::take_bb,
            clear: self::super::TestMutualRecursionA::clear_bb,
        };
        pub(in super::super) static SUBGROUP_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestMutualRecursionA,
                self::SubGroup,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestMutualRecursionA::subgroup,
            get_mut: self::super::TestMutualRecursionA::subgroup_mut,
            set: self::super::TestMutualRecursionA::set_subgroup,
            take: self::super::TestMutualRecursionA::take_subgroup,
            clear: self::super::TestMutualRecursionA::clear_subgroup,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestMutualRecursionB {
        a: ::std::option::Option<::std::boxed::Box<self::TestMutualRecursionA>>,
        optional_int32: ::std::option::Option<i32>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestMutualRecursionB {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => input.read_message(self.a_mut())?,
                    16 | 18 => self.set_optional_int32(input.read_int32()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(a) = self.a() {
                size += 1;
                size += ::protrust::io::sizes::message(a);
            }
            if let ::std::option::Option::Some(optional_int32) = self.optional_int32_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*optional_int32);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(a) = self.a() {
                output.write_raw_tag_bytes(&[10])?;
                output.write_message(a)?;
            }
            if let ::std::option::Option::Some(optional_int32) = self.optional_int32_option() {
                output.write_raw_tag_bytes(&[16])?;
                output.write_int32(*optional_int32)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(a) = self.a() {
                if !::protrust::CodedMessage::is_initialized(a) {
                    return false;
                }
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestMutualRecursionB {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(a) = &other.a() {
                ::protrust::LiteMessage::merge(self.a_mut(), a);
            }
            if let ::std::option::Option::Some(optional_int32) = other.optional_int32_option() {
                self.set_optional_int32(*optional_int32);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestMutualRecursionB {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[22]
        }
    }
    impl self::TestMutualRecursionB {
        pub const A_FIELD_NUMBER: i32 = 1;
        pub fn a(&self) -> ::std::option::Option<&self::TestMutualRecursionA> {
            self.a.as_ref().map(|v| &**v)
        }
        pub fn a_mut(&mut self) -> &mut self::TestMutualRecursionA {
            self.a.get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_a(&self) -> bool {
            self.a.is_some()
        }
        pub fn set_a(&mut self, value: self::TestMutualRecursionA) {
            self.a = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_a(&mut self) -> ::std::option::Option<self::TestMutualRecursionA> {
            self.a.take().map(|v| *v)
        }
        pub fn clear_a(&mut self) {
            self.a = ::std::option::Option::None;
        }
        pub const OPTIONAL_INT32_FIELD_NUMBER: i32 = 2;
        pub const OPTIONAL_INT32_DEFAULT_VALUE: i32 = 0;
        pub fn optional_int32(&self) -> i32 {
            self.optional_int32
                .unwrap_or(Self::OPTIONAL_INT32_DEFAULT_VALUE)
        }
        pub fn optional_int32_option(&self) -> ::std::option::Option<&i32> {
            self.optional_int32.as_ref()
        }
        pub fn optional_int32_mut(&mut self) -> &mut i32 {
            self.optional_int32
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_int32(&self) -> bool {
            self.optional_int32.is_some()
        }
        pub fn set_optional_int32(&mut self, value: i32) {
            self.optional_int32 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_int32(&mut self) -> ::std::option::Option<i32> {
            self.optional_int32.take()
        }
        pub fn clear_optional_int32(&mut self) {
            self.optional_int32 = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod test_mutual_recursion_b {
        pub(in super::super) static A_REFLECTOR: ::protrust::reflect::access::VerboseFieldAccessor<
            self::super::TestMutualRecursionB,
            self::super::TestMutualRecursionA,
        > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestMutualRecursionB::a,
            get_mut: self::super::TestMutualRecursionB::a_mut,
            set: self::super::TestMutualRecursionB::set_a,
            take: self::super::TestMutualRecursionB::take_a,
            clear: self::super::TestMutualRecursionB::clear_a,
        };
        pub(in super::super) static OPTIONAL_INT32_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestMutualRecursionB,
                i32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestMutualRecursionB::optional_int32_option,
            get_mut: self::super::TestMutualRecursionB::optional_int32_mut,
            set: self::super::TestMutualRecursionB::set_optional_int32,
            take: self::super::TestMutualRecursionB::take_optional_int32,
            clear: self::super::TestMutualRecursionB::clear_optional_int32,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestIsInitialized {
        sub_message:
            ::std::option::Option<::std::boxed::Box<self::test_is_initialized::SubMessage>>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestIsInitialized {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => input.read_message(self.sub_message_mut())?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(sub_message) = self.sub_message() {
                size += 1;
                size += ::protrust::io::sizes::message(sub_message);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(sub_message) = self.sub_message() {
                output.write_raw_tag_bytes(&[10])?;
                output.write_message(sub_message)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(sub_message) = self.sub_message() {
                if !::protrust::CodedMessage::is_initialized(sub_message) {
                    return false;
                }
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestIsInitialized {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(sub_message) = &other.sub_message() {
                ::protrust::LiteMessage::merge(self.sub_message_mut(), sub_message);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestIsInitialized {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[23]
        }
    }
    impl self::TestIsInitialized {
        pub const SUB_MESSAGE_FIELD_NUMBER: i32 = 1;
        pub fn sub_message(&self) -> ::std::option::Option<&self::test_is_initialized::SubMessage> {
            self.sub_message.as_ref().map(|v| &**v)
        }
        pub fn sub_message_mut(&mut self) -> &mut self::test_is_initialized::SubMessage {
            self.sub_message
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_sub_message(&self) -> bool {
            self.sub_message.is_some()
        }
        pub fn set_sub_message(&mut self, value: self::test_is_initialized::SubMessage) {
            self.sub_message = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_sub_message(
            &mut self,
        ) -> ::std::option::Option<self::test_is_initialized::SubMessage> {
            self.sub_message.take().map(|v| *v)
        }
        pub fn clear_sub_message(&mut self) {
            self.sub_message = ::std::option::Option::None;
        }
    }
    pub mod test_is_initialized {
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct SubMessage {
            subgroup: ::std::option::Option<::std::boxed::Box<self::sub_message::SubGroup>>,
            unknown_fields: ::protrust::UnknownFieldSet,
        }
        impl ::protrust::CodedMessage for self::SubMessage {
            fn merge_from(
                &mut self,
                input: &mut ::protrust::io::CodedInput,
            ) -> ::protrust::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        11 => input.read_group(self.subgroup_mut())?,
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> i32 {
                let mut size = 0i32;
                if let ::std::option::Option::Some(subgroup) = self.subgroup() {
                    size += 1;
                    size += ::protrust::io::sizes::group(subgroup);
                    size += 1;
                }
                size += self.unknown_fields.calculate_size();
                size
            }
            fn write_to(
                &self,
                output: &mut ::protrust::io::CodedOutput,
            ) -> ::protrust::io::OutputResult {
                if let ::std::option::Option::Some(subgroup) = self.subgroup() {
                    output.write_raw_tag_bytes(&[11])?;
                    output.write_group(subgroup)?;
                    output.write_raw_tag_bytes(&[12])?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                if let ::std::option::Option::Some(subgroup) = self.subgroup() {
                    if !::protrust::CodedMessage::is_initialized(subgroup) {
                        return false;
                    }
                }
                true
            }
        }
        impl ::protrust::LiteMessage for self::SubMessage {
            fn merge(&mut self, other: &Self) {
                if let ::std::option::Option::Some(subgroup) = &other.subgroup() {
                    ::protrust::LiteMessage::merge(self.subgroup_mut(), subgroup);
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl ::protrust::Message for self::SubMessage {
            fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
                &<self::super::TestIsInitialized as ::protrust::Message>::descriptor().messages()[0]
            }
        }
        impl self::SubMessage {
            pub const SUBGROUP_FIELD_NUMBER: i32 = 1;
            pub fn subgroup(&self) -> ::std::option::Option<&self::sub_message::SubGroup> {
                self.subgroup.as_ref().map(|v| &**v)
            }
            pub fn subgroup_mut(&mut self) -> &mut self::sub_message::SubGroup {
                self.subgroup
                    .get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_subgroup(&self) -> bool {
                self.subgroup.is_some()
            }
            pub fn set_subgroup(&mut self, value: self::sub_message::SubGroup) {
                self.subgroup = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_subgroup(&mut self) -> ::std::option::Option<self::sub_message::SubGroup> {
                self.subgroup.take().map(|v| *v)
            }
            pub fn clear_subgroup(&mut self) {
                self.subgroup = ::std::option::Option::None;
            }
        }
        pub mod sub_message {
            #[derive(Clone, Debug, PartialEq, Default)]
            pub struct SubGroup {
                i: ::std::option::Option<i32>,
                unknown_fields: ::protrust::UnknownFieldSet,
            }
            impl ::protrust::CodedMessage for self::SubGroup {
                fn merge_from(
                    &mut self,
                    input: &mut ::protrust::io::CodedInput,
                ) -> ::protrust::io::InputResult<()> {
                    while let ::std::option::Option::Some(tag) = input.read_tag()? {
                        match tag.get() {
                            16 | 18 => self.set_i(input.read_int32()?),
                            12 => break,
                            _ => self.unknown_fields.merge_from(tag, input)?,
                        }
                    }
                    ::std::result::Result::Ok(())
                }
                fn calculate_size(&self) -> i32 {
                    let mut size = 0i32;
                    if let ::std::option::Option::Some(i) = self.i_option() {
                        size += 1;
                        size += ::protrust::io::sizes::int32(*i);
                    }
                    size += self.unknown_fields.calculate_size();
                    size
                }
                fn write_to(
                    &self,
                    output: &mut ::protrust::io::CodedOutput,
                ) -> ::protrust::io::OutputResult {
                    if let ::std::option::Option::Some(i) = self.i_option() {
                        output.write_raw_tag_bytes(&[16])?;
                        output.write_int32(*i)?;
                    }
                    self.unknown_fields.write_to(output)?;
                    ::std::result::Result::Ok(())
                }
                fn is_initialized(&self) -> bool {
                    if !self.has_i() {
                        return false;
                    }
                    true
                }
            }
            impl ::protrust::LiteMessage for self::SubGroup {
                fn merge(&mut self, other: &Self) {
                    if let ::std::option::Option::Some(i) = other.i_option() {
                        self.set_i(*i);
                    }
                    self.unknown_fields.merge(&other.unknown_fields);
                }
            }
            impl ::protrust::Message for self::SubGroup {
                fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
                    &<self::super::SubMessage as ::protrust::Message>::descriptor().messages()[0]
                }
            }
            impl self::SubGroup {
                pub const I_FIELD_NUMBER: i32 = 2;
                pub const I_DEFAULT_VALUE: i32 = 0;
                pub fn i(&self) -> i32 {
                    self.i.unwrap_or(Self::I_DEFAULT_VALUE)
                }
                pub fn i_option(&self) -> ::std::option::Option<&i32> {
                    self.i.as_ref()
                }
                pub fn i_mut(&mut self) -> &mut i32 {
                    self.i.get_or_insert_with(::std::default::Default::default)
                }
                pub fn has_i(&self) -> bool {
                    self.i.is_some()
                }
                pub fn set_i(&mut self, value: i32) {
                    self.i = ::std::option::Option::Some(::std::convert::From::from(value))
                }
                pub fn take_i(&mut self) -> ::std::option::Option<i32> {
                    self.i.take()
                }
                pub fn clear_i(&mut self) {
                    self.i = ::std::option::Option::None;
                }
            }
            pub(in super::super::super::super) mod sub_group {
                pub(in super::super::super::super) static I_REFLECTOR:
                    ::protrust::reflect::access::VerboseFieldAccessor<self::super::SubGroup, i32> =
                    ::protrust::reflect::access::VerboseFieldAccessor {
                        get_option: self::super::SubGroup::i_option,
                        get_mut: self::super::SubGroup::i_mut,
                        set: self::super::SubGroup::set_i,
                        take: self::super::SubGroup::take_i,
                        clear: self::super::SubGroup::clear_i,
                    };
            }
            pub(in super::super::super) static SUBGROUP_REFLECTOR:
                ::protrust::reflect::access::VerboseFieldAccessor<
                    self::super::SubMessage,
                    self::SubGroup,
                > = ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::SubMessage::subgroup,
                get_mut: self::super::SubMessage::subgroup_mut,
                set: self::super::SubMessage::set_subgroup,
                take: self::super::SubMessage::take_subgroup,
                clear: self::super::SubMessage::clear_subgroup,
            };
        }
        pub(in super::super) static SUB_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestIsInitialized,
                self::SubMessage,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestIsInitialized::sub_message,
            get_mut: self::super::TestIsInitialized::sub_message_mut,
            set: self::super::TestIsInitialized::set_sub_message,
            take: self::super::TestIsInitialized::take_sub_message,
            clear: self::super::TestIsInitialized::clear_sub_message,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestDupFieldNumber {
        a: ::std::option::Option<i32>,
        foo: ::std::option::Option<::std::boxed::Box<self::test_dup_field_number::Foo>>,
        bar: ::std::option::Option<::std::boxed::Box<self::test_dup_field_number::Bar>>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestDupFieldNumber {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.set_a(input.read_int32()?),
                    19 => input.read_group(self.foo_mut())?,
                    27 => input.read_group(self.bar_mut())?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(a) = self.a_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*a);
            }
            if let ::std::option::Option::Some(foo) = self.foo() {
                size += 1;
                size += ::protrust::io::sizes::group(foo);
                size += 1;
            }
            if let ::std::option::Option::Some(bar) = self.bar() {
                size += 1;
                size += ::protrust::io::sizes::group(bar);
                size += 1;
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(a) = self.a_option() {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(*a)?;
            }
            if let ::std::option::Option::Some(foo) = self.foo() {
                output.write_raw_tag_bytes(&[19])?;
                output.write_group(foo)?;
                output.write_raw_tag_bytes(&[20])?;
            }
            if let ::std::option::Option::Some(bar) = self.bar() {
                output.write_raw_tag_bytes(&[27])?;
                output.write_group(bar)?;
                output.write_raw_tag_bytes(&[28])?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(foo) = self.foo() {
                if !::protrust::CodedMessage::is_initialized(foo) {
                    return false;
                }
            }
            if let ::std::option::Option::Some(bar) = self.bar() {
                if !::protrust::CodedMessage::is_initialized(bar) {
                    return false;
                }
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestDupFieldNumber {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(a) = other.a_option() {
                self.set_a(*a);
            }
            if let ::std::option::Option::Some(foo) = &other.foo() {
                ::protrust::LiteMessage::merge(self.foo_mut(), foo);
            }
            if let ::std::option::Option::Some(bar) = &other.bar() {
                ::protrust::LiteMessage::merge(self.bar_mut(), bar);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestDupFieldNumber {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[24]
        }
    }
    impl self::TestDupFieldNumber {
        pub const A_FIELD_NUMBER: i32 = 1;
        pub const A_DEFAULT_VALUE: i32 = 0;
        pub fn a(&self) -> i32 {
            self.a.unwrap_or(Self::A_DEFAULT_VALUE)
        }
        pub fn a_option(&self) -> ::std::option::Option<&i32> {
            self.a.as_ref()
        }
        pub fn a_mut(&mut self) -> &mut i32 {
            self.a.get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_a(&self) -> bool {
            self.a.is_some()
        }
        pub fn set_a(&mut self, value: i32) {
            self.a = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_a(&mut self) -> ::std::option::Option<i32> {
            self.a.take()
        }
        pub fn clear_a(&mut self) {
            self.a = ::std::option::Option::None;
        }
        pub const FOO_FIELD_NUMBER: i32 = 2;
        pub fn foo(&self) -> ::std::option::Option<&self::test_dup_field_number::Foo> {
            self.foo.as_ref().map(|v| &**v)
        }
        pub fn foo_mut(&mut self) -> &mut self::test_dup_field_number::Foo {
            self.foo
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_foo(&self) -> bool {
            self.foo.is_some()
        }
        pub fn set_foo(&mut self, value: self::test_dup_field_number::Foo) {
            self.foo = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_foo(&mut self) -> ::std::option::Option<self::test_dup_field_number::Foo> {
            self.foo.take().map(|v| *v)
        }
        pub fn clear_foo(&mut self) {
            self.foo = ::std::option::Option::None;
        }
        pub const BAR_FIELD_NUMBER: i32 = 3;
        pub fn bar(&self) -> ::std::option::Option<&self::test_dup_field_number::Bar> {
            self.bar.as_ref().map(|v| &**v)
        }
        pub fn bar_mut(&mut self) -> &mut self::test_dup_field_number::Bar {
            self.bar
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_bar(&self) -> bool {
            self.bar.is_some()
        }
        pub fn set_bar(&mut self, value: self::test_dup_field_number::Bar) {
            self.bar = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_bar(&mut self) -> ::std::option::Option<self::test_dup_field_number::Bar> {
            self.bar.take().map(|v| *v)
        }
        pub fn clear_bar(&mut self) {
            self.bar = ::std::option::Option::None;
        }
    }
    pub mod test_dup_field_number {
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct Foo {
            a: ::std::option::Option<i32>,
            unknown_fields: ::protrust::UnknownFieldSet,
        }
        impl ::protrust::CodedMessage for self::Foo {
            fn merge_from(
                &mut self,
                input: &mut ::protrust::io::CodedInput,
            ) -> ::protrust::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        8 | 10 => self.set_a(input.read_int32()?),
                        20 => break,
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> i32 {
                let mut size = 0i32;
                if let ::std::option::Option::Some(a) = self.a_option() {
                    size += 1;
                    size += ::protrust::io::sizes::int32(*a);
                }
                size += self.unknown_fields.calculate_size();
                size
            }
            fn write_to(
                &self,
                output: &mut ::protrust::io::CodedOutput,
            ) -> ::protrust::io::OutputResult {
                if let ::std::option::Option::Some(a) = self.a_option() {
                    output.write_raw_tag_bytes(&[8])?;
                    output.write_int32(*a)?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                true
            }
        }
        impl ::protrust::LiteMessage for self::Foo {
            fn merge(&mut self, other: &Self) {
                if let ::std::option::Option::Some(a) = other.a_option() {
                    self.set_a(*a);
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl ::protrust::Message for self::Foo {
            fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
                &<self::super::TestDupFieldNumber as ::protrust::Message>::descriptor().messages()
                    [0]
            }
        }
        impl self::Foo {
            pub const A_FIELD_NUMBER: i32 = 1;
            pub const A_DEFAULT_VALUE: i32 = 0;
            pub fn a(&self) -> i32 {
                self.a.unwrap_or(Self::A_DEFAULT_VALUE)
            }
            pub fn a_option(&self) -> ::std::option::Option<&i32> {
                self.a.as_ref()
            }
            pub fn a_mut(&mut self) -> &mut i32 {
                self.a.get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_a(&self) -> bool {
                self.a.is_some()
            }
            pub fn set_a(&mut self, value: i32) {
                self.a = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_a(&mut self) -> ::std::option::Option<i32> {
                self.a.take()
            }
            pub fn clear_a(&mut self) {
                self.a = ::std::option::Option::None;
            }
        }
        pub(in super::super::super) mod foo {
            pub(in super::super::super) static A_REFLECTOR:
                ::protrust::reflect::access::VerboseFieldAccessor<self::super::Foo, i32> =
                ::protrust::reflect::access::VerboseFieldAccessor {
                    get_option: self::super::Foo::a_option,
                    get_mut: self::super::Foo::a_mut,
                    set: self::super::Foo::set_a,
                    take: self::super::Foo::take_a,
                    clear: self::super::Foo::clear_a,
                };
        }
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct Bar {
            a: ::std::option::Option<i32>,
            unknown_fields: ::protrust::UnknownFieldSet,
        }
        impl ::protrust::CodedMessage for self::Bar {
            fn merge_from(
                &mut self,
                input: &mut ::protrust::io::CodedInput,
            ) -> ::protrust::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        8 | 10 => self.set_a(input.read_int32()?),
                        28 => break,
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> i32 {
                let mut size = 0i32;
                if let ::std::option::Option::Some(a) = self.a_option() {
                    size += 1;
                    size += ::protrust::io::sizes::int32(*a);
                }
                size += self.unknown_fields.calculate_size();
                size
            }
            fn write_to(
                &self,
                output: &mut ::protrust::io::CodedOutput,
            ) -> ::protrust::io::OutputResult {
                if let ::std::option::Option::Some(a) = self.a_option() {
                    output.write_raw_tag_bytes(&[8])?;
                    output.write_int32(*a)?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                true
            }
        }
        impl ::protrust::LiteMessage for self::Bar {
            fn merge(&mut self, other: &Self) {
                if let ::std::option::Option::Some(a) = other.a_option() {
                    self.set_a(*a);
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl ::protrust::Message for self::Bar {
            fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
                &<self::super::TestDupFieldNumber as ::protrust::Message>::descriptor().messages()
                    [1]
            }
        }
        impl self::Bar {
            pub const A_FIELD_NUMBER: i32 = 1;
            pub const A_DEFAULT_VALUE: i32 = 0;
            pub fn a(&self) -> i32 {
                self.a.unwrap_or(Self::A_DEFAULT_VALUE)
            }
            pub fn a_option(&self) -> ::std::option::Option<&i32> {
                self.a.as_ref()
            }
            pub fn a_mut(&mut self) -> &mut i32 {
                self.a.get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_a(&self) -> bool {
                self.a.is_some()
            }
            pub fn set_a(&mut self, value: i32) {
                self.a = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_a(&mut self) -> ::std::option::Option<i32> {
                self.a.take()
            }
            pub fn clear_a(&mut self) {
                self.a = ::std::option::Option::None;
            }
        }
        pub(in super::super::super) mod bar {
            pub(in super::super::super) static A_REFLECTOR:
                ::protrust::reflect::access::VerboseFieldAccessor<self::super::Bar, i32> =
                ::protrust::reflect::access::VerboseFieldAccessor {
                    get_option: self::super::Bar::a_option,
                    get_mut: self::super::Bar::a_mut,
                    set: self::super::Bar::set_a,
                    take: self::super::Bar::take_a,
                    clear: self::super::Bar::clear_a,
                };
        }
        pub(in super::super) static A_REFLECTOR: ::protrust::reflect::access::VerboseFieldAccessor<
            self::super::TestDupFieldNumber,
            i32,
        > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestDupFieldNumber::a_option,
            get_mut: self::super::TestDupFieldNumber::a_mut,
            set: self::super::TestDupFieldNumber::set_a,
            take: self::super::TestDupFieldNumber::take_a,
            clear: self::super::TestDupFieldNumber::clear_a,
        };
        pub(in super::super) static FOO_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestDupFieldNumber,
                self::Foo,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestDupFieldNumber::foo,
            get_mut: self::super::TestDupFieldNumber::foo_mut,
            set: self::super::TestDupFieldNumber::set_foo,
            take: self::super::TestDupFieldNumber::take_foo,
            clear: self::super::TestDupFieldNumber::clear_foo,
        };
        pub(in super::super) static BAR_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestDupFieldNumber,
                self::Bar,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestDupFieldNumber::bar,
            get_mut: self::super::TestDupFieldNumber::bar_mut,
            set: self::super::TestDupFieldNumber::set_bar,
            take: self::super::TestDupFieldNumber::take_bar,
            clear: self::super::TestDupFieldNumber::clear_bar,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestEagerMessage {
        sub_message: ::std::option::Option<::std::boxed::Box<self::TestAllTypes>>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestEagerMessage {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => input.read_message(self.sub_message_mut())?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(sub_message) = self.sub_message() {
                size += 1;
                size += ::protrust::io::sizes::message(sub_message);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(sub_message) = self.sub_message() {
                output.write_raw_tag_bytes(&[10])?;
                output.write_message(sub_message)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(sub_message) = self.sub_message() {
                if !::protrust::CodedMessage::is_initialized(sub_message) {
                    return false;
                }
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestEagerMessage {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(sub_message) = &other.sub_message() {
                ::protrust::LiteMessage::merge(self.sub_message_mut(), sub_message);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestEagerMessage {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[25]
        }
    }
    impl self::TestEagerMessage {
        pub const SUB_MESSAGE_FIELD_NUMBER: i32 = 1;
        pub fn sub_message(&self) -> ::std::option::Option<&self::TestAllTypes> {
            self.sub_message.as_ref().map(|v| &**v)
        }
        pub fn sub_message_mut(&mut self) -> &mut self::TestAllTypes {
            self.sub_message
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_sub_message(&self) -> bool {
            self.sub_message.is_some()
        }
        pub fn set_sub_message(&mut self, value: self::TestAllTypes) {
            self.sub_message = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_sub_message(&mut self) -> ::std::option::Option<self::TestAllTypes> {
            self.sub_message.take().map(|v| *v)
        }
        pub fn clear_sub_message(&mut self) {
            self.sub_message = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod test_eager_message {
        pub(in super::super) static SUB_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestEagerMessage,
                self::super::TestAllTypes,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestEagerMessage::sub_message,
            get_mut: self::super::TestEagerMessage::sub_message_mut,
            set: self::super::TestEagerMessage::set_sub_message,
            take: self::super::TestEagerMessage::take_sub_message,
            clear: self::super::TestEagerMessage::clear_sub_message,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestLazyMessage {
        sub_message: ::std::option::Option<::std::boxed::Box<self::TestAllTypes>>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestLazyMessage {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => input.read_message(self.sub_message_mut())?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(sub_message) = self.sub_message() {
                size += 1;
                size += ::protrust::io::sizes::message(sub_message);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(sub_message) = self.sub_message() {
                output.write_raw_tag_bytes(&[10])?;
                output.write_message(sub_message)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(sub_message) = self.sub_message() {
                if !::protrust::CodedMessage::is_initialized(sub_message) {
                    return false;
                }
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestLazyMessage {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(sub_message) = &other.sub_message() {
                ::protrust::LiteMessage::merge(self.sub_message_mut(), sub_message);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestLazyMessage {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[26]
        }
    }
    impl self::TestLazyMessage {
        pub const SUB_MESSAGE_FIELD_NUMBER: i32 = 1;
        pub fn sub_message(&self) -> ::std::option::Option<&self::TestAllTypes> {
            self.sub_message.as_ref().map(|v| &**v)
        }
        pub fn sub_message_mut(&mut self) -> &mut self::TestAllTypes {
            self.sub_message
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_sub_message(&self) -> bool {
            self.sub_message.is_some()
        }
        pub fn set_sub_message(&mut self, value: self::TestAllTypes) {
            self.sub_message = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_sub_message(&mut self) -> ::std::option::Option<self::TestAllTypes> {
            self.sub_message.take().map(|v| *v)
        }
        pub fn clear_sub_message(&mut self) {
            self.sub_message = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod test_lazy_message {
        pub(in super::super) static SUB_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestLazyMessage,
                self::super::TestAllTypes,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestLazyMessage::sub_message,
            get_mut: self::super::TestLazyMessage::sub_message_mut,
            set: self::super::TestLazyMessage::set_sub_message,
            take: self::super::TestLazyMessage::take_sub_message,
            clear: self::super::TestLazyMessage::clear_sub_message,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestNestedMessageHasBits {
        optional_nested_message: ::std::option::Option<
            ::std::boxed::Box<self::test_nested_message_has_bits::NestedMessage>,
        >,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestNestedMessageHasBits {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => input.read_message(self.optional_nested_message_mut())?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(optional_nested_message) =
                self.optional_nested_message()
            {
                size += 1;
                size += ::protrust::io::sizes::message(optional_nested_message);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(optional_nested_message) =
                self.optional_nested_message()
            {
                output.write_raw_tag_bytes(&[10])?;
                output.write_message(optional_nested_message)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(optional_nested_message) =
                self.optional_nested_message()
            {
                if !::protrust::CodedMessage::is_initialized(optional_nested_message) {
                    return false;
                }
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestNestedMessageHasBits {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(optional_nested_message) =
                &other.optional_nested_message()
            {
                ::protrust::LiteMessage::merge(
                    self.optional_nested_message_mut(),
                    optional_nested_message,
                );
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestNestedMessageHasBits {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[27]
        }
    }
    impl self::TestNestedMessageHasBits {
        pub const OPTIONAL_NESTED_MESSAGE_FIELD_NUMBER: i32 = 1;
        pub fn optional_nested_message(
            &self,
        ) -> ::std::option::Option<&self::test_nested_message_has_bits::NestedMessage> {
            self.optional_nested_message.as_ref().map(|v| &**v)
        }
        pub fn optional_nested_message_mut(
            &mut self,
        ) -> &mut self::test_nested_message_has_bits::NestedMessage {
            self.optional_nested_message
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_nested_message(&self) -> bool {
            self.optional_nested_message.is_some()
        }
        pub fn set_optional_nested_message(
            &mut self,
            value: self::test_nested_message_has_bits::NestedMessage,
        ) {
            self.optional_nested_message =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_nested_message(
            &mut self,
        ) -> ::std::option::Option<self::test_nested_message_has_bits::NestedMessage> {
            self.optional_nested_message.take().map(|v| *v)
        }
        pub fn clear_optional_nested_message(&mut self) {
            self.optional_nested_message = ::std::option::Option::None;
        }
    }
    pub mod test_nested_message_has_bits {
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct NestedMessage {
            nestedmessage_repeated_int32: ::protrust::collections::RepeatedField<i32>,
            nestedmessage_repeated_foreignmessage:
                ::protrust::collections::RepeatedField<self::super::ForeignMessage>,
            unknown_fields: ::protrust::UnknownFieldSet,
        }
        impl ::protrust::CodedMessage for self::NestedMessage {
            fn merge_from(
                &mut self,
                input: &mut ::protrust::io::CodedInput,
            ) -> ::protrust::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        8 | 10 => self.nestedmessage_repeated_int32.add_entries(
                            input,
                            &self::nested_message::NESTEDMESSAGE_REPEATED_INT32_CODEC,
                        )?,
                        18 => self.nestedmessage_repeated_foreignmessage.add_entries(
                            input,
                            &self::nested_message::NESTEDMESSAGE_REPEATED_FOREIGNMESSAGE_CODEC,
                        )?,
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> i32 {
                let mut size = 0i32;
                size += self
                    .nestedmessage_repeated_int32()
                    .calculate_size(&self::nested_message::NESTEDMESSAGE_REPEATED_INT32_CODEC);
                size += self.nestedmessage_repeated_foreignmessage().calculate_size(
                    &self::nested_message::NESTEDMESSAGE_REPEATED_FOREIGNMESSAGE_CODEC,
                );
                size += self.unknown_fields.calculate_size();
                size
            }
            fn write_to(
                &self,
                output: &mut ::protrust::io::CodedOutput,
            ) -> ::protrust::io::OutputResult {
                self.nestedmessage_repeated_int32().write_to(
                    output,
                    &self::nested_message::NESTEDMESSAGE_REPEATED_INT32_CODEC,
                )?;
                self.nestedmessage_repeated_foreignmessage().write_to(
                    output,
                    &self::nested_message::NESTEDMESSAGE_REPEATED_FOREIGNMESSAGE_CODEC,
                )?;
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                if !self.nestedmessage_repeated_foreignmessage.is_initialized() {
                    return false;
                }
                true
            }
        }
        impl ::protrust::LiteMessage for self::NestedMessage {
            fn merge(&mut self, other: &Self) {
                self.nestedmessage_repeated_int32
                    .merge(&other.nestedmessage_repeated_int32);
                self.nestedmessage_repeated_foreignmessage
                    .merge(&other.nestedmessage_repeated_foreignmessage);
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl ::protrust::Message for self::NestedMessage {
            fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
                &<self::super::TestNestedMessageHasBits as ::protrust::Message>::descriptor()
                    .messages()[0]
            }
        }
        impl self::NestedMessage {
            pub const NESTEDMESSAGE_REPEATED_INT32_FIELD_NUMBER: i32 = 1;
            pub fn nestedmessage_repeated_int32(
                &self,
            ) -> &::protrust::collections::RepeatedField<i32> {
                &self.nestedmessage_repeated_int32
            }
            pub fn nestedmessage_repeated_int32_mut(
                &mut self,
            ) -> &mut ::protrust::collections::RepeatedField<i32> {
                &mut self.nestedmessage_repeated_int32
            }
            pub const NESTEDMESSAGE_REPEATED_FOREIGNMESSAGE_FIELD_NUMBER: i32 = 2;
            pub fn nestedmessage_repeated_foreignmessage(
                &self,
            ) -> &::protrust::collections::RepeatedField<self::super::ForeignMessage> {
                &self.nestedmessage_repeated_foreignmessage
            }
            pub fn nestedmessage_repeated_foreignmessage_mut(
                &mut self,
            ) -> &mut ::protrust::collections::RepeatedField<self::super::ForeignMessage>
            {
                &mut self.nestedmessage_repeated_foreignmessage
            }
        }
        pub(in super::super::super) mod nested_message {
            pub(super) static NESTEDMESSAGE_REPEATED_INT32_CODEC: ::protrust::Codec<i32> =
                ::protrust::Codec::int32(8);
            pub(super) static NESTEDMESSAGE_REPEATED_FOREIGNMESSAGE_CODEC: ::protrust::Codec<
                self::super::super::ForeignMessage,
            > = ::protrust::Codec::message(18);
            pub(in super::super::super) static NESTEDMESSAGE_REPEATED_INT32_REFLECTOR:
                ::protrust::reflect::access::SimpleFieldAccessor<
                    self::super::NestedMessage,
                    ::protrust::collections::RepeatedField<i32>,
                > = ::protrust::reflect::access::SimpleFieldAccessor {
                get: self::super::NestedMessage::nestedmessage_repeated_int32,
                get_mut: self::super::NestedMessage::nestedmessage_repeated_int32_mut,
            };
            pub(in super::super::super) static NESTEDMESSAGE_REPEATED_FOREIGNMESSAGE_REFLECTOR:
                ::protrust::reflect::access::SimpleFieldAccessor<
                    self::super::NestedMessage,
                    ::protrust::collections::RepeatedField<self::super::super::ForeignMessage>,
                > = ::protrust::reflect::access::SimpleFieldAccessor {
                get: self::super::NestedMessage::nestedmessage_repeated_foreignmessage,
                get_mut: self::super::NestedMessage::nestedmessage_repeated_foreignmessage_mut,
            };
        }
        pub(in super::super) static OPTIONAL_NESTED_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestNestedMessageHasBits,
                self::NestedMessage,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestNestedMessageHasBits::optional_nested_message,
            get_mut: self::super::TestNestedMessageHasBits::optional_nested_message_mut,
            set: self::super::TestNestedMessageHasBits::set_optional_nested_message,
            take: self::super::TestNestedMessageHasBits::take_optional_nested_message,
            clear: self::super::TestNestedMessageHasBits::clear_optional_nested_message,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestCamelCaseFieldNames {
        PrimitiveField: ::std::option::Option<i32>,
        StringField: ::std::option::Option<::std::string::String>,
        EnumField: ::std::option::Option<::protrust::EnumValue<self::ForeignEnum>>,
        MessageField: ::std::option::Option<::std::boxed::Box<self::ForeignMessage>>,
        StringPieceField: ::std::option::Option<::std::string::String>,
        CordField: ::std::option::Option<::std::string::String>,
        RepeatedPrimitiveField: ::protrust::collections::RepeatedField<i32>,
        RepeatedStringField: ::protrust::collections::RepeatedField<::std::string::String>,
        RepeatedEnumField:
            ::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>>,
        RepeatedMessageField: ::protrust::collections::RepeatedField<self::ForeignMessage>,
        RepeatedStringPieceField: ::protrust::collections::RepeatedField<::std::string::String>,
        RepeatedCordField: ::protrust::collections::RepeatedField<::std::string::String>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestCamelCaseFieldNames {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.set_PrimitiveField(input.read_int32()?),
                    18 => self.set_StringField(input.read_string()?),
                    24 | 26 => self.set_EnumField(input.read_enum_value()?),
                    34 => input.read_message(self.MessageField_mut())?,
                    42 => self.set_StringPieceField(input.read_string()?),
                    50 => self.set_CordField(input.read_string()?),
                    56 | 58 => self.RepeatedPrimitiveField.add_entries(
                        input,
                        &self::test_camel_case_field_names::REPEATEDPRIMITIVEFIELD_CODEC,
                    )?,
                    66 => self.RepeatedStringField.add_entries(
                        input,
                        &self::test_camel_case_field_names::REPEATEDSTRINGFIELD_CODEC,
                    )?,
                    72 | 74 => self.RepeatedEnumField.add_entries(
                        input,
                        &self::test_camel_case_field_names::REPEATEDENUMFIELD_CODEC,
                    )?,
                    82 => self.RepeatedMessageField.add_entries(
                        input,
                        &self::test_camel_case_field_names::REPEATEDMESSAGEFIELD_CODEC,
                    )?,
                    90 => self.RepeatedStringPieceField.add_entries(
                        input,
                        &self::test_camel_case_field_names::REPEATEDSTRINGPIECEFIELD_CODEC,
                    )?,
                    98 => self.RepeatedCordField.add_entries(
                        input,
                        &self::test_camel_case_field_names::REPEATEDCORDFIELD_CODEC,
                    )?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(PrimitiveField) = self.PrimitiveField_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*PrimitiveField);
            }
            if let ::std::option::Option::Some(StringField) = self.StringField_option() {
                size += 1;
                size += ::protrust::io::sizes::string(StringField);
            }
            if let ::std::option::Option::Some(EnumField) = self.EnumField_option() {
                size += 1;
                size += ::protrust::io::sizes::enum_value(*EnumField);
            }
            if let ::std::option::Option::Some(MessageField) = self.MessageField() {
                size += 1;
                size += ::protrust::io::sizes::message(MessageField);
            }
            if let ::std::option::Option::Some(StringPieceField) = self.StringPieceField_option() {
                size += 1;
                size += ::protrust::io::sizes::string(StringPieceField);
            }
            if let ::std::option::Option::Some(CordField) = self.CordField_option() {
                size += 1;
                size += ::protrust::io::sizes::string(CordField);
            }
            size += self
                .RepeatedPrimitiveField()
                .calculate_size(&self::test_camel_case_field_names::REPEATEDPRIMITIVEFIELD_CODEC);
            size += self
                .RepeatedStringField()
                .calculate_size(&self::test_camel_case_field_names::REPEATEDSTRINGFIELD_CODEC);
            size += self
                .RepeatedEnumField()
                .calculate_size(&self::test_camel_case_field_names::REPEATEDENUMFIELD_CODEC);
            size += self
                .RepeatedMessageField()
                .calculate_size(&self::test_camel_case_field_names::REPEATEDMESSAGEFIELD_CODEC);
            size += self
                .RepeatedStringPieceField()
                .calculate_size(&self::test_camel_case_field_names::REPEATEDSTRINGPIECEFIELD_CODEC);
            size += self
                .RepeatedCordField()
                .calculate_size(&self::test_camel_case_field_names::REPEATEDCORDFIELD_CODEC);
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(PrimitiveField) = self.PrimitiveField_option() {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(*PrimitiveField)?;
            }
            if let ::std::option::Option::Some(StringField) = self.StringField_option() {
                output.write_raw_tag_bytes(&[18])?;
                output.write_string(StringField)?;
            }
            if let ::std::option::Option::Some(EnumField) = self.EnumField_option() {
                output.write_raw_tag_bytes(&[24])?;
                output.write_enum_value(*EnumField)?;
            }
            if let ::std::option::Option::Some(MessageField) = self.MessageField() {
                output.write_raw_tag_bytes(&[34])?;
                output.write_message(MessageField)?;
            }
            if let ::std::option::Option::Some(StringPieceField) = self.StringPieceField_option() {
                output.write_raw_tag_bytes(&[42])?;
                output.write_string(StringPieceField)?;
            }
            if let ::std::option::Option::Some(CordField) = self.CordField_option() {
                output.write_raw_tag_bytes(&[50])?;
                output.write_string(CordField)?;
            }
            self.RepeatedPrimitiveField().write_to(
                output,
                &self::test_camel_case_field_names::REPEATEDPRIMITIVEFIELD_CODEC,
            )?;
            self.RepeatedStringField().write_to(
                output,
                &self::test_camel_case_field_names::REPEATEDSTRINGFIELD_CODEC,
            )?;
            self.RepeatedEnumField().write_to(
                output,
                &self::test_camel_case_field_names::REPEATEDENUMFIELD_CODEC,
            )?;
            self.RepeatedMessageField().write_to(
                output,
                &self::test_camel_case_field_names::REPEATEDMESSAGEFIELD_CODEC,
            )?;
            self.RepeatedStringPieceField().write_to(
                output,
                &self::test_camel_case_field_names::REPEATEDSTRINGPIECEFIELD_CODEC,
            )?;
            self.RepeatedCordField().write_to(
                output,
                &self::test_camel_case_field_names::REPEATEDCORDFIELD_CODEC,
            )?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(MessageField) = self.MessageField() {
                if !::protrust::CodedMessage::is_initialized(MessageField) {
                    return false;
                }
            }
            if !self.RepeatedMessageField.is_initialized() {
                return false;
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestCamelCaseFieldNames {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(PrimitiveField) = other.PrimitiveField_option() {
                self.set_PrimitiveField(*PrimitiveField);
            }
            if let ::std::option::Option::Some(StringField) = other.StringField_option() {
                self.set_StringField(::std::clone::Clone::clone(StringField));
            }
            if let ::std::option::Option::Some(EnumField) = other.EnumField_option() {
                self.set_EnumField(*EnumField);
            }
            if let ::std::option::Option::Some(MessageField) = &other.MessageField() {
                ::protrust::LiteMessage::merge(self.MessageField_mut(), MessageField);
            }
            if let ::std::option::Option::Some(StringPieceField) = other.StringPieceField_option() {
                self.set_StringPieceField(::std::clone::Clone::clone(StringPieceField));
            }
            if let ::std::option::Option::Some(CordField) = other.CordField_option() {
                self.set_CordField(::std::clone::Clone::clone(CordField));
            }
            self.RepeatedPrimitiveField
                .merge(&other.RepeatedPrimitiveField);
            self.RepeatedStringField.merge(&other.RepeatedStringField);
            self.RepeatedEnumField.merge(&other.RepeatedEnumField);
            self.RepeatedMessageField.merge(&other.RepeatedMessageField);
            self.RepeatedStringPieceField
                .merge(&other.RepeatedStringPieceField);
            self.RepeatedCordField.merge(&other.RepeatedCordField);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestCamelCaseFieldNames {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[28]
        }
    }
    impl self::TestCamelCaseFieldNames {
        pub const PRIMITIVEFIELD_FIELD_NUMBER: i32 = 1;
        pub const PRIMITIVEFIELD_DEFAULT_VALUE: i32 = 0;
        pub fn PrimitiveField(&self) -> i32 {
            self.PrimitiveField
                .unwrap_or(Self::PRIMITIVEFIELD_DEFAULT_VALUE)
        }
        pub fn PrimitiveField_option(&self) -> ::std::option::Option<&i32> {
            self.PrimitiveField.as_ref()
        }
        pub fn PrimitiveField_mut(&mut self) -> &mut i32 {
            self.PrimitiveField
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_PrimitiveField(&self) -> bool {
            self.PrimitiveField.is_some()
        }
        pub fn set_PrimitiveField(&mut self, value: i32) {
            self.PrimitiveField = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_PrimitiveField(&mut self) -> ::std::option::Option<i32> {
            self.PrimitiveField.take()
        }
        pub fn clear_PrimitiveField(&mut self) {
            self.PrimitiveField = ::std::option::Option::None;
        }
        pub const STRINGFIELD_FIELD_NUMBER: i32 = 2;
        pub const STRINGFIELD_DEFAULT_VALUE: &'static str = "";
        pub fn StringField(&self) -> &str {
            self.StringField
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::STRINGFIELD_DEFAULT_VALUE)
        }
        pub fn StringField_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.StringField.as_ref()
        }
        pub fn StringField_mut(&mut self) -> &mut ::std::string::String {
            self.StringField
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_StringField(&self) -> bool {
            self.StringField.is_some()
        }
        pub fn set_StringField(&mut self, value: ::std::string::String) {
            self.StringField = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_StringField(&mut self) -> ::std::option::Option<::std::string::String> {
            self.StringField.take()
        }
        pub fn clear_StringField(&mut self) {
            self.StringField = ::std::option::Option::None;
        }
        pub const ENUMFIELD_FIELD_NUMBER: i32 = 3;
        pub const ENUMFIELD_DEFAULT_VALUE: ::protrust::EnumValue<self::ForeignEnum> =
            ::protrust::EnumValue::Undefined(0);
        pub fn EnumField(&self) -> ::protrust::EnumValue<self::ForeignEnum> {
            self.EnumField.unwrap_or(Self::ENUMFIELD_DEFAULT_VALUE)
        }
        pub fn EnumField_option(
            &self,
        ) -> ::std::option::Option<&::protrust::EnumValue<self::ForeignEnum>> {
            self.EnumField.as_ref()
        }
        pub fn EnumField_mut(&mut self) -> &mut ::protrust::EnumValue<self::ForeignEnum> {
            self.EnumField
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_EnumField(&self) -> bool {
            self.EnumField.is_some()
        }
        pub fn set_EnumField(&mut self, value: ::protrust::EnumValue<self::ForeignEnum>) {
            self.EnumField = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_EnumField(
            &mut self,
        ) -> ::std::option::Option<::protrust::EnumValue<self::ForeignEnum>> {
            self.EnumField.take()
        }
        pub fn clear_EnumField(&mut self) {
            self.EnumField = ::std::option::Option::None;
        }
        pub const MESSAGEFIELD_FIELD_NUMBER: i32 = 4;
        pub fn MessageField(&self) -> ::std::option::Option<&self::ForeignMessage> {
            self.MessageField.as_ref().map(|v| &**v)
        }
        pub fn MessageField_mut(&mut self) -> &mut self::ForeignMessage {
            self.MessageField
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_MessageField(&self) -> bool {
            self.MessageField.is_some()
        }
        pub fn set_MessageField(&mut self, value: self::ForeignMessage) {
            self.MessageField = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_MessageField(&mut self) -> ::std::option::Option<self::ForeignMessage> {
            self.MessageField.take().map(|v| *v)
        }
        pub fn clear_MessageField(&mut self) {
            self.MessageField = ::std::option::Option::None;
        }
        pub const STRINGPIECEFIELD_FIELD_NUMBER: i32 = 5;
        pub const STRINGPIECEFIELD_DEFAULT_VALUE: &'static str = "";
        pub fn StringPieceField(&self) -> &str {
            self.StringPieceField
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::STRINGPIECEFIELD_DEFAULT_VALUE)
        }
        pub fn StringPieceField_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.StringPieceField.as_ref()
        }
        pub fn StringPieceField_mut(&mut self) -> &mut ::std::string::String {
            self.StringPieceField
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_StringPieceField(&self) -> bool {
            self.StringPieceField.is_some()
        }
        pub fn set_StringPieceField(&mut self, value: ::std::string::String) {
            self.StringPieceField = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_StringPieceField(&mut self) -> ::std::option::Option<::std::string::String> {
            self.StringPieceField.take()
        }
        pub fn clear_StringPieceField(&mut self) {
            self.StringPieceField = ::std::option::Option::None;
        }
        pub const CORDFIELD_FIELD_NUMBER: i32 = 6;
        pub const CORDFIELD_DEFAULT_VALUE: &'static str = "";
        pub fn CordField(&self) -> &str {
            self.CordField
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::CORDFIELD_DEFAULT_VALUE)
        }
        pub fn CordField_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.CordField.as_ref()
        }
        pub fn CordField_mut(&mut self) -> &mut ::std::string::String {
            self.CordField
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_CordField(&self) -> bool {
            self.CordField.is_some()
        }
        pub fn set_CordField(&mut self, value: ::std::string::String) {
            self.CordField = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_CordField(&mut self) -> ::std::option::Option<::std::string::String> {
            self.CordField.take()
        }
        pub fn clear_CordField(&mut self) {
            self.CordField = ::std::option::Option::None;
        }
        pub const REPEATEDPRIMITIVEFIELD_FIELD_NUMBER: i32 = 7;
        pub fn RepeatedPrimitiveField(&self) -> &::protrust::collections::RepeatedField<i32> {
            &self.RepeatedPrimitiveField
        }
        pub fn RepeatedPrimitiveField_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<i32> {
            &mut self.RepeatedPrimitiveField
        }
        pub const REPEATEDSTRINGFIELD_FIELD_NUMBER: i32 = 8;
        pub fn RepeatedStringField(
            &self,
        ) -> &::protrust::collections::RepeatedField<::std::string::String> {
            &self.RepeatedStringField
        }
        pub fn RepeatedStringField_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<::std::string::String> {
            &mut self.RepeatedStringField
        }
        pub const REPEATEDENUMFIELD_FIELD_NUMBER: i32 = 9;
        pub fn RepeatedEnumField(
            &self,
        ) -> &::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>>
        {
            &self.RepeatedEnumField
        }
        pub fn RepeatedEnumField_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>>
        {
            &mut self.RepeatedEnumField
        }
        pub const REPEATEDMESSAGEFIELD_FIELD_NUMBER: i32 = 10;
        pub fn RepeatedMessageField(
            &self,
        ) -> &::protrust::collections::RepeatedField<self::ForeignMessage> {
            &self.RepeatedMessageField
        }
        pub fn RepeatedMessageField_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<self::ForeignMessage> {
            &mut self.RepeatedMessageField
        }
        pub const REPEATEDSTRINGPIECEFIELD_FIELD_NUMBER: i32 = 11;
        pub fn RepeatedStringPieceField(
            &self,
        ) -> &::protrust::collections::RepeatedField<::std::string::String> {
            &self.RepeatedStringPieceField
        }
        pub fn RepeatedStringPieceField_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<::std::string::String> {
            &mut self.RepeatedStringPieceField
        }
        pub const REPEATEDCORDFIELD_FIELD_NUMBER: i32 = 12;
        pub fn RepeatedCordField(
            &self,
        ) -> &::protrust::collections::RepeatedField<::std::string::String> {
            &self.RepeatedCordField
        }
        pub fn RepeatedCordField_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<::std::string::String> {
            &mut self.RepeatedCordField
        }
    }
    pub(in super::super) mod test_camel_case_field_names {
        pub(super) static REPEATEDPRIMITIVEFIELD_CODEC: ::protrust::Codec<i32> =
            ::protrust::Codec::int32(56);
        pub(super) static REPEATEDSTRINGFIELD_CODEC: ::protrust::Codec<::std::string::String> =
            ::protrust::Codec::string(66);
        pub(super) static REPEATEDENUMFIELD_CODEC: ::protrust::Codec<
            ::protrust::EnumValue<self::super::ForeignEnum>,
        > = ::protrust::Codec::enum_value(72);
        pub(super) static REPEATEDMESSAGEFIELD_CODEC: ::protrust::Codec<
            self::super::ForeignMessage,
        > = ::protrust::Codec::message(82);
        pub(super) static REPEATEDSTRINGPIECEFIELD_CODEC: ::protrust::Codec<::std::string::String> =
            ::protrust::Codec::string(90);
        pub(super) static REPEATEDCORDFIELD_CODEC: ::protrust::Codec<::std::string::String> =
            ::protrust::Codec::string(98);
        pub(in super::super) static PRIMITIVEFIELD_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestCamelCaseFieldNames,
                i32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestCamelCaseFieldNames::PrimitiveField_option,
            get_mut: self::super::TestCamelCaseFieldNames::PrimitiveField_mut,
            set: self::super::TestCamelCaseFieldNames::set_PrimitiveField,
            take: self::super::TestCamelCaseFieldNames::take_PrimitiveField,
            clear: self::super::TestCamelCaseFieldNames::clear_PrimitiveField,
        };
        pub(in super::super) static STRINGFIELD_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestCamelCaseFieldNames,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestCamelCaseFieldNames::StringField_option,
            get_mut: self::super::TestCamelCaseFieldNames::StringField_mut,
            set: self::super::TestCamelCaseFieldNames::set_StringField,
            take: self::super::TestCamelCaseFieldNames::take_StringField,
            clear: self::super::TestCamelCaseFieldNames::clear_StringField,
        };
        pub(in super::super) static ENUMFIELD_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestCamelCaseFieldNames,
                ::protrust::EnumValue<self::super::ForeignEnum>,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestCamelCaseFieldNames::EnumField_option,
            get_mut: self::super::TestCamelCaseFieldNames::EnumField_mut,
            set: self::super::TestCamelCaseFieldNames::set_EnumField,
            take: self::super::TestCamelCaseFieldNames::take_EnumField,
            clear: self::super::TestCamelCaseFieldNames::clear_EnumField,
        };
        pub(in super::super) static MESSAGEFIELD_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestCamelCaseFieldNames,
                self::super::ForeignMessage,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestCamelCaseFieldNames::MessageField,
            get_mut: self::super::TestCamelCaseFieldNames::MessageField_mut,
            set: self::super::TestCamelCaseFieldNames::set_MessageField,
            take: self::super::TestCamelCaseFieldNames::take_MessageField,
            clear: self::super::TestCamelCaseFieldNames::clear_MessageField,
        };
        pub(in super::super) static STRINGPIECEFIELD_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestCamelCaseFieldNames,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestCamelCaseFieldNames::StringPieceField_option,
            get_mut: self::super::TestCamelCaseFieldNames::StringPieceField_mut,
            set: self::super::TestCamelCaseFieldNames::set_StringPieceField,
            take: self::super::TestCamelCaseFieldNames::take_StringPieceField,
            clear: self::super::TestCamelCaseFieldNames::clear_StringPieceField,
        };
        pub(in super::super) static CORDFIELD_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestCamelCaseFieldNames,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestCamelCaseFieldNames::CordField_option,
            get_mut: self::super::TestCamelCaseFieldNames::CordField_mut,
            set: self::super::TestCamelCaseFieldNames::set_CordField,
            take: self::super::TestCamelCaseFieldNames::take_CordField,
            clear: self::super::TestCamelCaseFieldNames::clear_CordField,
        };
        pub(in super::super) static REPEATEDPRIMITIVEFIELD_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestCamelCaseFieldNames,
                ::protrust::collections::RepeatedField<i32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestCamelCaseFieldNames::RepeatedPrimitiveField,
            get_mut: self::super::TestCamelCaseFieldNames::RepeatedPrimitiveField_mut,
        };
        pub(in super::super) static REPEATEDSTRINGFIELD_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestCamelCaseFieldNames,
                ::protrust::collections::RepeatedField<::std::string::String>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestCamelCaseFieldNames::RepeatedStringField,
            get_mut: self::super::TestCamelCaseFieldNames::RepeatedStringField_mut,
        };
        pub(in super::super) static REPEATEDENUMFIELD_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestCamelCaseFieldNames,
                ::protrust::collections::RepeatedField<
                    ::protrust::EnumValue<self::super::ForeignEnum>,
                >,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestCamelCaseFieldNames::RepeatedEnumField,
            get_mut: self::super::TestCamelCaseFieldNames::RepeatedEnumField_mut,
        };
        pub(in super::super) static REPEATEDMESSAGEFIELD_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestCamelCaseFieldNames,
                ::protrust::collections::RepeatedField<self::super::ForeignMessage>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestCamelCaseFieldNames::RepeatedMessageField,
            get_mut: self::super::TestCamelCaseFieldNames::RepeatedMessageField_mut,
        };
        pub(in super::super) static REPEATEDSTRINGPIECEFIELD_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestCamelCaseFieldNames,
                ::protrust::collections::RepeatedField<::std::string::String>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestCamelCaseFieldNames::RepeatedStringPieceField,
            get_mut: self::super::TestCamelCaseFieldNames::RepeatedStringPieceField_mut,
        };
        pub(in super::super) static REPEATEDCORDFIELD_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestCamelCaseFieldNames,
                ::protrust::collections::RepeatedField<::std::string::String>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestCamelCaseFieldNames::RepeatedCordField,
            get_mut: self::super::TestCamelCaseFieldNames::RepeatedCordField_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestFieldOrderings {
        my_string: ::std::option::Option<::std::string::String>,
        my_int: ::std::option::Option<i64>,
        my_float: ::std::option::Option<f32>,
        optional_nested_message:
            ::std::option::Option<::std::boxed::Box<self::test_field_orderings::NestedMessage>>,
        unknown_fields: ::protrust::UnknownFieldSet,
        extensions: ::protrust::ExtensionSet<Self>,
    }
    impl ::protrust::CodedMessage for self::TestFieldOrderings {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    90 => self.set_my_string(input.read_string()?),
                    8 | 10 => self.set_my_int(input.read_int64()?),
                    813 | 810 => self.set_my_float(input.read_float()?),
                    1602 => input.read_message(self.optional_nested_message_mut())?,
                    _ => {
                        if !self.extensions.merge_from(input)? {
                            self.unknown_fields.merge_from(tag, input)?
                        }
                    }
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(my_string) = self.my_string_option() {
                size += 1;
                size += ::protrust::io::sizes::string(my_string);
            }
            if let ::std::option::Option::Some(my_int) = self.my_int_option() {
                size += 1;
                size += ::protrust::io::sizes::int64(*my_int);
            }
            if let ::std::option::Option::Some(my_float) = self.my_float_option() {
                size += 2;
                size += ::protrust::io::sizes::float(*my_float);
            }
            if let ::std::option::Option::Some(optional_nested_message) =
                self.optional_nested_message()
            {
                size += 2;
                size += ::protrust::io::sizes::message(optional_nested_message);
            }
            size += self.extensions.calculate_size();
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(my_string) = self.my_string_option() {
                output.write_raw_tag_bytes(&[90])?;
                output.write_string(my_string)?;
            }
            if let ::std::option::Option::Some(my_int) = self.my_int_option() {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int64(*my_int)?;
            }
            if let ::std::option::Option::Some(my_float) = self.my_float_option() {
                output.write_raw_tag_bytes(&[173, 6])?;
                output.write_float(*my_float)?;
            }
            if let ::std::option::Option::Some(optional_nested_message) =
                self.optional_nested_message()
            {
                output.write_raw_tag_bytes(&[194, 12])?;
                output.write_message(optional_nested_message)?;
            }
            self.extensions.write_to(output)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(optional_nested_message) =
                self.optional_nested_message()
            {
                if !::protrust::CodedMessage::is_initialized(optional_nested_message) {
                    return false;
                }
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestFieldOrderings {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(my_string) = other.my_string_option() {
                self.set_my_string(::std::clone::Clone::clone(my_string));
            }
            if let ::std::option::Option::Some(my_int) = other.my_int_option() {
                self.set_my_int(*my_int);
            }
            if let ::std::option::Option::Some(my_float) = other.my_float_option() {
                self.set_my_float(*my_float);
            }
            if let ::std::option::Option::Some(optional_nested_message) =
                &other.optional_nested_message()
            {
                ::protrust::LiteMessage::merge(
                    self.optional_nested_message_mut(),
                    optional_nested_message,
                );
            }
            self.extensions.merge(&other.extensions);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::ExtendableMessage for self::TestFieldOrderings {
        fn registry(&self) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> {
            self.extensions.registry()
        }
        fn replace_registry(
            &mut self,
            extensions: ::std::option::Option<&'static ::protrust::ExtensionRegistry>,
        ) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> {
            self.extensions.replace_registry(extensions)
        }
        fn has_extension<T: ::protrust::ExtensionIdentifier>(&self, extension: &'static T) -> bool {
            self.extensions.has_extension(extension)
        }
        fn has_extension_unchecked<T: ::protrust::ExtensionIdentifier>(
            &self,
            extension: &'static T,
        ) -> bool {
            self.extensions.has_extension_unchecked(extension)
        }
        fn get_value<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> Option<&V> {
            self.extensions.get_value(extension)
        }
        fn get_value_or_default<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync
                + ::std::ops::Deref<Target = L>,
            D: ::std::marker::Sync + ::std::ops::Deref<Target = L>,
            L,
        >(
            &self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> Option<&L> {
            self.extensions.get_value_or_default(extension)
        }
        fn get_repeated_value<
            V: ::std::cmp::PartialEq
                + ::std::clone::Clone
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &self,
            extension: &'static ::protrust::RepeatedExtension<Self, V>,
        ) -> Option<&::protrust::collections::RepeatedField<V>> {
            self.extensions.get_repeated_value(extension)
        }
        fn field<
            V: ::std::default::Default
                + ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> ::std::option::Option<::protrust::ExtensionField<Self, V, D>> {
            self.extensions.field(extension)
        }
        fn repeated_field<
            V: ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static ::protrust::RepeatedExtension<Self, V>,
        ) -> ::std::option::Option<::protrust::RepeatedExtensionField<Self, V>> {
            self.extensions.repeated_field(extension)
        }
    }
    impl ::protrust::Message for self::TestFieldOrderings {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[29]
        }
    }
    impl self::TestFieldOrderings {
        pub const MY_STRING_FIELD_NUMBER: i32 = 11;
        pub const MY_STRING_DEFAULT_VALUE: &'static str = "";
        pub fn my_string(&self) -> &str {
            self.my_string
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::MY_STRING_DEFAULT_VALUE)
        }
        pub fn my_string_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.my_string.as_ref()
        }
        pub fn my_string_mut(&mut self) -> &mut ::std::string::String {
            self.my_string
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_my_string(&self) -> bool {
            self.my_string.is_some()
        }
        pub fn set_my_string(&mut self, value: ::std::string::String) {
            self.my_string = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_my_string(&mut self) -> ::std::option::Option<::std::string::String> {
            self.my_string.take()
        }
        pub fn clear_my_string(&mut self) {
            self.my_string = ::std::option::Option::None;
        }
        pub const MY_INT_FIELD_NUMBER: i32 = 1;
        pub const MY_INT_DEFAULT_VALUE: i64 = 0;
        pub fn my_int(&self) -> i64 {
            self.my_int.unwrap_or(Self::MY_INT_DEFAULT_VALUE)
        }
        pub fn my_int_option(&self) -> ::std::option::Option<&i64> {
            self.my_int.as_ref()
        }
        pub fn my_int_mut(&mut self) -> &mut i64 {
            self.my_int
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_my_int(&self) -> bool {
            self.my_int.is_some()
        }
        pub fn set_my_int(&mut self, value: i64) {
            self.my_int = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_my_int(&mut self) -> ::std::option::Option<i64> {
            self.my_int.take()
        }
        pub fn clear_my_int(&mut self) {
            self.my_int = ::std::option::Option::None;
        }
        pub const MY_FLOAT_FIELD_NUMBER: i32 = 101;
        pub const MY_FLOAT_DEFAULT_VALUE: f32 = 0.0;
        pub fn my_float(&self) -> f32 {
            self.my_float.unwrap_or(Self::MY_FLOAT_DEFAULT_VALUE)
        }
        pub fn my_float_option(&self) -> ::std::option::Option<&f32> {
            self.my_float.as_ref()
        }
        pub fn my_float_mut(&mut self) -> &mut f32 {
            self.my_float
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_my_float(&self) -> bool {
            self.my_float.is_some()
        }
        pub fn set_my_float(&mut self, value: f32) {
            self.my_float = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_my_float(&mut self) -> ::std::option::Option<f32> {
            self.my_float.take()
        }
        pub fn clear_my_float(&mut self) {
            self.my_float = ::std::option::Option::None;
        }
        pub const OPTIONAL_NESTED_MESSAGE_FIELD_NUMBER: i32 = 200;
        pub fn optional_nested_message(
            &self,
        ) -> ::std::option::Option<&self::test_field_orderings::NestedMessage> {
            self.optional_nested_message.as_ref().map(|v| &**v)
        }
        pub fn optional_nested_message_mut(
            &mut self,
        ) -> &mut self::test_field_orderings::NestedMessage {
            self.optional_nested_message
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_nested_message(&self) -> bool {
            self.optional_nested_message.is_some()
        }
        pub fn set_optional_nested_message(
            &mut self,
            value: self::test_field_orderings::NestedMessage,
        ) {
            self.optional_nested_message =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_nested_message(
            &mut self,
        ) -> ::std::option::Option<self::test_field_orderings::NestedMessage> {
            self.optional_nested_message.take().map(|v| *v)
        }
        pub fn clear_optional_nested_message(&mut self) {
            self.optional_nested_message = ::std::option::Option::None;
        }
    }
    pub mod test_field_orderings {
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct NestedMessage {
            oo: ::std::option::Option<i64>,
            bb: ::std::option::Option<i32>,
            unknown_fields: ::protrust::UnknownFieldSet,
        }
        impl ::protrust::CodedMessage for self::NestedMessage {
            fn merge_from(
                &mut self,
                input: &mut ::protrust::io::CodedInput,
            ) -> ::protrust::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        16 | 18 => self.set_oo(input.read_int64()?),
                        8 | 10 => self.set_bb(input.read_int32()?),
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> i32 {
                let mut size = 0i32;
                if let ::std::option::Option::Some(oo) = self.oo_option() {
                    size += 1;
                    size += ::protrust::io::sizes::int64(*oo);
                }
                if let ::std::option::Option::Some(bb) = self.bb_option() {
                    size += 1;
                    size += ::protrust::io::sizes::int32(*bb);
                }
                size += self.unknown_fields.calculate_size();
                size
            }
            fn write_to(
                &self,
                output: &mut ::protrust::io::CodedOutput,
            ) -> ::protrust::io::OutputResult {
                if let ::std::option::Option::Some(oo) = self.oo_option() {
                    output.write_raw_tag_bytes(&[16])?;
                    output.write_int64(*oo)?;
                }
                if let ::std::option::Option::Some(bb) = self.bb_option() {
                    output.write_raw_tag_bytes(&[8])?;
                    output.write_int32(*bb)?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                true
            }
        }
        impl ::protrust::LiteMessage for self::NestedMessage {
            fn merge(&mut self, other: &Self) {
                if let ::std::option::Option::Some(oo) = other.oo_option() {
                    self.set_oo(*oo);
                }
                if let ::std::option::Option::Some(bb) = other.bb_option() {
                    self.set_bb(*bb);
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl ::protrust::Message for self::NestedMessage {
            fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
                &<self::super::TestFieldOrderings as ::protrust::Message>::descriptor().messages()
                    [0]
            }
        }
        impl self::NestedMessage {
            pub const OO_FIELD_NUMBER: i32 = 2;
            pub const OO_DEFAULT_VALUE: i64 = 0;
            pub fn oo(&self) -> i64 {
                self.oo.unwrap_or(Self::OO_DEFAULT_VALUE)
            }
            pub fn oo_option(&self) -> ::std::option::Option<&i64> {
                self.oo.as_ref()
            }
            pub fn oo_mut(&mut self) -> &mut i64 {
                self.oo.get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_oo(&self) -> bool {
                self.oo.is_some()
            }
            pub fn set_oo(&mut self, value: i64) {
                self.oo = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_oo(&mut self) -> ::std::option::Option<i64> {
                self.oo.take()
            }
            pub fn clear_oo(&mut self) {
                self.oo = ::std::option::Option::None;
            }
            pub const BB_FIELD_NUMBER: i32 = 1;
            pub const BB_DEFAULT_VALUE: i32 = 0;
            pub fn bb(&self) -> i32 {
                self.bb.unwrap_or(Self::BB_DEFAULT_VALUE)
            }
            pub fn bb_option(&self) -> ::std::option::Option<&i32> {
                self.bb.as_ref()
            }
            pub fn bb_mut(&mut self) -> &mut i32 {
                self.bb.get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_bb(&self) -> bool {
                self.bb.is_some()
            }
            pub fn set_bb(&mut self, value: i32) {
                self.bb = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_bb(&mut self) -> ::std::option::Option<i32> {
                self.bb.take()
            }
            pub fn clear_bb(&mut self) {
                self.bb = ::std::option::Option::None;
            }
        }
        pub(in super::super::super) mod nested_message {
            pub(in super::super::super) static OO_REFLECTOR:
                ::protrust::reflect::access::VerboseFieldAccessor<self::super::NestedMessage, i64> =
                ::protrust::reflect::access::VerboseFieldAccessor {
                    get_option: self::super::NestedMessage::oo_option,
                    get_mut: self::super::NestedMessage::oo_mut,
                    set: self::super::NestedMessage::set_oo,
                    take: self::super::NestedMessage::take_oo,
                    clear: self::super::NestedMessage::clear_oo,
                };
            pub(in super::super::super) static BB_REFLECTOR:
                ::protrust::reflect::access::VerboseFieldAccessor<self::super::NestedMessage, i32> =
                ::protrust::reflect::access::VerboseFieldAccessor {
                    get_option: self::super::NestedMessage::bb_option,
                    get_mut: self::super::NestedMessage::bb_mut,
                    set: self::super::NestedMessage::set_bb,
                    take: self::super::NestedMessage::take_bb,
                    clear: self::super::NestedMessage::clear_bb,
                };
        }
        pub(in super::super) static MY_STRING_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestFieldOrderings,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestFieldOrderings::my_string_option,
            get_mut: self::super::TestFieldOrderings::my_string_mut,
            set: self::super::TestFieldOrderings::set_my_string,
            take: self::super::TestFieldOrderings::take_my_string,
            clear: self::super::TestFieldOrderings::clear_my_string,
        };
        pub(in super::super) static MY_INT_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestFieldOrderings, i64> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestFieldOrderings::my_int_option,
                get_mut: self::super::TestFieldOrderings::my_int_mut,
                set: self::super::TestFieldOrderings::set_my_int,
                take: self::super::TestFieldOrderings::take_my_int,
                clear: self::super::TestFieldOrderings::clear_my_int,
            };
        pub(in super::super) static MY_FLOAT_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestFieldOrderings, f32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestFieldOrderings::my_float_option,
                get_mut: self::super::TestFieldOrderings::my_float_mut,
                set: self::super::TestFieldOrderings::set_my_float,
                take: self::super::TestFieldOrderings::take_my_float,
                clear: self::super::TestFieldOrderings::clear_my_float,
            };
        pub(in super::super) static OPTIONAL_NESTED_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestFieldOrderings,
                self::NestedMessage,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestFieldOrderings::optional_nested_message,
            get_mut: self::super::TestFieldOrderings::optional_nested_message_mut,
            set: self::super::TestFieldOrderings::set_optional_nested_message,
            take: self::super::TestFieldOrderings::take_optional_nested_message,
            clear: self::super::TestFieldOrderings::clear_optional_nested_message,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestExtensionOrderings1 {
        my_string: ::std::option::Option<::std::string::String>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestExtensionOrderings1 {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => self.set_my_string(input.read_string()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(my_string) = self.my_string_option() {
                size += 1;
                size += ::protrust::io::sizes::string(my_string);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(my_string) = self.my_string_option() {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(my_string)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestExtensionOrderings1 {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(my_string) = other.my_string_option() {
                self.set_my_string(::std::clone::Clone::clone(my_string));
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestExtensionOrderings1 {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[30]
        }
    }
    impl self::TestExtensionOrderings1 {
        pub const MY_STRING_FIELD_NUMBER: i32 = 1;
        pub const MY_STRING_DEFAULT_VALUE: &'static str = "";
        pub fn my_string(&self) -> &str {
            self.my_string
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::MY_STRING_DEFAULT_VALUE)
        }
        pub fn my_string_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.my_string.as_ref()
        }
        pub fn my_string_mut(&mut self) -> &mut ::std::string::String {
            self.my_string
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_my_string(&self) -> bool {
            self.my_string.is_some()
        }
        pub fn set_my_string(&mut self, value: ::std::string::String) {
            self.my_string = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_my_string(&mut self) -> ::std::option::Option<::std::string::String> {
            self.my_string.take()
        }
        pub fn clear_my_string(&mut self) {
            self.my_string = ::std::option::Option::None;
        }
    }
    pub mod test_extension_orderings1 {
        pub static TEST_EXT_ORDERINGS1: ::protrust::Extension<
            self::super::TestFieldOrderings,
            self::super::TestExtensionOrderings1,
            self::super::TestExtensionOrderings1,
        > = ::protrust::Extension::message(106);
        pub(in super::super) static MY_STRING_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtensionOrderings1,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtensionOrderings1::my_string_option,
            get_mut: self::super::TestExtensionOrderings1::my_string_mut,
            set: self::super::TestExtensionOrderings1::set_my_string,
            take: self::super::TestExtensionOrderings1::take_my_string,
            clear: self::super::TestExtensionOrderings1::clear_my_string,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestExtensionOrderings2 {
        my_string: ::std::option::Option<::std::string::String>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestExtensionOrderings2 {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => self.set_my_string(input.read_string()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(my_string) = self.my_string_option() {
                size += 1;
                size += ::protrust::io::sizes::string(my_string);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(my_string) = self.my_string_option() {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(my_string)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestExtensionOrderings2 {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(my_string) = other.my_string_option() {
                self.set_my_string(::std::clone::Clone::clone(my_string));
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestExtensionOrderings2 {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[31]
        }
    }
    impl self::TestExtensionOrderings2 {
        pub const MY_STRING_FIELD_NUMBER: i32 = 1;
        pub const MY_STRING_DEFAULT_VALUE: &'static str = "";
        pub fn my_string(&self) -> &str {
            self.my_string
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::MY_STRING_DEFAULT_VALUE)
        }
        pub fn my_string_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.my_string.as_ref()
        }
        pub fn my_string_mut(&mut self) -> &mut ::std::string::String {
            self.my_string
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_my_string(&self) -> bool {
            self.my_string.is_some()
        }
        pub fn set_my_string(&mut self, value: ::std::string::String) {
            self.my_string = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_my_string(&mut self) -> ::std::option::Option<::std::string::String> {
            self.my_string.take()
        }
        pub fn clear_my_string(&mut self) {
            self.my_string = ::std::option::Option::None;
        }
    }
    pub mod test_extension_orderings2 {
        pub static TEST_EXT_ORDERINGS2: ::protrust::Extension<
            self::super::TestFieldOrderings,
            self::super::TestExtensionOrderings2,
            self::super::TestExtensionOrderings2,
        > = ::protrust::Extension::message(98);
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct TestExtensionOrderings3 {
            my_string: ::std::option::Option<::std::string::String>,
            unknown_fields: ::protrust::UnknownFieldSet,
        }
        impl ::protrust::CodedMessage for self::TestExtensionOrderings3 {
            fn merge_from(
                &mut self,
                input: &mut ::protrust::io::CodedInput,
            ) -> ::protrust::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        10 => self.set_my_string(input.read_string()?),
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> i32 {
                let mut size = 0i32;
                if let ::std::option::Option::Some(my_string) = self.my_string_option() {
                    size += 1;
                    size += ::protrust::io::sizes::string(my_string);
                }
                size += self.unknown_fields.calculate_size();
                size
            }
            fn write_to(
                &self,
                output: &mut ::protrust::io::CodedOutput,
            ) -> ::protrust::io::OutputResult {
                if let ::std::option::Option::Some(my_string) = self.my_string_option() {
                    output.write_raw_tag_bytes(&[10])?;
                    output.write_string(my_string)?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                true
            }
        }
        impl ::protrust::LiteMessage for self::TestExtensionOrderings3 {
            fn merge(&mut self, other: &Self) {
                if let ::std::option::Option::Some(my_string) = other.my_string_option() {
                    self.set_my_string(::std::clone::Clone::clone(my_string));
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl ::protrust::Message for self::TestExtensionOrderings3 {
            fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
                &<self::super::TestExtensionOrderings2 as ::protrust::Message>::descriptor()
                    .messages()[0]
            }
        }
        impl self::TestExtensionOrderings3 {
            pub const MY_STRING_FIELD_NUMBER: i32 = 1;
            pub const MY_STRING_DEFAULT_VALUE: &'static str = "";
            pub fn my_string(&self) -> &str {
                self.my_string
                    .as_ref()
                    .map(|v| &**v)
                    .unwrap_or(Self::MY_STRING_DEFAULT_VALUE)
            }
            pub fn my_string_option(&self) -> ::std::option::Option<&::std::string::String> {
                self.my_string.as_ref()
            }
            pub fn my_string_mut(&mut self) -> &mut ::std::string::String {
                self.my_string
                    .get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_my_string(&self) -> bool {
                self.my_string.is_some()
            }
            pub fn set_my_string(&mut self, value: ::std::string::String) {
                self.my_string = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_my_string(&mut self) -> ::std::option::Option<::std::string::String> {
                self.my_string.take()
            }
            pub fn clear_my_string(&mut self) {
                self.my_string = ::std::option::Option::None;
            }
        }
        pub mod test_extension_orderings3 {
            pub static TEST_EXT_ORDERINGS3: ::protrust::Extension<
                self::super::super::TestFieldOrderings,
                self::super::TestExtensionOrderings3,
                self::super::TestExtensionOrderings3,
            > = ::protrust::Extension::message(114);
            pub(in super::super::super) static MY_STRING_REFLECTOR:
                ::protrust::reflect::access::VerboseFieldAccessor<
                    self::super::TestExtensionOrderings3,
                    ::std::string::String,
                > = ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestExtensionOrderings3::my_string_option,
                get_mut: self::super::TestExtensionOrderings3::my_string_mut,
                set: self::super::TestExtensionOrderings3::set_my_string,
                take: self::super::TestExtensionOrderings3::take_my_string,
                clear: self::super::TestExtensionOrderings3::clear_my_string,
            };
        }
        pub(in super::super) static MY_STRING_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtensionOrderings2,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtensionOrderings2::my_string_option,
            get_mut: self::super::TestExtensionOrderings2::my_string_mut,
            set: self::super::TestExtensionOrderings2::set_my_string,
            take: self::super::TestExtensionOrderings2::take_my_string,
            clear: self::super::TestExtensionOrderings2::clear_my_string,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestExtremeDefaultValues {
        escaped_bytes: ::std::option::Option<::std::vec::Vec<u8>>,
        large_uint32: ::std::option::Option<u32>,
        large_uint64: ::std::option::Option<u64>,
        small_int32: ::std::option::Option<i32>,
        small_int64: ::std::option::Option<i64>,
        really_small_int32: ::std::option::Option<i32>,
        really_small_int64: ::std::option::Option<i64>,
        utf8_string: ::std::option::Option<::std::string::String>,
        zero_float: ::std::option::Option<f32>,
        one_float: ::std::option::Option<f32>,
        small_float: ::std::option::Option<f32>,
        negative_one_float: ::std::option::Option<f32>,
        negative_float: ::std::option::Option<f32>,
        large_float: ::std::option::Option<f32>,
        small_negative_float: ::std::option::Option<f32>,
        inf_double: ::std::option::Option<f64>,
        neg_inf_double: ::std::option::Option<f64>,
        nan_double: ::std::option::Option<f64>,
        inf_float: ::std::option::Option<f32>,
        neg_inf_float: ::std::option::Option<f32>,
        nan_float: ::std::option::Option<f32>,
        cpp_trigraph: ::std::option::Option<::std::string::String>,
        string_with_zero: ::std::option::Option<::std::string::String>,
        bytes_with_zero: ::std::option::Option<::std::vec::Vec<u8>>,
        string_piece_with_zero: ::std::option::Option<::std::string::String>,
        cord_with_zero: ::std::option::Option<::std::string::String>,
        replacement_string: ::std::option::Option<::std::string::String>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestExtremeDefaultValues {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => self.set_escaped_bytes(input.read_bytes()?),
                    16 | 18 => self.set_large_uint32(input.read_uint32()?),
                    24 | 26 => self.set_large_uint64(input.read_uint64()?),
                    32 | 34 => self.set_small_int32(input.read_int32()?),
                    40 | 42 => self.set_small_int64(input.read_int64()?),
                    168 | 170 => self.set_really_small_int32(input.read_int32()?),
                    176 | 178 => self.set_really_small_int64(input.read_int64()?),
                    50 => self.set_utf8_string(input.read_string()?),
                    61 | 58 => self.set_zero_float(input.read_float()?),
                    69 | 66 => self.set_one_float(input.read_float()?),
                    77 | 74 => self.set_small_float(input.read_float()?),
                    85 | 82 => self.set_negative_one_float(input.read_float()?),
                    93 | 90 => self.set_negative_float(input.read_float()?),
                    101 | 98 => self.set_large_float(input.read_float()?),
                    109 | 106 => self.set_small_negative_float(input.read_float()?),
                    113 | 114 => self.set_inf_double(input.read_double()?),
                    121 | 122 => self.set_neg_inf_double(input.read_double()?),
                    129 | 130 => self.set_nan_double(input.read_double()?),
                    141 | 138 => self.set_inf_float(input.read_float()?),
                    149 | 146 => self.set_neg_inf_float(input.read_float()?),
                    157 | 154 => self.set_nan_float(input.read_float()?),
                    162 => self.set_cpp_trigraph(input.read_string()?),
                    186 => self.set_string_with_zero(input.read_string()?),
                    194 => self.set_bytes_with_zero(input.read_bytes()?),
                    202 => self.set_string_piece_with_zero(input.read_string()?),
                    210 => self.set_cord_with_zero(input.read_string()?),
                    218 => self.set_replacement_string(input.read_string()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(escaped_bytes) = self.escaped_bytes_option() {
                size += 1;
                size += ::protrust::io::sizes::bytes(escaped_bytes);
            }
            if let ::std::option::Option::Some(large_uint32) = self.large_uint32_option() {
                size += 1;
                size += ::protrust::io::sizes::uint32(*large_uint32);
            }
            if let ::std::option::Option::Some(large_uint64) = self.large_uint64_option() {
                size += 1;
                size += ::protrust::io::sizes::uint64(*large_uint64);
            }
            if let ::std::option::Option::Some(small_int32) = self.small_int32_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*small_int32);
            }
            if let ::std::option::Option::Some(small_int64) = self.small_int64_option() {
                size += 1;
                size += ::protrust::io::sizes::int64(*small_int64);
            }
            if let ::std::option::Option::Some(really_small_int32) =
                self.really_small_int32_option()
            {
                size += 2;
                size += ::protrust::io::sizes::int32(*really_small_int32);
            }
            if let ::std::option::Option::Some(really_small_int64) =
                self.really_small_int64_option()
            {
                size += 2;
                size += ::protrust::io::sizes::int64(*really_small_int64);
            }
            if let ::std::option::Option::Some(utf8_string) = self.utf8_string_option() {
                size += 1;
                size += ::protrust::io::sizes::string(utf8_string);
            }
            if let ::std::option::Option::Some(zero_float) = self.zero_float_option() {
                size += 1;
                size += ::protrust::io::sizes::float(*zero_float);
            }
            if let ::std::option::Option::Some(one_float) = self.one_float_option() {
                size += 1;
                size += ::protrust::io::sizes::float(*one_float);
            }
            if let ::std::option::Option::Some(small_float) = self.small_float_option() {
                size += 1;
                size += ::protrust::io::sizes::float(*small_float);
            }
            if let ::std::option::Option::Some(negative_one_float) =
                self.negative_one_float_option()
            {
                size += 1;
                size += ::protrust::io::sizes::float(*negative_one_float);
            }
            if let ::std::option::Option::Some(negative_float) = self.negative_float_option() {
                size += 1;
                size += ::protrust::io::sizes::float(*negative_float);
            }
            if let ::std::option::Option::Some(large_float) = self.large_float_option() {
                size += 1;
                size += ::protrust::io::sizes::float(*large_float);
            }
            if let ::std::option::Option::Some(small_negative_float) =
                self.small_negative_float_option()
            {
                size += 1;
                size += ::protrust::io::sizes::float(*small_negative_float);
            }
            if let ::std::option::Option::Some(inf_double) = self.inf_double_option() {
                size += 1;
                size += ::protrust::io::sizes::double(*inf_double);
            }
            if let ::std::option::Option::Some(neg_inf_double) = self.neg_inf_double_option() {
                size += 1;
                size += ::protrust::io::sizes::double(*neg_inf_double);
            }
            if let ::std::option::Option::Some(nan_double) = self.nan_double_option() {
                size += 2;
                size += ::protrust::io::sizes::double(*nan_double);
            }
            if let ::std::option::Option::Some(inf_float) = self.inf_float_option() {
                size += 2;
                size += ::protrust::io::sizes::float(*inf_float);
            }
            if let ::std::option::Option::Some(neg_inf_float) = self.neg_inf_float_option() {
                size += 2;
                size += ::protrust::io::sizes::float(*neg_inf_float);
            }
            if let ::std::option::Option::Some(nan_float) = self.nan_float_option() {
                size += 2;
                size += ::protrust::io::sizes::float(*nan_float);
            }
            if let ::std::option::Option::Some(cpp_trigraph) = self.cpp_trigraph_option() {
                size += 2;
                size += ::protrust::io::sizes::string(cpp_trigraph);
            }
            if let ::std::option::Option::Some(string_with_zero) = self.string_with_zero_option() {
                size += 2;
                size += ::protrust::io::sizes::string(string_with_zero);
            }
            if let ::std::option::Option::Some(bytes_with_zero) = self.bytes_with_zero_option() {
                size += 2;
                size += ::protrust::io::sizes::bytes(bytes_with_zero);
            }
            if let ::std::option::Option::Some(string_piece_with_zero) =
                self.string_piece_with_zero_option()
            {
                size += 2;
                size += ::protrust::io::sizes::string(string_piece_with_zero);
            }
            if let ::std::option::Option::Some(cord_with_zero) = self.cord_with_zero_option() {
                size += 2;
                size += ::protrust::io::sizes::string(cord_with_zero);
            }
            if let ::std::option::Option::Some(replacement_string) =
                self.replacement_string_option()
            {
                size += 2;
                size += ::protrust::io::sizes::string(replacement_string);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(escaped_bytes) = self.escaped_bytes_option() {
                output.write_raw_tag_bytes(&[10])?;
                output.write_bytes(escaped_bytes)?;
            }
            if let ::std::option::Option::Some(large_uint32) = self.large_uint32_option() {
                output.write_raw_tag_bytes(&[16])?;
                output.write_uint32(*large_uint32)?;
            }
            if let ::std::option::Option::Some(large_uint64) = self.large_uint64_option() {
                output.write_raw_tag_bytes(&[24])?;
                output.write_uint64(*large_uint64)?;
            }
            if let ::std::option::Option::Some(small_int32) = self.small_int32_option() {
                output.write_raw_tag_bytes(&[32])?;
                output.write_int32(*small_int32)?;
            }
            if let ::std::option::Option::Some(small_int64) = self.small_int64_option() {
                output.write_raw_tag_bytes(&[40])?;
                output.write_int64(*small_int64)?;
            }
            if let ::std::option::Option::Some(really_small_int32) =
                self.really_small_int32_option()
            {
                output.write_raw_tag_bytes(&[168, 1])?;
                output.write_int32(*really_small_int32)?;
            }
            if let ::std::option::Option::Some(really_small_int64) =
                self.really_small_int64_option()
            {
                output.write_raw_tag_bytes(&[176, 1])?;
                output.write_int64(*really_small_int64)?;
            }
            if let ::std::option::Option::Some(utf8_string) = self.utf8_string_option() {
                output.write_raw_tag_bytes(&[50])?;
                output.write_string(utf8_string)?;
            }
            if let ::std::option::Option::Some(zero_float) = self.zero_float_option() {
                output.write_raw_tag_bytes(&[61])?;
                output.write_float(*zero_float)?;
            }
            if let ::std::option::Option::Some(one_float) = self.one_float_option() {
                output.write_raw_tag_bytes(&[69])?;
                output.write_float(*one_float)?;
            }
            if let ::std::option::Option::Some(small_float) = self.small_float_option() {
                output.write_raw_tag_bytes(&[77])?;
                output.write_float(*small_float)?;
            }
            if let ::std::option::Option::Some(negative_one_float) =
                self.negative_one_float_option()
            {
                output.write_raw_tag_bytes(&[85])?;
                output.write_float(*negative_one_float)?;
            }
            if let ::std::option::Option::Some(negative_float) = self.negative_float_option() {
                output.write_raw_tag_bytes(&[93])?;
                output.write_float(*negative_float)?;
            }
            if let ::std::option::Option::Some(large_float) = self.large_float_option() {
                output.write_raw_tag_bytes(&[101])?;
                output.write_float(*large_float)?;
            }
            if let ::std::option::Option::Some(small_negative_float) =
                self.small_negative_float_option()
            {
                output.write_raw_tag_bytes(&[109])?;
                output.write_float(*small_negative_float)?;
            }
            if let ::std::option::Option::Some(inf_double) = self.inf_double_option() {
                output.write_raw_tag_bytes(&[113])?;
                output.write_double(*inf_double)?;
            }
            if let ::std::option::Option::Some(neg_inf_double) = self.neg_inf_double_option() {
                output.write_raw_tag_bytes(&[121])?;
                output.write_double(*neg_inf_double)?;
            }
            if let ::std::option::Option::Some(nan_double) = self.nan_double_option() {
                output.write_raw_tag_bytes(&[129, 1])?;
                output.write_double(*nan_double)?;
            }
            if let ::std::option::Option::Some(inf_float) = self.inf_float_option() {
                output.write_raw_tag_bytes(&[141, 1])?;
                output.write_float(*inf_float)?;
            }
            if let ::std::option::Option::Some(neg_inf_float) = self.neg_inf_float_option() {
                output.write_raw_tag_bytes(&[149, 1])?;
                output.write_float(*neg_inf_float)?;
            }
            if let ::std::option::Option::Some(nan_float) = self.nan_float_option() {
                output.write_raw_tag_bytes(&[157, 1])?;
                output.write_float(*nan_float)?;
            }
            if let ::std::option::Option::Some(cpp_trigraph) = self.cpp_trigraph_option() {
                output.write_raw_tag_bytes(&[162, 1])?;
                output.write_string(cpp_trigraph)?;
            }
            if let ::std::option::Option::Some(string_with_zero) = self.string_with_zero_option() {
                output.write_raw_tag_bytes(&[186, 1])?;
                output.write_string(string_with_zero)?;
            }
            if let ::std::option::Option::Some(bytes_with_zero) = self.bytes_with_zero_option() {
                output.write_raw_tag_bytes(&[194, 1])?;
                output.write_bytes(bytes_with_zero)?;
            }
            if let ::std::option::Option::Some(string_piece_with_zero) =
                self.string_piece_with_zero_option()
            {
                output.write_raw_tag_bytes(&[202, 1])?;
                output.write_string(string_piece_with_zero)?;
            }
            if let ::std::option::Option::Some(cord_with_zero) = self.cord_with_zero_option() {
                output.write_raw_tag_bytes(&[210, 1])?;
                output.write_string(cord_with_zero)?;
            }
            if let ::std::option::Option::Some(replacement_string) =
                self.replacement_string_option()
            {
                output.write_raw_tag_bytes(&[218, 1])?;
                output.write_string(replacement_string)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestExtremeDefaultValues {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(escaped_bytes) = other.escaped_bytes_option() {
                self.set_escaped_bytes(::std::clone::Clone::clone(escaped_bytes));
            }
            if let ::std::option::Option::Some(large_uint32) = other.large_uint32_option() {
                self.set_large_uint32(*large_uint32);
            }
            if let ::std::option::Option::Some(large_uint64) = other.large_uint64_option() {
                self.set_large_uint64(*large_uint64);
            }
            if let ::std::option::Option::Some(small_int32) = other.small_int32_option() {
                self.set_small_int32(*small_int32);
            }
            if let ::std::option::Option::Some(small_int64) = other.small_int64_option() {
                self.set_small_int64(*small_int64);
            }
            if let ::std::option::Option::Some(really_small_int32) =
                other.really_small_int32_option()
            {
                self.set_really_small_int32(*really_small_int32);
            }
            if let ::std::option::Option::Some(really_small_int64) =
                other.really_small_int64_option()
            {
                self.set_really_small_int64(*really_small_int64);
            }
            if let ::std::option::Option::Some(utf8_string) = other.utf8_string_option() {
                self.set_utf8_string(::std::clone::Clone::clone(utf8_string));
            }
            if let ::std::option::Option::Some(zero_float) = other.zero_float_option() {
                self.set_zero_float(*zero_float);
            }
            if let ::std::option::Option::Some(one_float) = other.one_float_option() {
                self.set_one_float(*one_float);
            }
            if let ::std::option::Option::Some(small_float) = other.small_float_option() {
                self.set_small_float(*small_float);
            }
            if let ::std::option::Option::Some(negative_one_float) =
                other.negative_one_float_option()
            {
                self.set_negative_one_float(*negative_one_float);
            }
            if let ::std::option::Option::Some(negative_float) = other.negative_float_option() {
                self.set_negative_float(*negative_float);
            }
            if let ::std::option::Option::Some(large_float) = other.large_float_option() {
                self.set_large_float(*large_float);
            }
            if let ::std::option::Option::Some(small_negative_float) =
                other.small_negative_float_option()
            {
                self.set_small_negative_float(*small_negative_float);
            }
            if let ::std::option::Option::Some(inf_double) = other.inf_double_option() {
                self.set_inf_double(*inf_double);
            }
            if let ::std::option::Option::Some(neg_inf_double) = other.neg_inf_double_option() {
                self.set_neg_inf_double(*neg_inf_double);
            }
            if let ::std::option::Option::Some(nan_double) = other.nan_double_option() {
                self.set_nan_double(*nan_double);
            }
            if let ::std::option::Option::Some(inf_float) = other.inf_float_option() {
                self.set_inf_float(*inf_float);
            }
            if let ::std::option::Option::Some(neg_inf_float) = other.neg_inf_float_option() {
                self.set_neg_inf_float(*neg_inf_float);
            }
            if let ::std::option::Option::Some(nan_float) = other.nan_float_option() {
                self.set_nan_float(*nan_float);
            }
            if let ::std::option::Option::Some(cpp_trigraph) = other.cpp_trigraph_option() {
                self.set_cpp_trigraph(::std::clone::Clone::clone(cpp_trigraph));
            }
            if let ::std::option::Option::Some(string_with_zero) = other.string_with_zero_option() {
                self.set_string_with_zero(::std::clone::Clone::clone(string_with_zero));
            }
            if let ::std::option::Option::Some(bytes_with_zero) = other.bytes_with_zero_option() {
                self.set_bytes_with_zero(::std::clone::Clone::clone(bytes_with_zero));
            }
            if let ::std::option::Option::Some(string_piece_with_zero) =
                other.string_piece_with_zero_option()
            {
                self.set_string_piece_with_zero(::std::clone::Clone::clone(string_piece_with_zero));
            }
            if let ::std::option::Option::Some(cord_with_zero) = other.cord_with_zero_option() {
                self.set_cord_with_zero(::std::clone::Clone::clone(cord_with_zero));
            }
            if let ::std::option::Option::Some(replacement_string) =
                other.replacement_string_option()
            {
                self.set_replacement_string(::std::clone::Clone::clone(replacement_string));
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestExtremeDefaultValues {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[32]
        }
    }
    impl self::TestExtremeDefaultValues {
        pub const ESCAPED_BYTES_FIELD_NUMBER: i32 = 1;
        pub const ESCAPED_BYTES_DEFAULT_VALUE: &'static [u8] = &[
            0, 48, 48, 48, 1, 48, 48, 49, 7, 48, 48, 55, 8, 48, 49, 48, 12, 48, 49, 52, 10, 110,
            13, 114, 9, 116, 11, 48, 49, 51, 92, 92, 39, 39, 34, 34, 254, 51, 55, 54,
        ];
        pub fn escaped_bytes(&self) -> &[u8] {
            self.escaped_bytes
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::ESCAPED_BYTES_DEFAULT_VALUE)
        }
        pub fn escaped_bytes_option(&self) -> ::std::option::Option<&::std::vec::Vec<u8>> {
            self.escaped_bytes.as_ref()
        }
        pub fn escaped_bytes_mut(&mut self) -> &mut ::std::vec::Vec<u8> {
            self.escaped_bytes
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_escaped_bytes(&self) -> bool {
            self.escaped_bytes.is_some()
        }
        pub fn set_escaped_bytes(&mut self, value: ::std::vec::Vec<u8>) {
            self.escaped_bytes = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_escaped_bytes(&mut self) -> ::std::option::Option<::std::vec::Vec<u8>> {
            self.escaped_bytes.take()
        }
        pub fn clear_escaped_bytes(&mut self) {
            self.escaped_bytes = ::std::option::Option::None;
        }
        pub const LARGE_UINT32_FIELD_NUMBER: i32 = 2;
        pub const LARGE_UINT32_DEFAULT_VALUE: u32 = 4294967295;
        pub fn large_uint32(&self) -> u32 {
            self.large_uint32
                .unwrap_or(Self::LARGE_UINT32_DEFAULT_VALUE)
        }
        pub fn large_uint32_option(&self) -> ::std::option::Option<&u32> {
            self.large_uint32.as_ref()
        }
        pub fn large_uint32_mut(&mut self) -> &mut u32 {
            self.large_uint32
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_large_uint32(&self) -> bool {
            self.large_uint32.is_some()
        }
        pub fn set_large_uint32(&mut self, value: u32) {
            self.large_uint32 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_large_uint32(&mut self) -> ::std::option::Option<u32> {
            self.large_uint32.take()
        }
        pub fn clear_large_uint32(&mut self) {
            self.large_uint32 = ::std::option::Option::None;
        }
        pub const LARGE_UINT64_FIELD_NUMBER: i32 = 3;
        pub const LARGE_UINT64_DEFAULT_VALUE: u64 = 18446744073709551615;
        pub fn large_uint64(&self) -> u64 {
            self.large_uint64
                .unwrap_or(Self::LARGE_UINT64_DEFAULT_VALUE)
        }
        pub fn large_uint64_option(&self) -> ::std::option::Option<&u64> {
            self.large_uint64.as_ref()
        }
        pub fn large_uint64_mut(&mut self) -> &mut u64 {
            self.large_uint64
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_large_uint64(&self) -> bool {
            self.large_uint64.is_some()
        }
        pub fn set_large_uint64(&mut self, value: u64) {
            self.large_uint64 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_large_uint64(&mut self) -> ::std::option::Option<u64> {
            self.large_uint64.take()
        }
        pub fn clear_large_uint64(&mut self) {
            self.large_uint64 = ::std::option::Option::None;
        }
        pub const SMALL_INT32_FIELD_NUMBER: i32 = 4;
        pub const SMALL_INT32_DEFAULT_VALUE: i32 = -2147483647;
        pub fn small_int32(&self) -> i32 {
            self.small_int32.unwrap_or(Self::SMALL_INT32_DEFAULT_VALUE)
        }
        pub fn small_int32_option(&self) -> ::std::option::Option<&i32> {
            self.small_int32.as_ref()
        }
        pub fn small_int32_mut(&mut self) -> &mut i32 {
            self.small_int32
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_small_int32(&self) -> bool {
            self.small_int32.is_some()
        }
        pub fn set_small_int32(&mut self, value: i32) {
            self.small_int32 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_small_int32(&mut self) -> ::std::option::Option<i32> {
            self.small_int32.take()
        }
        pub fn clear_small_int32(&mut self) {
            self.small_int32 = ::std::option::Option::None;
        }
        pub const SMALL_INT64_FIELD_NUMBER: i32 = 5;
        pub const SMALL_INT64_DEFAULT_VALUE: i64 = -9223372036854775807;
        pub fn small_int64(&self) -> i64 {
            self.small_int64.unwrap_or(Self::SMALL_INT64_DEFAULT_VALUE)
        }
        pub fn small_int64_option(&self) -> ::std::option::Option<&i64> {
            self.small_int64.as_ref()
        }
        pub fn small_int64_mut(&mut self) -> &mut i64 {
            self.small_int64
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_small_int64(&self) -> bool {
            self.small_int64.is_some()
        }
        pub fn set_small_int64(&mut self, value: i64) {
            self.small_int64 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_small_int64(&mut self) -> ::std::option::Option<i64> {
            self.small_int64.take()
        }
        pub fn clear_small_int64(&mut self) {
            self.small_int64 = ::std::option::Option::None;
        }
        pub const REALLY_SMALL_INT32_FIELD_NUMBER: i32 = 21;
        pub const REALLY_SMALL_INT32_DEFAULT_VALUE: i32 = -2147483648;
        pub fn really_small_int32(&self) -> i32 {
            self.really_small_int32
                .unwrap_or(Self::REALLY_SMALL_INT32_DEFAULT_VALUE)
        }
        pub fn really_small_int32_option(&self) -> ::std::option::Option<&i32> {
            self.really_small_int32.as_ref()
        }
        pub fn really_small_int32_mut(&mut self) -> &mut i32 {
            self.really_small_int32
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_really_small_int32(&self) -> bool {
            self.really_small_int32.is_some()
        }
        pub fn set_really_small_int32(&mut self, value: i32) {
            self.really_small_int32 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_really_small_int32(&mut self) -> ::std::option::Option<i32> {
            self.really_small_int32.take()
        }
        pub fn clear_really_small_int32(&mut self) {
            self.really_small_int32 = ::std::option::Option::None;
        }
        pub const REALLY_SMALL_INT64_FIELD_NUMBER: i32 = 22;
        pub const REALLY_SMALL_INT64_DEFAULT_VALUE: i64 = -9223372036854775808;
        pub fn really_small_int64(&self) -> i64 {
            self.really_small_int64
                .unwrap_or(Self::REALLY_SMALL_INT64_DEFAULT_VALUE)
        }
        pub fn really_small_int64_option(&self) -> ::std::option::Option<&i64> {
            self.really_small_int64.as_ref()
        }
        pub fn really_small_int64_mut(&mut self) -> &mut i64 {
            self.really_small_int64
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_really_small_int64(&self) -> bool {
            self.really_small_int64.is_some()
        }
        pub fn set_really_small_int64(&mut self, value: i64) {
            self.really_small_int64 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_really_small_int64(&mut self) -> ::std::option::Option<i64> {
            self.really_small_int64.take()
        }
        pub fn clear_really_small_int64(&mut self) {
            self.really_small_int64 = ::std::option::Option::None;
        }
        pub const UTF8_STRING_FIELD_NUMBER: i32 = 6;
        pub const UTF8_STRING_DEFAULT_VALUE: &'static str = "\u{1234}";
        pub fn utf8_string(&self) -> &str {
            self.utf8_string
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::UTF8_STRING_DEFAULT_VALUE)
        }
        pub fn utf8_string_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.utf8_string.as_ref()
        }
        pub fn utf8_string_mut(&mut self) -> &mut ::std::string::String {
            self.utf8_string
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_utf8_string(&self) -> bool {
            self.utf8_string.is_some()
        }
        pub fn set_utf8_string(&mut self, value: ::std::string::String) {
            self.utf8_string = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_utf8_string(&mut self) -> ::std::option::Option<::std::string::String> {
            self.utf8_string.take()
        }
        pub fn clear_utf8_string(&mut self) {
            self.utf8_string = ::std::option::Option::None;
        }
        pub const ZERO_FLOAT_FIELD_NUMBER: i32 = 7;
        pub const ZERO_FLOAT_DEFAULT_VALUE: f32 = 0.0;
        pub fn zero_float(&self) -> f32 {
            self.zero_float.unwrap_or(Self::ZERO_FLOAT_DEFAULT_VALUE)
        }
        pub fn zero_float_option(&self) -> ::std::option::Option<&f32> {
            self.zero_float.as_ref()
        }
        pub fn zero_float_mut(&mut self) -> &mut f32 {
            self.zero_float
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_zero_float(&self) -> bool {
            self.zero_float.is_some()
        }
        pub fn set_zero_float(&mut self, value: f32) {
            self.zero_float = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_zero_float(&mut self) -> ::std::option::Option<f32> {
            self.zero_float.take()
        }
        pub fn clear_zero_float(&mut self) {
            self.zero_float = ::std::option::Option::None;
        }
        pub const ONE_FLOAT_FIELD_NUMBER: i32 = 8;
        pub const ONE_FLOAT_DEFAULT_VALUE: f32 = 1.0;
        pub fn one_float(&self) -> f32 {
            self.one_float.unwrap_or(Self::ONE_FLOAT_DEFAULT_VALUE)
        }
        pub fn one_float_option(&self) -> ::std::option::Option<&f32> {
            self.one_float.as_ref()
        }
        pub fn one_float_mut(&mut self) -> &mut f32 {
            self.one_float
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_one_float(&self) -> bool {
            self.one_float.is_some()
        }
        pub fn set_one_float(&mut self, value: f32) {
            self.one_float = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_one_float(&mut self) -> ::std::option::Option<f32> {
            self.one_float.take()
        }
        pub fn clear_one_float(&mut self) {
            self.one_float = ::std::option::Option::None;
        }
        pub const SMALL_FLOAT_FIELD_NUMBER: i32 = 9;
        pub const SMALL_FLOAT_DEFAULT_VALUE: f32 = 1.5;
        pub fn small_float(&self) -> f32 {
            self.small_float.unwrap_or(Self::SMALL_FLOAT_DEFAULT_VALUE)
        }
        pub fn small_float_option(&self) -> ::std::option::Option<&f32> {
            self.small_float.as_ref()
        }
        pub fn small_float_mut(&mut self) -> &mut f32 {
            self.small_float
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_small_float(&self) -> bool {
            self.small_float.is_some()
        }
        pub fn set_small_float(&mut self, value: f32) {
            self.small_float = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_small_float(&mut self) -> ::std::option::Option<f32> {
            self.small_float.take()
        }
        pub fn clear_small_float(&mut self) {
            self.small_float = ::std::option::Option::None;
        }
        pub const NEGATIVE_ONE_FLOAT_FIELD_NUMBER: i32 = 10;
        pub const NEGATIVE_ONE_FLOAT_DEFAULT_VALUE: f32 = -1.0;
        pub fn negative_one_float(&self) -> f32 {
            self.negative_one_float
                .unwrap_or(Self::NEGATIVE_ONE_FLOAT_DEFAULT_VALUE)
        }
        pub fn negative_one_float_option(&self) -> ::std::option::Option<&f32> {
            self.negative_one_float.as_ref()
        }
        pub fn negative_one_float_mut(&mut self) -> &mut f32 {
            self.negative_one_float
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_negative_one_float(&self) -> bool {
            self.negative_one_float.is_some()
        }
        pub fn set_negative_one_float(&mut self, value: f32) {
            self.negative_one_float = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_negative_one_float(&mut self) -> ::std::option::Option<f32> {
            self.negative_one_float.take()
        }
        pub fn clear_negative_one_float(&mut self) {
            self.negative_one_float = ::std::option::Option::None;
        }
        pub const NEGATIVE_FLOAT_FIELD_NUMBER: i32 = 11;
        pub const NEGATIVE_FLOAT_DEFAULT_VALUE: f32 = -1.5;
        pub fn negative_float(&self) -> f32 {
            self.negative_float
                .unwrap_or(Self::NEGATIVE_FLOAT_DEFAULT_VALUE)
        }
        pub fn negative_float_option(&self) -> ::std::option::Option<&f32> {
            self.negative_float.as_ref()
        }
        pub fn negative_float_mut(&mut self) -> &mut f32 {
            self.negative_float
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_negative_float(&self) -> bool {
            self.negative_float.is_some()
        }
        pub fn set_negative_float(&mut self, value: f32) {
            self.negative_float = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_negative_float(&mut self) -> ::std::option::Option<f32> {
            self.negative_float.take()
        }
        pub fn clear_negative_float(&mut self) {
            self.negative_float = ::std::option::Option::None;
        }
        pub const LARGE_FLOAT_FIELD_NUMBER: i32 = 12;
        pub const LARGE_FLOAT_DEFAULT_VALUE: f32 = 200000000.0;
        pub fn large_float(&self) -> f32 {
            self.large_float.unwrap_or(Self::LARGE_FLOAT_DEFAULT_VALUE)
        }
        pub fn large_float_option(&self) -> ::std::option::Option<&f32> {
            self.large_float.as_ref()
        }
        pub fn large_float_mut(&mut self) -> &mut f32 {
            self.large_float
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_large_float(&self) -> bool {
            self.large_float.is_some()
        }
        pub fn set_large_float(&mut self, value: f32) {
            self.large_float = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_large_float(&mut self) -> ::std::option::Option<f32> {
            self.large_float.take()
        }
        pub fn clear_large_float(&mut self) {
            self.large_float = ::std::option::Option::None;
        }
        pub const SMALL_NEGATIVE_FLOAT_FIELD_NUMBER: i32 = 13;
        pub const SMALL_NEGATIVE_FLOAT_DEFAULT_VALUE: f32 =
            -0.0000000000000000000000000008000000025368615;
        pub fn small_negative_float(&self) -> f32 {
            self.small_negative_float
                .unwrap_or(Self::SMALL_NEGATIVE_FLOAT_DEFAULT_VALUE)
        }
        pub fn small_negative_float_option(&self) -> ::std::option::Option<&f32> {
            self.small_negative_float.as_ref()
        }
        pub fn small_negative_float_mut(&mut self) -> &mut f32 {
            self.small_negative_float
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_small_negative_float(&self) -> bool {
            self.small_negative_float.is_some()
        }
        pub fn set_small_negative_float(&mut self, value: f32) {
            self.small_negative_float =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_small_negative_float(&mut self) -> ::std::option::Option<f32> {
            self.small_negative_float.take()
        }
        pub fn clear_small_negative_float(&mut self) {
            self.small_negative_float = ::std::option::Option::None;
        }
        pub const INF_DOUBLE_FIELD_NUMBER: i32 = 14;
        pub const INF_DOUBLE_DEFAULT_VALUE: f64 = ::std::f64::INFINITY;
        pub fn inf_double(&self) -> f64 {
            self.inf_double.unwrap_or(Self::INF_DOUBLE_DEFAULT_VALUE)
        }
        pub fn inf_double_option(&self) -> ::std::option::Option<&f64> {
            self.inf_double.as_ref()
        }
        pub fn inf_double_mut(&mut self) -> &mut f64 {
            self.inf_double
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_inf_double(&self) -> bool {
            self.inf_double.is_some()
        }
        pub fn set_inf_double(&mut self, value: f64) {
            self.inf_double = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_inf_double(&mut self) -> ::std::option::Option<f64> {
            self.inf_double.take()
        }
        pub fn clear_inf_double(&mut self) {
            self.inf_double = ::std::option::Option::None;
        }
        pub const NEG_INF_DOUBLE_FIELD_NUMBER: i32 = 15;
        pub const NEG_INF_DOUBLE_DEFAULT_VALUE: f64 = ::std::f64::INFINITY;
        pub fn neg_inf_double(&self) -> f64 {
            self.neg_inf_double
                .unwrap_or(Self::NEG_INF_DOUBLE_DEFAULT_VALUE)
        }
        pub fn neg_inf_double_option(&self) -> ::std::option::Option<&f64> {
            self.neg_inf_double.as_ref()
        }
        pub fn neg_inf_double_mut(&mut self) -> &mut f64 {
            self.neg_inf_double
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_neg_inf_double(&self) -> bool {
            self.neg_inf_double.is_some()
        }
        pub fn set_neg_inf_double(&mut self, value: f64) {
            self.neg_inf_double = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_neg_inf_double(&mut self) -> ::std::option::Option<f64> {
            self.neg_inf_double.take()
        }
        pub fn clear_neg_inf_double(&mut self) {
            self.neg_inf_double = ::std::option::Option::None;
        }
        pub const NAN_DOUBLE_FIELD_NUMBER: i32 = 16;
        pub const NAN_DOUBLE_DEFAULT_VALUE: f64 = ::std::f64::NAN;
        pub fn nan_double(&self) -> f64 {
            self.nan_double.unwrap_or(Self::NAN_DOUBLE_DEFAULT_VALUE)
        }
        pub fn nan_double_option(&self) -> ::std::option::Option<&f64> {
            self.nan_double.as_ref()
        }
        pub fn nan_double_mut(&mut self) -> &mut f64 {
            self.nan_double
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_nan_double(&self) -> bool {
            self.nan_double.is_some()
        }
        pub fn set_nan_double(&mut self, value: f64) {
            self.nan_double = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_nan_double(&mut self) -> ::std::option::Option<f64> {
            self.nan_double.take()
        }
        pub fn clear_nan_double(&mut self) {
            self.nan_double = ::std::option::Option::None;
        }
        pub const INF_FLOAT_FIELD_NUMBER: i32 = 17;
        pub const INF_FLOAT_DEFAULT_VALUE: f32 = ::std::f32::INFINITY;
        pub fn inf_float(&self) -> f32 {
            self.inf_float.unwrap_or(Self::INF_FLOAT_DEFAULT_VALUE)
        }
        pub fn inf_float_option(&self) -> ::std::option::Option<&f32> {
            self.inf_float.as_ref()
        }
        pub fn inf_float_mut(&mut self) -> &mut f32 {
            self.inf_float
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_inf_float(&self) -> bool {
            self.inf_float.is_some()
        }
        pub fn set_inf_float(&mut self, value: f32) {
            self.inf_float = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_inf_float(&mut self) -> ::std::option::Option<f32> {
            self.inf_float.take()
        }
        pub fn clear_inf_float(&mut self) {
            self.inf_float = ::std::option::Option::None;
        }
        pub const NEG_INF_FLOAT_FIELD_NUMBER: i32 = 18;
        pub const NEG_INF_FLOAT_DEFAULT_VALUE: f32 = ::std::f32::INFINITY;
        pub fn neg_inf_float(&self) -> f32 {
            self.neg_inf_float
                .unwrap_or(Self::NEG_INF_FLOAT_DEFAULT_VALUE)
        }
        pub fn neg_inf_float_option(&self) -> ::std::option::Option<&f32> {
            self.neg_inf_float.as_ref()
        }
        pub fn neg_inf_float_mut(&mut self) -> &mut f32 {
            self.neg_inf_float
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_neg_inf_float(&self) -> bool {
            self.neg_inf_float.is_some()
        }
        pub fn set_neg_inf_float(&mut self, value: f32) {
            self.neg_inf_float = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_neg_inf_float(&mut self) -> ::std::option::Option<f32> {
            self.neg_inf_float.take()
        }
        pub fn clear_neg_inf_float(&mut self) {
            self.neg_inf_float = ::std::option::Option::None;
        }
        pub const NAN_FLOAT_FIELD_NUMBER: i32 = 19;
        pub const NAN_FLOAT_DEFAULT_VALUE: f32 = ::std::f32::NAN;
        pub fn nan_float(&self) -> f32 {
            self.nan_float.unwrap_or(Self::NAN_FLOAT_DEFAULT_VALUE)
        }
        pub fn nan_float_option(&self) -> ::std::option::Option<&f32> {
            self.nan_float.as_ref()
        }
        pub fn nan_float_mut(&mut self) -> &mut f32 {
            self.nan_float
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_nan_float(&self) -> bool {
            self.nan_float.is_some()
        }
        pub fn set_nan_float(&mut self, value: f32) {
            self.nan_float = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_nan_float(&mut self) -> ::std::option::Option<f32> {
            self.nan_float.take()
        }
        pub fn clear_nan_float(&mut self) {
            self.nan_float = ::std::option::Option::None;
        }
        pub const CPP_TRIGRAPH_FIELD_NUMBER: i32 = 20;
        pub const CPP_TRIGRAPH_DEFAULT_VALUE: &'static str = "? ? ?? ?? ??? ??/ ??-";
        pub fn cpp_trigraph(&self) -> &str {
            self.cpp_trigraph
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::CPP_TRIGRAPH_DEFAULT_VALUE)
        }
        pub fn cpp_trigraph_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.cpp_trigraph.as_ref()
        }
        pub fn cpp_trigraph_mut(&mut self) -> &mut ::std::string::String {
            self.cpp_trigraph
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_cpp_trigraph(&self) -> bool {
            self.cpp_trigraph.is_some()
        }
        pub fn set_cpp_trigraph(&mut self, value: ::std::string::String) {
            self.cpp_trigraph = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_cpp_trigraph(&mut self) -> ::std::option::Option<::std::string::String> {
            self.cpp_trigraph.take()
        }
        pub fn clear_cpp_trigraph(&mut self) {
            self.cpp_trigraph = ::std::option::Option::None;
        }
        pub const STRING_WITH_ZERO_FIELD_NUMBER: i32 = 23;
        pub const STRING_WITH_ZERO_DEFAULT_VALUE: &'static str = "hel\u{0}lo";
        pub fn string_with_zero(&self) -> &str {
            self.string_with_zero
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::STRING_WITH_ZERO_DEFAULT_VALUE)
        }
        pub fn string_with_zero_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.string_with_zero.as_ref()
        }
        pub fn string_with_zero_mut(&mut self) -> &mut ::std::string::String {
            self.string_with_zero
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_string_with_zero(&self) -> bool {
            self.string_with_zero.is_some()
        }
        pub fn set_string_with_zero(&mut self, value: ::std::string::String) {
            self.string_with_zero = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_string_with_zero(&mut self) -> ::std::option::Option<::std::string::String> {
            self.string_with_zero.take()
        }
        pub fn clear_string_with_zero(&mut self) {
            self.string_with_zero = ::std::option::Option::None;
        }
        pub const BYTES_WITH_ZERO_FIELD_NUMBER: i32 = 24;
        pub const BYTES_WITH_ZERO_DEFAULT_VALUE: &'static [u8] =
            &[119, 111, 114, 0, 48, 48, 48, 108, 100];
        pub fn bytes_with_zero(&self) -> &[u8] {
            self.bytes_with_zero
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::BYTES_WITH_ZERO_DEFAULT_VALUE)
        }
        pub fn bytes_with_zero_option(&self) -> ::std::option::Option<&::std::vec::Vec<u8>> {
            self.bytes_with_zero.as_ref()
        }
        pub fn bytes_with_zero_mut(&mut self) -> &mut ::std::vec::Vec<u8> {
            self.bytes_with_zero
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_bytes_with_zero(&self) -> bool {
            self.bytes_with_zero.is_some()
        }
        pub fn set_bytes_with_zero(&mut self, value: ::std::vec::Vec<u8>) {
            self.bytes_with_zero = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_bytes_with_zero(&mut self) -> ::std::option::Option<::std::vec::Vec<u8>> {
            self.bytes_with_zero.take()
        }
        pub fn clear_bytes_with_zero(&mut self) {
            self.bytes_with_zero = ::std::option::Option::None;
        }
        pub const STRING_PIECE_WITH_ZERO_FIELD_NUMBER: i32 = 25;
        pub const STRING_PIECE_WITH_ZERO_DEFAULT_VALUE: &'static str = "ab\u{0}c";
        pub fn string_piece_with_zero(&self) -> &str {
            self.string_piece_with_zero
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::STRING_PIECE_WITH_ZERO_DEFAULT_VALUE)
        }
        pub fn string_piece_with_zero_option(
            &self,
        ) -> ::std::option::Option<&::std::string::String> {
            self.string_piece_with_zero.as_ref()
        }
        pub fn string_piece_with_zero_mut(&mut self) -> &mut ::std::string::String {
            self.string_piece_with_zero
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_string_piece_with_zero(&self) -> bool {
            self.string_piece_with_zero.is_some()
        }
        pub fn set_string_piece_with_zero(&mut self, value: ::std::string::String) {
            self.string_piece_with_zero =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_string_piece_with_zero(
            &mut self,
        ) -> ::std::option::Option<::std::string::String> {
            self.string_piece_with_zero.take()
        }
        pub fn clear_string_piece_with_zero(&mut self) {
            self.string_piece_with_zero = ::std::option::Option::None;
        }
        pub const CORD_WITH_ZERO_FIELD_NUMBER: i32 = 26;
        pub const CORD_WITH_ZERO_DEFAULT_VALUE: &'static str = "12\u{0}3";
        pub fn cord_with_zero(&self) -> &str {
            self.cord_with_zero
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::CORD_WITH_ZERO_DEFAULT_VALUE)
        }
        pub fn cord_with_zero_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.cord_with_zero.as_ref()
        }
        pub fn cord_with_zero_mut(&mut self) -> &mut ::std::string::String {
            self.cord_with_zero
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_cord_with_zero(&self) -> bool {
            self.cord_with_zero.is_some()
        }
        pub fn set_cord_with_zero(&mut self, value: ::std::string::String) {
            self.cord_with_zero = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_cord_with_zero(&mut self) -> ::std::option::Option<::std::string::String> {
            self.cord_with_zero.take()
        }
        pub fn clear_cord_with_zero(&mut self) {
            self.cord_with_zero = ::std::option::Option::None;
        }
        pub const REPLACEMENT_STRING_FIELD_NUMBER: i32 = 27;
        pub const REPLACEMENT_STRING_DEFAULT_VALUE: &'static str = "${unknown}";
        pub fn replacement_string(&self) -> &str {
            self.replacement_string
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::REPLACEMENT_STRING_DEFAULT_VALUE)
        }
        pub fn replacement_string_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.replacement_string.as_ref()
        }
        pub fn replacement_string_mut(&mut self) -> &mut ::std::string::String {
            self.replacement_string
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_replacement_string(&self) -> bool {
            self.replacement_string.is_some()
        }
        pub fn set_replacement_string(&mut self, value: ::std::string::String) {
            self.replacement_string = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_replacement_string(&mut self) -> ::std::option::Option<::std::string::String> {
            self.replacement_string.take()
        }
        pub fn clear_replacement_string(&mut self) {
            self.replacement_string = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod test_extreme_default_values {
        pub(in super::super) static ESCAPED_BYTES_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtremeDefaultValues,
                ::std::vec::Vec<u8>,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtremeDefaultValues::escaped_bytes_option,
            get_mut: self::super::TestExtremeDefaultValues::escaped_bytes_mut,
            set: self::super::TestExtremeDefaultValues::set_escaped_bytes,
            take: self::super::TestExtremeDefaultValues::take_escaped_bytes,
            clear: self::super::TestExtremeDefaultValues::clear_escaped_bytes,
        };
        pub(in super::super) static LARGE_UINT32_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtremeDefaultValues,
                u32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtremeDefaultValues::large_uint32_option,
            get_mut: self::super::TestExtremeDefaultValues::large_uint32_mut,
            set: self::super::TestExtremeDefaultValues::set_large_uint32,
            take: self::super::TestExtremeDefaultValues::take_large_uint32,
            clear: self::super::TestExtremeDefaultValues::clear_large_uint32,
        };
        pub(in super::super) static LARGE_UINT64_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtremeDefaultValues,
                u64,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtremeDefaultValues::large_uint64_option,
            get_mut: self::super::TestExtremeDefaultValues::large_uint64_mut,
            set: self::super::TestExtremeDefaultValues::set_large_uint64,
            take: self::super::TestExtremeDefaultValues::take_large_uint64,
            clear: self::super::TestExtremeDefaultValues::clear_large_uint64,
        };
        pub(in super::super) static SMALL_INT32_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtremeDefaultValues,
                i32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtremeDefaultValues::small_int32_option,
            get_mut: self::super::TestExtremeDefaultValues::small_int32_mut,
            set: self::super::TestExtremeDefaultValues::set_small_int32,
            take: self::super::TestExtremeDefaultValues::take_small_int32,
            clear: self::super::TestExtremeDefaultValues::clear_small_int32,
        };
        pub(in super::super) static SMALL_INT64_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtremeDefaultValues,
                i64,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtremeDefaultValues::small_int64_option,
            get_mut: self::super::TestExtremeDefaultValues::small_int64_mut,
            set: self::super::TestExtremeDefaultValues::set_small_int64,
            take: self::super::TestExtremeDefaultValues::take_small_int64,
            clear: self::super::TestExtremeDefaultValues::clear_small_int64,
        };
        pub(in super::super) static REALLY_SMALL_INT32_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtremeDefaultValues,
                i32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtremeDefaultValues::really_small_int32_option,
            get_mut: self::super::TestExtremeDefaultValues::really_small_int32_mut,
            set: self::super::TestExtremeDefaultValues::set_really_small_int32,
            take: self::super::TestExtremeDefaultValues::take_really_small_int32,
            clear: self::super::TestExtremeDefaultValues::clear_really_small_int32,
        };
        pub(in super::super) static REALLY_SMALL_INT64_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtremeDefaultValues,
                i64,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtremeDefaultValues::really_small_int64_option,
            get_mut: self::super::TestExtremeDefaultValues::really_small_int64_mut,
            set: self::super::TestExtremeDefaultValues::set_really_small_int64,
            take: self::super::TestExtremeDefaultValues::take_really_small_int64,
            clear: self::super::TestExtremeDefaultValues::clear_really_small_int64,
        };
        pub(in super::super) static UTF8_STRING_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtremeDefaultValues,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtremeDefaultValues::utf8_string_option,
            get_mut: self::super::TestExtremeDefaultValues::utf8_string_mut,
            set: self::super::TestExtremeDefaultValues::set_utf8_string,
            take: self::super::TestExtremeDefaultValues::take_utf8_string,
            clear: self::super::TestExtremeDefaultValues::clear_utf8_string,
        };
        pub(in super::super) static ZERO_FLOAT_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtremeDefaultValues,
                f32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtremeDefaultValues::zero_float_option,
            get_mut: self::super::TestExtremeDefaultValues::zero_float_mut,
            set: self::super::TestExtremeDefaultValues::set_zero_float,
            take: self::super::TestExtremeDefaultValues::take_zero_float,
            clear: self::super::TestExtremeDefaultValues::clear_zero_float,
        };
        pub(in super::super) static ONE_FLOAT_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtremeDefaultValues,
                f32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtremeDefaultValues::one_float_option,
            get_mut: self::super::TestExtremeDefaultValues::one_float_mut,
            set: self::super::TestExtremeDefaultValues::set_one_float,
            take: self::super::TestExtremeDefaultValues::take_one_float,
            clear: self::super::TestExtremeDefaultValues::clear_one_float,
        };
        pub(in super::super) static SMALL_FLOAT_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtremeDefaultValues,
                f32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtremeDefaultValues::small_float_option,
            get_mut: self::super::TestExtremeDefaultValues::small_float_mut,
            set: self::super::TestExtremeDefaultValues::set_small_float,
            take: self::super::TestExtremeDefaultValues::take_small_float,
            clear: self::super::TestExtremeDefaultValues::clear_small_float,
        };
        pub(in super::super) static NEGATIVE_ONE_FLOAT_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtremeDefaultValues,
                f32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtremeDefaultValues::negative_one_float_option,
            get_mut: self::super::TestExtremeDefaultValues::negative_one_float_mut,
            set: self::super::TestExtremeDefaultValues::set_negative_one_float,
            take: self::super::TestExtremeDefaultValues::take_negative_one_float,
            clear: self::super::TestExtremeDefaultValues::clear_negative_one_float,
        };
        pub(in super::super) static NEGATIVE_FLOAT_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtremeDefaultValues,
                f32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtremeDefaultValues::negative_float_option,
            get_mut: self::super::TestExtremeDefaultValues::negative_float_mut,
            set: self::super::TestExtremeDefaultValues::set_negative_float,
            take: self::super::TestExtremeDefaultValues::take_negative_float,
            clear: self::super::TestExtremeDefaultValues::clear_negative_float,
        };
        pub(in super::super) static LARGE_FLOAT_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtremeDefaultValues,
                f32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtremeDefaultValues::large_float_option,
            get_mut: self::super::TestExtremeDefaultValues::large_float_mut,
            set: self::super::TestExtremeDefaultValues::set_large_float,
            take: self::super::TestExtremeDefaultValues::take_large_float,
            clear: self::super::TestExtremeDefaultValues::clear_large_float,
        };
        pub(in super::super) static SMALL_NEGATIVE_FLOAT_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtremeDefaultValues,
                f32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtremeDefaultValues::small_negative_float_option,
            get_mut: self::super::TestExtremeDefaultValues::small_negative_float_mut,
            set: self::super::TestExtremeDefaultValues::set_small_negative_float,
            take: self::super::TestExtremeDefaultValues::take_small_negative_float,
            clear: self::super::TestExtremeDefaultValues::clear_small_negative_float,
        };
        pub(in super::super) static INF_DOUBLE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtremeDefaultValues,
                f64,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtremeDefaultValues::inf_double_option,
            get_mut: self::super::TestExtremeDefaultValues::inf_double_mut,
            set: self::super::TestExtremeDefaultValues::set_inf_double,
            take: self::super::TestExtremeDefaultValues::take_inf_double,
            clear: self::super::TestExtremeDefaultValues::clear_inf_double,
        };
        pub(in super::super) static NEG_INF_DOUBLE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtremeDefaultValues,
                f64,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtremeDefaultValues::neg_inf_double_option,
            get_mut: self::super::TestExtremeDefaultValues::neg_inf_double_mut,
            set: self::super::TestExtremeDefaultValues::set_neg_inf_double,
            take: self::super::TestExtremeDefaultValues::take_neg_inf_double,
            clear: self::super::TestExtremeDefaultValues::clear_neg_inf_double,
        };
        pub(in super::super) static NAN_DOUBLE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtremeDefaultValues,
                f64,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtremeDefaultValues::nan_double_option,
            get_mut: self::super::TestExtremeDefaultValues::nan_double_mut,
            set: self::super::TestExtremeDefaultValues::set_nan_double,
            take: self::super::TestExtremeDefaultValues::take_nan_double,
            clear: self::super::TestExtremeDefaultValues::clear_nan_double,
        };
        pub(in super::super) static INF_FLOAT_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtremeDefaultValues,
                f32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtremeDefaultValues::inf_float_option,
            get_mut: self::super::TestExtremeDefaultValues::inf_float_mut,
            set: self::super::TestExtremeDefaultValues::set_inf_float,
            take: self::super::TestExtremeDefaultValues::take_inf_float,
            clear: self::super::TestExtremeDefaultValues::clear_inf_float,
        };
        pub(in super::super) static NEG_INF_FLOAT_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtremeDefaultValues,
                f32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtremeDefaultValues::neg_inf_float_option,
            get_mut: self::super::TestExtremeDefaultValues::neg_inf_float_mut,
            set: self::super::TestExtremeDefaultValues::set_neg_inf_float,
            take: self::super::TestExtremeDefaultValues::take_neg_inf_float,
            clear: self::super::TestExtremeDefaultValues::clear_neg_inf_float,
        };
        pub(in super::super) static NAN_FLOAT_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtremeDefaultValues,
                f32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtremeDefaultValues::nan_float_option,
            get_mut: self::super::TestExtremeDefaultValues::nan_float_mut,
            set: self::super::TestExtremeDefaultValues::set_nan_float,
            take: self::super::TestExtremeDefaultValues::take_nan_float,
            clear: self::super::TestExtremeDefaultValues::clear_nan_float,
        };
        pub(in super::super) static CPP_TRIGRAPH_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtremeDefaultValues,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtremeDefaultValues::cpp_trigraph_option,
            get_mut: self::super::TestExtremeDefaultValues::cpp_trigraph_mut,
            set: self::super::TestExtremeDefaultValues::set_cpp_trigraph,
            take: self::super::TestExtremeDefaultValues::take_cpp_trigraph,
            clear: self::super::TestExtremeDefaultValues::clear_cpp_trigraph,
        };
        pub(in super::super) static STRING_WITH_ZERO_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtremeDefaultValues,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtremeDefaultValues::string_with_zero_option,
            get_mut: self::super::TestExtremeDefaultValues::string_with_zero_mut,
            set: self::super::TestExtremeDefaultValues::set_string_with_zero,
            take: self::super::TestExtremeDefaultValues::take_string_with_zero,
            clear: self::super::TestExtremeDefaultValues::clear_string_with_zero,
        };
        pub(in super::super) static BYTES_WITH_ZERO_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtremeDefaultValues,
                ::std::vec::Vec<u8>,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtremeDefaultValues::bytes_with_zero_option,
            get_mut: self::super::TestExtremeDefaultValues::bytes_with_zero_mut,
            set: self::super::TestExtremeDefaultValues::set_bytes_with_zero,
            take: self::super::TestExtremeDefaultValues::take_bytes_with_zero,
            clear: self::super::TestExtremeDefaultValues::clear_bytes_with_zero,
        };
        pub(in super::super) static STRING_PIECE_WITH_ZERO_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtremeDefaultValues,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtremeDefaultValues::string_piece_with_zero_option,
            get_mut: self::super::TestExtremeDefaultValues::string_piece_with_zero_mut,
            set: self::super::TestExtremeDefaultValues::set_string_piece_with_zero,
            take: self::super::TestExtremeDefaultValues::take_string_piece_with_zero,
            clear: self::super::TestExtremeDefaultValues::clear_string_piece_with_zero,
        };
        pub(in super::super) static CORD_WITH_ZERO_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtremeDefaultValues,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtremeDefaultValues::cord_with_zero_option,
            get_mut: self::super::TestExtremeDefaultValues::cord_with_zero_mut,
            set: self::super::TestExtremeDefaultValues::set_cord_with_zero,
            take: self::super::TestExtremeDefaultValues::take_cord_with_zero,
            clear: self::super::TestExtremeDefaultValues::clear_cord_with_zero,
        };
        pub(in super::super) static REPLACEMENT_STRING_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtremeDefaultValues,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtremeDefaultValues::replacement_string_option,
            get_mut: self::super::TestExtremeDefaultValues::replacement_string_mut,
            set: self::super::TestExtremeDefaultValues::set_replacement_string,
            take: self::super::TestExtremeDefaultValues::take_replacement_string,
            clear: self::super::TestExtremeDefaultValues::clear_replacement_string,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct SparseEnumMessage {
        sparse_enum: ::std::option::Option<::protrust::EnumValue<self::TestSparseEnum>>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::SparseEnumMessage {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.set_sparse_enum(input.read_enum_value()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(sparse_enum) = self.sparse_enum_option() {
                size += 1;
                size += ::protrust::io::sizes::enum_value(*sparse_enum);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(sparse_enum) = self.sparse_enum_option() {
                output.write_raw_tag_bytes(&[8])?;
                output.write_enum_value(*sparse_enum)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::SparseEnumMessage {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(sparse_enum) = other.sparse_enum_option() {
                self.set_sparse_enum(*sparse_enum);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::SparseEnumMessage {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[33]
        }
    }
    impl self::SparseEnumMessage {
        pub const SPARSE_ENUM_FIELD_NUMBER: i32 = 1;
        pub const SPARSE_ENUM_DEFAULT_VALUE: ::protrust::EnumValue<self::TestSparseEnum> =
            ::protrust::EnumValue::Defined(self::TestSparseEnum::SparseF);
        pub fn sparse_enum(&self) -> ::protrust::EnumValue<self::TestSparseEnum> {
            self.sparse_enum.unwrap_or(Self::SPARSE_ENUM_DEFAULT_VALUE)
        }
        pub fn sparse_enum_option(
            &self,
        ) -> ::std::option::Option<&::protrust::EnumValue<self::TestSparseEnum>> {
            self.sparse_enum.as_ref()
        }
        pub fn sparse_enum_mut(&mut self) -> &mut ::protrust::EnumValue<self::TestSparseEnum> {
            self.sparse_enum
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_sparse_enum(&self) -> bool {
            self.sparse_enum.is_some()
        }
        pub fn set_sparse_enum(&mut self, value: ::protrust::EnumValue<self::TestSparseEnum>) {
            self.sparse_enum = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_sparse_enum(
            &mut self,
        ) -> ::std::option::Option<::protrust::EnumValue<self::TestSparseEnum>> {
            self.sparse_enum.take()
        }
        pub fn clear_sparse_enum(&mut self) {
            self.sparse_enum = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod sparse_enum_message {
        pub(in super::super) static SPARSE_ENUM_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::SparseEnumMessage,
                ::protrust::EnumValue<self::super::TestSparseEnum>,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::SparseEnumMessage::sparse_enum_option,
            get_mut: self::super::SparseEnumMessage::sparse_enum_mut,
            set: self::super::SparseEnumMessage::set_sparse_enum,
            take: self::super::SparseEnumMessage::take_sparse_enum,
            clear: self::super::SparseEnumMessage::clear_sparse_enum,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct OneString {
        data: ::std::option::Option<::std::string::String>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::OneString {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => self.set_data(input.read_string()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(data) = self.data_option() {
                size += 1;
                size += ::protrust::io::sizes::string(data);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(data) = self.data_option() {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(data)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::OneString {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(data) = other.data_option() {
                self.set_data(::std::clone::Clone::clone(data));
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::OneString {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[34]
        }
    }
    impl self::OneString {
        pub const DATA_FIELD_NUMBER: i32 = 1;
        pub const DATA_DEFAULT_VALUE: &'static str = "";
        pub fn data(&self) -> &str {
            self.data
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::DATA_DEFAULT_VALUE)
        }
        pub fn data_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.data.as_ref()
        }
        pub fn data_mut(&mut self) -> &mut ::std::string::String {
            self.data
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }
        pub fn set_data(&mut self, value: ::std::string::String) {
            self.data = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_data(&mut self) -> ::std::option::Option<::std::string::String> {
            self.data.take()
        }
        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod one_string {
        pub(in super::super) static DATA_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::OneString,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::OneString::data_option,
            get_mut: self::super::OneString::data_mut,
            set: self::super::OneString::set_data,
            take: self::super::OneString::take_data,
            clear: self::super::OneString::clear_data,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct MoreString {
        data: ::protrust::collections::RepeatedField<::std::string::String>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::MoreString {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => self
                        .data
                        .add_entries(input, &self::more_string::DATA_CODEC)?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            size += self.data().calculate_size(&self::more_string::DATA_CODEC);
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            self.data()
                .write_to(output, &self::more_string::DATA_CODEC)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::MoreString {
        fn merge(&mut self, other: &Self) {
            self.data.merge(&other.data);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::MoreString {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[35]
        }
    }
    impl self::MoreString {
        pub const DATA_FIELD_NUMBER: i32 = 1;
        pub fn data(&self) -> &::protrust::collections::RepeatedField<::std::string::String> {
            &self.data
        }
        pub fn data_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<::std::string::String> {
            &mut self.data
        }
    }
    pub(in super::super) mod more_string {
        pub(super) static DATA_CODEC: ::protrust::Codec<::std::string::String> =
            ::protrust::Codec::string(10);
        pub(in super::super) static DATA_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::MoreString,
                ::protrust::collections::RepeatedField<::std::string::String>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::MoreString::data,
            get_mut: self::super::MoreString::data_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct OneBytes {
        data: ::std::option::Option<::std::vec::Vec<u8>>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::OneBytes {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => self.set_data(input.read_bytes()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(data) = self.data_option() {
                size += 1;
                size += ::protrust::io::sizes::bytes(data);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(data) = self.data_option() {
                output.write_raw_tag_bytes(&[10])?;
                output.write_bytes(data)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::OneBytes {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(data) = other.data_option() {
                self.set_data(::std::clone::Clone::clone(data));
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::OneBytes {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[36]
        }
    }
    impl self::OneBytes {
        pub const DATA_FIELD_NUMBER: i32 = 1;
        pub const DATA_DEFAULT_VALUE: &'static [u8] = &[];
        pub fn data(&self) -> &[u8] {
            self.data
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::DATA_DEFAULT_VALUE)
        }
        pub fn data_option(&self) -> ::std::option::Option<&::std::vec::Vec<u8>> {
            self.data.as_ref()
        }
        pub fn data_mut(&mut self) -> &mut ::std::vec::Vec<u8> {
            self.data
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }
        pub fn set_data(&mut self, value: ::std::vec::Vec<u8>) {
            self.data = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_data(&mut self) -> ::std::option::Option<::std::vec::Vec<u8>> {
            self.data.take()
        }
        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod one_bytes {
        pub(in super::super) static DATA_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::OneBytes,
                ::std::vec::Vec<u8>,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::OneBytes::data_option,
            get_mut: self::super::OneBytes::data_mut,
            set: self::super::OneBytes::set_data,
            take: self::super::OneBytes::take_data,
            clear: self::super::OneBytes::clear_data,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct MoreBytes {
        data: ::protrust::collections::RepeatedField<::std::vec::Vec<u8>>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::MoreBytes {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => self
                        .data
                        .add_entries(input, &self::more_bytes::DATA_CODEC)?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            size += self.data().calculate_size(&self::more_bytes::DATA_CODEC);
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            self.data()
                .write_to(output, &self::more_bytes::DATA_CODEC)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::MoreBytes {
        fn merge(&mut self, other: &Self) {
            self.data.merge(&other.data);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::MoreBytes {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[37]
        }
    }
    impl self::MoreBytes {
        pub const DATA_FIELD_NUMBER: i32 = 1;
        pub fn data(&self) -> &::protrust::collections::RepeatedField<::std::vec::Vec<u8>> {
            &self.data
        }
        pub fn data_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<::std::vec::Vec<u8>> {
            &mut self.data
        }
    }
    pub(in super::super) mod more_bytes {
        pub(super) static DATA_CODEC: ::protrust::Codec<::std::vec::Vec<u8>> =
            ::protrust::Codec::bytes(10);
        pub(in super::super) static DATA_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::MoreBytes,
                ::protrust::collections::RepeatedField<::std::vec::Vec<u8>>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::MoreBytes::data,
            get_mut: self::super::MoreBytes::data_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct Int32Message {
        data: ::std::option::Option<i32>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::Int32Message {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.set_data(input.read_int32()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(data) = self.data_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*data);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(data) = self.data_option() {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(*data)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::Int32Message {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(data) = other.data_option() {
                self.set_data(*data);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::Int32Message {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[38]
        }
    }
    impl self::Int32Message {
        pub const DATA_FIELD_NUMBER: i32 = 1;
        pub const DATA_DEFAULT_VALUE: i32 = 0;
        pub fn data(&self) -> i32 {
            self.data.unwrap_or(Self::DATA_DEFAULT_VALUE)
        }
        pub fn data_option(&self) -> ::std::option::Option<&i32> {
            self.data.as_ref()
        }
        pub fn data_mut(&mut self) -> &mut i32 {
            self.data
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }
        pub fn set_data(&mut self, value: i32) {
            self.data = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_data(&mut self) -> ::std::option::Option<i32> {
            self.data.take()
        }
        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod int32_message {
        pub(in super::super) static DATA_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::Int32Message, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::Int32Message::data_option,
                get_mut: self::super::Int32Message::data_mut,
                set: self::super::Int32Message::set_data,
                take: self::super::Int32Message::take_data,
                clear: self::super::Int32Message::clear_data,
            };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct Uint32Message {
        data: ::std::option::Option<u32>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::Uint32Message {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.set_data(input.read_uint32()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(data) = self.data_option() {
                size += 1;
                size += ::protrust::io::sizes::uint32(*data);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(data) = self.data_option() {
                output.write_raw_tag_bytes(&[8])?;
                output.write_uint32(*data)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::Uint32Message {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(data) = other.data_option() {
                self.set_data(*data);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::Uint32Message {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[39]
        }
    }
    impl self::Uint32Message {
        pub const DATA_FIELD_NUMBER: i32 = 1;
        pub const DATA_DEFAULT_VALUE: u32 = 0;
        pub fn data(&self) -> u32 {
            self.data.unwrap_or(Self::DATA_DEFAULT_VALUE)
        }
        pub fn data_option(&self) -> ::std::option::Option<&u32> {
            self.data.as_ref()
        }
        pub fn data_mut(&mut self) -> &mut u32 {
            self.data
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }
        pub fn set_data(&mut self, value: u32) {
            self.data = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_data(&mut self) -> ::std::option::Option<u32> {
            self.data.take()
        }
        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod uint32_message {
        pub(in super::super) static DATA_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::Uint32Message, u32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::Uint32Message::data_option,
                get_mut: self::super::Uint32Message::data_mut,
                set: self::super::Uint32Message::set_data,
                take: self::super::Uint32Message::take_data,
                clear: self::super::Uint32Message::clear_data,
            };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct Int64Message {
        data: ::std::option::Option<i64>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::Int64Message {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.set_data(input.read_int64()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(data) = self.data_option() {
                size += 1;
                size += ::protrust::io::sizes::int64(*data);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(data) = self.data_option() {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int64(*data)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::Int64Message {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(data) = other.data_option() {
                self.set_data(*data);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::Int64Message {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[40]
        }
    }
    impl self::Int64Message {
        pub const DATA_FIELD_NUMBER: i32 = 1;
        pub const DATA_DEFAULT_VALUE: i64 = 0;
        pub fn data(&self) -> i64 {
            self.data.unwrap_or(Self::DATA_DEFAULT_VALUE)
        }
        pub fn data_option(&self) -> ::std::option::Option<&i64> {
            self.data.as_ref()
        }
        pub fn data_mut(&mut self) -> &mut i64 {
            self.data
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }
        pub fn set_data(&mut self, value: i64) {
            self.data = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_data(&mut self) -> ::std::option::Option<i64> {
            self.data.take()
        }
        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod int64_message {
        pub(in super::super) static DATA_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::Int64Message, i64> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::Int64Message::data_option,
                get_mut: self::super::Int64Message::data_mut,
                set: self::super::Int64Message::set_data,
                take: self::super::Int64Message::take_data,
                clear: self::super::Int64Message::clear_data,
            };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct Uint64Message {
        data: ::std::option::Option<u64>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::Uint64Message {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.set_data(input.read_uint64()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(data) = self.data_option() {
                size += 1;
                size += ::protrust::io::sizes::uint64(*data);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(data) = self.data_option() {
                output.write_raw_tag_bytes(&[8])?;
                output.write_uint64(*data)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::Uint64Message {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(data) = other.data_option() {
                self.set_data(*data);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::Uint64Message {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[41]
        }
    }
    impl self::Uint64Message {
        pub const DATA_FIELD_NUMBER: i32 = 1;
        pub const DATA_DEFAULT_VALUE: u64 = 0;
        pub fn data(&self) -> u64 {
            self.data.unwrap_or(Self::DATA_DEFAULT_VALUE)
        }
        pub fn data_option(&self) -> ::std::option::Option<&u64> {
            self.data.as_ref()
        }
        pub fn data_mut(&mut self) -> &mut u64 {
            self.data
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }
        pub fn set_data(&mut self, value: u64) {
            self.data = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_data(&mut self) -> ::std::option::Option<u64> {
            self.data.take()
        }
        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod uint64_message {
        pub(in super::super) static DATA_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::Uint64Message, u64> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::Uint64Message::data_option,
                get_mut: self::super::Uint64Message::data_mut,
                set: self::super::Uint64Message::set_data,
                take: self::super::Uint64Message::take_data,
                clear: self::super::Uint64Message::clear_data,
            };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct BoolMessage {
        data: ::std::option::Option<bool>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::BoolMessage {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.set_data(input.read_bool()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(data) = self.data_option() {
                size += 1;
                size += ::protrust::io::sizes::bool(*data);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(data) = self.data_option() {
                output.write_raw_tag_bytes(&[8])?;
                output.write_bool(*data)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::BoolMessage {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(data) = other.data_option() {
                self.set_data(*data);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::BoolMessage {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[42]
        }
    }
    impl self::BoolMessage {
        pub const DATA_FIELD_NUMBER: i32 = 1;
        pub const DATA_DEFAULT_VALUE: bool = false;
        pub fn data(&self) -> bool {
            self.data.unwrap_or(Self::DATA_DEFAULT_VALUE)
        }
        pub fn data_option(&self) -> ::std::option::Option<&bool> {
            self.data.as_ref()
        }
        pub fn data_mut(&mut self) -> &mut bool {
            self.data
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }
        pub fn set_data(&mut self, value: bool) {
            self.data = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_data(&mut self) -> ::std::option::Option<bool> {
            self.data.take()
        }
        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod bool_message {
        pub(in super::super) static DATA_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::BoolMessage, bool> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::BoolMessage::data_option,
                get_mut: self::super::BoolMessage::data_mut,
                set: self::super::BoolMessage::set_data,
                take: self::super::BoolMessage::take_data,
                clear: self::super::BoolMessage::clear_data,
            };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestOneof {
        foo: self::test_oneof::Foo,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestOneof {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.set_foo_int(input.read_int32()?),
                    18 => self.set_foo_string(input.read_string()?),
                    26 => input.read_message(self.foo_message_mut())?,
                    35 => input.read_group(self.foogroup_mut())?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(foo_int) = self.foo_int() {
                size += 1;
                size += ::protrust::io::sizes::int32(*foo_int);
            }
            if let ::std::option::Option::Some(foo_string) = self.foo_string() {
                size += 1;
                size += ::protrust::io::sizes::string(foo_string);
            }
            if let ::std::option::Option::Some(foo_message) = self.foo_message() {
                size += 1;
                size += ::protrust::io::sizes::message(foo_message);
            }
            if let ::std::option::Option::Some(foogroup) = self.foogroup() {
                size += 1;
                size += ::protrust::io::sizes::group(foogroup);
                size += 1;
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(foo_int) = self.foo_int() {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(*foo_int)?;
            }
            if let ::std::option::Option::Some(foo_string) = self.foo_string() {
                output.write_raw_tag_bytes(&[18])?;
                output.write_string(foo_string)?;
            }
            if let ::std::option::Option::Some(foo_message) = self.foo_message() {
                output.write_raw_tag_bytes(&[26])?;
                output.write_message(foo_message)?;
            }
            if let ::std::option::Option::Some(foogroup) = self.foogroup() {
                output.write_raw_tag_bytes(&[35])?;
                output.write_group(foogroup)?;
                output.write_raw_tag_bytes(&[36])?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(foo_message) = self.foo_message() {
                if !::protrust::CodedMessage::is_initialized(foo_message) {
                    return false;
                }
            }
            if let ::std::option::Option::Some(foogroup) = self.foogroup() {
                if !::protrust::CodedMessage::is_initialized(foogroup) {
                    return false;
                }
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestOneof {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(foo_int) = other.foo_int() {
                self.set_foo_int(*foo_int);
            }
            if let ::std::option::Option::Some(foo_string) = other.foo_string() {
                self.set_foo_string(::std::clone::Clone::clone(foo_string));
            }
            if let ::std::option::Option::Some(foo_message) = &other.foo_message() {
                ::protrust::LiteMessage::merge(self.foo_message_mut(), foo_message);
            }
            if let ::std::option::Option::Some(foogroup) = &other.foogroup() {
                ::protrust::LiteMessage::merge(self.foogroup_mut(), foogroup);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestOneof {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[43]
        }
    }
    impl self::TestOneof {
        pub const FOO_INT_FIELD_NUMBER: i32 = 1;
        pub const FOO_INT_DEFAULT_VALUE: i32 = 0;
        pub fn foo_int(&self) -> ::std::option::Option<&i32> {
            match &self.foo {
                self::test_oneof::Foo::FooInt(foo) => ::std::option::Option::Some(foo),
                _ => ::std::option::Option::None,
            }
        }
        pub fn foo_int_mut(&mut self) -> &mut i32 {
            match self.foo {
                self::test_oneof::Foo::FooInt(_) => (),
                _ => self.foo = self::test_oneof::Foo::FooInt(::std::default::Default::default()),
            }
            match self.foo {
                self::test_oneof::Foo::FooInt(ref mut foo) => foo,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_foo_int(&self) -> bool {
            match self.foo {
                self::test_oneof::Foo::FooInt(_) => true,
                _ => false,
            }
        }
        pub fn set_foo_int(&mut self, value: i32) {
            self.foo = self::test_oneof::Foo::FooInt(::std::convert::From::from(value))
        }
        pub fn take_foo_int(&mut self) -> ::std::option::Option<i32> {
            let foo = ::std::mem::replace(&mut self.foo, self::test_oneof::Foo::None);
            match foo {
                self::test_oneof::Foo::FooInt(foo) => ::std::option::Option::Some(foo),
                mut foo => {
                    ::std::mem::swap(&mut self.foo, &mut foo);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_foo_int(&mut self) {
            let foo = ::std::mem::replace(&mut self.foo, self::test_oneof::Foo::None);
            match foo {
                self::test_oneof::Foo::FooInt(_) => {}
                mut foo => ::std::mem::swap(&mut self.foo, &mut foo),
            }
        }
        pub const FOO_STRING_FIELD_NUMBER: i32 = 2;
        pub const FOO_STRING_DEFAULT_VALUE: &'static str = "";
        pub fn foo_string(&self) -> ::std::option::Option<&::std::string::String> {
            match &self.foo {
                self::test_oneof::Foo::FooString(foo) => ::std::option::Option::Some(foo),
                _ => ::std::option::Option::None,
            }
        }
        pub fn foo_string_mut(&mut self) -> &mut ::std::string::String {
            match self.foo {
                self::test_oneof::Foo::FooString(_) => (),
                _ => {
                    self.foo = self::test_oneof::Foo::FooString(::std::default::Default::default())
                }
            }
            match self.foo {
                self::test_oneof::Foo::FooString(ref mut foo) => foo,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_foo_string(&self) -> bool {
            match self.foo {
                self::test_oneof::Foo::FooString(_) => true,
                _ => false,
            }
        }
        pub fn set_foo_string(&mut self, value: ::std::string::String) {
            self.foo = self::test_oneof::Foo::FooString(::std::convert::From::from(value))
        }
        pub fn take_foo_string(&mut self) -> ::std::option::Option<::std::string::String> {
            let foo = ::std::mem::replace(&mut self.foo, self::test_oneof::Foo::None);
            match foo {
                self::test_oneof::Foo::FooString(foo) => ::std::option::Option::Some(foo),
                mut foo => {
                    ::std::mem::swap(&mut self.foo, &mut foo);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_foo_string(&mut self) {
            let foo = ::std::mem::replace(&mut self.foo, self::test_oneof::Foo::None);
            match foo {
                self::test_oneof::Foo::FooString(_) => {}
                mut foo => ::std::mem::swap(&mut self.foo, &mut foo),
            }
        }
        pub const FOO_MESSAGE_FIELD_NUMBER: i32 = 3;
        pub fn foo_message(&self) -> ::std::option::Option<&self::TestAllTypes> {
            match &self.foo {
                self::test_oneof::Foo::FooMessage(foo) => ::std::option::Option::Some(&**foo),
                _ => ::std::option::Option::None,
            }
        }
        pub fn foo_message_mut(&mut self) -> &mut self::TestAllTypes {
            match self.foo {
                self::test_oneof::Foo::FooMessage(_) => (),
                _ => {
                    self.foo = self::test_oneof::Foo::FooMessage(::std::default::Default::default())
                }
            }
            match self.foo {
                self::test_oneof::Foo::FooMessage(ref mut foo) => &mut **foo,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_foo_message(&self) -> bool {
            match self.foo {
                self::test_oneof::Foo::FooMessage(_) => true,
                _ => false,
            }
        }
        pub fn set_foo_message(&mut self, value: self::TestAllTypes) {
            self.foo = self::test_oneof::Foo::FooMessage(::std::convert::From::from(value))
        }
        pub fn take_foo_message(&mut self) -> ::std::option::Option<self::TestAllTypes> {
            let foo = ::std::mem::replace(&mut self.foo, self::test_oneof::Foo::None);
            match foo {
                self::test_oneof::Foo::FooMessage(foo) => ::std::option::Option::Some(*foo),
                mut foo => {
                    ::std::mem::swap(&mut self.foo, &mut foo);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_foo_message(&mut self) {
            let foo = ::std::mem::replace(&mut self.foo, self::test_oneof::Foo::None);
            match foo {
                self::test_oneof::Foo::FooMessage(_) => {}
                mut foo => ::std::mem::swap(&mut self.foo, &mut foo),
            }
        }
        pub const FOOGROUP_FIELD_NUMBER: i32 = 4;
        pub fn foogroup(&self) -> ::std::option::Option<&self::test_oneof::FooGroup> {
            match &self.foo {
                self::test_oneof::Foo::Foogroup(foo) => ::std::option::Option::Some(foo),
                _ => ::std::option::Option::None,
            }
        }
        pub fn foogroup_mut(&mut self) -> &mut self::test_oneof::FooGroup {
            match self.foo {
                self::test_oneof::Foo::Foogroup(_) => (),
                _ => self.foo = self::test_oneof::Foo::Foogroup(::std::default::Default::default()),
            }
            match self.foo {
                self::test_oneof::Foo::Foogroup(ref mut foo) => foo,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_foogroup(&self) -> bool {
            match self.foo {
                self::test_oneof::Foo::Foogroup(_) => true,
                _ => false,
            }
        }
        pub fn set_foogroup(&mut self, value: self::test_oneof::FooGroup) {
            self.foo = self::test_oneof::Foo::Foogroup(::std::convert::From::from(value))
        }
        pub fn take_foogroup(&mut self) -> ::std::option::Option<self::test_oneof::FooGroup> {
            let foo = ::std::mem::replace(&mut self.foo, self::test_oneof::Foo::None);
            match foo {
                self::test_oneof::Foo::Foogroup(foo) => ::std::option::Option::Some(*foo),
                mut foo => {
                    ::std::mem::swap(&mut self.foo, &mut foo);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_foogroup(&mut self) {
            let foo = ::std::mem::replace(&mut self.foo, self::test_oneof::Foo::None);
            match foo {
                self::test_oneof::Foo::Foogroup(_) => {}
                mut foo => ::std::mem::swap(&mut self.foo, &mut foo),
            }
        }
        pub fn foo(&self) -> &self::test_oneof::Foo {
            &self.foo
        }
        pub fn foo_mut(&mut self) -> &mut self::test_oneof::Foo {
            &mut self.foo
        }
    }
    pub mod test_oneof {
        #[derive(Clone, Debug, PartialEq)]
        pub enum Foo {
            None,
            FooInt(i32),
            FooString(::std::string::String),
            FooMessage(::std::boxed::Box<self::super::TestAllTypes>),
            Foogroup(::std::boxed::Box<self::FooGroup>),
        }
        impl ::std::default::Default for self::Foo {
            fn default() -> Self {
                self::Foo::None
            }
        }
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct FooGroup {
            a: ::std::option::Option<i32>,
            b: ::std::option::Option<::std::string::String>,
            unknown_fields: ::protrust::UnknownFieldSet,
        }
        impl ::protrust::CodedMessage for self::FooGroup {
            fn merge_from(
                &mut self,
                input: &mut ::protrust::io::CodedInput,
            ) -> ::protrust::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        40 | 42 => self.set_a(input.read_int32()?),
                        50 => self.set_b(input.read_string()?),
                        36 => break,
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> i32 {
                let mut size = 0i32;
                if let ::std::option::Option::Some(a) = self.a_option() {
                    size += 1;
                    size += ::protrust::io::sizes::int32(*a);
                }
                if let ::std::option::Option::Some(b) = self.b_option() {
                    size += 1;
                    size += ::protrust::io::sizes::string(b);
                }
                size += self.unknown_fields.calculate_size();
                size
            }
            fn write_to(
                &self,
                output: &mut ::protrust::io::CodedOutput,
            ) -> ::protrust::io::OutputResult {
                if let ::std::option::Option::Some(a) = self.a_option() {
                    output.write_raw_tag_bytes(&[40])?;
                    output.write_int32(*a)?;
                }
                if let ::std::option::Option::Some(b) = self.b_option() {
                    output.write_raw_tag_bytes(&[50])?;
                    output.write_string(b)?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                true
            }
        }
        impl ::protrust::LiteMessage for self::FooGroup {
            fn merge(&mut self, other: &Self) {
                if let ::std::option::Option::Some(a) = other.a_option() {
                    self.set_a(*a);
                }
                if let ::std::option::Option::Some(b) = other.b_option() {
                    self.set_b(::std::clone::Clone::clone(b));
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl ::protrust::Message for self::FooGroup {
            fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
                &<self::super::TestOneof as ::protrust::Message>::descriptor().messages()[0]
            }
        }
        impl self::FooGroup {
            pub const A_FIELD_NUMBER: i32 = 5;
            pub const A_DEFAULT_VALUE: i32 = 0;
            pub fn a(&self) -> i32 {
                self.a.unwrap_or(Self::A_DEFAULT_VALUE)
            }
            pub fn a_option(&self) -> ::std::option::Option<&i32> {
                self.a.as_ref()
            }
            pub fn a_mut(&mut self) -> &mut i32 {
                self.a.get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_a(&self) -> bool {
                self.a.is_some()
            }
            pub fn set_a(&mut self, value: i32) {
                self.a = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_a(&mut self) -> ::std::option::Option<i32> {
                self.a.take()
            }
            pub fn clear_a(&mut self) {
                self.a = ::std::option::Option::None;
            }
            pub const B_FIELD_NUMBER: i32 = 6;
            pub const B_DEFAULT_VALUE: &'static str = "";
            pub fn b(&self) -> &str {
                self.b
                    .as_ref()
                    .map(|v| &**v)
                    .unwrap_or(Self::B_DEFAULT_VALUE)
            }
            pub fn b_option(&self) -> ::std::option::Option<&::std::string::String> {
                self.b.as_ref()
            }
            pub fn b_mut(&mut self) -> &mut ::std::string::String {
                self.b.get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_b(&self) -> bool {
                self.b.is_some()
            }
            pub fn set_b(&mut self, value: ::std::string::String) {
                self.b = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_b(&mut self) -> ::std::option::Option<::std::string::String> {
                self.b.take()
            }
            pub fn clear_b(&mut self) {
                self.b = ::std::option::Option::None;
            }
        }
        pub(in super::super::super) mod foo_group {
            pub(in super::super::super) static A_REFLECTOR:
                ::protrust::reflect::access::VerboseFieldAccessor<self::super::FooGroup, i32> =
                ::protrust::reflect::access::VerboseFieldAccessor {
                    get_option: self::super::FooGroup::a_option,
                    get_mut: self::super::FooGroup::a_mut,
                    set: self::super::FooGroup::set_a,
                    take: self::super::FooGroup::take_a,
                    clear: self::super::FooGroup::clear_a,
                };
            pub(in super::super::super) static B_REFLECTOR:
                ::protrust::reflect::access::VerboseFieldAccessor<
                    self::super::FooGroup,
                    ::std::string::String,
                > = ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::FooGroup::b_option,
                get_mut: self::super::FooGroup::b_mut,
                set: self::super::FooGroup::set_b,
                take: self::super::FooGroup::take_b,
                clear: self::super::FooGroup::clear_b,
            };
        }
        pub(in super::super) static FOO_INT_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestOneof, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestOneof::foo_int,
                get_mut: self::super::TestOneof::foo_int_mut,
                set: self::super::TestOneof::set_foo_int,
                take: self::super::TestOneof::take_foo_int,
                clear: self::super::TestOneof::clear_foo_int,
            };
        pub(in super::super) static FOO_STRING_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestOneof,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestOneof::foo_string,
            get_mut: self::super::TestOneof::foo_string_mut,
            set: self::super::TestOneof::set_foo_string,
            take: self::super::TestOneof::take_foo_string,
            clear: self::super::TestOneof::clear_foo_string,
        };
        pub(in super::super) static FOO_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestOneof,
                self::super::TestAllTypes,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestOneof::foo_message,
            get_mut: self::super::TestOneof::foo_message_mut,
            set: self::super::TestOneof::set_foo_message,
            take: self::super::TestOneof::take_foo_message,
            clear: self::super::TestOneof::clear_foo_message,
        };
        pub(in super::super) static FOOGROUP_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestOneof,
                self::FooGroup,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestOneof::foogroup,
            get_mut: self::super::TestOneof::foogroup_mut,
            set: self::super::TestOneof::set_foogroup,
            take: self::super::TestOneof::take_foogroup,
            clear: self::super::TestOneof::clear_foogroup,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestOneofBackwardsCompatible {
        foo_int: ::std::option::Option<i32>,
        foo_string: ::std::option::Option<::std::string::String>,
        foo_message: ::std::option::Option<::std::boxed::Box<self::TestAllTypes>>,
        foogroup: ::std::option::Option<
            ::std::boxed::Box<self::test_oneof_backwards_compatible::FooGroup>,
        >,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestOneofBackwardsCompatible {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.set_foo_int(input.read_int32()?),
                    18 => self.set_foo_string(input.read_string()?),
                    26 => input.read_message(self.foo_message_mut())?,
                    35 => input.read_group(self.foogroup_mut())?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(foo_int) = self.foo_int_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*foo_int);
            }
            if let ::std::option::Option::Some(foo_string) = self.foo_string_option() {
                size += 1;
                size += ::protrust::io::sizes::string(foo_string);
            }
            if let ::std::option::Option::Some(foo_message) = self.foo_message() {
                size += 1;
                size += ::protrust::io::sizes::message(foo_message);
            }
            if let ::std::option::Option::Some(foogroup) = self.foogroup() {
                size += 1;
                size += ::protrust::io::sizes::group(foogroup);
                size += 1;
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(foo_int) = self.foo_int_option() {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(*foo_int)?;
            }
            if let ::std::option::Option::Some(foo_string) = self.foo_string_option() {
                output.write_raw_tag_bytes(&[18])?;
                output.write_string(foo_string)?;
            }
            if let ::std::option::Option::Some(foo_message) = self.foo_message() {
                output.write_raw_tag_bytes(&[26])?;
                output.write_message(foo_message)?;
            }
            if let ::std::option::Option::Some(foogroup) = self.foogroup() {
                output.write_raw_tag_bytes(&[35])?;
                output.write_group(foogroup)?;
                output.write_raw_tag_bytes(&[36])?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(foo_message) = self.foo_message() {
                if !::protrust::CodedMessage::is_initialized(foo_message) {
                    return false;
                }
            }
            if let ::std::option::Option::Some(foogroup) = self.foogroup() {
                if !::protrust::CodedMessage::is_initialized(foogroup) {
                    return false;
                }
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestOneofBackwardsCompatible {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(foo_int) = other.foo_int_option() {
                self.set_foo_int(*foo_int);
            }
            if let ::std::option::Option::Some(foo_string) = other.foo_string_option() {
                self.set_foo_string(::std::clone::Clone::clone(foo_string));
            }
            if let ::std::option::Option::Some(foo_message) = &other.foo_message() {
                ::protrust::LiteMessage::merge(self.foo_message_mut(), foo_message);
            }
            if let ::std::option::Option::Some(foogroup) = &other.foogroup() {
                ::protrust::LiteMessage::merge(self.foogroup_mut(), foogroup);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestOneofBackwardsCompatible {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[44]
        }
    }
    impl self::TestOneofBackwardsCompatible {
        pub const FOO_INT_FIELD_NUMBER: i32 = 1;
        pub const FOO_INT_DEFAULT_VALUE: i32 = 0;
        pub fn foo_int(&self) -> i32 {
            self.foo_int.unwrap_or(Self::FOO_INT_DEFAULT_VALUE)
        }
        pub fn foo_int_option(&self) -> ::std::option::Option<&i32> {
            self.foo_int.as_ref()
        }
        pub fn foo_int_mut(&mut self) -> &mut i32 {
            self.foo_int
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_foo_int(&self) -> bool {
            self.foo_int.is_some()
        }
        pub fn set_foo_int(&mut self, value: i32) {
            self.foo_int = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_foo_int(&mut self) -> ::std::option::Option<i32> {
            self.foo_int.take()
        }
        pub fn clear_foo_int(&mut self) {
            self.foo_int = ::std::option::Option::None;
        }
        pub const FOO_STRING_FIELD_NUMBER: i32 = 2;
        pub const FOO_STRING_DEFAULT_VALUE: &'static str = "";
        pub fn foo_string(&self) -> &str {
            self.foo_string
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::FOO_STRING_DEFAULT_VALUE)
        }
        pub fn foo_string_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.foo_string.as_ref()
        }
        pub fn foo_string_mut(&mut self) -> &mut ::std::string::String {
            self.foo_string
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_foo_string(&self) -> bool {
            self.foo_string.is_some()
        }
        pub fn set_foo_string(&mut self, value: ::std::string::String) {
            self.foo_string = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_foo_string(&mut self) -> ::std::option::Option<::std::string::String> {
            self.foo_string.take()
        }
        pub fn clear_foo_string(&mut self) {
            self.foo_string = ::std::option::Option::None;
        }
        pub const FOO_MESSAGE_FIELD_NUMBER: i32 = 3;
        pub fn foo_message(&self) -> ::std::option::Option<&self::TestAllTypes> {
            self.foo_message.as_ref().map(|v| &**v)
        }
        pub fn foo_message_mut(&mut self) -> &mut self::TestAllTypes {
            self.foo_message
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_foo_message(&self) -> bool {
            self.foo_message.is_some()
        }
        pub fn set_foo_message(&mut self, value: self::TestAllTypes) {
            self.foo_message = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_foo_message(&mut self) -> ::std::option::Option<self::TestAllTypes> {
            self.foo_message.take().map(|v| *v)
        }
        pub fn clear_foo_message(&mut self) {
            self.foo_message = ::std::option::Option::None;
        }
        pub const FOOGROUP_FIELD_NUMBER: i32 = 4;
        pub fn foogroup(
            &self,
        ) -> ::std::option::Option<&self::test_oneof_backwards_compatible::FooGroup> {
            self.foogroup.as_ref().map(|v| &**v)
        }
        pub fn foogroup_mut(&mut self) -> &mut self::test_oneof_backwards_compatible::FooGroup {
            self.foogroup
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_foogroup(&self) -> bool {
            self.foogroup.is_some()
        }
        pub fn set_foogroup(&mut self, value: self::test_oneof_backwards_compatible::FooGroup) {
            self.foogroup = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_foogroup(
            &mut self,
        ) -> ::std::option::Option<self::test_oneof_backwards_compatible::FooGroup> {
            self.foogroup.take().map(|v| *v)
        }
        pub fn clear_foogroup(&mut self) {
            self.foogroup = ::std::option::Option::None;
        }
    }
    pub mod test_oneof_backwards_compatible {
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct FooGroup {
            a: ::std::option::Option<i32>,
            b: ::std::option::Option<::std::string::String>,
            unknown_fields: ::protrust::UnknownFieldSet,
        }
        impl ::protrust::CodedMessage for self::FooGroup {
            fn merge_from(
                &mut self,
                input: &mut ::protrust::io::CodedInput,
            ) -> ::protrust::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        40 | 42 => self.set_a(input.read_int32()?),
                        50 => self.set_b(input.read_string()?),
                        36 => break,
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> i32 {
                let mut size = 0i32;
                if let ::std::option::Option::Some(a) = self.a_option() {
                    size += 1;
                    size += ::protrust::io::sizes::int32(*a);
                }
                if let ::std::option::Option::Some(b) = self.b_option() {
                    size += 1;
                    size += ::protrust::io::sizes::string(b);
                }
                size += self.unknown_fields.calculate_size();
                size
            }
            fn write_to(
                &self,
                output: &mut ::protrust::io::CodedOutput,
            ) -> ::protrust::io::OutputResult {
                if let ::std::option::Option::Some(a) = self.a_option() {
                    output.write_raw_tag_bytes(&[40])?;
                    output.write_int32(*a)?;
                }
                if let ::std::option::Option::Some(b) = self.b_option() {
                    output.write_raw_tag_bytes(&[50])?;
                    output.write_string(b)?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                true
            }
        }
        impl ::protrust::LiteMessage for self::FooGroup {
            fn merge(&mut self, other: &Self) {
                if let ::std::option::Option::Some(a) = other.a_option() {
                    self.set_a(*a);
                }
                if let ::std::option::Option::Some(b) = other.b_option() {
                    self.set_b(::std::clone::Clone::clone(b));
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl ::protrust::Message for self::FooGroup {
            fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
                &<self::super::TestOneofBackwardsCompatible as ::protrust::Message>::descriptor()
                    .messages()[0]
            }
        }
        impl self::FooGroup {
            pub const A_FIELD_NUMBER: i32 = 5;
            pub const A_DEFAULT_VALUE: i32 = 0;
            pub fn a(&self) -> i32 {
                self.a.unwrap_or(Self::A_DEFAULT_VALUE)
            }
            pub fn a_option(&self) -> ::std::option::Option<&i32> {
                self.a.as_ref()
            }
            pub fn a_mut(&mut self) -> &mut i32 {
                self.a.get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_a(&self) -> bool {
                self.a.is_some()
            }
            pub fn set_a(&mut self, value: i32) {
                self.a = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_a(&mut self) -> ::std::option::Option<i32> {
                self.a.take()
            }
            pub fn clear_a(&mut self) {
                self.a = ::std::option::Option::None;
            }
            pub const B_FIELD_NUMBER: i32 = 6;
            pub const B_DEFAULT_VALUE: &'static str = "";
            pub fn b(&self) -> &str {
                self.b
                    .as_ref()
                    .map(|v| &**v)
                    .unwrap_or(Self::B_DEFAULT_VALUE)
            }
            pub fn b_option(&self) -> ::std::option::Option<&::std::string::String> {
                self.b.as_ref()
            }
            pub fn b_mut(&mut self) -> &mut ::std::string::String {
                self.b.get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_b(&self) -> bool {
                self.b.is_some()
            }
            pub fn set_b(&mut self, value: ::std::string::String) {
                self.b = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_b(&mut self) -> ::std::option::Option<::std::string::String> {
                self.b.take()
            }
            pub fn clear_b(&mut self) {
                self.b = ::std::option::Option::None;
            }
        }
        pub(in super::super::super) mod foo_group {
            pub(in super::super::super) static A_REFLECTOR:
                ::protrust::reflect::access::VerboseFieldAccessor<self::super::FooGroup, i32> =
                ::protrust::reflect::access::VerboseFieldAccessor {
                    get_option: self::super::FooGroup::a_option,
                    get_mut: self::super::FooGroup::a_mut,
                    set: self::super::FooGroup::set_a,
                    take: self::super::FooGroup::take_a,
                    clear: self::super::FooGroup::clear_a,
                };
            pub(in super::super::super) static B_REFLECTOR:
                ::protrust::reflect::access::VerboseFieldAccessor<
                    self::super::FooGroup,
                    ::std::string::String,
                > = ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::FooGroup::b_option,
                get_mut: self::super::FooGroup::b_mut,
                set: self::super::FooGroup::set_b,
                take: self::super::FooGroup::take_b,
                clear: self::super::FooGroup::clear_b,
            };
        }
        pub(in super::super) static FOO_INT_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestOneofBackwardsCompatible,
                i32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestOneofBackwardsCompatible::foo_int_option,
            get_mut: self::super::TestOneofBackwardsCompatible::foo_int_mut,
            set: self::super::TestOneofBackwardsCompatible::set_foo_int,
            take: self::super::TestOneofBackwardsCompatible::take_foo_int,
            clear: self::super::TestOneofBackwardsCompatible::clear_foo_int,
        };
        pub(in super::super) static FOO_STRING_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestOneofBackwardsCompatible,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestOneofBackwardsCompatible::foo_string_option,
            get_mut: self::super::TestOneofBackwardsCompatible::foo_string_mut,
            set: self::super::TestOneofBackwardsCompatible::set_foo_string,
            take: self::super::TestOneofBackwardsCompatible::take_foo_string,
            clear: self::super::TestOneofBackwardsCompatible::clear_foo_string,
        };
        pub(in super::super) static FOO_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestOneofBackwardsCompatible,
                self::super::TestAllTypes,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestOneofBackwardsCompatible::foo_message,
            get_mut: self::super::TestOneofBackwardsCompatible::foo_message_mut,
            set: self::super::TestOneofBackwardsCompatible::set_foo_message,
            take: self::super::TestOneofBackwardsCompatible::take_foo_message,
            clear: self::super::TestOneofBackwardsCompatible::clear_foo_message,
        };
        pub(in super::super) static FOOGROUP_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestOneofBackwardsCompatible,
                self::FooGroup,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestOneofBackwardsCompatible::foogroup,
            get_mut: self::super::TestOneofBackwardsCompatible::foogroup_mut,
            set: self::super::TestOneofBackwardsCompatible::set_foogroup,
            take: self::super::TestOneofBackwardsCompatible::take_foogroup,
            clear: self::super::TestOneofBackwardsCompatible::clear_foogroup,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestOneof2 {
        baz_int: ::std::option::Option<i32>,
        baz_string: ::std::option::Option<::std::string::String>,
        foo: self::test_oneof2::Foo,
        bar: self::test_oneof2::Bar,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestOneof2 {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.set_foo_int(input.read_int32()?),
                    18 => self.set_foo_string(input.read_string()?),
                    26 => self.set_foo_cord(input.read_string()?),
                    34 => self.set_foo_string_piece(input.read_string()?),
                    42 => self.set_foo_bytes(input.read_bytes()?),
                    48 | 50 => self.set_foo_enum(input.read_enum_value()?),
                    58 => input.read_message(self.foo_message_mut())?,
                    67 => input.read_group(self.foogroup_mut())?,
                    90 => input.read_message(self.foo_lazy_message_mut())?,
                    96 | 98 => self.set_bar_int(input.read_int32()?),
                    106 => self.set_bar_string(input.read_string()?),
                    114 => self.set_bar_cord(input.read_string()?),
                    122 => self.set_bar_string_piece(input.read_string()?),
                    130 => self.set_bar_bytes(input.read_bytes()?),
                    136 | 138 => self.set_bar_enum(input.read_enum_value()?),
                    144 | 146 => self.set_baz_int(input.read_int32()?),
                    154 => self.set_baz_string(input.read_string()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(foo_int) = self.foo_int() {
                size += 1;
                size += ::protrust::io::sizes::int32(*foo_int);
            }
            if let ::std::option::Option::Some(foo_string) = self.foo_string() {
                size += 1;
                size += ::protrust::io::sizes::string(foo_string);
            }
            if let ::std::option::Option::Some(foo_cord) = self.foo_cord() {
                size += 1;
                size += ::protrust::io::sizes::string(foo_cord);
            }
            if let ::std::option::Option::Some(foo_string_piece) = self.foo_string_piece() {
                size += 1;
                size += ::protrust::io::sizes::string(foo_string_piece);
            }
            if let ::std::option::Option::Some(foo_bytes) = self.foo_bytes() {
                size += 1;
                size += ::protrust::io::sizes::bytes(foo_bytes);
            }
            if let ::std::option::Option::Some(foo_enum) = self.foo_enum() {
                size += 1;
                size += ::protrust::io::sizes::enum_value(*foo_enum);
            }
            if let ::std::option::Option::Some(foo_message) = self.foo_message() {
                size += 1;
                size += ::protrust::io::sizes::message(foo_message);
            }
            if let ::std::option::Option::Some(foogroup) = self.foogroup() {
                size += 1;
                size += ::protrust::io::sizes::group(foogroup);
                size += 1;
            }
            if let ::std::option::Option::Some(foo_lazy_message) = self.foo_lazy_message() {
                size += 1;
                size += ::protrust::io::sizes::message(foo_lazy_message);
            }
            if let ::std::option::Option::Some(bar_int) = self.bar_int() {
                size += 1;
                size += ::protrust::io::sizes::int32(*bar_int);
            }
            if let ::std::option::Option::Some(bar_string) = self.bar_string() {
                size += 1;
                size += ::protrust::io::sizes::string(bar_string);
            }
            if let ::std::option::Option::Some(bar_cord) = self.bar_cord() {
                size += 1;
                size += ::protrust::io::sizes::string(bar_cord);
            }
            if let ::std::option::Option::Some(bar_string_piece) = self.bar_string_piece() {
                size += 1;
                size += ::protrust::io::sizes::string(bar_string_piece);
            }
            if let ::std::option::Option::Some(bar_bytes) = self.bar_bytes() {
                size += 2;
                size += ::protrust::io::sizes::bytes(bar_bytes);
            }
            if let ::std::option::Option::Some(bar_enum) = self.bar_enum() {
                size += 2;
                size += ::protrust::io::sizes::enum_value(*bar_enum);
            }
            if let ::std::option::Option::Some(baz_int) = self.baz_int_option() {
                size += 2;
                size += ::protrust::io::sizes::int32(*baz_int);
            }
            if let ::std::option::Option::Some(baz_string) = self.baz_string_option() {
                size += 2;
                size += ::protrust::io::sizes::string(baz_string);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(foo_int) = self.foo_int() {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(*foo_int)?;
            }
            if let ::std::option::Option::Some(foo_string) = self.foo_string() {
                output.write_raw_tag_bytes(&[18])?;
                output.write_string(foo_string)?;
            }
            if let ::std::option::Option::Some(foo_cord) = self.foo_cord() {
                output.write_raw_tag_bytes(&[26])?;
                output.write_string(foo_cord)?;
            }
            if let ::std::option::Option::Some(foo_string_piece) = self.foo_string_piece() {
                output.write_raw_tag_bytes(&[34])?;
                output.write_string(foo_string_piece)?;
            }
            if let ::std::option::Option::Some(foo_bytes) = self.foo_bytes() {
                output.write_raw_tag_bytes(&[42])?;
                output.write_bytes(foo_bytes)?;
            }
            if let ::std::option::Option::Some(foo_enum) = self.foo_enum() {
                output.write_raw_tag_bytes(&[48])?;
                output.write_enum_value(*foo_enum)?;
            }
            if let ::std::option::Option::Some(foo_message) = self.foo_message() {
                output.write_raw_tag_bytes(&[58])?;
                output.write_message(foo_message)?;
            }
            if let ::std::option::Option::Some(foogroup) = self.foogroup() {
                output.write_raw_tag_bytes(&[67])?;
                output.write_group(foogroup)?;
                output.write_raw_tag_bytes(&[68])?;
            }
            if let ::std::option::Option::Some(foo_lazy_message) = self.foo_lazy_message() {
                output.write_raw_tag_bytes(&[90])?;
                output.write_message(foo_lazy_message)?;
            }
            if let ::std::option::Option::Some(bar_int) = self.bar_int() {
                output.write_raw_tag_bytes(&[96])?;
                output.write_int32(*bar_int)?;
            }
            if let ::std::option::Option::Some(bar_string) = self.bar_string() {
                output.write_raw_tag_bytes(&[106])?;
                output.write_string(bar_string)?;
            }
            if let ::std::option::Option::Some(bar_cord) = self.bar_cord() {
                output.write_raw_tag_bytes(&[114])?;
                output.write_string(bar_cord)?;
            }
            if let ::std::option::Option::Some(bar_string_piece) = self.bar_string_piece() {
                output.write_raw_tag_bytes(&[122])?;
                output.write_string(bar_string_piece)?;
            }
            if let ::std::option::Option::Some(bar_bytes) = self.bar_bytes() {
                output.write_raw_tag_bytes(&[130, 1])?;
                output.write_bytes(bar_bytes)?;
            }
            if let ::std::option::Option::Some(bar_enum) = self.bar_enum() {
                output.write_raw_tag_bytes(&[136, 1])?;
                output.write_enum_value(*bar_enum)?;
            }
            if let ::std::option::Option::Some(baz_int) = self.baz_int_option() {
                output.write_raw_tag_bytes(&[144, 1])?;
                output.write_int32(*baz_int)?;
            }
            if let ::std::option::Option::Some(baz_string) = self.baz_string_option() {
                output.write_raw_tag_bytes(&[154, 1])?;
                output.write_string(baz_string)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(foo_message) = self.foo_message() {
                if !::protrust::CodedMessage::is_initialized(foo_message) {
                    return false;
                }
            }
            if let ::std::option::Option::Some(foogroup) = self.foogroup() {
                if !::protrust::CodedMessage::is_initialized(foogroup) {
                    return false;
                }
            }
            if let ::std::option::Option::Some(foo_lazy_message) = self.foo_lazy_message() {
                if !::protrust::CodedMessage::is_initialized(foo_lazy_message) {
                    return false;
                }
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestOneof2 {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(foo_int) = other.foo_int() {
                self.set_foo_int(*foo_int);
            }
            if let ::std::option::Option::Some(foo_string) = other.foo_string() {
                self.set_foo_string(::std::clone::Clone::clone(foo_string));
            }
            if let ::std::option::Option::Some(foo_cord) = other.foo_cord() {
                self.set_foo_cord(::std::clone::Clone::clone(foo_cord));
            }
            if let ::std::option::Option::Some(foo_string_piece) = other.foo_string_piece() {
                self.set_foo_string_piece(::std::clone::Clone::clone(foo_string_piece));
            }
            if let ::std::option::Option::Some(foo_bytes) = other.foo_bytes() {
                self.set_foo_bytes(::std::clone::Clone::clone(foo_bytes));
            }
            if let ::std::option::Option::Some(foo_enum) = other.foo_enum() {
                self.set_foo_enum(*foo_enum);
            }
            if let ::std::option::Option::Some(foo_message) = &other.foo_message() {
                ::protrust::LiteMessage::merge(self.foo_message_mut(), foo_message);
            }
            if let ::std::option::Option::Some(foogroup) = &other.foogroup() {
                ::protrust::LiteMessage::merge(self.foogroup_mut(), foogroup);
            }
            if let ::std::option::Option::Some(foo_lazy_message) = &other.foo_lazy_message() {
                ::protrust::LiteMessage::merge(self.foo_lazy_message_mut(), foo_lazy_message);
            }
            if let ::std::option::Option::Some(bar_int) = other.bar_int() {
                self.set_bar_int(*bar_int);
            }
            if let ::std::option::Option::Some(bar_string) = other.bar_string() {
                self.set_bar_string(::std::clone::Clone::clone(bar_string));
            }
            if let ::std::option::Option::Some(bar_cord) = other.bar_cord() {
                self.set_bar_cord(::std::clone::Clone::clone(bar_cord));
            }
            if let ::std::option::Option::Some(bar_string_piece) = other.bar_string_piece() {
                self.set_bar_string_piece(::std::clone::Clone::clone(bar_string_piece));
            }
            if let ::std::option::Option::Some(bar_bytes) = other.bar_bytes() {
                self.set_bar_bytes(::std::clone::Clone::clone(bar_bytes));
            }
            if let ::std::option::Option::Some(bar_enum) = other.bar_enum() {
                self.set_bar_enum(*bar_enum);
            }
            if let ::std::option::Option::Some(baz_int) = other.baz_int_option() {
                self.set_baz_int(*baz_int);
            }
            if let ::std::option::Option::Some(baz_string) = other.baz_string_option() {
                self.set_baz_string(::std::clone::Clone::clone(baz_string));
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestOneof2 {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[45]
        }
    }
    impl self::TestOneof2 {
        pub const FOO_INT_FIELD_NUMBER: i32 = 1;
        pub const FOO_INT_DEFAULT_VALUE: i32 = 0;
        pub fn foo_int(&self) -> ::std::option::Option<&i32> {
            match &self.foo {
                self::test_oneof2::Foo::FooInt(foo) => ::std::option::Option::Some(foo),
                _ => ::std::option::Option::None,
            }
        }
        pub fn foo_int_mut(&mut self) -> &mut i32 {
            match self.foo {
                self::test_oneof2::Foo::FooInt(_) => (),
                _ => self.foo = self::test_oneof2::Foo::FooInt(::std::default::Default::default()),
            }
            match self.foo {
                self::test_oneof2::Foo::FooInt(ref mut foo) => foo,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_foo_int(&self) -> bool {
            match self.foo {
                self::test_oneof2::Foo::FooInt(_) => true,
                _ => false,
            }
        }
        pub fn set_foo_int(&mut self, value: i32) {
            self.foo = self::test_oneof2::Foo::FooInt(::std::convert::From::from(value))
        }
        pub fn take_foo_int(&mut self) -> ::std::option::Option<i32> {
            let foo = ::std::mem::replace(&mut self.foo, self::test_oneof2::Foo::None);
            match foo {
                self::test_oneof2::Foo::FooInt(foo) => ::std::option::Option::Some(foo),
                mut foo => {
                    ::std::mem::swap(&mut self.foo, &mut foo);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_foo_int(&mut self) {
            let foo = ::std::mem::replace(&mut self.foo, self::test_oneof2::Foo::None);
            match foo {
                self::test_oneof2::Foo::FooInt(_) => {}
                mut foo => ::std::mem::swap(&mut self.foo, &mut foo),
            }
        }
        pub const FOO_STRING_FIELD_NUMBER: i32 = 2;
        pub const FOO_STRING_DEFAULT_VALUE: &'static str = "";
        pub fn foo_string(&self) -> ::std::option::Option<&::std::string::String> {
            match &self.foo {
                self::test_oneof2::Foo::FooString(foo) => ::std::option::Option::Some(foo),
                _ => ::std::option::Option::None,
            }
        }
        pub fn foo_string_mut(&mut self) -> &mut ::std::string::String {
            match self.foo {
                self::test_oneof2::Foo::FooString(_) => (),
                _ => {
                    self.foo = self::test_oneof2::Foo::FooString(::std::default::Default::default())
                }
            }
            match self.foo {
                self::test_oneof2::Foo::FooString(ref mut foo) => foo,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_foo_string(&self) -> bool {
            match self.foo {
                self::test_oneof2::Foo::FooString(_) => true,
                _ => false,
            }
        }
        pub fn set_foo_string(&mut self, value: ::std::string::String) {
            self.foo = self::test_oneof2::Foo::FooString(::std::convert::From::from(value))
        }
        pub fn take_foo_string(&mut self) -> ::std::option::Option<::std::string::String> {
            let foo = ::std::mem::replace(&mut self.foo, self::test_oneof2::Foo::None);
            match foo {
                self::test_oneof2::Foo::FooString(foo) => ::std::option::Option::Some(foo),
                mut foo => {
                    ::std::mem::swap(&mut self.foo, &mut foo);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_foo_string(&mut self) {
            let foo = ::std::mem::replace(&mut self.foo, self::test_oneof2::Foo::None);
            match foo {
                self::test_oneof2::Foo::FooString(_) => {}
                mut foo => ::std::mem::swap(&mut self.foo, &mut foo),
            }
        }
        pub const FOO_CORD_FIELD_NUMBER: i32 = 3;
        pub const FOO_CORD_DEFAULT_VALUE: &'static str = "";
        pub fn foo_cord(&self) -> ::std::option::Option<&::std::string::String> {
            match &self.foo {
                self::test_oneof2::Foo::FooCord(foo) => ::std::option::Option::Some(foo),
                _ => ::std::option::Option::None,
            }
        }
        pub fn foo_cord_mut(&mut self) -> &mut ::std::string::String {
            match self.foo {
                self::test_oneof2::Foo::FooCord(_) => (),
                _ => self.foo = self::test_oneof2::Foo::FooCord(::std::default::Default::default()),
            }
            match self.foo {
                self::test_oneof2::Foo::FooCord(ref mut foo) => foo,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_foo_cord(&self) -> bool {
            match self.foo {
                self::test_oneof2::Foo::FooCord(_) => true,
                _ => false,
            }
        }
        pub fn set_foo_cord(&mut self, value: ::std::string::String) {
            self.foo = self::test_oneof2::Foo::FooCord(::std::convert::From::from(value))
        }
        pub fn take_foo_cord(&mut self) -> ::std::option::Option<::std::string::String> {
            let foo = ::std::mem::replace(&mut self.foo, self::test_oneof2::Foo::None);
            match foo {
                self::test_oneof2::Foo::FooCord(foo) => ::std::option::Option::Some(foo),
                mut foo => {
                    ::std::mem::swap(&mut self.foo, &mut foo);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_foo_cord(&mut self) {
            let foo = ::std::mem::replace(&mut self.foo, self::test_oneof2::Foo::None);
            match foo {
                self::test_oneof2::Foo::FooCord(_) => {}
                mut foo => ::std::mem::swap(&mut self.foo, &mut foo),
            }
        }
        pub const FOO_STRING_PIECE_FIELD_NUMBER: i32 = 4;
        pub const FOO_STRING_PIECE_DEFAULT_VALUE: &'static str = "";
        pub fn foo_string_piece(&self) -> ::std::option::Option<&::std::string::String> {
            match &self.foo {
                self::test_oneof2::Foo::FooStringPiece(foo) => ::std::option::Option::Some(foo),
                _ => ::std::option::Option::None,
            }
        }
        pub fn foo_string_piece_mut(&mut self) -> &mut ::std::string::String {
            match self.foo {
                self::test_oneof2::Foo::FooStringPiece(_) => (),
                _ => {
                    self.foo =
                        self::test_oneof2::Foo::FooStringPiece(::std::default::Default::default())
                }
            }
            match self.foo {
                self::test_oneof2::Foo::FooStringPiece(ref mut foo) => foo,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_foo_string_piece(&self) -> bool {
            match self.foo {
                self::test_oneof2::Foo::FooStringPiece(_) => true,
                _ => false,
            }
        }
        pub fn set_foo_string_piece(&mut self, value: ::std::string::String) {
            self.foo = self::test_oneof2::Foo::FooStringPiece(::std::convert::From::from(value))
        }
        pub fn take_foo_string_piece(&mut self) -> ::std::option::Option<::std::string::String> {
            let foo = ::std::mem::replace(&mut self.foo, self::test_oneof2::Foo::None);
            match foo {
                self::test_oneof2::Foo::FooStringPiece(foo) => ::std::option::Option::Some(foo),
                mut foo => {
                    ::std::mem::swap(&mut self.foo, &mut foo);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_foo_string_piece(&mut self) {
            let foo = ::std::mem::replace(&mut self.foo, self::test_oneof2::Foo::None);
            match foo {
                self::test_oneof2::Foo::FooStringPiece(_) => {}
                mut foo => ::std::mem::swap(&mut self.foo, &mut foo),
            }
        }
        pub const FOO_BYTES_FIELD_NUMBER: i32 = 5;
        pub const FOO_BYTES_DEFAULT_VALUE: &'static [u8] = &[];
        pub fn foo_bytes(&self) -> ::std::option::Option<&::std::vec::Vec<u8>> {
            match &self.foo {
                self::test_oneof2::Foo::FooBytes(foo) => ::std::option::Option::Some(foo),
                _ => ::std::option::Option::None,
            }
        }
        pub fn foo_bytes_mut(&mut self) -> &mut ::std::vec::Vec<u8> {
            match self.foo {
                self::test_oneof2::Foo::FooBytes(_) => (),
                _ => {
                    self.foo = self::test_oneof2::Foo::FooBytes(::std::default::Default::default())
                }
            }
            match self.foo {
                self::test_oneof2::Foo::FooBytes(ref mut foo) => foo,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_foo_bytes(&self) -> bool {
            match self.foo {
                self::test_oneof2::Foo::FooBytes(_) => true,
                _ => false,
            }
        }
        pub fn set_foo_bytes(&mut self, value: ::std::vec::Vec<u8>) {
            self.foo = self::test_oneof2::Foo::FooBytes(::std::convert::From::from(value))
        }
        pub fn take_foo_bytes(&mut self) -> ::std::option::Option<::std::vec::Vec<u8>> {
            let foo = ::std::mem::replace(&mut self.foo, self::test_oneof2::Foo::None);
            match foo {
                self::test_oneof2::Foo::FooBytes(foo) => ::std::option::Option::Some(foo),
                mut foo => {
                    ::std::mem::swap(&mut self.foo, &mut foo);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_foo_bytes(&mut self) {
            let foo = ::std::mem::replace(&mut self.foo, self::test_oneof2::Foo::None);
            match foo {
                self::test_oneof2::Foo::FooBytes(_) => {}
                mut foo => ::std::mem::swap(&mut self.foo, &mut foo),
            }
        }
        pub const FOO_ENUM_FIELD_NUMBER: i32 = 6;
        pub const FOO_ENUM_DEFAULT_VALUE: ::protrust::EnumValue<self::test_oneof2::NestedEnum> =
            ::protrust::EnumValue::Undefined(0);
        pub fn foo_enum(
            &self,
        ) -> ::std::option::Option<&::protrust::EnumValue<self::test_oneof2::NestedEnum>> {
            match &self.foo {
                self::test_oneof2::Foo::FooEnum(foo) => ::std::option::Option::Some(foo),
                _ => ::std::option::Option::None,
            }
        }
        pub fn foo_enum_mut(
            &mut self,
        ) -> &mut ::protrust::EnumValue<self::test_oneof2::NestedEnum> {
            match self.foo {
                self::test_oneof2::Foo::FooEnum(_) => (),
                _ => self.foo = self::test_oneof2::Foo::FooEnum(::std::default::Default::default()),
            }
            match self.foo {
                self::test_oneof2::Foo::FooEnum(ref mut foo) => foo,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_foo_enum(&self) -> bool {
            match self.foo {
                self::test_oneof2::Foo::FooEnum(_) => true,
                _ => false,
            }
        }
        pub fn set_foo_enum(
            &mut self,
            value: ::protrust::EnumValue<self::test_oneof2::NestedEnum>,
        ) {
            self.foo = self::test_oneof2::Foo::FooEnum(::std::convert::From::from(value))
        }
        pub fn take_foo_enum(
            &mut self,
        ) -> ::std::option::Option<::protrust::EnumValue<self::test_oneof2::NestedEnum>> {
            let foo = ::std::mem::replace(&mut self.foo, self::test_oneof2::Foo::None);
            match foo {
                self::test_oneof2::Foo::FooEnum(foo) => ::std::option::Option::Some(foo),
                mut foo => {
                    ::std::mem::swap(&mut self.foo, &mut foo);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_foo_enum(&mut self) {
            let foo = ::std::mem::replace(&mut self.foo, self::test_oneof2::Foo::None);
            match foo {
                self::test_oneof2::Foo::FooEnum(_) => {}
                mut foo => ::std::mem::swap(&mut self.foo, &mut foo),
            }
        }
        pub const FOO_MESSAGE_FIELD_NUMBER: i32 = 7;
        pub fn foo_message(&self) -> ::std::option::Option<&self::test_oneof2::NestedMessage> {
            match &self.foo {
                self::test_oneof2::Foo::FooMessage(foo) => ::std::option::Option::Some(&**foo),
                _ => ::std::option::Option::None,
            }
        }
        pub fn foo_message_mut(&mut self) -> &mut self::test_oneof2::NestedMessage {
            match self.foo {
                self::test_oneof2::Foo::FooMessage(_) => (),
                _ => {
                    self.foo =
                        self::test_oneof2::Foo::FooMessage(::std::default::Default::default())
                }
            }
            match self.foo {
                self::test_oneof2::Foo::FooMessage(ref mut foo) => &mut **foo,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_foo_message(&self) -> bool {
            match self.foo {
                self::test_oneof2::Foo::FooMessage(_) => true,
                _ => false,
            }
        }
        pub fn set_foo_message(&mut self, value: self::test_oneof2::NestedMessage) {
            self.foo = self::test_oneof2::Foo::FooMessage(::std::convert::From::from(value))
        }
        pub fn take_foo_message(
            &mut self,
        ) -> ::std::option::Option<self::test_oneof2::NestedMessage> {
            let foo = ::std::mem::replace(&mut self.foo, self::test_oneof2::Foo::None);
            match foo {
                self::test_oneof2::Foo::FooMessage(foo) => ::std::option::Option::Some(*foo),
                mut foo => {
                    ::std::mem::swap(&mut self.foo, &mut foo);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_foo_message(&mut self) {
            let foo = ::std::mem::replace(&mut self.foo, self::test_oneof2::Foo::None);
            match foo {
                self::test_oneof2::Foo::FooMessage(_) => {}
                mut foo => ::std::mem::swap(&mut self.foo, &mut foo),
            }
        }
        pub const FOOGROUP_FIELD_NUMBER: i32 = 8;
        pub fn foogroup(&self) -> ::std::option::Option<&self::test_oneof2::FooGroup> {
            match &self.foo {
                self::test_oneof2::Foo::Foogroup(foo) => ::std::option::Option::Some(foo),
                _ => ::std::option::Option::None,
            }
        }
        pub fn foogroup_mut(&mut self) -> &mut self::test_oneof2::FooGroup {
            match self.foo {
                self::test_oneof2::Foo::Foogroup(_) => (),
                _ => {
                    self.foo = self::test_oneof2::Foo::Foogroup(::std::default::Default::default())
                }
            }
            match self.foo {
                self::test_oneof2::Foo::Foogroup(ref mut foo) => foo,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_foogroup(&self) -> bool {
            match self.foo {
                self::test_oneof2::Foo::Foogroup(_) => true,
                _ => false,
            }
        }
        pub fn set_foogroup(&mut self, value: self::test_oneof2::FooGroup) {
            self.foo = self::test_oneof2::Foo::Foogroup(::std::convert::From::from(value))
        }
        pub fn take_foogroup(&mut self) -> ::std::option::Option<self::test_oneof2::FooGroup> {
            let foo = ::std::mem::replace(&mut self.foo, self::test_oneof2::Foo::None);
            match foo {
                self::test_oneof2::Foo::Foogroup(foo) => ::std::option::Option::Some(*foo),
                mut foo => {
                    ::std::mem::swap(&mut self.foo, &mut foo);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_foogroup(&mut self) {
            let foo = ::std::mem::replace(&mut self.foo, self::test_oneof2::Foo::None);
            match foo {
                self::test_oneof2::Foo::Foogroup(_) => {}
                mut foo => ::std::mem::swap(&mut self.foo, &mut foo),
            }
        }
        pub const FOO_LAZY_MESSAGE_FIELD_NUMBER: i32 = 11;
        pub fn foo_lazy_message(&self) -> ::std::option::Option<&self::test_oneof2::NestedMessage> {
            match &self.foo {
                self::test_oneof2::Foo::FooLazyMessage(foo) => ::std::option::Option::Some(&**foo),
                _ => ::std::option::Option::None,
            }
        }
        pub fn foo_lazy_message_mut(&mut self) -> &mut self::test_oneof2::NestedMessage {
            match self.foo {
                self::test_oneof2::Foo::FooLazyMessage(_) => (),
                _ => {
                    self.foo =
                        self::test_oneof2::Foo::FooLazyMessage(::std::default::Default::default())
                }
            }
            match self.foo {
                self::test_oneof2::Foo::FooLazyMessage(ref mut foo) => &mut **foo,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_foo_lazy_message(&self) -> bool {
            match self.foo {
                self::test_oneof2::Foo::FooLazyMessage(_) => true,
                _ => false,
            }
        }
        pub fn set_foo_lazy_message(&mut self, value: self::test_oneof2::NestedMessage) {
            self.foo = self::test_oneof2::Foo::FooLazyMessage(::std::convert::From::from(value))
        }
        pub fn take_foo_lazy_message(
            &mut self,
        ) -> ::std::option::Option<self::test_oneof2::NestedMessage> {
            let foo = ::std::mem::replace(&mut self.foo, self::test_oneof2::Foo::None);
            match foo {
                self::test_oneof2::Foo::FooLazyMessage(foo) => ::std::option::Option::Some(*foo),
                mut foo => {
                    ::std::mem::swap(&mut self.foo, &mut foo);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_foo_lazy_message(&mut self) {
            let foo = ::std::mem::replace(&mut self.foo, self::test_oneof2::Foo::None);
            match foo {
                self::test_oneof2::Foo::FooLazyMessage(_) => {}
                mut foo => ::std::mem::swap(&mut self.foo, &mut foo),
            }
        }
        pub const BAR_INT_FIELD_NUMBER: i32 = 12;
        pub const BAR_INT_DEFAULT_VALUE: i32 = 5;
        pub fn bar_int(&self) -> ::std::option::Option<&i32> {
            match &self.bar {
                self::test_oneof2::Bar::BarInt(bar) => ::std::option::Option::Some(bar),
                _ => ::std::option::Option::None,
            }
        }
        pub fn bar_int_mut(&mut self) -> &mut i32 {
            match self.bar {
                self::test_oneof2::Bar::BarInt(_) => (),
                _ => self.bar = self::test_oneof2::Bar::BarInt(::std::default::Default::default()),
            }
            match self.bar {
                self::test_oneof2::Bar::BarInt(ref mut bar) => bar,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_bar_int(&self) -> bool {
            match self.bar {
                self::test_oneof2::Bar::BarInt(_) => true,
                _ => false,
            }
        }
        pub fn set_bar_int(&mut self, value: i32) {
            self.bar = self::test_oneof2::Bar::BarInt(::std::convert::From::from(value))
        }
        pub fn take_bar_int(&mut self) -> ::std::option::Option<i32> {
            let bar = ::std::mem::replace(&mut self.bar, self::test_oneof2::Bar::None);
            match bar {
                self::test_oneof2::Bar::BarInt(bar) => ::std::option::Option::Some(bar),
                mut bar => {
                    ::std::mem::swap(&mut self.bar, &mut bar);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_bar_int(&mut self) {
            let bar = ::std::mem::replace(&mut self.bar, self::test_oneof2::Bar::None);
            match bar {
                self::test_oneof2::Bar::BarInt(_) => {}
                mut bar => ::std::mem::swap(&mut self.bar, &mut bar),
            }
        }
        pub const BAR_STRING_FIELD_NUMBER: i32 = 13;
        pub const BAR_STRING_DEFAULT_VALUE: &'static str = "STRING";
        pub fn bar_string(&self) -> ::std::option::Option<&::std::string::String> {
            match &self.bar {
                self::test_oneof2::Bar::BarString(bar) => ::std::option::Option::Some(bar),
                _ => ::std::option::Option::None,
            }
        }
        pub fn bar_string_mut(&mut self) -> &mut ::std::string::String {
            match self.bar {
                self::test_oneof2::Bar::BarString(_) => (),
                _ => {
                    self.bar = self::test_oneof2::Bar::BarString(::std::default::Default::default())
                }
            }
            match self.bar {
                self::test_oneof2::Bar::BarString(ref mut bar) => bar,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_bar_string(&self) -> bool {
            match self.bar {
                self::test_oneof2::Bar::BarString(_) => true,
                _ => false,
            }
        }
        pub fn set_bar_string(&mut self, value: ::std::string::String) {
            self.bar = self::test_oneof2::Bar::BarString(::std::convert::From::from(value))
        }
        pub fn take_bar_string(&mut self) -> ::std::option::Option<::std::string::String> {
            let bar = ::std::mem::replace(&mut self.bar, self::test_oneof2::Bar::None);
            match bar {
                self::test_oneof2::Bar::BarString(bar) => ::std::option::Option::Some(bar),
                mut bar => {
                    ::std::mem::swap(&mut self.bar, &mut bar);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_bar_string(&mut self) {
            let bar = ::std::mem::replace(&mut self.bar, self::test_oneof2::Bar::None);
            match bar {
                self::test_oneof2::Bar::BarString(_) => {}
                mut bar => ::std::mem::swap(&mut self.bar, &mut bar),
            }
        }
        pub const BAR_CORD_FIELD_NUMBER: i32 = 14;
        pub const BAR_CORD_DEFAULT_VALUE: &'static str = "CORD";
        pub fn bar_cord(&self) -> ::std::option::Option<&::std::string::String> {
            match &self.bar {
                self::test_oneof2::Bar::BarCord(bar) => ::std::option::Option::Some(bar),
                _ => ::std::option::Option::None,
            }
        }
        pub fn bar_cord_mut(&mut self) -> &mut ::std::string::String {
            match self.bar {
                self::test_oneof2::Bar::BarCord(_) => (),
                _ => self.bar = self::test_oneof2::Bar::BarCord(::std::default::Default::default()),
            }
            match self.bar {
                self::test_oneof2::Bar::BarCord(ref mut bar) => bar,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_bar_cord(&self) -> bool {
            match self.bar {
                self::test_oneof2::Bar::BarCord(_) => true,
                _ => false,
            }
        }
        pub fn set_bar_cord(&mut self, value: ::std::string::String) {
            self.bar = self::test_oneof2::Bar::BarCord(::std::convert::From::from(value))
        }
        pub fn take_bar_cord(&mut self) -> ::std::option::Option<::std::string::String> {
            let bar = ::std::mem::replace(&mut self.bar, self::test_oneof2::Bar::None);
            match bar {
                self::test_oneof2::Bar::BarCord(bar) => ::std::option::Option::Some(bar),
                mut bar => {
                    ::std::mem::swap(&mut self.bar, &mut bar);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_bar_cord(&mut self) {
            let bar = ::std::mem::replace(&mut self.bar, self::test_oneof2::Bar::None);
            match bar {
                self::test_oneof2::Bar::BarCord(_) => {}
                mut bar => ::std::mem::swap(&mut self.bar, &mut bar),
            }
        }
        pub const BAR_STRING_PIECE_FIELD_NUMBER: i32 = 15;
        pub const BAR_STRING_PIECE_DEFAULT_VALUE: &'static str = "SPIECE";
        pub fn bar_string_piece(&self) -> ::std::option::Option<&::std::string::String> {
            match &self.bar {
                self::test_oneof2::Bar::BarStringPiece(bar) => ::std::option::Option::Some(bar),
                _ => ::std::option::Option::None,
            }
        }
        pub fn bar_string_piece_mut(&mut self) -> &mut ::std::string::String {
            match self.bar {
                self::test_oneof2::Bar::BarStringPiece(_) => (),
                _ => {
                    self.bar =
                        self::test_oneof2::Bar::BarStringPiece(::std::default::Default::default())
                }
            }
            match self.bar {
                self::test_oneof2::Bar::BarStringPiece(ref mut bar) => bar,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_bar_string_piece(&self) -> bool {
            match self.bar {
                self::test_oneof2::Bar::BarStringPiece(_) => true,
                _ => false,
            }
        }
        pub fn set_bar_string_piece(&mut self, value: ::std::string::String) {
            self.bar = self::test_oneof2::Bar::BarStringPiece(::std::convert::From::from(value))
        }
        pub fn take_bar_string_piece(&mut self) -> ::std::option::Option<::std::string::String> {
            let bar = ::std::mem::replace(&mut self.bar, self::test_oneof2::Bar::None);
            match bar {
                self::test_oneof2::Bar::BarStringPiece(bar) => ::std::option::Option::Some(bar),
                mut bar => {
                    ::std::mem::swap(&mut self.bar, &mut bar);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_bar_string_piece(&mut self) {
            let bar = ::std::mem::replace(&mut self.bar, self::test_oneof2::Bar::None);
            match bar {
                self::test_oneof2::Bar::BarStringPiece(_) => {}
                mut bar => ::std::mem::swap(&mut self.bar, &mut bar),
            }
        }
        pub const BAR_BYTES_FIELD_NUMBER: i32 = 16;
        pub const BAR_BYTES_DEFAULT_VALUE: &'static [u8] = &[66, 89, 84, 69, 83];
        pub fn bar_bytes(&self) -> ::std::option::Option<&::std::vec::Vec<u8>> {
            match &self.bar {
                self::test_oneof2::Bar::BarBytes(bar) => ::std::option::Option::Some(bar),
                _ => ::std::option::Option::None,
            }
        }
        pub fn bar_bytes_mut(&mut self) -> &mut ::std::vec::Vec<u8> {
            match self.bar {
                self::test_oneof2::Bar::BarBytes(_) => (),
                _ => {
                    self.bar = self::test_oneof2::Bar::BarBytes(::std::default::Default::default())
                }
            }
            match self.bar {
                self::test_oneof2::Bar::BarBytes(ref mut bar) => bar,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_bar_bytes(&self) -> bool {
            match self.bar {
                self::test_oneof2::Bar::BarBytes(_) => true,
                _ => false,
            }
        }
        pub fn set_bar_bytes(&mut self, value: ::std::vec::Vec<u8>) {
            self.bar = self::test_oneof2::Bar::BarBytes(::std::convert::From::from(value))
        }
        pub fn take_bar_bytes(&mut self) -> ::std::option::Option<::std::vec::Vec<u8>> {
            let bar = ::std::mem::replace(&mut self.bar, self::test_oneof2::Bar::None);
            match bar {
                self::test_oneof2::Bar::BarBytes(bar) => ::std::option::Option::Some(bar),
                mut bar => {
                    ::std::mem::swap(&mut self.bar, &mut bar);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_bar_bytes(&mut self) {
            let bar = ::std::mem::replace(&mut self.bar, self::test_oneof2::Bar::None);
            match bar {
                self::test_oneof2::Bar::BarBytes(_) => {}
                mut bar => ::std::mem::swap(&mut self.bar, &mut bar),
            }
        }
        pub const BAR_ENUM_FIELD_NUMBER: i32 = 17;
        pub const BAR_ENUM_DEFAULT_VALUE: ::protrust::EnumValue<self::test_oneof2::NestedEnum> =
            ::protrust::EnumValue::Defined(self::test_oneof2::NestedEnum::Bar);
        pub fn bar_enum(
            &self,
        ) -> ::std::option::Option<&::protrust::EnumValue<self::test_oneof2::NestedEnum>> {
            match &self.bar {
                self::test_oneof2::Bar::BarEnum(bar) => ::std::option::Option::Some(bar),
                _ => ::std::option::Option::None,
            }
        }
        pub fn bar_enum_mut(
            &mut self,
        ) -> &mut ::protrust::EnumValue<self::test_oneof2::NestedEnum> {
            match self.bar {
                self::test_oneof2::Bar::BarEnum(_) => (),
                _ => self.bar = self::test_oneof2::Bar::BarEnum(::std::default::Default::default()),
            }
            match self.bar {
                self::test_oneof2::Bar::BarEnum(ref mut bar) => bar,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_bar_enum(&self) -> bool {
            match self.bar {
                self::test_oneof2::Bar::BarEnum(_) => true,
                _ => false,
            }
        }
        pub fn set_bar_enum(
            &mut self,
            value: ::protrust::EnumValue<self::test_oneof2::NestedEnum>,
        ) {
            self.bar = self::test_oneof2::Bar::BarEnum(::std::convert::From::from(value))
        }
        pub fn take_bar_enum(
            &mut self,
        ) -> ::std::option::Option<::protrust::EnumValue<self::test_oneof2::NestedEnum>> {
            let bar = ::std::mem::replace(&mut self.bar, self::test_oneof2::Bar::None);
            match bar {
                self::test_oneof2::Bar::BarEnum(bar) => ::std::option::Option::Some(bar),
                mut bar => {
                    ::std::mem::swap(&mut self.bar, &mut bar);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_bar_enum(&mut self) {
            let bar = ::std::mem::replace(&mut self.bar, self::test_oneof2::Bar::None);
            match bar {
                self::test_oneof2::Bar::BarEnum(_) => {}
                mut bar => ::std::mem::swap(&mut self.bar, &mut bar),
            }
        }
        pub const BAZ_INT_FIELD_NUMBER: i32 = 18;
        pub const BAZ_INT_DEFAULT_VALUE: i32 = 0;
        pub fn baz_int(&self) -> i32 {
            self.baz_int.unwrap_or(Self::BAZ_INT_DEFAULT_VALUE)
        }
        pub fn baz_int_option(&self) -> ::std::option::Option<&i32> {
            self.baz_int.as_ref()
        }
        pub fn baz_int_mut(&mut self) -> &mut i32 {
            self.baz_int
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_baz_int(&self) -> bool {
            self.baz_int.is_some()
        }
        pub fn set_baz_int(&mut self, value: i32) {
            self.baz_int = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_baz_int(&mut self) -> ::std::option::Option<i32> {
            self.baz_int.take()
        }
        pub fn clear_baz_int(&mut self) {
            self.baz_int = ::std::option::Option::None;
        }
        pub const BAZ_STRING_FIELD_NUMBER: i32 = 19;
        pub const BAZ_STRING_DEFAULT_VALUE: &'static str = "BAZ";
        pub fn baz_string(&self) -> &str {
            self.baz_string
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::BAZ_STRING_DEFAULT_VALUE)
        }
        pub fn baz_string_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.baz_string.as_ref()
        }
        pub fn baz_string_mut(&mut self) -> &mut ::std::string::String {
            self.baz_string
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_baz_string(&self) -> bool {
            self.baz_string.is_some()
        }
        pub fn set_baz_string(&mut self, value: ::std::string::String) {
            self.baz_string = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_baz_string(&mut self) -> ::std::option::Option<::std::string::String> {
            self.baz_string.take()
        }
        pub fn clear_baz_string(&mut self) {
            self.baz_string = ::std::option::Option::None;
        }
        pub fn foo(&self) -> &self::test_oneof2::Foo {
            &self.foo
        }
        pub fn foo_mut(&mut self) -> &mut self::test_oneof2::Foo {
            &mut self.foo
        }
        pub fn bar(&self) -> &self::test_oneof2::Bar {
            &self.bar
        }
        pub fn bar_mut(&mut self) -> &mut self::test_oneof2::Bar {
            &mut self.bar
        }
    }
    pub mod test_oneof2 {
        #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
        pub enum NestedEnum {
            Foo,
            Bar,
            Baz,
        }
        impl ::protrust::Enum for self::NestedEnum {
            fn descriptor() -> &'static ::protrust::reflect::EnumDescriptor<'static> {
                &<self::super::TestOneof2 as ::protrust::Message>::descriptor().enums()[0]
            }
        }
        impl ::std::convert::TryFrom<i32> for self::NestedEnum {
            type Error = ::protrust::VariantUndefinedError;
            fn try_from(
                value: i32,
            ) -> ::std::result::Result<Self, ::protrust::VariantUndefinedError> {
                #[allow(unreachable_patterns)]
                match value {
                    1 => ::std::result::Result::Ok(self::NestedEnum::Foo),
                    2 => ::std::result::Result::Ok(self::NestedEnum::Bar),
                    3 => ::std::result::Result::Ok(self::NestedEnum::Baz),
                    _ => ::std::result::Result::Err(::protrust::VariantUndefinedError),
                }
            }
        }
        impl ::std::convert::From<self::NestedEnum> for i32 {
            fn from(value: self::NestedEnum) -> i32 {
                match value {
                    self::NestedEnum::Foo => 1,
                    self::NestedEnum::Bar => 2,
                    self::NestedEnum::Baz => 3,
                }
            }
        }
        #[derive(Clone, Debug, PartialEq)]
        pub enum Foo {
            None,
            FooInt(i32),
            FooString(::std::string::String),
            FooCord(::std::string::String),
            FooStringPiece(::std::string::String),
            FooBytes(::std::vec::Vec<u8>),
            FooEnum(::protrust::EnumValue<self::NestedEnum>),
            FooMessage(::std::boxed::Box<self::NestedMessage>),
            Foogroup(::std::boxed::Box<self::FooGroup>),
            FooLazyMessage(::std::boxed::Box<self::NestedMessage>),
        }
        impl ::std::default::Default for self::Foo {
            fn default() -> Self {
                self::Foo::None
            }
        }
        #[derive(Clone, Debug, PartialEq)]
        pub enum Bar {
            None,
            BarInt(i32),
            BarString(::std::string::String),
            BarCord(::std::string::String),
            BarStringPiece(::std::string::String),
            BarBytes(::std::vec::Vec<u8>),
            BarEnum(::protrust::EnumValue<self::NestedEnum>),
        }
        impl ::std::default::Default for self::Bar {
            fn default() -> Self {
                self::Bar::None
            }
        }
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct FooGroup {
            a: ::std::option::Option<i32>,
            b: ::std::option::Option<::std::string::String>,
            unknown_fields: ::protrust::UnknownFieldSet,
        }
        impl ::protrust::CodedMessage for self::FooGroup {
            fn merge_from(
                &mut self,
                input: &mut ::protrust::io::CodedInput,
            ) -> ::protrust::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        72 | 74 => self.set_a(input.read_int32()?),
                        82 => self.set_b(input.read_string()?),
                        68 => break,
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> i32 {
                let mut size = 0i32;
                if let ::std::option::Option::Some(a) = self.a_option() {
                    size += 1;
                    size += ::protrust::io::sizes::int32(*a);
                }
                if let ::std::option::Option::Some(b) = self.b_option() {
                    size += 1;
                    size += ::protrust::io::sizes::string(b);
                }
                size += self.unknown_fields.calculate_size();
                size
            }
            fn write_to(
                &self,
                output: &mut ::protrust::io::CodedOutput,
            ) -> ::protrust::io::OutputResult {
                if let ::std::option::Option::Some(a) = self.a_option() {
                    output.write_raw_tag_bytes(&[72])?;
                    output.write_int32(*a)?;
                }
                if let ::std::option::Option::Some(b) = self.b_option() {
                    output.write_raw_tag_bytes(&[82])?;
                    output.write_string(b)?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                true
            }
        }
        impl ::protrust::LiteMessage for self::FooGroup {
            fn merge(&mut self, other: &Self) {
                if let ::std::option::Option::Some(a) = other.a_option() {
                    self.set_a(*a);
                }
                if let ::std::option::Option::Some(b) = other.b_option() {
                    self.set_b(::std::clone::Clone::clone(b));
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl ::protrust::Message for self::FooGroup {
            fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
                &<self::super::TestOneof2 as ::protrust::Message>::descriptor().messages()[0]
            }
        }
        impl self::FooGroup {
            pub const A_FIELD_NUMBER: i32 = 9;
            pub const A_DEFAULT_VALUE: i32 = 0;
            pub fn a(&self) -> i32 {
                self.a.unwrap_or(Self::A_DEFAULT_VALUE)
            }
            pub fn a_option(&self) -> ::std::option::Option<&i32> {
                self.a.as_ref()
            }
            pub fn a_mut(&mut self) -> &mut i32 {
                self.a.get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_a(&self) -> bool {
                self.a.is_some()
            }
            pub fn set_a(&mut self, value: i32) {
                self.a = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_a(&mut self) -> ::std::option::Option<i32> {
                self.a.take()
            }
            pub fn clear_a(&mut self) {
                self.a = ::std::option::Option::None;
            }
            pub const B_FIELD_NUMBER: i32 = 10;
            pub const B_DEFAULT_VALUE: &'static str = "";
            pub fn b(&self) -> &str {
                self.b
                    .as_ref()
                    .map(|v| &**v)
                    .unwrap_or(Self::B_DEFAULT_VALUE)
            }
            pub fn b_option(&self) -> ::std::option::Option<&::std::string::String> {
                self.b.as_ref()
            }
            pub fn b_mut(&mut self) -> &mut ::std::string::String {
                self.b.get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_b(&self) -> bool {
                self.b.is_some()
            }
            pub fn set_b(&mut self, value: ::std::string::String) {
                self.b = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_b(&mut self) -> ::std::option::Option<::std::string::String> {
                self.b.take()
            }
            pub fn clear_b(&mut self) {
                self.b = ::std::option::Option::None;
            }
        }
        pub(in super::super::super) mod foo_group {
            pub(in super::super::super) static A_REFLECTOR:
                ::protrust::reflect::access::VerboseFieldAccessor<self::super::FooGroup, i32> =
                ::protrust::reflect::access::VerboseFieldAccessor {
                    get_option: self::super::FooGroup::a_option,
                    get_mut: self::super::FooGroup::a_mut,
                    set: self::super::FooGroup::set_a,
                    take: self::super::FooGroup::take_a,
                    clear: self::super::FooGroup::clear_a,
                };
            pub(in super::super::super) static B_REFLECTOR:
                ::protrust::reflect::access::VerboseFieldAccessor<
                    self::super::FooGroup,
                    ::std::string::String,
                > = ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::FooGroup::b_option,
                get_mut: self::super::FooGroup::b_mut,
                set: self::super::FooGroup::set_b,
                take: self::super::FooGroup::take_b,
                clear: self::super::FooGroup::clear_b,
            };
        }
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct NestedMessage {
            qux_int: ::std::option::Option<i64>,
            corge_int: ::protrust::collections::RepeatedField<i32>,
            unknown_fields: ::protrust::UnknownFieldSet,
        }
        impl ::protrust::CodedMessage for self::NestedMessage {
            fn merge_from(
                &mut self,
                input: &mut ::protrust::io::CodedInput,
            ) -> ::protrust::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        8 | 10 => self.set_qux_int(input.read_int64()?),
                        16 | 18 => self
                            .corge_int
                            .add_entries(input, &self::nested_message::CORGE_INT_CODEC)?,
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> i32 {
                let mut size = 0i32;
                if let ::std::option::Option::Some(qux_int) = self.qux_int_option() {
                    size += 1;
                    size += ::protrust::io::sizes::int64(*qux_int);
                }
                size += self
                    .corge_int()
                    .calculate_size(&self::nested_message::CORGE_INT_CODEC);
                size += self.unknown_fields.calculate_size();
                size
            }
            fn write_to(
                &self,
                output: &mut ::protrust::io::CodedOutput,
            ) -> ::protrust::io::OutputResult {
                if let ::std::option::Option::Some(qux_int) = self.qux_int_option() {
                    output.write_raw_tag_bytes(&[8])?;
                    output.write_int64(*qux_int)?;
                }
                self.corge_int()
                    .write_to(output, &self::nested_message::CORGE_INT_CODEC)?;
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                true
            }
        }
        impl ::protrust::LiteMessage for self::NestedMessage {
            fn merge(&mut self, other: &Self) {
                if let ::std::option::Option::Some(qux_int) = other.qux_int_option() {
                    self.set_qux_int(*qux_int);
                }
                self.corge_int.merge(&other.corge_int);
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl ::protrust::Message for self::NestedMessage {
            fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
                &<self::super::TestOneof2 as ::protrust::Message>::descriptor().messages()[1]
            }
        }
        impl self::NestedMessage {
            pub const QUX_INT_FIELD_NUMBER: i32 = 1;
            pub const QUX_INT_DEFAULT_VALUE: i64 = 0;
            pub fn qux_int(&self) -> i64 {
                self.qux_int.unwrap_or(Self::QUX_INT_DEFAULT_VALUE)
            }
            pub fn qux_int_option(&self) -> ::std::option::Option<&i64> {
                self.qux_int.as_ref()
            }
            pub fn qux_int_mut(&mut self) -> &mut i64 {
                self.qux_int
                    .get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_qux_int(&self) -> bool {
                self.qux_int.is_some()
            }
            pub fn set_qux_int(&mut self, value: i64) {
                self.qux_int = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_qux_int(&mut self) -> ::std::option::Option<i64> {
                self.qux_int.take()
            }
            pub fn clear_qux_int(&mut self) {
                self.qux_int = ::std::option::Option::None;
            }
            pub const CORGE_INT_FIELD_NUMBER: i32 = 2;
            pub fn corge_int(&self) -> &::protrust::collections::RepeatedField<i32> {
                &self.corge_int
            }
            pub fn corge_int_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
                &mut self.corge_int
            }
        }
        pub(in super::super::super) mod nested_message {
            pub(super) static CORGE_INT_CODEC: ::protrust::Codec<i32> =
                ::protrust::Codec::int32(16);
            pub(in super::super::super) static QUX_INT_REFLECTOR:
                ::protrust::reflect::access::VerboseFieldAccessor<self::super::NestedMessage, i64> =
                ::protrust::reflect::access::VerboseFieldAccessor {
                    get_option: self::super::NestedMessage::qux_int_option,
                    get_mut: self::super::NestedMessage::qux_int_mut,
                    set: self::super::NestedMessage::set_qux_int,
                    take: self::super::NestedMessage::take_qux_int,
                    clear: self::super::NestedMessage::clear_qux_int,
                };
            pub(in super::super::super) static CORGE_INT_REFLECTOR:
                ::protrust::reflect::access::SimpleFieldAccessor<
                    self::super::NestedMessage,
                    ::protrust::collections::RepeatedField<i32>,
                > = ::protrust::reflect::access::SimpleFieldAccessor {
                get: self::super::NestedMessage::corge_int,
                get_mut: self::super::NestedMessage::corge_int_mut,
            };
        }
        pub(in super::super) static FOO_INT_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestOneof2, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestOneof2::foo_int,
                get_mut: self::super::TestOneof2::foo_int_mut,
                set: self::super::TestOneof2::set_foo_int,
                take: self::super::TestOneof2::take_foo_int,
                clear: self::super::TestOneof2::clear_foo_int,
            };
        pub(in super::super) static FOO_STRING_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestOneof2,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestOneof2::foo_string,
            get_mut: self::super::TestOneof2::foo_string_mut,
            set: self::super::TestOneof2::set_foo_string,
            take: self::super::TestOneof2::take_foo_string,
            clear: self::super::TestOneof2::clear_foo_string,
        };
        pub(in super::super) static FOO_CORD_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestOneof2,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestOneof2::foo_cord,
            get_mut: self::super::TestOneof2::foo_cord_mut,
            set: self::super::TestOneof2::set_foo_cord,
            take: self::super::TestOneof2::take_foo_cord,
            clear: self::super::TestOneof2::clear_foo_cord,
        };
        pub(in super::super) static FOO_STRING_PIECE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestOneof2,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestOneof2::foo_string_piece,
            get_mut: self::super::TestOneof2::foo_string_piece_mut,
            set: self::super::TestOneof2::set_foo_string_piece,
            take: self::super::TestOneof2::take_foo_string_piece,
            clear: self::super::TestOneof2::clear_foo_string_piece,
        };
        pub(in super::super) static FOO_BYTES_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestOneof2,
                ::std::vec::Vec<u8>,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestOneof2::foo_bytes,
            get_mut: self::super::TestOneof2::foo_bytes_mut,
            set: self::super::TestOneof2::set_foo_bytes,
            take: self::super::TestOneof2::take_foo_bytes,
            clear: self::super::TestOneof2::clear_foo_bytes,
        };
        pub(in super::super) static FOO_ENUM_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestOneof2,
                ::protrust::EnumValue<self::NestedEnum>,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestOneof2::foo_enum,
            get_mut: self::super::TestOneof2::foo_enum_mut,
            set: self::super::TestOneof2::set_foo_enum,
            take: self::super::TestOneof2::take_foo_enum,
            clear: self::super::TestOneof2::clear_foo_enum,
        };
        pub(in super::super) static FOO_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestOneof2,
                self::NestedMessage,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestOneof2::foo_message,
            get_mut: self::super::TestOneof2::foo_message_mut,
            set: self::super::TestOneof2::set_foo_message,
            take: self::super::TestOneof2::take_foo_message,
            clear: self::super::TestOneof2::clear_foo_message,
        };
        pub(in super::super) static FOOGROUP_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestOneof2,
                self::FooGroup,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestOneof2::foogroup,
            get_mut: self::super::TestOneof2::foogroup_mut,
            set: self::super::TestOneof2::set_foogroup,
            take: self::super::TestOneof2::take_foogroup,
            clear: self::super::TestOneof2::clear_foogroup,
        };
        pub(in super::super) static FOO_LAZY_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestOneof2,
                self::NestedMessage,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestOneof2::foo_lazy_message,
            get_mut: self::super::TestOneof2::foo_lazy_message_mut,
            set: self::super::TestOneof2::set_foo_lazy_message,
            take: self::super::TestOneof2::take_foo_lazy_message,
            clear: self::super::TestOneof2::clear_foo_lazy_message,
        };
        pub(in super::super) static BAR_INT_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestOneof2, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestOneof2::bar_int,
                get_mut: self::super::TestOneof2::bar_int_mut,
                set: self::super::TestOneof2::set_bar_int,
                take: self::super::TestOneof2::take_bar_int,
                clear: self::super::TestOneof2::clear_bar_int,
            };
        pub(in super::super) static BAR_STRING_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestOneof2,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestOneof2::bar_string,
            get_mut: self::super::TestOneof2::bar_string_mut,
            set: self::super::TestOneof2::set_bar_string,
            take: self::super::TestOneof2::take_bar_string,
            clear: self::super::TestOneof2::clear_bar_string,
        };
        pub(in super::super) static BAR_CORD_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestOneof2,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestOneof2::bar_cord,
            get_mut: self::super::TestOneof2::bar_cord_mut,
            set: self::super::TestOneof2::set_bar_cord,
            take: self::super::TestOneof2::take_bar_cord,
            clear: self::super::TestOneof2::clear_bar_cord,
        };
        pub(in super::super) static BAR_STRING_PIECE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestOneof2,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestOneof2::bar_string_piece,
            get_mut: self::super::TestOneof2::bar_string_piece_mut,
            set: self::super::TestOneof2::set_bar_string_piece,
            take: self::super::TestOneof2::take_bar_string_piece,
            clear: self::super::TestOneof2::clear_bar_string_piece,
        };
        pub(in super::super) static BAR_BYTES_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestOneof2,
                ::std::vec::Vec<u8>,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestOneof2::bar_bytes,
            get_mut: self::super::TestOneof2::bar_bytes_mut,
            set: self::super::TestOneof2::set_bar_bytes,
            take: self::super::TestOneof2::take_bar_bytes,
            clear: self::super::TestOneof2::clear_bar_bytes,
        };
        pub(in super::super) static BAR_ENUM_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestOneof2,
                ::protrust::EnumValue<self::NestedEnum>,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestOneof2::bar_enum,
            get_mut: self::super::TestOneof2::bar_enum_mut,
            set: self::super::TestOneof2::set_bar_enum,
            take: self::super::TestOneof2::take_bar_enum,
            clear: self::super::TestOneof2::clear_bar_enum,
        };
        pub(in super::super) static BAZ_INT_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestOneof2, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestOneof2::baz_int_option,
                get_mut: self::super::TestOneof2::baz_int_mut,
                set: self::super::TestOneof2::set_baz_int,
                take: self::super::TestOneof2::take_baz_int,
                clear: self::super::TestOneof2::clear_baz_int,
            };
        pub(in super::super) static BAZ_STRING_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestOneof2,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestOneof2::baz_string_option,
            get_mut: self::super::TestOneof2::baz_string_mut,
            set: self::super::TestOneof2::set_baz_string,
            take: self::super::TestOneof2::take_baz_string,
            clear: self::super::TestOneof2::clear_baz_string,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestRequiredOneof {
        foo: self::test_required_oneof::Foo,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestRequiredOneof {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.set_foo_int(input.read_int32()?),
                    18 => self.set_foo_string(input.read_string()?),
                    26 => input.read_message(self.foo_message_mut())?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(foo_int) = self.foo_int() {
                size += 1;
                size += ::protrust::io::sizes::int32(*foo_int);
            }
            if let ::std::option::Option::Some(foo_string) = self.foo_string() {
                size += 1;
                size += ::protrust::io::sizes::string(foo_string);
            }
            if let ::std::option::Option::Some(foo_message) = self.foo_message() {
                size += 1;
                size += ::protrust::io::sizes::message(foo_message);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(foo_int) = self.foo_int() {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(*foo_int)?;
            }
            if let ::std::option::Option::Some(foo_string) = self.foo_string() {
                output.write_raw_tag_bytes(&[18])?;
                output.write_string(foo_string)?;
            }
            if let ::std::option::Option::Some(foo_message) = self.foo_message() {
                output.write_raw_tag_bytes(&[26])?;
                output.write_message(foo_message)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(foo_message) = self.foo_message() {
                if !::protrust::CodedMessage::is_initialized(foo_message) {
                    return false;
                }
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestRequiredOneof {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(foo_int) = other.foo_int() {
                self.set_foo_int(*foo_int);
            }
            if let ::std::option::Option::Some(foo_string) = other.foo_string() {
                self.set_foo_string(::std::clone::Clone::clone(foo_string));
            }
            if let ::std::option::Option::Some(foo_message) = &other.foo_message() {
                ::protrust::LiteMessage::merge(self.foo_message_mut(), foo_message);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestRequiredOneof {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[46]
        }
    }
    impl self::TestRequiredOneof {
        pub const FOO_INT_FIELD_NUMBER: i32 = 1;
        pub const FOO_INT_DEFAULT_VALUE: i32 = 0;
        pub fn foo_int(&self) -> ::std::option::Option<&i32> {
            match &self.foo {
                self::test_required_oneof::Foo::FooInt(foo) => ::std::option::Option::Some(foo),
                _ => ::std::option::Option::None,
            }
        }
        pub fn foo_int_mut(&mut self) -> &mut i32 {
            match self.foo {
                self::test_required_oneof::Foo::FooInt(_) => (),
                _ => {
                    self.foo =
                        self::test_required_oneof::Foo::FooInt(::std::default::Default::default())
                }
            }
            match self.foo {
                self::test_required_oneof::Foo::FooInt(ref mut foo) => foo,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_foo_int(&self) -> bool {
            match self.foo {
                self::test_required_oneof::Foo::FooInt(_) => true,
                _ => false,
            }
        }
        pub fn set_foo_int(&mut self, value: i32) {
            self.foo = self::test_required_oneof::Foo::FooInt(::std::convert::From::from(value))
        }
        pub fn take_foo_int(&mut self) -> ::std::option::Option<i32> {
            let foo = ::std::mem::replace(&mut self.foo, self::test_required_oneof::Foo::None);
            match foo {
                self::test_required_oneof::Foo::FooInt(foo) => ::std::option::Option::Some(foo),
                mut foo => {
                    ::std::mem::swap(&mut self.foo, &mut foo);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_foo_int(&mut self) {
            let foo = ::std::mem::replace(&mut self.foo, self::test_required_oneof::Foo::None);
            match foo {
                self::test_required_oneof::Foo::FooInt(_) => {}
                mut foo => ::std::mem::swap(&mut self.foo, &mut foo),
            }
        }
        pub const FOO_STRING_FIELD_NUMBER: i32 = 2;
        pub const FOO_STRING_DEFAULT_VALUE: &'static str = "";
        pub fn foo_string(&self) -> ::std::option::Option<&::std::string::String> {
            match &self.foo {
                self::test_required_oneof::Foo::FooString(foo) => ::std::option::Option::Some(foo),
                _ => ::std::option::Option::None,
            }
        }
        pub fn foo_string_mut(&mut self) -> &mut ::std::string::String {
            match self.foo {
                self::test_required_oneof::Foo::FooString(_) => (),
                _ => {
                    self.foo = self::test_required_oneof::Foo::FooString(
                        ::std::default::Default::default(),
                    )
                }
            }
            match self.foo {
                self::test_required_oneof::Foo::FooString(ref mut foo) => foo,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_foo_string(&self) -> bool {
            match self.foo {
                self::test_required_oneof::Foo::FooString(_) => true,
                _ => false,
            }
        }
        pub fn set_foo_string(&mut self, value: ::std::string::String) {
            self.foo = self::test_required_oneof::Foo::FooString(::std::convert::From::from(value))
        }
        pub fn take_foo_string(&mut self) -> ::std::option::Option<::std::string::String> {
            let foo = ::std::mem::replace(&mut self.foo, self::test_required_oneof::Foo::None);
            match foo {
                self::test_required_oneof::Foo::FooString(foo) => ::std::option::Option::Some(foo),
                mut foo => {
                    ::std::mem::swap(&mut self.foo, &mut foo);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_foo_string(&mut self) {
            let foo = ::std::mem::replace(&mut self.foo, self::test_required_oneof::Foo::None);
            match foo {
                self::test_required_oneof::Foo::FooString(_) => {}
                mut foo => ::std::mem::swap(&mut self.foo, &mut foo),
            }
        }
        pub const FOO_MESSAGE_FIELD_NUMBER: i32 = 3;
        pub fn foo_message(
            &self,
        ) -> ::std::option::Option<&self::test_required_oneof::NestedMessage> {
            match &self.foo {
                self::test_required_oneof::Foo::FooMessage(foo) => {
                    ::std::option::Option::Some(&**foo)
                }
                _ => ::std::option::Option::None,
            }
        }
        pub fn foo_message_mut(&mut self) -> &mut self::test_required_oneof::NestedMessage {
            match self.foo {
                self::test_required_oneof::Foo::FooMessage(_) => (),
                _ => {
                    self.foo = self::test_required_oneof::Foo::FooMessage(
                        ::std::default::Default::default(),
                    )
                }
            }
            match self.foo {
                self::test_required_oneof::Foo::FooMessage(ref mut foo) => &mut **foo,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_foo_message(&self) -> bool {
            match self.foo {
                self::test_required_oneof::Foo::FooMessage(_) => true,
                _ => false,
            }
        }
        pub fn set_foo_message(&mut self, value: self::test_required_oneof::NestedMessage) {
            self.foo = self::test_required_oneof::Foo::FooMessage(::std::convert::From::from(value))
        }
        pub fn take_foo_message(
            &mut self,
        ) -> ::std::option::Option<self::test_required_oneof::NestedMessage> {
            let foo = ::std::mem::replace(&mut self.foo, self::test_required_oneof::Foo::None);
            match foo {
                self::test_required_oneof::Foo::FooMessage(foo) => {
                    ::std::option::Option::Some(*foo)
                }
                mut foo => {
                    ::std::mem::swap(&mut self.foo, &mut foo);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_foo_message(&mut self) {
            let foo = ::std::mem::replace(&mut self.foo, self::test_required_oneof::Foo::None);
            match foo {
                self::test_required_oneof::Foo::FooMessage(_) => {}
                mut foo => ::std::mem::swap(&mut self.foo, &mut foo),
            }
        }
        pub fn foo(&self) -> &self::test_required_oneof::Foo {
            &self.foo
        }
        pub fn foo_mut(&mut self) -> &mut self::test_required_oneof::Foo {
            &mut self.foo
        }
    }
    pub mod test_required_oneof {
        #[derive(Clone, Debug, PartialEq)]
        pub enum Foo {
            None,
            FooInt(i32),
            FooString(::std::string::String),
            FooMessage(::std::boxed::Box<self::NestedMessage>),
        }
        impl ::std::default::Default for self::Foo {
            fn default() -> Self {
                self::Foo::None
            }
        }
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct NestedMessage {
            required_double: ::std::option::Option<f64>,
            unknown_fields: ::protrust::UnknownFieldSet,
        }
        impl ::protrust::CodedMessage for self::NestedMessage {
            fn merge_from(
                &mut self,
                input: &mut ::protrust::io::CodedInput,
            ) -> ::protrust::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        9 | 10 => self.set_required_double(input.read_double()?),
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> i32 {
                let mut size = 0i32;
                if let ::std::option::Option::Some(required_double) = self.required_double_option()
                {
                    size += 1;
                    size += ::protrust::io::sizes::double(*required_double);
                }
                size += self.unknown_fields.calculate_size();
                size
            }
            fn write_to(
                &self,
                output: &mut ::protrust::io::CodedOutput,
            ) -> ::protrust::io::OutputResult {
                if let ::std::option::Option::Some(required_double) = self.required_double_option()
                {
                    output.write_raw_tag_bytes(&[9])?;
                    output.write_double(*required_double)?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                if !self.has_required_double() {
                    return false;
                }
                true
            }
        }
        impl ::protrust::LiteMessage for self::NestedMessage {
            fn merge(&mut self, other: &Self) {
                if let ::std::option::Option::Some(required_double) = other.required_double_option()
                {
                    self.set_required_double(*required_double);
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl ::protrust::Message for self::NestedMessage {
            fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
                &<self::super::TestRequiredOneof as ::protrust::Message>::descriptor().messages()[0]
            }
        }
        impl self::NestedMessage {
            pub const REQUIRED_DOUBLE_FIELD_NUMBER: i32 = 1;
            pub const REQUIRED_DOUBLE_DEFAULT_VALUE: f64 = 0.0;
            pub fn required_double(&self) -> f64 {
                self.required_double
                    .unwrap_or(Self::REQUIRED_DOUBLE_DEFAULT_VALUE)
            }
            pub fn required_double_option(&self) -> ::std::option::Option<&f64> {
                self.required_double.as_ref()
            }
            pub fn required_double_mut(&mut self) -> &mut f64 {
                self.required_double
                    .get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_required_double(&self) -> bool {
                self.required_double.is_some()
            }
            pub fn set_required_double(&mut self, value: f64) {
                self.required_double =
                    ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_required_double(&mut self) -> ::std::option::Option<f64> {
                self.required_double.take()
            }
            pub fn clear_required_double(&mut self) {
                self.required_double = ::std::option::Option::None;
            }
        }
        pub(in super::super::super) mod nested_message {
            pub(in super::super::super) static REQUIRED_DOUBLE_REFLECTOR:
                ::protrust::reflect::access::VerboseFieldAccessor<self::super::NestedMessage, f64> =
                ::protrust::reflect::access::VerboseFieldAccessor {
                    get_option: self::super::NestedMessage::required_double_option,
                    get_mut: self::super::NestedMessage::required_double_mut,
                    set: self::super::NestedMessage::set_required_double,
                    take: self::super::NestedMessage::take_required_double,
                    clear: self::super::NestedMessage::clear_required_double,
                };
        }
        pub(in super::super) static FOO_INT_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestRequiredOneof, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestRequiredOneof::foo_int,
                get_mut: self::super::TestRequiredOneof::foo_int_mut,
                set: self::super::TestRequiredOneof::set_foo_int,
                take: self::super::TestRequiredOneof::take_foo_int,
                clear: self::super::TestRequiredOneof::clear_foo_int,
            };
        pub(in super::super) static FOO_STRING_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestRequiredOneof,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestRequiredOneof::foo_string,
            get_mut: self::super::TestRequiredOneof::foo_string_mut,
            set: self::super::TestRequiredOneof::set_foo_string,
            take: self::super::TestRequiredOneof::take_foo_string,
            clear: self::super::TestRequiredOneof::clear_foo_string,
        };
        pub(in super::super) static FOO_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestRequiredOneof,
                self::NestedMessage,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestRequiredOneof::foo_message,
            get_mut: self::super::TestRequiredOneof::foo_message_mut,
            set: self::super::TestRequiredOneof::set_foo_message,
            take: self::super::TestRequiredOneof::take_foo_message,
            clear: self::super::TestRequiredOneof::clear_foo_message,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestPackedTypes {
        packed_int32: ::protrust::collections::RepeatedField<i32>,
        packed_int64: ::protrust::collections::RepeatedField<i64>,
        packed_uint32: ::protrust::collections::RepeatedField<u32>,
        packed_uint64: ::protrust::collections::RepeatedField<u64>,
        packed_sint32: ::protrust::collections::RepeatedField<i32>,
        packed_sint64: ::protrust::collections::RepeatedField<i64>,
        packed_fixed32: ::protrust::collections::RepeatedField<u32>,
        packed_fixed64: ::protrust::collections::RepeatedField<u64>,
        packed_sfixed32: ::protrust::collections::RepeatedField<i32>,
        packed_sfixed64: ::protrust::collections::RepeatedField<i64>,
        packed_float: ::protrust::collections::RepeatedField<f32>,
        packed_double: ::protrust::collections::RepeatedField<f64>,
        packed_bool: ::protrust::collections::RepeatedField<bool>,
        packed_enum:
            ::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestPackedTypes {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    722 => self
                        .packed_int32
                        .add_entries(input, &self::test_packed_types::PACKED_INT32_CODEC)?,
                    730 => self
                        .packed_int64
                        .add_entries(input, &self::test_packed_types::PACKED_INT64_CODEC)?,
                    738 => self
                        .packed_uint32
                        .add_entries(input, &self::test_packed_types::PACKED_UINT32_CODEC)?,
                    746 => self
                        .packed_uint64
                        .add_entries(input, &self::test_packed_types::PACKED_UINT64_CODEC)?,
                    754 => self
                        .packed_sint32
                        .add_entries(input, &self::test_packed_types::PACKED_SINT32_CODEC)?,
                    762 => self
                        .packed_sint64
                        .add_entries(input, &self::test_packed_types::PACKED_SINT64_CODEC)?,
                    770 => self
                        .packed_fixed32
                        .add_entries(input, &self::test_packed_types::PACKED_FIXED32_CODEC)?,
                    778 => self
                        .packed_fixed64
                        .add_entries(input, &self::test_packed_types::PACKED_FIXED64_CODEC)?,
                    786 => self
                        .packed_sfixed32
                        .add_entries(input, &self::test_packed_types::PACKED_SFIXED32_CODEC)?,
                    794 => self
                        .packed_sfixed64
                        .add_entries(input, &self::test_packed_types::PACKED_SFIXED64_CODEC)?,
                    802 => self
                        .packed_float
                        .add_entries(input, &self::test_packed_types::PACKED_FLOAT_CODEC)?,
                    810 => self
                        .packed_double
                        .add_entries(input, &self::test_packed_types::PACKED_DOUBLE_CODEC)?,
                    818 => self
                        .packed_bool
                        .add_entries(input, &self::test_packed_types::PACKED_BOOL_CODEC)?,
                    826 => self
                        .packed_enum
                        .add_entries(input, &self::test_packed_types::PACKED_ENUM_CODEC)?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            size += self
                .packed_int32()
                .calculate_size(&self::test_packed_types::PACKED_INT32_CODEC);
            size += self
                .packed_int64()
                .calculate_size(&self::test_packed_types::PACKED_INT64_CODEC);
            size += self
                .packed_uint32()
                .calculate_size(&self::test_packed_types::PACKED_UINT32_CODEC);
            size += self
                .packed_uint64()
                .calculate_size(&self::test_packed_types::PACKED_UINT64_CODEC);
            size += self
                .packed_sint32()
                .calculate_size(&self::test_packed_types::PACKED_SINT32_CODEC);
            size += self
                .packed_sint64()
                .calculate_size(&self::test_packed_types::PACKED_SINT64_CODEC);
            size += self
                .packed_fixed32()
                .calculate_size(&self::test_packed_types::PACKED_FIXED32_CODEC);
            size += self
                .packed_fixed64()
                .calculate_size(&self::test_packed_types::PACKED_FIXED64_CODEC);
            size += self
                .packed_sfixed32()
                .calculate_size(&self::test_packed_types::PACKED_SFIXED32_CODEC);
            size += self
                .packed_sfixed64()
                .calculate_size(&self::test_packed_types::PACKED_SFIXED64_CODEC);
            size += self
                .packed_float()
                .calculate_size(&self::test_packed_types::PACKED_FLOAT_CODEC);
            size += self
                .packed_double()
                .calculate_size(&self::test_packed_types::PACKED_DOUBLE_CODEC);
            size += self
                .packed_bool()
                .calculate_size(&self::test_packed_types::PACKED_BOOL_CODEC);
            size += self
                .packed_enum()
                .calculate_size(&self::test_packed_types::PACKED_ENUM_CODEC);
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            self.packed_int32()
                .write_to(output, &self::test_packed_types::PACKED_INT32_CODEC)?;
            self.packed_int64()
                .write_to(output, &self::test_packed_types::PACKED_INT64_CODEC)?;
            self.packed_uint32()
                .write_to(output, &self::test_packed_types::PACKED_UINT32_CODEC)?;
            self.packed_uint64()
                .write_to(output, &self::test_packed_types::PACKED_UINT64_CODEC)?;
            self.packed_sint32()
                .write_to(output, &self::test_packed_types::PACKED_SINT32_CODEC)?;
            self.packed_sint64()
                .write_to(output, &self::test_packed_types::PACKED_SINT64_CODEC)?;
            self.packed_fixed32()
                .write_to(output, &self::test_packed_types::PACKED_FIXED32_CODEC)?;
            self.packed_fixed64()
                .write_to(output, &self::test_packed_types::PACKED_FIXED64_CODEC)?;
            self.packed_sfixed32()
                .write_to(output, &self::test_packed_types::PACKED_SFIXED32_CODEC)?;
            self.packed_sfixed64()
                .write_to(output, &self::test_packed_types::PACKED_SFIXED64_CODEC)?;
            self.packed_float()
                .write_to(output, &self::test_packed_types::PACKED_FLOAT_CODEC)?;
            self.packed_double()
                .write_to(output, &self::test_packed_types::PACKED_DOUBLE_CODEC)?;
            self.packed_bool()
                .write_to(output, &self::test_packed_types::PACKED_BOOL_CODEC)?;
            self.packed_enum()
                .write_to(output, &self::test_packed_types::PACKED_ENUM_CODEC)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestPackedTypes {
        fn merge(&mut self, other: &Self) {
            self.packed_int32.merge(&other.packed_int32);
            self.packed_int64.merge(&other.packed_int64);
            self.packed_uint32.merge(&other.packed_uint32);
            self.packed_uint64.merge(&other.packed_uint64);
            self.packed_sint32.merge(&other.packed_sint32);
            self.packed_sint64.merge(&other.packed_sint64);
            self.packed_fixed32.merge(&other.packed_fixed32);
            self.packed_fixed64.merge(&other.packed_fixed64);
            self.packed_sfixed32.merge(&other.packed_sfixed32);
            self.packed_sfixed64.merge(&other.packed_sfixed64);
            self.packed_float.merge(&other.packed_float);
            self.packed_double.merge(&other.packed_double);
            self.packed_bool.merge(&other.packed_bool);
            self.packed_enum.merge(&other.packed_enum);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestPackedTypes {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[47]
        }
    }
    impl self::TestPackedTypes {
        pub const PACKED_INT32_FIELD_NUMBER: i32 = 90;
        pub fn packed_int32(&self) -> &::protrust::collections::RepeatedField<i32> {
            &self.packed_int32
        }
        pub fn packed_int32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
            &mut self.packed_int32
        }
        pub const PACKED_INT64_FIELD_NUMBER: i32 = 91;
        pub fn packed_int64(&self) -> &::protrust::collections::RepeatedField<i64> {
            &self.packed_int64
        }
        pub fn packed_int64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
            &mut self.packed_int64
        }
        pub const PACKED_UINT32_FIELD_NUMBER: i32 = 92;
        pub fn packed_uint32(&self) -> &::protrust::collections::RepeatedField<u32> {
            &self.packed_uint32
        }
        pub fn packed_uint32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u32> {
            &mut self.packed_uint32
        }
        pub const PACKED_UINT64_FIELD_NUMBER: i32 = 93;
        pub fn packed_uint64(&self) -> &::protrust::collections::RepeatedField<u64> {
            &self.packed_uint64
        }
        pub fn packed_uint64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u64> {
            &mut self.packed_uint64
        }
        pub const PACKED_SINT32_FIELD_NUMBER: i32 = 94;
        pub fn packed_sint32(&self) -> &::protrust::collections::RepeatedField<i32> {
            &self.packed_sint32
        }
        pub fn packed_sint32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
            &mut self.packed_sint32
        }
        pub const PACKED_SINT64_FIELD_NUMBER: i32 = 95;
        pub fn packed_sint64(&self) -> &::protrust::collections::RepeatedField<i64> {
            &self.packed_sint64
        }
        pub fn packed_sint64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
            &mut self.packed_sint64
        }
        pub const PACKED_FIXED32_FIELD_NUMBER: i32 = 96;
        pub fn packed_fixed32(&self) -> &::protrust::collections::RepeatedField<u32> {
            &self.packed_fixed32
        }
        pub fn packed_fixed32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u32> {
            &mut self.packed_fixed32
        }
        pub const PACKED_FIXED64_FIELD_NUMBER: i32 = 97;
        pub fn packed_fixed64(&self) -> &::protrust::collections::RepeatedField<u64> {
            &self.packed_fixed64
        }
        pub fn packed_fixed64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u64> {
            &mut self.packed_fixed64
        }
        pub const PACKED_SFIXED32_FIELD_NUMBER: i32 = 98;
        pub fn packed_sfixed32(&self) -> &::protrust::collections::RepeatedField<i32> {
            &self.packed_sfixed32
        }
        pub fn packed_sfixed32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
            &mut self.packed_sfixed32
        }
        pub const PACKED_SFIXED64_FIELD_NUMBER: i32 = 99;
        pub fn packed_sfixed64(&self) -> &::protrust::collections::RepeatedField<i64> {
            &self.packed_sfixed64
        }
        pub fn packed_sfixed64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
            &mut self.packed_sfixed64
        }
        pub const PACKED_FLOAT_FIELD_NUMBER: i32 = 100;
        pub fn packed_float(&self) -> &::protrust::collections::RepeatedField<f32> {
            &self.packed_float
        }
        pub fn packed_float_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<f32> {
            &mut self.packed_float
        }
        pub const PACKED_DOUBLE_FIELD_NUMBER: i32 = 101;
        pub fn packed_double(&self) -> &::protrust::collections::RepeatedField<f64> {
            &self.packed_double
        }
        pub fn packed_double_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<f64> {
            &mut self.packed_double
        }
        pub const PACKED_BOOL_FIELD_NUMBER: i32 = 102;
        pub fn packed_bool(&self) -> &::protrust::collections::RepeatedField<bool> {
            &self.packed_bool
        }
        pub fn packed_bool_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<bool> {
            &mut self.packed_bool
        }
        pub const PACKED_ENUM_FIELD_NUMBER: i32 = 103;
        pub fn packed_enum(
            &self,
        ) -> &::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>>
        {
            &self.packed_enum
        }
        pub fn packed_enum_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>>
        {
            &mut self.packed_enum
        }
    }
    pub(in super::super) mod test_packed_types {
        pub(super) static PACKED_INT32_CODEC: ::protrust::Codec<i32> =
            ::protrust::Codec::int32(722);
        pub(super) static PACKED_INT64_CODEC: ::protrust::Codec<i64> =
            ::protrust::Codec::int64(730);
        pub(super) static PACKED_UINT32_CODEC: ::protrust::Codec<u32> =
            ::protrust::Codec::uint32(738);
        pub(super) static PACKED_UINT64_CODEC: ::protrust::Codec<u64> =
            ::protrust::Codec::uint64(746);
        pub(super) static PACKED_SINT32_CODEC: ::protrust::Codec<i32> =
            ::protrust::Codec::sint32(754);
        pub(super) static PACKED_SINT64_CODEC: ::protrust::Codec<i64> =
            ::protrust::Codec::sint64(762);
        pub(super) static PACKED_FIXED32_CODEC: ::protrust::Codec<u32> =
            ::protrust::Codec::fixed32(770);
        pub(super) static PACKED_FIXED64_CODEC: ::protrust::Codec<u64> =
            ::protrust::Codec::fixed64(778);
        pub(super) static PACKED_SFIXED32_CODEC: ::protrust::Codec<i32> =
            ::protrust::Codec::sfixed32(786);
        pub(super) static PACKED_SFIXED64_CODEC: ::protrust::Codec<i64> =
            ::protrust::Codec::sfixed64(794);
        pub(super) static PACKED_FLOAT_CODEC: ::protrust::Codec<f32> =
            ::protrust::Codec::float(802);
        pub(super) static PACKED_DOUBLE_CODEC: ::protrust::Codec<f64> =
            ::protrust::Codec::double(810);
        pub(super) static PACKED_BOOL_CODEC: ::protrust::Codec<bool> = ::protrust::Codec::bool(818);
        pub(super) static PACKED_ENUM_CODEC: ::protrust::Codec<
            ::protrust::EnumValue<self::super::ForeignEnum>,
        > = ::protrust::Codec::enum_value(826);
        pub(in super::super) static PACKED_INT32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestPackedTypes,
                ::protrust::collections::RepeatedField<i32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestPackedTypes::packed_int32,
            get_mut: self::super::TestPackedTypes::packed_int32_mut,
        };
        pub(in super::super) static PACKED_INT64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestPackedTypes,
                ::protrust::collections::RepeatedField<i64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestPackedTypes::packed_int64,
            get_mut: self::super::TestPackedTypes::packed_int64_mut,
        };
        pub(in super::super) static PACKED_UINT32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestPackedTypes,
                ::protrust::collections::RepeatedField<u32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestPackedTypes::packed_uint32,
            get_mut: self::super::TestPackedTypes::packed_uint32_mut,
        };
        pub(in super::super) static PACKED_UINT64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestPackedTypes,
                ::protrust::collections::RepeatedField<u64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestPackedTypes::packed_uint64,
            get_mut: self::super::TestPackedTypes::packed_uint64_mut,
        };
        pub(in super::super) static PACKED_SINT32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestPackedTypes,
                ::protrust::collections::RepeatedField<i32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestPackedTypes::packed_sint32,
            get_mut: self::super::TestPackedTypes::packed_sint32_mut,
        };
        pub(in super::super) static PACKED_SINT64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestPackedTypes,
                ::protrust::collections::RepeatedField<i64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestPackedTypes::packed_sint64,
            get_mut: self::super::TestPackedTypes::packed_sint64_mut,
        };
        pub(in super::super) static PACKED_FIXED32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestPackedTypes,
                ::protrust::collections::RepeatedField<u32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestPackedTypes::packed_fixed32,
            get_mut: self::super::TestPackedTypes::packed_fixed32_mut,
        };
        pub(in super::super) static PACKED_FIXED64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestPackedTypes,
                ::protrust::collections::RepeatedField<u64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestPackedTypes::packed_fixed64,
            get_mut: self::super::TestPackedTypes::packed_fixed64_mut,
        };
        pub(in super::super) static PACKED_SFIXED32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestPackedTypes,
                ::protrust::collections::RepeatedField<i32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestPackedTypes::packed_sfixed32,
            get_mut: self::super::TestPackedTypes::packed_sfixed32_mut,
        };
        pub(in super::super) static PACKED_SFIXED64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestPackedTypes,
                ::protrust::collections::RepeatedField<i64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestPackedTypes::packed_sfixed64,
            get_mut: self::super::TestPackedTypes::packed_sfixed64_mut,
        };
        pub(in super::super) static PACKED_FLOAT_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestPackedTypes,
                ::protrust::collections::RepeatedField<f32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestPackedTypes::packed_float,
            get_mut: self::super::TestPackedTypes::packed_float_mut,
        };
        pub(in super::super) static PACKED_DOUBLE_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestPackedTypes,
                ::protrust::collections::RepeatedField<f64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestPackedTypes::packed_double,
            get_mut: self::super::TestPackedTypes::packed_double_mut,
        };
        pub(in super::super) static PACKED_BOOL_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestPackedTypes,
                ::protrust::collections::RepeatedField<bool>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestPackedTypes::packed_bool,
            get_mut: self::super::TestPackedTypes::packed_bool_mut,
        };
        pub(in super::super) static PACKED_ENUM_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestPackedTypes,
                ::protrust::collections::RepeatedField<
                    ::protrust::EnumValue<self::super::ForeignEnum>,
                >,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestPackedTypes::packed_enum,
            get_mut: self::super::TestPackedTypes::packed_enum_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestUnpackedTypes {
        unpacked_int32: ::protrust::collections::RepeatedField<i32>,
        unpacked_int64: ::protrust::collections::RepeatedField<i64>,
        unpacked_uint32: ::protrust::collections::RepeatedField<u32>,
        unpacked_uint64: ::protrust::collections::RepeatedField<u64>,
        unpacked_sint32: ::protrust::collections::RepeatedField<i32>,
        unpacked_sint64: ::protrust::collections::RepeatedField<i64>,
        unpacked_fixed32: ::protrust::collections::RepeatedField<u32>,
        unpacked_fixed64: ::protrust::collections::RepeatedField<u64>,
        unpacked_sfixed32: ::protrust::collections::RepeatedField<i32>,
        unpacked_sfixed64: ::protrust::collections::RepeatedField<i64>,
        unpacked_float: ::protrust::collections::RepeatedField<f32>,
        unpacked_double: ::protrust::collections::RepeatedField<f64>,
        unpacked_bool: ::protrust::collections::RepeatedField<bool>,
        unpacked_enum:
            ::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestUnpackedTypes {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    720 | 722 => self
                        .unpacked_int32
                        .add_entries(input, &self::test_unpacked_types::UNPACKED_INT32_CODEC)?,
                    728 | 730 => self
                        .unpacked_int64
                        .add_entries(input, &self::test_unpacked_types::UNPACKED_INT64_CODEC)?,
                    736 | 738 => self
                        .unpacked_uint32
                        .add_entries(input, &self::test_unpacked_types::UNPACKED_UINT32_CODEC)?,
                    744 | 746 => self
                        .unpacked_uint64
                        .add_entries(input, &self::test_unpacked_types::UNPACKED_UINT64_CODEC)?,
                    752 | 754 => self
                        .unpacked_sint32
                        .add_entries(input, &self::test_unpacked_types::UNPACKED_SINT32_CODEC)?,
                    760 | 762 => self
                        .unpacked_sint64
                        .add_entries(input, &self::test_unpacked_types::UNPACKED_SINT64_CODEC)?,
                    773 | 770 => self
                        .unpacked_fixed32
                        .add_entries(input, &self::test_unpacked_types::UNPACKED_FIXED32_CODEC)?,
                    777 | 778 => self
                        .unpacked_fixed64
                        .add_entries(input, &self::test_unpacked_types::UNPACKED_FIXED64_CODEC)?,
                    789 | 786 => self
                        .unpacked_sfixed32
                        .add_entries(input, &self::test_unpacked_types::UNPACKED_SFIXED32_CODEC)?,
                    793 | 794 => self
                        .unpacked_sfixed64
                        .add_entries(input, &self::test_unpacked_types::UNPACKED_SFIXED64_CODEC)?,
                    805 | 802 => self
                        .unpacked_float
                        .add_entries(input, &self::test_unpacked_types::UNPACKED_FLOAT_CODEC)?,
                    809 | 810 => self
                        .unpacked_double
                        .add_entries(input, &self::test_unpacked_types::UNPACKED_DOUBLE_CODEC)?,
                    816 | 818 => self
                        .unpacked_bool
                        .add_entries(input, &self::test_unpacked_types::UNPACKED_BOOL_CODEC)?,
                    824 | 826 => self
                        .unpacked_enum
                        .add_entries(input, &self::test_unpacked_types::UNPACKED_ENUM_CODEC)?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            size += self
                .unpacked_int32()
                .calculate_size(&self::test_unpacked_types::UNPACKED_INT32_CODEC);
            size += self
                .unpacked_int64()
                .calculate_size(&self::test_unpacked_types::UNPACKED_INT64_CODEC);
            size += self
                .unpacked_uint32()
                .calculate_size(&self::test_unpacked_types::UNPACKED_UINT32_CODEC);
            size += self
                .unpacked_uint64()
                .calculate_size(&self::test_unpacked_types::UNPACKED_UINT64_CODEC);
            size += self
                .unpacked_sint32()
                .calculate_size(&self::test_unpacked_types::UNPACKED_SINT32_CODEC);
            size += self
                .unpacked_sint64()
                .calculate_size(&self::test_unpacked_types::UNPACKED_SINT64_CODEC);
            size += self
                .unpacked_fixed32()
                .calculate_size(&self::test_unpacked_types::UNPACKED_FIXED32_CODEC);
            size += self
                .unpacked_fixed64()
                .calculate_size(&self::test_unpacked_types::UNPACKED_FIXED64_CODEC);
            size += self
                .unpacked_sfixed32()
                .calculate_size(&self::test_unpacked_types::UNPACKED_SFIXED32_CODEC);
            size += self
                .unpacked_sfixed64()
                .calculate_size(&self::test_unpacked_types::UNPACKED_SFIXED64_CODEC);
            size += self
                .unpacked_float()
                .calculate_size(&self::test_unpacked_types::UNPACKED_FLOAT_CODEC);
            size += self
                .unpacked_double()
                .calculate_size(&self::test_unpacked_types::UNPACKED_DOUBLE_CODEC);
            size += self
                .unpacked_bool()
                .calculate_size(&self::test_unpacked_types::UNPACKED_BOOL_CODEC);
            size += self
                .unpacked_enum()
                .calculate_size(&self::test_unpacked_types::UNPACKED_ENUM_CODEC);
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            self.unpacked_int32()
                .write_to(output, &self::test_unpacked_types::UNPACKED_INT32_CODEC)?;
            self.unpacked_int64()
                .write_to(output, &self::test_unpacked_types::UNPACKED_INT64_CODEC)?;
            self.unpacked_uint32()
                .write_to(output, &self::test_unpacked_types::UNPACKED_UINT32_CODEC)?;
            self.unpacked_uint64()
                .write_to(output, &self::test_unpacked_types::UNPACKED_UINT64_CODEC)?;
            self.unpacked_sint32()
                .write_to(output, &self::test_unpacked_types::UNPACKED_SINT32_CODEC)?;
            self.unpacked_sint64()
                .write_to(output, &self::test_unpacked_types::UNPACKED_SINT64_CODEC)?;
            self.unpacked_fixed32()
                .write_to(output, &self::test_unpacked_types::UNPACKED_FIXED32_CODEC)?;
            self.unpacked_fixed64()
                .write_to(output, &self::test_unpacked_types::UNPACKED_FIXED64_CODEC)?;
            self.unpacked_sfixed32()
                .write_to(output, &self::test_unpacked_types::UNPACKED_SFIXED32_CODEC)?;
            self.unpacked_sfixed64()
                .write_to(output, &self::test_unpacked_types::UNPACKED_SFIXED64_CODEC)?;
            self.unpacked_float()
                .write_to(output, &self::test_unpacked_types::UNPACKED_FLOAT_CODEC)?;
            self.unpacked_double()
                .write_to(output, &self::test_unpacked_types::UNPACKED_DOUBLE_CODEC)?;
            self.unpacked_bool()
                .write_to(output, &self::test_unpacked_types::UNPACKED_BOOL_CODEC)?;
            self.unpacked_enum()
                .write_to(output, &self::test_unpacked_types::UNPACKED_ENUM_CODEC)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestUnpackedTypes {
        fn merge(&mut self, other: &Self) {
            self.unpacked_int32.merge(&other.unpacked_int32);
            self.unpacked_int64.merge(&other.unpacked_int64);
            self.unpacked_uint32.merge(&other.unpacked_uint32);
            self.unpacked_uint64.merge(&other.unpacked_uint64);
            self.unpacked_sint32.merge(&other.unpacked_sint32);
            self.unpacked_sint64.merge(&other.unpacked_sint64);
            self.unpacked_fixed32.merge(&other.unpacked_fixed32);
            self.unpacked_fixed64.merge(&other.unpacked_fixed64);
            self.unpacked_sfixed32.merge(&other.unpacked_sfixed32);
            self.unpacked_sfixed64.merge(&other.unpacked_sfixed64);
            self.unpacked_float.merge(&other.unpacked_float);
            self.unpacked_double.merge(&other.unpacked_double);
            self.unpacked_bool.merge(&other.unpacked_bool);
            self.unpacked_enum.merge(&other.unpacked_enum);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestUnpackedTypes {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[48]
        }
    }
    impl self::TestUnpackedTypes {
        pub const UNPACKED_INT32_FIELD_NUMBER: i32 = 90;
        pub fn unpacked_int32(&self) -> &::protrust::collections::RepeatedField<i32> {
            &self.unpacked_int32
        }
        pub fn unpacked_int32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
            &mut self.unpacked_int32
        }
        pub const UNPACKED_INT64_FIELD_NUMBER: i32 = 91;
        pub fn unpacked_int64(&self) -> &::protrust::collections::RepeatedField<i64> {
            &self.unpacked_int64
        }
        pub fn unpacked_int64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
            &mut self.unpacked_int64
        }
        pub const UNPACKED_UINT32_FIELD_NUMBER: i32 = 92;
        pub fn unpacked_uint32(&self) -> &::protrust::collections::RepeatedField<u32> {
            &self.unpacked_uint32
        }
        pub fn unpacked_uint32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u32> {
            &mut self.unpacked_uint32
        }
        pub const UNPACKED_UINT64_FIELD_NUMBER: i32 = 93;
        pub fn unpacked_uint64(&self) -> &::protrust::collections::RepeatedField<u64> {
            &self.unpacked_uint64
        }
        pub fn unpacked_uint64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u64> {
            &mut self.unpacked_uint64
        }
        pub const UNPACKED_SINT32_FIELD_NUMBER: i32 = 94;
        pub fn unpacked_sint32(&self) -> &::protrust::collections::RepeatedField<i32> {
            &self.unpacked_sint32
        }
        pub fn unpacked_sint32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
            &mut self.unpacked_sint32
        }
        pub const UNPACKED_SINT64_FIELD_NUMBER: i32 = 95;
        pub fn unpacked_sint64(&self) -> &::protrust::collections::RepeatedField<i64> {
            &self.unpacked_sint64
        }
        pub fn unpacked_sint64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
            &mut self.unpacked_sint64
        }
        pub const UNPACKED_FIXED32_FIELD_NUMBER: i32 = 96;
        pub fn unpacked_fixed32(&self) -> &::protrust::collections::RepeatedField<u32> {
            &self.unpacked_fixed32
        }
        pub fn unpacked_fixed32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u32> {
            &mut self.unpacked_fixed32
        }
        pub const UNPACKED_FIXED64_FIELD_NUMBER: i32 = 97;
        pub fn unpacked_fixed64(&self) -> &::protrust::collections::RepeatedField<u64> {
            &self.unpacked_fixed64
        }
        pub fn unpacked_fixed64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u64> {
            &mut self.unpacked_fixed64
        }
        pub const UNPACKED_SFIXED32_FIELD_NUMBER: i32 = 98;
        pub fn unpacked_sfixed32(&self) -> &::protrust::collections::RepeatedField<i32> {
            &self.unpacked_sfixed32
        }
        pub fn unpacked_sfixed32_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<i32> {
            &mut self.unpacked_sfixed32
        }
        pub const UNPACKED_SFIXED64_FIELD_NUMBER: i32 = 99;
        pub fn unpacked_sfixed64(&self) -> &::protrust::collections::RepeatedField<i64> {
            &self.unpacked_sfixed64
        }
        pub fn unpacked_sfixed64_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<i64> {
            &mut self.unpacked_sfixed64
        }
        pub const UNPACKED_FLOAT_FIELD_NUMBER: i32 = 100;
        pub fn unpacked_float(&self) -> &::protrust::collections::RepeatedField<f32> {
            &self.unpacked_float
        }
        pub fn unpacked_float_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<f32> {
            &mut self.unpacked_float
        }
        pub const UNPACKED_DOUBLE_FIELD_NUMBER: i32 = 101;
        pub fn unpacked_double(&self) -> &::protrust::collections::RepeatedField<f64> {
            &self.unpacked_double
        }
        pub fn unpacked_double_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<f64> {
            &mut self.unpacked_double
        }
        pub const UNPACKED_BOOL_FIELD_NUMBER: i32 = 102;
        pub fn unpacked_bool(&self) -> &::protrust::collections::RepeatedField<bool> {
            &self.unpacked_bool
        }
        pub fn unpacked_bool_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<bool> {
            &mut self.unpacked_bool
        }
        pub const UNPACKED_ENUM_FIELD_NUMBER: i32 = 103;
        pub fn unpacked_enum(
            &self,
        ) -> &::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>>
        {
            &self.unpacked_enum
        }
        pub fn unpacked_enum_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>>
        {
            &mut self.unpacked_enum
        }
    }
    pub(in super::super) mod test_unpacked_types {
        pub(super) static UNPACKED_INT32_CODEC: ::protrust::Codec<i32> =
            ::protrust::Codec::int32(720);
        pub(super) static UNPACKED_INT64_CODEC: ::protrust::Codec<i64> =
            ::protrust::Codec::int64(728);
        pub(super) static UNPACKED_UINT32_CODEC: ::protrust::Codec<u32> =
            ::protrust::Codec::uint32(736);
        pub(super) static UNPACKED_UINT64_CODEC: ::protrust::Codec<u64> =
            ::protrust::Codec::uint64(744);
        pub(super) static UNPACKED_SINT32_CODEC: ::protrust::Codec<i32> =
            ::protrust::Codec::sint32(752);
        pub(super) static UNPACKED_SINT64_CODEC: ::protrust::Codec<i64> =
            ::protrust::Codec::sint64(760);
        pub(super) static UNPACKED_FIXED32_CODEC: ::protrust::Codec<u32> =
            ::protrust::Codec::fixed32(773);
        pub(super) static UNPACKED_FIXED64_CODEC: ::protrust::Codec<u64> =
            ::protrust::Codec::fixed64(777);
        pub(super) static UNPACKED_SFIXED32_CODEC: ::protrust::Codec<i32> =
            ::protrust::Codec::sfixed32(789);
        pub(super) static UNPACKED_SFIXED64_CODEC: ::protrust::Codec<i64> =
            ::protrust::Codec::sfixed64(793);
        pub(super) static UNPACKED_FLOAT_CODEC: ::protrust::Codec<f32> =
            ::protrust::Codec::float(805);
        pub(super) static UNPACKED_DOUBLE_CODEC: ::protrust::Codec<f64> =
            ::protrust::Codec::double(809);
        pub(super) static UNPACKED_BOOL_CODEC: ::protrust::Codec<bool> =
            ::protrust::Codec::bool(816);
        pub(super) static UNPACKED_ENUM_CODEC: ::protrust::Codec<
            ::protrust::EnumValue<self::super::ForeignEnum>,
        > = ::protrust::Codec::enum_value(824);
        pub(in super::super) static UNPACKED_INT32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestUnpackedTypes,
                ::protrust::collections::RepeatedField<i32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestUnpackedTypes::unpacked_int32,
            get_mut: self::super::TestUnpackedTypes::unpacked_int32_mut,
        };
        pub(in super::super) static UNPACKED_INT64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestUnpackedTypes,
                ::protrust::collections::RepeatedField<i64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestUnpackedTypes::unpacked_int64,
            get_mut: self::super::TestUnpackedTypes::unpacked_int64_mut,
        };
        pub(in super::super) static UNPACKED_UINT32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestUnpackedTypes,
                ::protrust::collections::RepeatedField<u32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestUnpackedTypes::unpacked_uint32,
            get_mut: self::super::TestUnpackedTypes::unpacked_uint32_mut,
        };
        pub(in super::super) static UNPACKED_UINT64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestUnpackedTypes,
                ::protrust::collections::RepeatedField<u64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestUnpackedTypes::unpacked_uint64,
            get_mut: self::super::TestUnpackedTypes::unpacked_uint64_mut,
        };
        pub(in super::super) static UNPACKED_SINT32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestUnpackedTypes,
                ::protrust::collections::RepeatedField<i32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestUnpackedTypes::unpacked_sint32,
            get_mut: self::super::TestUnpackedTypes::unpacked_sint32_mut,
        };
        pub(in super::super) static UNPACKED_SINT64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestUnpackedTypes,
                ::protrust::collections::RepeatedField<i64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestUnpackedTypes::unpacked_sint64,
            get_mut: self::super::TestUnpackedTypes::unpacked_sint64_mut,
        };
        pub(in super::super) static UNPACKED_FIXED32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestUnpackedTypes,
                ::protrust::collections::RepeatedField<u32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestUnpackedTypes::unpacked_fixed32,
            get_mut: self::super::TestUnpackedTypes::unpacked_fixed32_mut,
        };
        pub(in super::super) static UNPACKED_FIXED64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestUnpackedTypes,
                ::protrust::collections::RepeatedField<u64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestUnpackedTypes::unpacked_fixed64,
            get_mut: self::super::TestUnpackedTypes::unpacked_fixed64_mut,
        };
        pub(in super::super) static UNPACKED_SFIXED32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestUnpackedTypes,
                ::protrust::collections::RepeatedField<i32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestUnpackedTypes::unpacked_sfixed32,
            get_mut: self::super::TestUnpackedTypes::unpacked_sfixed32_mut,
        };
        pub(in super::super) static UNPACKED_SFIXED64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestUnpackedTypes,
                ::protrust::collections::RepeatedField<i64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestUnpackedTypes::unpacked_sfixed64,
            get_mut: self::super::TestUnpackedTypes::unpacked_sfixed64_mut,
        };
        pub(in super::super) static UNPACKED_FLOAT_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestUnpackedTypes,
                ::protrust::collections::RepeatedField<f32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestUnpackedTypes::unpacked_float,
            get_mut: self::super::TestUnpackedTypes::unpacked_float_mut,
        };
        pub(in super::super) static UNPACKED_DOUBLE_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestUnpackedTypes,
                ::protrust::collections::RepeatedField<f64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestUnpackedTypes::unpacked_double,
            get_mut: self::super::TestUnpackedTypes::unpacked_double_mut,
        };
        pub(in super::super) static UNPACKED_BOOL_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestUnpackedTypes,
                ::protrust::collections::RepeatedField<bool>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestUnpackedTypes::unpacked_bool,
            get_mut: self::super::TestUnpackedTypes::unpacked_bool_mut,
        };
        pub(in super::super) static UNPACKED_ENUM_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestUnpackedTypes,
                ::protrust::collections::RepeatedField<
                    ::protrust::EnumValue<self::super::ForeignEnum>,
                >,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestUnpackedTypes::unpacked_enum,
            get_mut: self::super::TestUnpackedTypes::unpacked_enum_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestPackedExtensions {
        unknown_fields: ::protrust::UnknownFieldSet,
        extensions: ::protrust::ExtensionSet<Self>,
    }
    impl ::protrust::CodedMessage for self::TestPackedExtensions {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    _ => {
                        if !self.extensions.merge_from(input)? {
                            self.unknown_fields.merge_from(tag, input)?
                        }
                    }
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            size += self.extensions.calculate_size();
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            self.extensions.write_to(output)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestPackedExtensions {
        fn merge(&mut self, other: &Self) {
            self.extensions.merge(&other.extensions);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::ExtendableMessage for self::TestPackedExtensions {
        fn registry(&self) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> {
            self.extensions.registry()
        }
        fn replace_registry(
            &mut self,
            extensions: ::std::option::Option<&'static ::protrust::ExtensionRegistry>,
        ) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> {
            self.extensions.replace_registry(extensions)
        }
        fn has_extension<T: ::protrust::ExtensionIdentifier>(&self, extension: &'static T) -> bool {
            self.extensions.has_extension(extension)
        }
        fn has_extension_unchecked<T: ::protrust::ExtensionIdentifier>(
            &self,
            extension: &'static T,
        ) -> bool {
            self.extensions.has_extension_unchecked(extension)
        }
        fn get_value<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> Option<&V> {
            self.extensions.get_value(extension)
        }
        fn get_value_or_default<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync
                + ::std::ops::Deref<Target = L>,
            D: ::std::marker::Sync + ::std::ops::Deref<Target = L>,
            L,
        >(
            &self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> Option<&L> {
            self.extensions.get_value_or_default(extension)
        }
        fn get_repeated_value<
            V: ::std::cmp::PartialEq
                + ::std::clone::Clone
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &self,
            extension: &'static ::protrust::RepeatedExtension<Self, V>,
        ) -> Option<&::protrust::collections::RepeatedField<V>> {
            self.extensions.get_repeated_value(extension)
        }
        fn field<
            V: ::std::default::Default
                + ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> ::std::option::Option<::protrust::ExtensionField<Self, V, D>> {
            self.extensions.field(extension)
        }
        fn repeated_field<
            V: ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static ::protrust::RepeatedExtension<Self, V>,
        ) -> ::std::option::Option<::protrust::RepeatedExtensionField<Self, V>> {
            self.extensions.repeated_field(extension)
        }
    }
    impl ::protrust::Message for self::TestPackedExtensions {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[49]
        }
    }
    impl self::TestPackedExtensions {}
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestUnpackedExtensions {
        unknown_fields: ::protrust::UnknownFieldSet,
        extensions: ::protrust::ExtensionSet<Self>,
    }
    impl ::protrust::CodedMessage for self::TestUnpackedExtensions {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    _ => {
                        if !self.extensions.merge_from(input)? {
                            self.unknown_fields.merge_from(tag, input)?
                        }
                    }
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            size += self.extensions.calculate_size();
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            self.extensions.write_to(output)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestUnpackedExtensions {
        fn merge(&mut self, other: &Self) {
            self.extensions.merge(&other.extensions);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::ExtendableMessage for self::TestUnpackedExtensions {
        fn registry(&self) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> {
            self.extensions.registry()
        }
        fn replace_registry(
            &mut self,
            extensions: ::std::option::Option<&'static ::protrust::ExtensionRegistry>,
        ) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> {
            self.extensions.replace_registry(extensions)
        }
        fn has_extension<T: ::protrust::ExtensionIdentifier>(&self, extension: &'static T) -> bool {
            self.extensions.has_extension(extension)
        }
        fn has_extension_unchecked<T: ::protrust::ExtensionIdentifier>(
            &self,
            extension: &'static T,
        ) -> bool {
            self.extensions.has_extension_unchecked(extension)
        }
        fn get_value<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> Option<&V> {
            self.extensions.get_value(extension)
        }
        fn get_value_or_default<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync
                + ::std::ops::Deref<Target = L>,
            D: ::std::marker::Sync + ::std::ops::Deref<Target = L>,
            L,
        >(
            &self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> Option<&L> {
            self.extensions.get_value_or_default(extension)
        }
        fn get_repeated_value<
            V: ::std::cmp::PartialEq
                + ::std::clone::Clone
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &self,
            extension: &'static ::protrust::RepeatedExtension<Self, V>,
        ) -> Option<&::protrust::collections::RepeatedField<V>> {
            self.extensions.get_repeated_value(extension)
        }
        fn field<
            V: ::std::default::Default
                + ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> ::std::option::Option<::protrust::ExtensionField<Self, V, D>> {
            self.extensions.field(extension)
        }
        fn repeated_field<
            V: ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static ::protrust::RepeatedExtension<Self, V>,
        ) -> ::std::option::Option<::protrust::RepeatedExtensionField<Self, V>> {
            self.extensions.repeated_field(extension)
        }
    }
    impl ::protrust::Message for self::TestUnpackedExtensions {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[50]
        }
    }
    impl self::TestUnpackedExtensions {}
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestDynamicExtensions {
        scalar_extension: ::std::option::Option<u32>,
        enum_extension: ::std::option::Option<::protrust::EnumValue<self::ForeignEnum>>,
        dynamic_enum_extension: ::std::option::Option<
            ::protrust::EnumValue<self::test_dynamic_extensions::DynamicEnumType>,
        >,
        message_extension: ::std::option::Option<::std::boxed::Box<self::ForeignMessage>>,
        dynamic_message_extension: ::std::option::Option<
            ::std::boxed::Box<self::test_dynamic_extensions::DynamicMessageType>,
        >,
        repeated_extension: ::protrust::collections::RepeatedField<::std::string::String>,
        packed_extension: ::protrust::collections::RepeatedField<i32>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestDynamicExtensions {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    16005 | 16002 => self.set_scalar_extension(input.read_fixed32()?),
                    16008 | 16010 => self.set_enum_extension(input.read_enum_value()?),
                    16016 | 16018 => self.set_dynamic_enum_extension(input.read_enum_value()?),
                    16026 => input.read_message(self.message_extension_mut())?,
                    16034 => input.read_message(self.dynamic_message_extension_mut())?,
                    16042 => self.repeated_extension.add_entries(
                        input,
                        &self::test_dynamic_extensions::REPEATED_EXTENSION_CODEC,
                    )?,
                    16050 => self.packed_extension.add_entries(
                        input,
                        &self::test_dynamic_extensions::PACKED_EXTENSION_CODEC,
                    )?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(scalar_extension) = self.scalar_extension_option() {
                size += 2;
                size += ::protrust::io::sizes::fixed32(*scalar_extension);
            }
            if let ::std::option::Option::Some(enum_extension) = self.enum_extension_option() {
                size += 2;
                size += ::protrust::io::sizes::enum_value(*enum_extension);
            }
            if let ::std::option::Option::Some(dynamic_enum_extension) =
                self.dynamic_enum_extension_option()
            {
                size += 2;
                size += ::protrust::io::sizes::enum_value(*dynamic_enum_extension);
            }
            if let ::std::option::Option::Some(message_extension) = self.message_extension() {
                size += 2;
                size += ::protrust::io::sizes::message(message_extension);
            }
            if let ::std::option::Option::Some(dynamic_message_extension) =
                self.dynamic_message_extension()
            {
                size += 2;
                size += ::protrust::io::sizes::message(dynamic_message_extension);
            }
            size += self
                .repeated_extension()
                .calculate_size(&self::test_dynamic_extensions::REPEATED_EXTENSION_CODEC);
            size += self
                .packed_extension()
                .calculate_size(&self::test_dynamic_extensions::PACKED_EXTENSION_CODEC);
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(scalar_extension) = self.scalar_extension_option() {
                output.write_raw_tag_bytes(&[133, 125])?;
                output.write_fixed32(*scalar_extension)?;
            }
            if let ::std::option::Option::Some(enum_extension) = self.enum_extension_option() {
                output.write_raw_tag_bytes(&[136, 125])?;
                output.write_enum_value(*enum_extension)?;
            }
            if let ::std::option::Option::Some(dynamic_enum_extension) =
                self.dynamic_enum_extension_option()
            {
                output.write_raw_tag_bytes(&[144, 125])?;
                output.write_enum_value(*dynamic_enum_extension)?;
            }
            if let ::std::option::Option::Some(message_extension) = self.message_extension() {
                output.write_raw_tag_bytes(&[154, 125])?;
                output.write_message(message_extension)?;
            }
            if let ::std::option::Option::Some(dynamic_message_extension) =
                self.dynamic_message_extension()
            {
                output.write_raw_tag_bytes(&[162, 125])?;
                output.write_message(dynamic_message_extension)?;
            }
            self.repeated_extension().write_to(
                output,
                &self::test_dynamic_extensions::REPEATED_EXTENSION_CODEC,
            )?;
            self.packed_extension().write_to(
                output,
                &self::test_dynamic_extensions::PACKED_EXTENSION_CODEC,
            )?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(message_extension) = self.message_extension() {
                if !::protrust::CodedMessage::is_initialized(message_extension) {
                    return false;
                }
            }
            if let ::std::option::Option::Some(dynamic_message_extension) =
                self.dynamic_message_extension()
            {
                if !::protrust::CodedMessage::is_initialized(dynamic_message_extension) {
                    return false;
                }
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestDynamicExtensions {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(scalar_extension) = other.scalar_extension_option() {
                self.set_scalar_extension(*scalar_extension);
            }
            if let ::std::option::Option::Some(enum_extension) = other.enum_extension_option() {
                self.set_enum_extension(*enum_extension);
            }
            if let ::std::option::Option::Some(dynamic_enum_extension) =
                other.dynamic_enum_extension_option()
            {
                self.set_dynamic_enum_extension(*dynamic_enum_extension);
            }
            if let ::std::option::Option::Some(message_extension) = &other.message_extension() {
                ::protrust::LiteMessage::merge(self.message_extension_mut(), message_extension);
            }
            if let ::std::option::Option::Some(dynamic_message_extension) =
                &other.dynamic_message_extension()
            {
                ::protrust::LiteMessage::merge(
                    self.dynamic_message_extension_mut(),
                    dynamic_message_extension,
                );
            }
            self.repeated_extension.merge(&other.repeated_extension);
            self.packed_extension.merge(&other.packed_extension);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestDynamicExtensions {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[51]
        }
    }
    impl self::TestDynamicExtensions {
        pub const SCALAR_EXTENSION_FIELD_NUMBER: i32 = 2000;
        pub const SCALAR_EXTENSION_DEFAULT_VALUE: u32 = 0;
        pub fn scalar_extension(&self) -> u32 {
            self.scalar_extension
                .unwrap_or(Self::SCALAR_EXTENSION_DEFAULT_VALUE)
        }
        pub fn scalar_extension_option(&self) -> ::std::option::Option<&u32> {
            self.scalar_extension.as_ref()
        }
        pub fn scalar_extension_mut(&mut self) -> &mut u32 {
            self.scalar_extension
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_scalar_extension(&self) -> bool {
            self.scalar_extension.is_some()
        }
        pub fn set_scalar_extension(&mut self, value: u32) {
            self.scalar_extension = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_scalar_extension(&mut self) -> ::std::option::Option<u32> {
            self.scalar_extension.take()
        }
        pub fn clear_scalar_extension(&mut self) {
            self.scalar_extension = ::std::option::Option::None;
        }
        pub const ENUM_EXTENSION_FIELD_NUMBER: i32 = 2001;
        pub const ENUM_EXTENSION_DEFAULT_VALUE: ::protrust::EnumValue<self::ForeignEnum> =
            ::protrust::EnumValue::Undefined(0);
        pub fn enum_extension(&self) -> ::protrust::EnumValue<self::ForeignEnum> {
            self.enum_extension
                .unwrap_or(Self::ENUM_EXTENSION_DEFAULT_VALUE)
        }
        pub fn enum_extension_option(
            &self,
        ) -> ::std::option::Option<&::protrust::EnumValue<self::ForeignEnum>> {
            self.enum_extension.as_ref()
        }
        pub fn enum_extension_mut(&mut self) -> &mut ::protrust::EnumValue<self::ForeignEnum> {
            self.enum_extension
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_enum_extension(&self) -> bool {
            self.enum_extension.is_some()
        }
        pub fn set_enum_extension(&mut self, value: ::protrust::EnumValue<self::ForeignEnum>) {
            self.enum_extension = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_enum_extension(
            &mut self,
        ) -> ::std::option::Option<::protrust::EnumValue<self::ForeignEnum>> {
            self.enum_extension.take()
        }
        pub fn clear_enum_extension(&mut self) {
            self.enum_extension = ::std::option::Option::None;
        }
        pub const DYNAMIC_ENUM_EXTENSION_FIELD_NUMBER: i32 = 2002;
        pub const DYNAMIC_ENUM_EXTENSION_DEFAULT_VALUE: ::protrust::EnumValue<
            self::test_dynamic_extensions::DynamicEnumType,
        > = ::protrust::EnumValue::Undefined(0);
        pub fn dynamic_enum_extension(
            &self,
        ) -> ::protrust::EnumValue<self::test_dynamic_extensions::DynamicEnumType> {
            self.dynamic_enum_extension
                .unwrap_or(Self::DYNAMIC_ENUM_EXTENSION_DEFAULT_VALUE)
        }
        pub fn dynamic_enum_extension_option(
            &self,
        ) -> ::std::option::Option<
            &::protrust::EnumValue<self::test_dynamic_extensions::DynamicEnumType>,
        > {
            self.dynamic_enum_extension.as_ref()
        }
        pub fn dynamic_enum_extension_mut(
            &mut self,
        ) -> &mut ::protrust::EnumValue<self::test_dynamic_extensions::DynamicEnumType> {
            self.dynamic_enum_extension
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dynamic_enum_extension(&self) -> bool {
            self.dynamic_enum_extension.is_some()
        }
        pub fn set_dynamic_enum_extension(
            &mut self,
            value: ::protrust::EnumValue<self::test_dynamic_extensions::DynamicEnumType>,
        ) {
            self.dynamic_enum_extension =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dynamic_enum_extension(
            &mut self,
        ) -> ::std::option::Option<
            ::protrust::EnumValue<self::test_dynamic_extensions::DynamicEnumType>,
        > {
            self.dynamic_enum_extension.take()
        }
        pub fn clear_dynamic_enum_extension(&mut self) {
            self.dynamic_enum_extension = ::std::option::Option::None;
        }
        pub const MESSAGE_EXTENSION_FIELD_NUMBER: i32 = 2003;
        pub fn message_extension(&self) -> ::std::option::Option<&self::ForeignMessage> {
            self.message_extension.as_ref().map(|v| &**v)
        }
        pub fn message_extension_mut(&mut self) -> &mut self::ForeignMessage {
            self.message_extension
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_message_extension(&self) -> bool {
            self.message_extension.is_some()
        }
        pub fn set_message_extension(&mut self, value: self::ForeignMessage) {
            self.message_extension = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_message_extension(&mut self) -> ::std::option::Option<self::ForeignMessage> {
            self.message_extension.take().map(|v| *v)
        }
        pub fn clear_message_extension(&mut self) {
            self.message_extension = ::std::option::Option::None;
        }
        pub const DYNAMIC_MESSAGE_EXTENSION_FIELD_NUMBER: i32 = 2004;
        pub fn dynamic_message_extension(
            &self,
        ) -> ::std::option::Option<&self::test_dynamic_extensions::DynamicMessageType> {
            self.dynamic_message_extension.as_ref().map(|v| &**v)
        }
        pub fn dynamic_message_extension_mut(
            &mut self,
        ) -> &mut self::test_dynamic_extensions::DynamicMessageType {
            self.dynamic_message_extension
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_dynamic_message_extension(&self) -> bool {
            self.dynamic_message_extension.is_some()
        }
        pub fn set_dynamic_message_extension(
            &mut self,
            value: self::test_dynamic_extensions::DynamicMessageType,
        ) {
            self.dynamic_message_extension =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_dynamic_message_extension(
            &mut self,
        ) -> ::std::option::Option<self::test_dynamic_extensions::DynamicMessageType> {
            self.dynamic_message_extension.take().map(|v| *v)
        }
        pub fn clear_dynamic_message_extension(&mut self) {
            self.dynamic_message_extension = ::std::option::Option::None;
        }
        pub const REPEATED_EXTENSION_FIELD_NUMBER: i32 = 2005;
        pub fn repeated_extension(
            &self,
        ) -> &::protrust::collections::RepeatedField<::std::string::String> {
            &self.repeated_extension
        }
        pub fn repeated_extension_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<::std::string::String> {
            &mut self.repeated_extension
        }
        pub const PACKED_EXTENSION_FIELD_NUMBER: i32 = 2006;
        pub fn packed_extension(&self) -> &::protrust::collections::RepeatedField<i32> {
            &self.packed_extension
        }
        pub fn packed_extension_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
            &mut self.packed_extension
        }
    }
    pub mod test_dynamic_extensions {
        #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
        pub enum DynamicEnumType {
            DynamicFoo,
            DynamicBar,
            DynamicBaz,
        }
        impl ::protrust::Enum for self::DynamicEnumType {
            fn descriptor() -> &'static ::protrust::reflect::EnumDescriptor<'static> {
                &<self::super::TestDynamicExtensions as ::protrust::Message>::descriptor().enums()
                    [0]
            }
        }
        impl ::std::convert::TryFrom<i32> for self::DynamicEnumType {
            type Error = ::protrust::VariantUndefinedError;
            fn try_from(
                value: i32,
            ) -> ::std::result::Result<Self, ::protrust::VariantUndefinedError> {
                #[allow(unreachable_patterns)]
                match value {
                    2200 => ::std::result::Result::Ok(self::DynamicEnumType::DynamicFoo),
                    2201 => ::std::result::Result::Ok(self::DynamicEnumType::DynamicBar),
                    2202 => ::std::result::Result::Ok(self::DynamicEnumType::DynamicBaz),
                    _ => ::std::result::Result::Err(::protrust::VariantUndefinedError),
                }
            }
        }
        impl ::std::convert::From<self::DynamicEnumType> for i32 {
            fn from(value: self::DynamicEnumType) -> i32 {
                match value {
                    self::DynamicEnumType::DynamicFoo => 2200,
                    self::DynamicEnumType::DynamicBar => 2201,
                    self::DynamicEnumType::DynamicBaz => 2202,
                }
            }
        }
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct DynamicMessageType {
            dynamic_field: ::std::option::Option<i32>,
            unknown_fields: ::protrust::UnknownFieldSet,
        }
        impl ::protrust::CodedMessage for self::DynamicMessageType {
            fn merge_from(
                &mut self,
                input: &mut ::protrust::io::CodedInput,
            ) -> ::protrust::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        16800 | 16802 => self.set_dynamic_field(input.read_int32()?),
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> i32 {
                let mut size = 0i32;
                if let ::std::option::Option::Some(dynamic_field) = self.dynamic_field_option() {
                    size += 3;
                    size += ::protrust::io::sizes::int32(*dynamic_field);
                }
                size += self.unknown_fields.calculate_size();
                size
            }
            fn write_to(
                &self,
                output: &mut ::protrust::io::CodedOutput,
            ) -> ::protrust::io::OutputResult {
                if let ::std::option::Option::Some(dynamic_field) = self.dynamic_field_option() {
                    output.write_raw_tag_bytes(&[160, 131, 1])?;
                    output.write_int32(*dynamic_field)?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                true
            }
        }
        impl ::protrust::LiteMessage for self::DynamicMessageType {
            fn merge(&mut self, other: &Self) {
                if let ::std::option::Option::Some(dynamic_field) = other.dynamic_field_option() {
                    self.set_dynamic_field(*dynamic_field);
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl ::protrust::Message for self::DynamicMessageType {
            fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
                &<self::super::TestDynamicExtensions as ::protrust::Message>::descriptor()
                    .messages()[0]
            }
        }
        impl self::DynamicMessageType {
            pub const DYNAMIC_FIELD_FIELD_NUMBER: i32 = 2100;
            pub const DYNAMIC_FIELD_DEFAULT_VALUE: i32 = 0;
            pub fn dynamic_field(&self) -> i32 {
                self.dynamic_field
                    .unwrap_or(Self::DYNAMIC_FIELD_DEFAULT_VALUE)
            }
            pub fn dynamic_field_option(&self) -> ::std::option::Option<&i32> {
                self.dynamic_field.as_ref()
            }
            pub fn dynamic_field_mut(&mut self) -> &mut i32 {
                self.dynamic_field
                    .get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_dynamic_field(&self) -> bool {
                self.dynamic_field.is_some()
            }
            pub fn set_dynamic_field(&mut self, value: i32) {
                self.dynamic_field = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_dynamic_field(&mut self) -> ::std::option::Option<i32> {
                self.dynamic_field.take()
            }
            pub fn clear_dynamic_field(&mut self) {
                self.dynamic_field = ::std::option::Option::None;
            }
        }
        pub(in super::super::super) mod dynamic_message_type {
            pub(in super::super::super) static DYNAMIC_FIELD_REFLECTOR:
                ::protrust::reflect::access::VerboseFieldAccessor<
                    self::super::DynamicMessageType,
                    i32,
                > = ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::DynamicMessageType::dynamic_field_option,
                get_mut: self::super::DynamicMessageType::dynamic_field_mut,
                set: self::super::DynamicMessageType::set_dynamic_field,
                take: self::super::DynamicMessageType::take_dynamic_field,
                clear: self::super::DynamicMessageType::clear_dynamic_field,
            };
        }
        pub(super) static REPEATED_EXTENSION_CODEC: ::protrust::Codec<::std::string::String> =
            ::protrust::Codec::string(16042);
        pub(super) static PACKED_EXTENSION_CODEC: ::protrust::Codec<i32> =
            ::protrust::Codec::sint32(16050);
        pub(in super::super) static SCALAR_EXTENSION_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestDynamicExtensions,
                u32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestDynamicExtensions::scalar_extension_option,
            get_mut: self::super::TestDynamicExtensions::scalar_extension_mut,
            set: self::super::TestDynamicExtensions::set_scalar_extension,
            take: self::super::TestDynamicExtensions::take_scalar_extension,
            clear: self::super::TestDynamicExtensions::clear_scalar_extension,
        };
        pub(in super::super) static ENUM_EXTENSION_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestDynamicExtensions,
                ::protrust::EnumValue<self::super::ForeignEnum>,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestDynamicExtensions::enum_extension_option,
            get_mut: self::super::TestDynamicExtensions::enum_extension_mut,
            set: self::super::TestDynamicExtensions::set_enum_extension,
            take: self::super::TestDynamicExtensions::take_enum_extension,
            clear: self::super::TestDynamicExtensions::clear_enum_extension,
        };
        pub(in super::super) static DYNAMIC_ENUM_EXTENSION_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestDynamicExtensions,
                ::protrust::EnumValue<self::DynamicEnumType>,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestDynamicExtensions::dynamic_enum_extension_option,
            get_mut: self::super::TestDynamicExtensions::dynamic_enum_extension_mut,
            set: self::super::TestDynamicExtensions::set_dynamic_enum_extension,
            take: self::super::TestDynamicExtensions::take_dynamic_enum_extension,
            clear: self::super::TestDynamicExtensions::clear_dynamic_enum_extension,
        };
        pub(in super::super) static MESSAGE_EXTENSION_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestDynamicExtensions,
                self::super::ForeignMessage,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestDynamicExtensions::message_extension,
            get_mut: self::super::TestDynamicExtensions::message_extension_mut,
            set: self::super::TestDynamicExtensions::set_message_extension,
            take: self::super::TestDynamicExtensions::take_message_extension,
            clear: self::super::TestDynamicExtensions::clear_message_extension,
        };
        pub(in super::super) static DYNAMIC_MESSAGE_EXTENSION_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestDynamicExtensions,
                self::DynamicMessageType,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestDynamicExtensions::dynamic_message_extension,
            get_mut: self::super::TestDynamicExtensions::dynamic_message_extension_mut,
            set: self::super::TestDynamicExtensions::set_dynamic_message_extension,
            take: self::super::TestDynamicExtensions::take_dynamic_message_extension,
            clear: self::super::TestDynamicExtensions::clear_dynamic_message_extension,
        };
        pub(in super::super) static REPEATED_EXTENSION_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestDynamicExtensions,
                ::protrust::collections::RepeatedField<::std::string::String>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestDynamicExtensions::repeated_extension,
            get_mut: self::super::TestDynamicExtensions::repeated_extension_mut,
        };
        pub(in super::super) static PACKED_EXTENSION_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestDynamicExtensions,
                ::protrust::collections::RepeatedField<i32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestDynamicExtensions::packed_extension,
            get_mut: self::super::TestDynamicExtensions::packed_extension_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestRepeatedScalarDifferentTagSizes {
        repeated_fixed32: ::protrust::collections::RepeatedField<u32>,
        repeated_int32: ::protrust::collections::RepeatedField<i32>,
        repeated_fixed64: ::protrust::collections::RepeatedField<u64>,
        repeated_int64: ::protrust::collections::RepeatedField<i64>,
        repeated_float: ::protrust::collections::RepeatedField<f32>,
        repeated_uint64: ::protrust::collections::RepeatedField<u64>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestRepeatedScalarDifferentTagSizes {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    101 | 98 => self.repeated_fixed32.add_entries(
                        input,
                        &self::test_repeated_scalar_different_tag_sizes::REPEATED_FIXED32_CODEC,
                    )?,
                    104 | 106 => self.repeated_int32.add_entries(
                        input,
                        &self::test_repeated_scalar_different_tag_sizes::REPEATED_INT32_CODEC,
                    )?,
                    16369 | 16370 => self.repeated_fixed64.add_entries(
                        input,
                        &self::test_repeated_scalar_different_tag_sizes::REPEATED_FIXED64_CODEC,
                    )?,
                    16376 | 16378 => self.repeated_int64.add_entries(
                        input,
                        &self::test_repeated_scalar_different_tag_sizes::REPEATED_INT64_CODEC,
                    )?,
                    2097141 | 2097138 => self.repeated_float.add_entries(
                        input,
                        &self::test_repeated_scalar_different_tag_sizes::REPEATED_FLOAT_CODEC,
                    )?,
                    2097144 | 2097146 => self.repeated_uint64.add_entries(
                        input,
                        &self::test_repeated_scalar_different_tag_sizes::REPEATED_UINT64_CODEC,
                    )?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            size += self.repeated_fixed32().calculate_size(
                &self::test_repeated_scalar_different_tag_sizes::REPEATED_FIXED32_CODEC,
            );
            size += self.repeated_int32().calculate_size(
                &self::test_repeated_scalar_different_tag_sizes::REPEATED_INT32_CODEC,
            );
            size += self.repeated_fixed64().calculate_size(
                &self::test_repeated_scalar_different_tag_sizes::REPEATED_FIXED64_CODEC,
            );
            size += self.repeated_int64().calculate_size(
                &self::test_repeated_scalar_different_tag_sizes::REPEATED_INT64_CODEC,
            );
            size += self.repeated_float().calculate_size(
                &self::test_repeated_scalar_different_tag_sizes::REPEATED_FLOAT_CODEC,
            );
            size += self.repeated_uint64().calculate_size(
                &self::test_repeated_scalar_different_tag_sizes::REPEATED_UINT64_CODEC,
            );
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            self.repeated_fixed32().write_to(
                output,
                &self::test_repeated_scalar_different_tag_sizes::REPEATED_FIXED32_CODEC,
            )?;
            self.repeated_int32().write_to(
                output,
                &self::test_repeated_scalar_different_tag_sizes::REPEATED_INT32_CODEC,
            )?;
            self.repeated_fixed64().write_to(
                output,
                &self::test_repeated_scalar_different_tag_sizes::REPEATED_FIXED64_CODEC,
            )?;
            self.repeated_int64().write_to(
                output,
                &self::test_repeated_scalar_different_tag_sizes::REPEATED_INT64_CODEC,
            )?;
            self.repeated_float().write_to(
                output,
                &self::test_repeated_scalar_different_tag_sizes::REPEATED_FLOAT_CODEC,
            )?;
            self.repeated_uint64().write_to(
                output,
                &self::test_repeated_scalar_different_tag_sizes::REPEATED_UINT64_CODEC,
            )?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestRepeatedScalarDifferentTagSizes {
        fn merge(&mut self, other: &Self) {
            self.repeated_fixed32.merge(&other.repeated_fixed32);
            self.repeated_int32.merge(&other.repeated_int32);
            self.repeated_fixed64.merge(&other.repeated_fixed64);
            self.repeated_int64.merge(&other.repeated_int64);
            self.repeated_float.merge(&other.repeated_float);
            self.repeated_uint64.merge(&other.repeated_uint64);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestRepeatedScalarDifferentTagSizes {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[52]
        }
    }
    impl self::TestRepeatedScalarDifferentTagSizes {
        pub const REPEATED_FIXED32_FIELD_NUMBER: i32 = 12;
        pub fn repeated_fixed32(&self) -> &::protrust::collections::RepeatedField<u32> {
            &self.repeated_fixed32
        }
        pub fn repeated_fixed32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u32> {
            &mut self.repeated_fixed32
        }
        pub const REPEATED_INT32_FIELD_NUMBER: i32 = 13;
        pub fn repeated_int32(&self) -> &::protrust::collections::RepeatedField<i32> {
            &self.repeated_int32
        }
        pub fn repeated_int32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
            &mut self.repeated_int32
        }
        pub const REPEATED_FIXED64_FIELD_NUMBER: i32 = 2046;
        pub fn repeated_fixed64(&self) -> &::protrust::collections::RepeatedField<u64> {
            &self.repeated_fixed64
        }
        pub fn repeated_fixed64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u64> {
            &mut self.repeated_fixed64
        }
        pub const REPEATED_INT64_FIELD_NUMBER: i32 = 2047;
        pub fn repeated_int64(&self) -> &::protrust::collections::RepeatedField<i64> {
            &self.repeated_int64
        }
        pub fn repeated_int64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
            &mut self.repeated_int64
        }
        pub const REPEATED_FLOAT_FIELD_NUMBER: i32 = 262142;
        pub fn repeated_float(&self) -> &::protrust::collections::RepeatedField<f32> {
            &self.repeated_float
        }
        pub fn repeated_float_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<f32> {
            &mut self.repeated_float
        }
        pub const REPEATED_UINT64_FIELD_NUMBER: i32 = 262143;
        pub fn repeated_uint64(&self) -> &::protrust::collections::RepeatedField<u64> {
            &self.repeated_uint64
        }
        pub fn repeated_uint64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u64> {
            &mut self.repeated_uint64
        }
    }
    pub(in super::super) mod test_repeated_scalar_different_tag_sizes {
        pub(super) static REPEATED_FIXED32_CODEC: ::protrust::Codec<u32> =
            ::protrust::Codec::fixed32(101);
        pub(super) static REPEATED_INT32_CODEC: ::protrust::Codec<i32> =
            ::protrust::Codec::int32(104);
        pub(super) static REPEATED_FIXED64_CODEC: ::protrust::Codec<u64> =
            ::protrust::Codec::fixed64(16369);
        pub(super) static REPEATED_INT64_CODEC: ::protrust::Codec<i64> =
            ::protrust::Codec::int64(16376);
        pub(super) static REPEATED_FLOAT_CODEC: ::protrust::Codec<f32> =
            ::protrust::Codec::float(2097141);
        pub(super) static REPEATED_UINT64_CODEC: ::protrust::Codec<u64> =
            ::protrust::Codec::uint64(2097144);
        pub(in super::super) static REPEATED_FIXED32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestRepeatedScalarDifferentTagSizes,
                ::protrust::collections::RepeatedField<u32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestRepeatedScalarDifferentTagSizes::repeated_fixed32,
            get_mut: self::super::TestRepeatedScalarDifferentTagSizes::repeated_fixed32_mut,
        };
        pub(in super::super) static REPEATED_INT32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestRepeatedScalarDifferentTagSizes,
                ::protrust::collections::RepeatedField<i32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestRepeatedScalarDifferentTagSizes::repeated_int32,
            get_mut: self::super::TestRepeatedScalarDifferentTagSizes::repeated_int32_mut,
        };
        pub(in super::super) static REPEATED_FIXED64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestRepeatedScalarDifferentTagSizes,
                ::protrust::collections::RepeatedField<u64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestRepeatedScalarDifferentTagSizes::repeated_fixed64,
            get_mut: self::super::TestRepeatedScalarDifferentTagSizes::repeated_fixed64_mut,
        };
        pub(in super::super) static REPEATED_INT64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestRepeatedScalarDifferentTagSizes,
                ::protrust::collections::RepeatedField<i64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestRepeatedScalarDifferentTagSizes::repeated_int64,
            get_mut: self::super::TestRepeatedScalarDifferentTagSizes::repeated_int64_mut,
        };
        pub(in super::super) static REPEATED_FLOAT_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestRepeatedScalarDifferentTagSizes,
                ::protrust::collections::RepeatedField<f32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestRepeatedScalarDifferentTagSizes::repeated_float,
            get_mut: self::super::TestRepeatedScalarDifferentTagSizes::repeated_float_mut,
        };
        pub(in super::super) static REPEATED_UINT64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestRepeatedScalarDifferentTagSizes,
                ::protrust::collections::RepeatedField<u64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestRepeatedScalarDifferentTagSizes::repeated_uint64,
            get_mut: self::super::TestRepeatedScalarDifferentTagSizes::repeated_uint64_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestParsingMerge {
        required_all_types: ::std::option::Option<::std::boxed::Box<self::TestAllTypes>>,
        optional_all_types: ::std::option::Option<::std::boxed::Box<self::TestAllTypes>>,
        repeated_all_types: ::protrust::collections::RepeatedField<self::TestAllTypes>,
        optionalgroup:
            ::std::option::Option<::std::boxed::Box<self::test_parsing_merge::OptionalGroup>>,
        repeatedgroup:
            ::protrust::collections::RepeatedField<self::test_parsing_merge::RepeatedGroup>,
        unknown_fields: ::protrust::UnknownFieldSet,
        extensions: ::protrust::ExtensionSet<Self>,
    }
    impl ::protrust::CodedMessage for self::TestParsingMerge {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => input.read_message(self.required_all_types_mut())?,
                    18 => input.read_message(self.optional_all_types_mut())?,
                    26 => self
                        .repeated_all_types
                        .add_entries(input, &self::test_parsing_merge::REPEATED_ALL_TYPES_CODEC)?,
                    83 => input.read_group(self.optionalgroup_mut())?,
                    163 => self
                        .repeatedgroup
                        .add_entries(input, &self::test_parsing_merge::REPEATEDGROUP_CODEC)?,
                    _ => {
                        if !self.extensions.merge_from(input)? {
                            self.unknown_fields.merge_from(tag, input)?
                        }
                    }
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(required_all_types) = self.required_all_types() {
                size += 1;
                size += ::protrust::io::sizes::message(required_all_types);
            }
            if let ::std::option::Option::Some(optional_all_types) = self.optional_all_types() {
                size += 1;
                size += ::protrust::io::sizes::message(optional_all_types);
            }
            size += self
                .repeated_all_types()
                .calculate_size(&self::test_parsing_merge::REPEATED_ALL_TYPES_CODEC);
            if let ::std::option::Option::Some(optionalgroup) = self.optionalgroup() {
                size += 1;
                size += ::protrust::io::sizes::group(optionalgroup);
                size += 1;
            }
            size += self
                .repeatedgroup()
                .calculate_size(&self::test_parsing_merge::REPEATEDGROUP_CODEC);
            size += self.extensions.calculate_size();
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(required_all_types) = self.required_all_types() {
                output.write_raw_tag_bytes(&[10])?;
                output.write_message(required_all_types)?;
            }
            if let ::std::option::Option::Some(optional_all_types) = self.optional_all_types() {
                output.write_raw_tag_bytes(&[18])?;
                output.write_message(optional_all_types)?;
            }
            self.repeated_all_types()
                .write_to(output, &self::test_parsing_merge::REPEATED_ALL_TYPES_CODEC)?;
            if let ::std::option::Option::Some(optionalgroup) = self.optionalgroup() {
                output.write_raw_tag_bytes(&[83])?;
                output.write_group(optionalgroup)?;
                output.write_raw_tag_bytes(&[84])?;
            }
            self.repeatedgroup()
                .write_to(output, &self::test_parsing_merge::REPEATEDGROUP_CODEC)?;
            self.extensions.write_to(output)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(required_all_types) = self.required_all_types() {
                if !::protrust::CodedMessage::is_initialized(required_all_types) {
                    return false;
                }
            } else {
                return false;
            }
            if let ::std::option::Option::Some(optional_all_types) = self.optional_all_types() {
                if !::protrust::CodedMessage::is_initialized(optional_all_types) {
                    return false;
                }
            }
            if !self.repeated_all_types.is_initialized() {
                return false;
            }
            if let ::std::option::Option::Some(optionalgroup) = self.optionalgroup() {
                if !::protrust::CodedMessage::is_initialized(optionalgroup) {
                    return false;
                }
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestParsingMerge {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(required_all_types) = &other.required_all_types() {
                ::protrust::LiteMessage::merge(self.required_all_types_mut(), required_all_types);
            }
            if let ::std::option::Option::Some(optional_all_types) = &other.optional_all_types() {
                ::protrust::LiteMessage::merge(self.optional_all_types_mut(), optional_all_types);
            }
            self.repeated_all_types.merge(&other.repeated_all_types);
            if let ::std::option::Option::Some(optionalgroup) = &other.optionalgroup() {
                ::protrust::LiteMessage::merge(self.optionalgroup_mut(), optionalgroup);
            }
            self.repeatedgroup.merge(&other.repeatedgroup);
            self.extensions.merge(&other.extensions);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::ExtendableMessage for self::TestParsingMerge {
        fn registry(&self) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> {
            self.extensions.registry()
        }
        fn replace_registry(
            &mut self,
            extensions: ::std::option::Option<&'static ::protrust::ExtensionRegistry>,
        ) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> {
            self.extensions.replace_registry(extensions)
        }
        fn has_extension<T: ::protrust::ExtensionIdentifier>(&self, extension: &'static T) -> bool {
            self.extensions.has_extension(extension)
        }
        fn has_extension_unchecked<T: ::protrust::ExtensionIdentifier>(
            &self,
            extension: &'static T,
        ) -> bool {
            self.extensions.has_extension_unchecked(extension)
        }
        fn get_value<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> Option<&V> {
            self.extensions.get_value(extension)
        }
        fn get_value_or_default<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync
                + ::std::ops::Deref<Target = L>,
            D: ::std::marker::Sync + ::std::ops::Deref<Target = L>,
            L,
        >(
            &self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> Option<&L> {
            self.extensions.get_value_or_default(extension)
        }
        fn get_repeated_value<
            V: ::std::cmp::PartialEq
                + ::std::clone::Clone
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &self,
            extension: &'static ::protrust::RepeatedExtension<Self, V>,
        ) -> Option<&::protrust::collections::RepeatedField<V>> {
            self.extensions.get_repeated_value(extension)
        }
        fn field<
            V: ::std::default::Default
                + ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> ::std::option::Option<::protrust::ExtensionField<Self, V, D>> {
            self.extensions.field(extension)
        }
        fn repeated_field<
            V: ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static ::protrust::RepeatedExtension<Self, V>,
        ) -> ::std::option::Option<::protrust::RepeatedExtensionField<Self, V>> {
            self.extensions.repeated_field(extension)
        }
    }
    impl ::protrust::Message for self::TestParsingMerge {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[53]
        }
    }
    impl self::TestParsingMerge {
        pub const REQUIRED_ALL_TYPES_FIELD_NUMBER: i32 = 1;
        pub fn required_all_types(&self) -> ::std::option::Option<&self::TestAllTypes> {
            self.required_all_types.as_ref().map(|v| &**v)
        }
        pub fn required_all_types_mut(&mut self) -> &mut self::TestAllTypes {
            self.required_all_types
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_required_all_types(&self) -> bool {
            self.required_all_types.is_some()
        }
        pub fn set_required_all_types(&mut self, value: self::TestAllTypes) {
            self.required_all_types = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_required_all_types(&mut self) -> ::std::option::Option<self::TestAllTypes> {
            self.required_all_types.take().map(|v| *v)
        }
        pub fn clear_required_all_types(&mut self) {
            self.required_all_types = ::std::option::Option::None;
        }
        pub const OPTIONAL_ALL_TYPES_FIELD_NUMBER: i32 = 2;
        pub fn optional_all_types(&self) -> ::std::option::Option<&self::TestAllTypes> {
            self.optional_all_types.as_ref().map(|v| &**v)
        }
        pub fn optional_all_types_mut(&mut self) -> &mut self::TestAllTypes {
            self.optional_all_types
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_all_types(&self) -> bool {
            self.optional_all_types.is_some()
        }
        pub fn set_optional_all_types(&mut self, value: self::TestAllTypes) {
            self.optional_all_types = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_all_types(&mut self) -> ::std::option::Option<self::TestAllTypes> {
            self.optional_all_types.take().map(|v| *v)
        }
        pub fn clear_optional_all_types(&mut self) {
            self.optional_all_types = ::std::option::Option::None;
        }
        pub const REPEATED_ALL_TYPES_FIELD_NUMBER: i32 = 3;
        pub fn repeated_all_types(
            &self,
        ) -> &::protrust::collections::RepeatedField<self::TestAllTypes> {
            &self.repeated_all_types
        }
        pub fn repeated_all_types_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<self::TestAllTypes> {
            &mut self.repeated_all_types
        }
        pub const OPTIONALGROUP_FIELD_NUMBER: i32 = 10;
        pub fn optionalgroup(
            &self,
        ) -> ::std::option::Option<&self::test_parsing_merge::OptionalGroup> {
            self.optionalgroup.as_ref().map(|v| &**v)
        }
        pub fn optionalgroup_mut(&mut self) -> &mut self::test_parsing_merge::OptionalGroup {
            self.optionalgroup
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optionalgroup(&self) -> bool {
            self.optionalgroup.is_some()
        }
        pub fn set_optionalgroup(&mut self, value: self::test_parsing_merge::OptionalGroup) {
            self.optionalgroup = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optionalgroup(
            &mut self,
        ) -> ::std::option::Option<self::test_parsing_merge::OptionalGroup> {
            self.optionalgroup.take().map(|v| *v)
        }
        pub fn clear_optionalgroup(&mut self) {
            self.optionalgroup = ::std::option::Option::None;
        }
        pub const REPEATEDGROUP_FIELD_NUMBER: i32 = 20;
        pub fn repeatedgroup(
            &self,
        ) -> &::protrust::collections::RepeatedField<self::test_parsing_merge::RepeatedGroup>
        {
            &self.repeatedgroup
        }
        pub fn repeatedgroup_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<self::test_parsing_merge::RepeatedGroup>
        {
            &mut self.repeatedgroup
        }
    }
    pub mod test_parsing_merge {
        pub static OPTIONAL_EXT: ::protrust::Extension<
            self::super::TestParsingMerge,
            self::super::TestAllTypes,
            self::super::TestAllTypes,
        > = ::protrust::Extension::message(8002);
        pub static REPEATED_EXT: ::protrust::RepeatedExtension<
            self::super::TestParsingMerge,
            self::super::TestAllTypes,
        > = ::protrust::RepeatedExtension::message(8010);
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct RepeatedFieldsGenerator {
            field1: ::protrust::collections::RepeatedField<self::super::TestAllTypes>,
            field2: ::protrust::collections::RepeatedField<self::super::TestAllTypes>,
            field3: ::protrust::collections::RepeatedField<self::super::TestAllTypes>,
            group1: ::protrust::collections::RepeatedField<self::repeated_fields_generator::Group1>,
            group2: ::protrust::collections::RepeatedField<self::repeated_fields_generator::Group2>,
            ext1: ::protrust::collections::RepeatedField<self::super::TestAllTypes>,
            ext2: ::protrust::collections::RepeatedField<self::super::TestAllTypes>,
            unknown_fields: ::protrust::UnknownFieldSet,
        }
        impl ::protrust::CodedMessage for self::RepeatedFieldsGenerator {
            fn merge_from(
                &mut self,
                input: &mut ::protrust::io::CodedInput,
            ) -> ::protrust::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        10 => self
                            .field1
                            .add_entries(input, &self::repeated_fields_generator::FIELD1_CODEC)?,
                        18 => self
                            .field2
                            .add_entries(input, &self::repeated_fields_generator::FIELD2_CODEC)?,
                        26 => self
                            .field3
                            .add_entries(input, &self::repeated_fields_generator::FIELD3_CODEC)?,
                        83 => self
                            .group1
                            .add_entries(input, &self::repeated_fields_generator::GROUP1_CODEC)?,
                        163 => self
                            .group2
                            .add_entries(input, &self::repeated_fields_generator::GROUP2_CODEC)?,
                        8002 => self
                            .ext1
                            .add_entries(input, &self::repeated_fields_generator::EXT1_CODEC)?,
                        8010 => self
                            .ext2
                            .add_entries(input, &self::repeated_fields_generator::EXT2_CODEC)?,
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> i32 {
                let mut size = 0i32;
                size += self
                    .field1()
                    .calculate_size(&self::repeated_fields_generator::FIELD1_CODEC);
                size += self
                    .field2()
                    .calculate_size(&self::repeated_fields_generator::FIELD2_CODEC);
                size += self
                    .field3()
                    .calculate_size(&self::repeated_fields_generator::FIELD3_CODEC);
                size += self
                    .group1()
                    .calculate_size(&self::repeated_fields_generator::GROUP1_CODEC);
                size += self
                    .group2()
                    .calculate_size(&self::repeated_fields_generator::GROUP2_CODEC);
                size += self
                    .ext1()
                    .calculate_size(&self::repeated_fields_generator::EXT1_CODEC);
                size += self
                    .ext2()
                    .calculate_size(&self::repeated_fields_generator::EXT2_CODEC);
                size += self.unknown_fields.calculate_size();
                size
            }
            fn write_to(
                &self,
                output: &mut ::protrust::io::CodedOutput,
            ) -> ::protrust::io::OutputResult {
                self.field1()
                    .write_to(output, &self::repeated_fields_generator::FIELD1_CODEC)?;
                self.field2()
                    .write_to(output, &self::repeated_fields_generator::FIELD2_CODEC)?;
                self.field3()
                    .write_to(output, &self::repeated_fields_generator::FIELD3_CODEC)?;
                self.group1()
                    .write_to(output, &self::repeated_fields_generator::GROUP1_CODEC)?;
                self.group2()
                    .write_to(output, &self::repeated_fields_generator::GROUP2_CODEC)?;
                self.ext1()
                    .write_to(output, &self::repeated_fields_generator::EXT1_CODEC)?;
                self.ext2()
                    .write_to(output, &self::repeated_fields_generator::EXT2_CODEC)?;
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                if !self.field1.is_initialized() {
                    return false;
                }
                if !self.field2.is_initialized() {
                    return false;
                }
                if !self.field3.is_initialized() {
                    return false;
                }
                if !self.ext1.is_initialized() {
                    return false;
                }
                if !self.ext2.is_initialized() {
                    return false;
                }
                true
            }
        }
        impl ::protrust::LiteMessage for self::RepeatedFieldsGenerator {
            fn merge(&mut self, other: &Self) {
                self.field1.merge(&other.field1);
                self.field2.merge(&other.field2);
                self.field3.merge(&other.field3);
                self.group1.merge(&other.group1);
                self.group2.merge(&other.group2);
                self.ext1.merge(&other.ext1);
                self.ext2.merge(&other.ext2);
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl ::protrust::Message for self::RepeatedFieldsGenerator {
            fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
                &<self::super::TestParsingMerge as ::protrust::Message>::descriptor().messages()[0]
            }
        }
        impl self::RepeatedFieldsGenerator {
            pub const FIELD1_FIELD_NUMBER: i32 = 1;
            pub fn field1(
                &self,
            ) -> &::protrust::collections::RepeatedField<self::super::TestAllTypes> {
                &self.field1
            }
            pub fn field1_mut(
                &mut self,
            ) -> &mut ::protrust::collections::RepeatedField<self::super::TestAllTypes>
            {
                &mut self.field1
            }
            pub const FIELD2_FIELD_NUMBER: i32 = 2;
            pub fn field2(
                &self,
            ) -> &::protrust::collections::RepeatedField<self::super::TestAllTypes> {
                &self.field2
            }
            pub fn field2_mut(
                &mut self,
            ) -> &mut ::protrust::collections::RepeatedField<self::super::TestAllTypes>
            {
                &mut self.field2
            }
            pub const FIELD3_FIELD_NUMBER: i32 = 3;
            pub fn field3(
                &self,
            ) -> &::protrust::collections::RepeatedField<self::super::TestAllTypes> {
                &self.field3
            }
            pub fn field3_mut(
                &mut self,
            ) -> &mut ::protrust::collections::RepeatedField<self::super::TestAllTypes>
            {
                &mut self.field3
            }
            pub const GROUP1_FIELD_NUMBER: i32 = 10;
            pub fn group1(
                &self,
            ) -> &::protrust::collections::RepeatedField<self::repeated_fields_generator::Group1>
            {
                &self.group1
            }
            pub fn group1_mut(
                &mut self,
            ) -> &mut ::protrust::collections::RepeatedField<self::repeated_fields_generator::Group1>
            {
                &mut self.group1
            }
            pub const GROUP2_FIELD_NUMBER: i32 = 20;
            pub fn group2(
                &self,
            ) -> &::protrust::collections::RepeatedField<self::repeated_fields_generator::Group2>
            {
                &self.group2
            }
            pub fn group2_mut(
                &mut self,
            ) -> &mut ::protrust::collections::RepeatedField<self::repeated_fields_generator::Group2>
            {
                &mut self.group2
            }
            pub const EXT1_FIELD_NUMBER: i32 = 1000;
            pub fn ext1(
                &self,
            ) -> &::protrust::collections::RepeatedField<self::super::TestAllTypes> {
                &self.ext1
            }
            pub fn ext1_mut(
                &mut self,
            ) -> &mut ::protrust::collections::RepeatedField<self::super::TestAllTypes>
            {
                &mut self.ext1
            }
            pub const EXT2_FIELD_NUMBER: i32 = 1001;
            pub fn ext2(
                &self,
            ) -> &::protrust::collections::RepeatedField<self::super::TestAllTypes> {
                &self.ext2
            }
            pub fn ext2_mut(
                &mut self,
            ) -> &mut ::protrust::collections::RepeatedField<self::super::TestAllTypes>
            {
                &mut self.ext2
            }
        }
        pub mod repeated_fields_generator {
            #[derive(Clone, Debug, PartialEq, Default)]
            pub struct Group1 {
                field1: ::std::option::Option<::std::boxed::Box<self::super::super::TestAllTypes>>,
                unknown_fields: ::protrust::UnknownFieldSet,
            }
            impl ::protrust::CodedMessage for self::Group1 {
                fn merge_from(
                    &mut self,
                    input: &mut ::protrust::io::CodedInput,
                ) -> ::protrust::io::InputResult<()> {
                    while let ::std::option::Option::Some(tag) = input.read_tag()? {
                        match tag.get() {
                            90 => input.read_message(self.field1_mut())?,
                            84 => break,
                            _ => self.unknown_fields.merge_from(tag, input)?,
                        }
                    }
                    ::std::result::Result::Ok(())
                }
                fn calculate_size(&self) -> i32 {
                    let mut size = 0i32;
                    if let ::std::option::Option::Some(field1) = self.field1() {
                        size += 1;
                        size += ::protrust::io::sizes::message(field1);
                    }
                    size += self.unknown_fields.calculate_size();
                    size
                }
                fn write_to(
                    &self,
                    output: &mut ::protrust::io::CodedOutput,
                ) -> ::protrust::io::OutputResult {
                    if let ::std::option::Option::Some(field1) = self.field1() {
                        output.write_raw_tag_bytes(&[90])?;
                        output.write_message(field1)?;
                    }
                    self.unknown_fields.write_to(output)?;
                    ::std::result::Result::Ok(())
                }
                fn is_initialized(&self) -> bool {
                    if let ::std::option::Option::Some(field1) = self.field1() {
                        if !::protrust::CodedMessage::is_initialized(field1) {
                            return false;
                        }
                    }
                    true
                }
            }
            impl ::protrust::LiteMessage for self::Group1 {
                fn merge(&mut self, other: &Self) {
                    if let ::std::option::Option::Some(field1) = &other.field1() {
                        ::protrust::LiteMessage::merge(self.field1_mut(), field1);
                    }
                    self.unknown_fields.merge(&other.unknown_fields);
                }
            }
            impl ::protrust::Message for self::Group1 {
                fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
                    &<self::super::RepeatedFieldsGenerator as ::protrust::Message>::descriptor()
                        .messages()[0]
                }
            }
            impl self::Group1 {
                pub const FIELD1_FIELD_NUMBER: i32 = 11;
                pub fn field1(&self) -> ::std::option::Option<&self::super::super::TestAllTypes> {
                    self.field1.as_ref().map(|v| &**v)
                }
                pub fn field1_mut(&mut self) -> &mut self::super::super::TestAllTypes {
                    self.field1
                        .get_or_insert_with(::std::default::Default::default)
                }
                pub fn has_field1(&self) -> bool {
                    self.field1.is_some()
                }
                pub fn set_field1(&mut self, value: self::super::super::TestAllTypes) {
                    self.field1 = ::std::option::Option::Some(::std::convert::From::from(value))
                }
                pub fn take_field1(
                    &mut self,
                ) -> ::std::option::Option<self::super::super::TestAllTypes> {
                    self.field1.take().map(|v| *v)
                }
                pub fn clear_field1(&mut self) {
                    self.field1 = ::std::option::Option::None;
                }
            }
            pub(in super::super::super::super) mod group1 {
                pub(in super::super::super::super) static FIELD1_REFLECTOR:
                    ::protrust::reflect::access::VerboseFieldAccessor<
                        self::super::Group1,
                        self::super::super::super::TestAllTypes,
                    > = ::protrust::reflect::access::VerboseFieldAccessor {
                    get_option: self::super::Group1::field1,
                    get_mut: self::super::Group1::field1_mut,
                    set: self::super::Group1::set_field1,
                    take: self::super::Group1::take_field1,
                    clear: self::super::Group1::clear_field1,
                };
            }
            #[derive(Clone, Debug, PartialEq, Default)]
            pub struct Group2 {
                field1: ::std::option::Option<::std::boxed::Box<self::super::super::TestAllTypes>>,
                unknown_fields: ::protrust::UnknownFieldSet,
            }
            impl ::protrust::CodedMessage for self::Group2 {
                fn merge_from(
                    &mut self,
                    input: &mut ::protrust::io::CodedInput,
                ) -> ::protrust::io::InputResult<()> {
                    while let ::std::option::Option::Some(tag) = input.read_tag()? {
                        match tag.get() {
                            170 => input.read_message(self.field1_mut())?,
                            164 => break,
                            _ => self.unknown_fields.merge_from(tag, input)?,
                        }
                    }
                    ::std::result::Result::Ok(())
                }
                fn calculate_size(&self) -> i32 {
                    let mut size = 0i32;
                    if let ::std::option::Option::Some(field1) = self.field1() {
                        size += 2;
                        size += ::protrust::io::sizes::message(field1);
                    }
                    size += self.unknown_fields.calculate_size();
                    size
                }
                fn write_to(
                    &self,
                    output: &mut ::protrust::io::CodedOutput,
                ) -> ::protrust::io::OutputResult {
                    if let ::std::option::Option::Some(field1) = self.field1() {
                        output.write_raw_tag_bytes(&[170, 1])?;
                        output.write_message(field1)?;
                    }
                    self.unknown_fields.write_to(output)?;
                    ::std::result::Result::Ok(())
                }
                fn is_initialized(&self) -> bool {
                    if let ::std::option::Option::Some(field1) = self.field1() {
                        if !::protrust::CodedMessage::is_initialized(field1) {
                            return false;
                        }
                    }
                    true
                }
            }
            impl ::protrust::LiteMessage for self::Group2 {
                fn merge(&mut self, other: &Self) {
                    if let ::std::option::Option::Some(field1) = &other.field1() {
                        ::protrust::LiteMessage::merge(self.field1_mut(), field1);
                    }
                    self.unknown_fields.merge(&other.unknown_fields);
                }
            }
            impl ::protrust::Message for self::Group2 {
                fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
                    &<self::super::RepeatedFieldsGenerator as ::protrust::Message>::descriptor()
                        .messages()[1]
                }
            }
            impl self::Group2 {
                pub const FIELD1_FIELD_NUMBER: i32 = 21;
                pub fn field1(&self) -> ::std::option::Option<&self::super::super::TestAllTypes> {
                    self.field1.as_ref().map(|v| &**v)
                }
                pub fn field1_mut(&mut self) -> &mut self::super::super::TestAllTypes {
                    self.field1
                        .get_or_insert_with(::std::default::Default::default)
                }
                pub fn has_field1(&self) -> bool {
                    self.field1.is_some()
                }
                pub fn set_field1(&mut self, value: self::super::super::TestAllTypes) {
                    self.field1 = ::std::option::Option::Some(::std::convert::From::from(value))
                }
                pub fn take_field1(
                    &mut self,
                ) -> ::std::option::Option<self::super::super::TestAllTypes> {
                    self.field1.take().map(|v| *v)
                }
                pub fn clear_field1(&mut self) {
                    self.field1 = ::std::option::Option::None;
                }
            }
            pub(in super::super::super::super) mod group2 {
                pub(in super::super::super::super) static FIELD1_REFLECTOR:
                    ::protrust::reflect::access::VerboseFieldAccessor<
                        self::super::Group2,
                        self::super::super::super::TestAllTypes,
                    > = ::protrust::reflect::access::VerboseFieldAccessor {
                    get_option: self::super::Group2::field1,
                    get_mut: self::super::Group2::field1_mut,
                    set: self::super::Group2::set_field1,
                    take: self::super::Group2::take_field1,
                    clear: self::super::Group2::clear_field1,
                };
            }
            pub(super) static FIELD1_CODEC: ::protrust::Codec<self::super::super::TestAllTypes> =
                ::protrust::Codec::message(10);
            pub(super) static FIELD2_CODEC: ::protrust::Codec<self::super::super::TestAllTypes> =
                ::protrust::Codec::message(18);
            pub(super) static FIELD3_CODEC: ::protrust::Codec<self::super::super::TestAllTypes> =
                ::protrust::Codec::message(26);
            pub(super) static GROUP1_CODEC: ::protrust::Codec<self::Group1> =
                ::protrust::Codec::group(83, 84);
            pub(super) static GROUP2_CODEC: ::protrust::Codec<self::Group2> =
                ::protrust::Codec::group(163, 164);
            pub(super) static EXT1_CODEC: ::protrust::Codec<self::super::super::TestAllTypes> =
                ::protrust::Codec::message(8002);
            pub(super) static EXT2_CODEC: ::protrust::Codec<self::super::super::TestAllTypes> =
                ::protrust::Codec::message(8010);
            pub(in super::super::super) static FIELD1_REFLECTOR:
                ::protrust::reflect::access::SimpleFieldAccessor<
                    self::super::RepeatedFieldsGenerator,
                    ::protrust::collections::RepeatedField<self::super::super::TestAllTypes>,
                > = ::protrust::reflect::access::SimpleFieldAccessor {
                get: self::super::RepeatedFieldsGenerator::field1,
                get_mut: self::super::RepeatedFieldsGenerator::field1_mut,
            };
            pub(in super::super::super) static FIELD2_REFLECTOR:
                ::protrust::reflect::access::SimpleFieldAccessor<
                    self::super::RepeatedFieldsGenerator,
                    ::protrust::collections::RepeatedField<self::super::super::TestAllTypes>,
                > = ::protrust::reflect::access::SimpleFieldAccessor {
                get: self::super::RepeatedFieldsGenerator::field2,
                get_mut: self::super::RepeatedFieldsGenerator::field2_mut,
            };
            pub(in super::super::super) static FIELD3_REFLECTOR:
                ::protrust::reflect::access::SimpleFieldAccessor<
                    self::super::RepeatedFieldsGenerator,
                    ::protrust::collections::RepeatedField<self::super::super::TestAllTypes>,
                > = ::protrust::reflect::access::SimpleFieldAccessor {
                get: self::super::RepeatedFieldsGenerator::field3,
                get_mut: self::super::RepeatedFieldsGenerator::field3_mut,
            };
            pub(in super::super::super) static GROUP1_REFLECTOR:
                ::protrust::reflect::access::SimpleFieldAccessor<
                    self::super::RepeatedFieldsGenerator,
                    ::protrust::collections::RepeatedField<self::Group1>,
                > = ::protrust::reflect::access::SimpleFieldAccessor {
                get: self::super::RepeatedFieldsGenerator::group1,
                get_mut: self::super::RepeatedFieldsGenerator::group1_mut,
            };
            pub(in super::super::super) static GROUP2_REFLECTOR:
                ::protrust::reflect::access::SimpleFieldAccessor<
                    self::super::RepeatedFieldsGenerator,
                    ::protrust::collections::RepeatedField<self::Group2>,
                > = ::protrust::reflect::access::SimpleFieldAccessor {
                get: self::super::RepeatedFieldsGenerator::group2,
                get_mut: self::super::RepeatedFieldsGenerator::group2_mut,
            };
            pub(in super::super::super) static EXT1_REFLECTOR:
                ::protrust::reflect::access::SimpleFieldAccessor<
                    self::super::RepeatedFieldsGenerator,
                    ::protrust::collections::RepeatedField<self::super::super::TestAllTypes>,
                > = ::protrust::reflect::access::SimpleFieldAccessor {
                get: self::super::RepeatedFieldsGenerator::ext1,
                get_mut: self::super::RepeatedFieldsGenerator::ext1_mut,
            };
            pub(in super::super::super) static EXT2_REFLECTOR:
                ::protrust::reflect::access::SimpleFieldAccessor<
                    self::super::RepeatedFieldsGenerator,
                    ::protrust::collections::RepeatedField<self::super::super::TestAllTypes>,
                > = ::protrust::reflect::access::SimpleFieldAccessor {
                get: self::super::RepeatedFieldsGenerator::ext2,
                get_mut: self::super::RepeatedFieldsGenerator::ext2_mut,
            };
        }
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct OptionalGroup {
            optional_group_all_types:
                ::std::option::Option<::std::boxed::Box<self::super::TestAllTypes>>,
            unknown_fields: ::protrust::UnknownFieldSet,
        }
        impl ::protrust::CodedMessage for self::OptionalGroup {
            fn merge_from(
                &mut self,
                input: &mut ::protrust::io::CodedInput,
            ) -> ::protrust::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        90 => input.read_message(self.optional_group_all_types_mut())?,
                        84 => break,
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> i32 {
                let mut size = 0i32;
                if let ::std::option::Option::Some(optional_group_all_types) =
                    self.optional_group_all_types()
                {
                    size += 1;
                    size += ::protrust::io::sizes::message(optional_group_all_types);
                }
                size += self.unknown_fields.calculate_size();
                size
            }
            fn write_to(
                &self,
                output: &mut ::protrust::io::CodedOutput,
            ) -> ::protrust::io::OutputResult {
                if let ::std::option::Option::Some(optional_group_all_types) =
                    self.optional_group_all_types()
                {
                    output.write_raw_tag_bytes(&[90])?;
                    output.write_message(optional_group_all_types)?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                if let ::std::option::Option::Some(optional_group_all_types) =
                    self.optional_group_all_types()
                {
                    if !::protrust::CodedMessage::is_initialized(optional_group_all_types) {
                        return false;
                    }
                }
                true
            }
        }
        impl ::protrust::LiteMessage for self::OptionalGroup {
            fn merge(&mut self, other: &Self) {
                if let ::std::option::Option::Some(optional_group_all_types) =
                    &other.optional_group_all_types()
                {
                    ::protrust::LiteMessage::merge(
                        self.optional_group_all_types_mut(),
                        optional_group_all_types,
                    );
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl ::protrust::Message for self::OptionalGroup {
            fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
                &<self::super::TestParsingMerge as ::protrust::Message>::descriptor().messages()[1]
            }
        }
        impl self::OptionalGroup {
            pub const OPTIONAL_GROUP_ALL_TYPES_FIELD_NUMBER: i32 = 11;
            pub fn optional_group_all_types(
                &self,
            ) -> ::std::option::Option<&self::super::TestAllTypes> {
                self.optional_group_all_types.as_ref().map(|v| &**v)
            }
            pub fn optional_group_all_types_mut(&mut self) -> &mut self::super::TestAllTypes {
                self.optional_group_all_types
                    .get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_optional_group_all_types(&self) -> bool {
                self.optional_group_all_types.is_some()
            }
            pub fn set_optional_group_all_types(&mut self, value: self::super::TestAllTypes) {
                self.optional_group_all_types =
                    ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_optional_group_all_types(
                &mut self,
            ) -> ::std::option::Option<self::super::TestAllTypes> {
                self.optional_group_all_types.take().map(|v| *v)
            }
            pub fn clear_optional_group_all_types(&mut self) {
                self.optional_group_all_types = ::std::option::Option::None;
            }
        }
        pub(in super::super::super) mod optional_group {
            pub(in super::super::super) static OPTIONAL_GROUP_ALL_TYPES_REFLECTOR:
                ::protrust::reflect::access::VerboseFieldAccessor<
                    self::super::OptionalGroup,
                    self::super::super::TestAllTypes,
                > = ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::OptionalGroup::optional_group_all_types,
                get_mut: self::super::OptionalGroup::optional_group_all_types_mut,
                set: self::super::OptionalGroup::set_optional_group_all_types,
                take: self::super::OptionalGroup::take_optional_group_all_types,
                clear: self::super::OptionalGroup::clear_optional_group_all_types,
            };
        }
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct RepeatedGroup {
            repeated_group_all_types:
                ::std::option::Option<::std::boxed::Box<self::super::TestAllTypes>>,
            unknown_fields: ::protrust::UnknownFieldSet,
        }
        impl ::protrust::CodedMessage for self::RepeatedGroup {
            fn merge_from(
                &mut self,
                input: &mut ::protrust::io::CodedInput,
            ) -> ::protrust::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        170 => input.read_message(self.repeated_group_all_types_mut())?,
                        164 => break,
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> i32 {
                let mut size = 0i32;
                if let ::std::option::Option::Some(repeated_group_all_types) =
                    self.repeated_group_all_types()
                {
                    size += 2;
                    size += ::protrust::io::sizes::message(repeated_group_all_types);
                }
                size += self.unknown_fields.calculate_size();
                size
            }
            fn write_to(
                &self,
                output: &mut ::protrust::io::CodedOutput,
            ) -> ::protrust::io::OutputResult {
                if let ::std::option::Option::Some(repeated_group_all_types) =
                    self.repeated_group_all_types()
                {
                    output.write_raw_tag_bytes(&[170, 1])?;
                    output.write_message(repeated_group_all_types)?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                if let ::std::option::Option::Some(repeated_group_all_types) =
                    self.repeated_group_all_types()
                {
                    if !::protrust::CodedMessage::is_initialized(repeated_group_all_types) {
                        return false;
                    }
                }
                true
            }
        }
        impl ::protrust::LiteMessage for self::RepeatedGroup {
            fn merge(&mut self, other: &Self) {
                if let ::std::option::Option::Some(repeated_group_all_types) =
                    &other.repeated_group_all_types()
                {
                    ::protrust::LiteMessage::merge(
                        self.repeated_group_all_types_mut(),
                        repeated_group_all_types,
                    );
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl ::protrust::Message for self::RepeatedGroup {
            fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
                &<self::super::TestParsingMerge as ::protrust::Message>::descriptor().messages()[2]
            }
        }
        impl self::RepeatedGroup {
            pub const REPEATED_GROUP_ALL_TYPES_FIELD_NUMBER: i32 = 21;
            pub fn repeated_group_all_types(
                &self,
            ) -> ::std::option::Option<&self::super::TestAllTypes> {
                self.repeated_group_all_types.as_ref().map(|v| &**v)
            }
            pub fn repeated_group_all_types_mut(&mut self) -> &mut self::super::TestAllTypes {
                self.repeated_group_all_types
                    .get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_repeated_group_all_types(&self) -> bool {
                self.repeated_group_all_types.is_some()
            }
            pub fn set_repeated_group_all_types(&mut self, value: self::super::TestAllTypes) {
                self.repeated_group_all_types =
                    ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_repeated_group_all_types(
                &mut self,
            ) -> ::std::option::Option<self::super::TestAllTypes> {
                self.repeated_group_all_types.take().map(|v| *v)
            }
            pub fn clear_repeated_group_all_types(&mut self) {
                self.repeated_group_all_types = ::std::option::Option::None;
            }
        }
        pub(in super::super::super) mod repeated_group {
            pub(in super::super::super) static REPEATED_GROUP_ALL_TYPES_REFLECTOR:
                ::protrust::reflect::access::VerboseFieldAccessor<
                    self::super::RepeatedGroup,
                    self::super::super::TestAllTypes,
                > = ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::RepeatedGroup::repeated_group_all_types,
                get_mut: self::super::RepeatedGroup::repeated_group_all_types_mut,
                set: self::super::RepeatedGroup::set_repeated_group_all_types,
                take: self::super::RepeatedGroup::take_repeated_group_all_types,
                clear: self::super::RepeatedGroup::clear_repeated_group_all_types,
            };
        }
        pub(super) static REPEATED_ALL_TYPES_CODEC: ::protrust::Codec<self::super::TestAllTypes> =
            ::protrust::Codec::message(26);
        pub(super) static REPEATEDGROUP_CODEC: ::protrust::Codec<self::RepeatedGroup> =
            ::protrust::Codec::group(163, 164);
        pub(in super::super) static REQUIRED_ALL_TYPES_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestParsingMerge,
                self::super::TestAllTypes,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestParsingMerge::required_all_types,
            get_mut: self::super::TestParsingMerge::required_all_types_mut,
            set: self::super::TestParsingMerge::set_required_all_types,
            take: self::super::TestParsingMerge::take_required_all_types,
            clear: self::super::TestParsingMerge::clear_required_all_types,
        };
        pub(in super::super) static OPTIONAL_ALL_TYPES_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestParsingMerge,
                self::super::TestAllTypes,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestParsingMerge::optional_all_types,
            get_mut: self::super::TestParsingMerge::optional_all_types_mut,
            set: self::super::TestParsingMerge::set_optional_all_types,
            take: self::super::TestParsingMerge::take_optional_all_types,
            clear: self::super::TestParsingMerge::clear_optional_all_types,
        };
        pub(in super::super) static REPEATED_ALL_TYPES_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestParsingMerge,
                ::protrust::collections::RepeatedField<self::super::TestAllTypes>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestParsingMerge::repeated_all_types,
            get_mut: self::super::TestParsingMerge::repeated_all_types_mut,
        };
        pub(in super::super) static OPTIONALGROUP_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestParsingMerge,
                self::OptionalGroup,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestParsingMerge::optionalgroup,
            get_mut: self::super::TestParsingMerge::optionalgroup_mut,
            set: self::super::TestParsingMerge::set_optionalgroup,
            take: self::super::TestParsingMerge::take_optionalgroup,
            clear: self::super::TestParsingMerge::clear_optionalgroup,
        };
        pub(in super::super) static REPEATEDGROUP_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestParsingMerge,
                ::protrust::collections::RepeatedField<self::RepeatedGroup>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestParsingMerge::repeatedgroup,
            get_mut: self::super::TestParsingMerge::repeatedgroup_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestCommentInjectionMessage {
        a: ::std::option::Option<::std::string::String>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestCommentInjectionMessage {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => self.set_a(input.read_string()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(a) = self.a_option() {
                size += 1;
                size += ::protrust::io::sizes::string(a);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(a) = self.a_option() {
                output.write_raw_tag_bytes(&[10])?;
                output.write_string(a)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestCommentInjectionMessage {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(a) = other.a_option() {
                self.set_a(::std::clone::Clone::clone(a));
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestCommentInjectionMessage {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[54]
        }
    }
    impl self::TestCommentInjectionMessage {
        pub const A_FIELD_NUMBER: i32 = 1;
        pub const A_DEFAULT_VALUE: &'static str = "*/ <- Neither should this.";
        pub fn a(&self) -> &str {
            self.a
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::A_DEFAULT_VALUE)
        }
        pub fn a_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.a.as_ref()
        }
        pub fn a_mut(&mut self) -> &mut ::std::string::String {
            self.a.get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_a(&self) -> bool {
            self.a.is_some()
        }
        pub fn set_a(&mut self, value: ::std::string::String) {
            self.a = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_a(&mut self) -> ::std::option::Option<::std::string::String> {
            self.a.take()
        }
        pub fn clear_a(&mut self) {
            self.a = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod test_comment_injection_message {
        pub(in super::super) static A_REFLECTOR: ::protrust::reflect::access::VerboseFieldAccessor<
            self::super::TestCommentInjectionMessage,
            ::std::string::String,
        > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestCommentInjectionMessage::a_option,
            get_mut: self::super::TestCommentInjectionMessage::a_mut,
            set: self::super::TestCommentInjectionMessage::set_a,
            take: self::super::TestCommentInjectionMessage::take_a,
            clear: self::super::TestCommentInjectionMessage::clear_a,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct FooRequest {
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::FooRequest {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::FooRequest {
        fn merge(&mut self, other: &Self) {
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::FooRequest {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[55]
        }
    }
    impl self::FooRequest {}
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct FooResponse {
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::FooResponse {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::FooResponse {
        fn merge(&mut self, other: &Self) {
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::FooResponse {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[56]
        }
    }
    impl self::FooResponse {}
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct FooClientMessage {
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::FooClientMessage {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::FooClientMessage {
        fn merge(&mut self, other: &Self) {
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::FooClientMessage {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[57]
        }
    }
    impl self::FooClientMessage {}
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct FooServerMessage {
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::FooServerMessage {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::FooServerMessage {
        fn merge(&mut self, other: &Self) {
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::FooServerMessage {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[58]
        }
    }
    impl self::FooServerMessage {}
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct BarRequest {
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::BarRequest {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::BarRequest {
        fn merge(&mut self, other: &Self) {
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::BarRequest {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[59]
        }
    }
    impl self::BarRequest {}
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct BarResponse {
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::BarResponse {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::BarResponse {
        fn merge(&mut self, other: &Self) {
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::BarResponse {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[60]
        }
    }
    impl self::BarResponse {}
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestJsonName {
        field_name1: ::std::option::Option<i32>,
        fieldName2: ::std::option::Option<i32>,
        FieldName3: ::std::option::Option<i32>,
        _field_name4: ::std::option::Option<i32>,
        FIELD_NAME5: ::std::option::Option<i32>,
        field_name6: ::std::option::Option<i32>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestJsonName {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.set_field_name1(input.read_int32()?),
                    16 | 18 => self.set_fieldName2(input.read_int32()?),
                    24 | 26 => self.set_FieldName3(input.read_int32()?),
                    32 | 34 => self.set__field_name4(input.read_int32()?),
                    40 | 42 => self.set_FIELD_NAME5(input.read_int32()?),
                    48 | 50 => self.set_field_name6(input.read_int32()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(field_name1) = self.field_name1_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*field_name1);
            }
            if let ::std::option::Option::Some(fieldName2) = self.fieldName2_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*fieldName2);
            }
            if let ::std::option::Option::Some(FieldName3) = self.FieldName3_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*FieldName3);
            }
            if let ::std::option::Option::Some(_field_name4) = self._field_name4_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*_field_name4);
            }
            if let ::std::option::Option::Some(FIELD_NAME5) = self.FIELD_NAME5_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*FIELD_NAME5);
            }
            if let ::std::option::Option::Some(field_name6) = self.field_name6_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*field_name6);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(field_name1) = self.field_name1_option() {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(*field_name1)?;
            }
            if let ::std::option::Option::Some(fieldName2) = self.fieldName2_option() {
                output.write_raw_tag_bytes(&[16])?;
                output.write_int32(*fieldName2)?;
            }
            if let ::std::option::Option::Some(FieldName3) = self.FieldName3_option() {
                output.write_raw_tag_bytes(&[24])?;
                output.write_int32(*FieldName3)?;
            }
            if let ::std::option::Option::Some(_field_name4) = self._field_name4_option() {
                output.write_raw_tag_bytes(&[32])?;
                output.write_int32(*_field_name4)?;
            }
            if let ::std::option::Option::Some(FIELD_NAME5) = self.FIELD_NAME5_option() {
                output.write_raw_tag_bytes(&[40])?;
                output.write_int32(*FIELD_NAME5)?;
            }
            if let ::std::option::Option::Some(field_name6) = self.field_name6_option() {
                output.write_raw_tag_bytes(&[48])?;
                output.write_int32(*field_name6)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestJsonName {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(field_name1) = other.field_name1_option() {
                self.set_field_name1(*field_name1);
            }
            if let ::std::option::Option::Some(fieldName2) = other.fieldName2_option() {
                self.set_fieldName2(*fieldName2);
            }
            if let ::std::option::Option::Some(FieldName3) = other.FieldName3_option() {
                self.set_FieldName3(*FieldName3);
            }
            if let ::std::option::Option::Some(_field_name4) = other._field_name4_option() {
                self.set__field_name4(*_field_name4);
            }
            if let ::std::option::Option::Some(FIELD_NAME5) = other.FIELD_NAME5_option() {
                self.set_FIELD_NAME5(*FIELD_NAME5);
            }
            if let ::std::option::Option::Some(field_name6) = other.field_name6_option() {
                self.set_field_name6(*field_name6);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestJsonName {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[61]
        }
    }
    impl self::TestJsonName {
        pub const FIELD_NAME1_FIELD_NUMBER: i32 = 1;
        pub const FIELD_NAME1_DEFAULT_VALUE: i32 = 0;
        pub fn field_name1(&self) -> i32 {
            self.field_name1.unwrap_or(Self::FIELD_NAME1_DEFAULT_VALUE)
        }
        pub fn field_name1_option(&self) -> ::std::option::Option<&i32> {
            self.field_name1.as_ref()
        }
        pub fn field_name1_mut(&mut self) -> &mut i32 {
            self.field_name1
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_field_name1(&self) -> bool {
            self.field_name1.is_some()
        }
        pub fn set_field_name1(&mut self, value: i32) {
            self.field_name1 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_field_name1(&mut self) -> ::std::option::Option<i32> {
            self.field_name1.take()
        }
        pub fn clear_field_name1(&mut self) {
            self.field_name1 = ::std::option::Option::None;
        }
        pub const FIELDNAME2_FIELD_NUMBER: i32 = 2;
        pub const FIELDNAME2_DEFAULT_VALUE: i32 = 0;
        pub fn fieldName2(&self) -> i32 {
            self.fieldName2.unwrap_or(Self::FIELDNAME2_DEFAULT_VALUE)
        }
        pub fn fieldName2_option(&self) -> ::std::option::Option<&i32> {
            self.fieldName2.as_ref()
        }
        pub fn fieldName2_mut(&mut self) -> &mut i32 {
            self.fieldName2
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_fieldName2(&self) -> bool {
            self.fieldName2.is_some()
        }
        pub fn set_fieldName2(&mut self, value: i32) {
            self.fieldName2 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_fieldName2(&mut self) -> ::std::option::Option<i32> {
            self.fieldName2.take()
        }
        pub fn clear_fieldName2(&mut self) {
            self.fieldName2 = ::std::option::Option::None;
        }
        pub const FIELDNAME3_FIELD_NUMBER: i32 = 3;
        pub const FIELDNAME3_DEFAULT_VALUE: i32 = 0;
        pub fn FieldName3(&self) -> i32 {
            self.FieldName3.unwrap_or(Self::FIELDNAME3_DEFAULT_VALUE)
        }
        pub fn FieldName3_option(&self) -> ::std::option::Option<&i32> {
            self.FieldName3.as_ref()
        }
        pub fn FieldName3_mut(&mut self) -> &mut i32 {
            self.FieldName3
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_FieldName3(&self) -> bool {
            self.FieldName3.is_some()
        }
        pub fn set_FieldName3(&mut self, value: i32) {
            self.FieldName3 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_FieldName3(&mut self) -> ::std::option::Option<i32> {
            self.FieldName3.take()
        }
        pub fn clear_FieldName3(&mut self) {
            self.FieldName3 = ::std::option::Option::None;
        }
        pub const _FIELD_NAME4_FIELD_NUMBER: i32 = 4;
        pub const _FIELD_NAME4_DEFAULT_VALUE: i32 = 0;
        pub fn _field_name4(&self) -> i32 {
            self._field_name4
                .unwrap_or(Self::_FIELD_NAME4_DEFAULT_VALUE)
        }
        pub fn _field_name4_option(&self) -> ::std::option::Option<&i32> {
            self._field_name4.as_ref()
        }
        pub fn _field_name4_mut(&mut self) -> &mut i32 {
            self._field_name4
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has__field_name4(&self) -> bool {
            self._field_name4.is_some()
        }
        pub fn set__field_name4(&mut self, value: i32) {
            self._field_name4 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take__field_name4(&mut self) -> ::std::option::Option<i32> {
            self._field_name4.take()
        }
        pub fn clear__field_name4(&mut self) {
            self._field_name4 = ::std::option::Option::None;
        }
        pub const FIELD_NAME5_FIELD_NUMBER: i32 = 5;
        pub const FIELD_NAME5_DEFAULT_VALUE: i32 = 0;
        pub fn FIELD_NAME5(&self) -> i32 {
            self.FIELD_NAME5.unwrap_or(Self::FIELD_NAME5_DEFAULT_VALUE)
        }
        pub fn FIELD_NAME5_option(&self) -> ::std::option::Option<&i32> {
            self.FIELD_NAME5.as_ref()
        }
        pub fn FIELD_NAME5_mut(&mut self) -> &mut i32 {
            self.FIELD_NAME5
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_FIELD_NAME5(&self) -> bool {
            self.FIELD_NAME5.is_some()
        }
        pub fn set_FIELD_NAME5(&mut self, value: i32) {
            self.FIELD_NAME5 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_FIELD_NAME5(&mut self) -> ::std::option::Option<i32> {
            self.FIELD_NAME5.take()
        }
        pub fn clear_FIELD_NAME5(&mut self) {
            self.FIELD_NAME5 = ::std::option::Option::None;
        }
        pub const FIELD_NAME6_FIELD_NUMBER: i32 = 6;
        pub const FIELD_NAME6_DEFAULT_VALUE: i32 = 0;
        pub fn field_name6(&self) -> i32 {
            self.field_name6.unwrap_or(Self::FIELD_NAME6_DEFAULT_VALUE)
        }
        pub fn field_name6_option(&self) -> ::std::option::Option<&i32> {
            self.field_name6.as_ref()
        }
        pub fn field_name6_mut(&mut self) -> &mut i32 {
            self.field_name6
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_field_name6(&self) -> bool {
            self.field_name6.is_some()
        }
        pub fn set_field_name6(&mut self, value: i32) {
            self.field_name6 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_field_name6(&mut self) -> ::std::option::Option<i32> {
            self.field_name6.take()
        }
        pub fn clear_field_name6(&mut self) {
            self.field_name6 = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod test_json_name {
        pub(in super::super) static FIELD_NAME1_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestJsonName, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestJsonName::field_name1_option,
                get_mut: self::super::TestJsonName::field_name1_mut,
                set: self::super::TestJsonName::set_field_name1,
                take: self::super::TestJsonName::take_field_name1,
                clear: self::super::TestJsonName::clear_field_name1,
            };
        pub(in super::super) static FIELDNAME2_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestJsonName, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestJsonName::fieldName2_option,
                get_mut: self::super::TestJsonName::fieldName2_mut,
                set: self::super::TestJsonName::set_fieldName2,
                take: self::super::TestJsonName::take_fieldName2,
                clear: self::super::TestJsonName::clear_fieldName2,
            };
        pub(in super::super) static FIELDNAME3_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestJsonName, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestJsonName::FieldName3_option,
                get_mut: self::super::TestJsonName::FieldName3_mut,
                set: self::super::TestJsonName::set_FieldName3,
                take: self::super::TestJsonName::take_FieldName3,
                clear: self::super::TestJsonName::clear_FieldName3,
            };
        pub(in super::super) static _FIELD_NAME4_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestJsonName, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestJsonName::_field_name4_option,
                get_mut: self::super::TestJsonName::_field_name4_mut,
                set: self::super::TestJsonName::set__field_name4,
                take: self::super::TestJsonName::take__field_name4,
                clear: self::super::TestJsonName::clear__field_name4,
            };
        pub(in super::super) static FIELD_NAME5_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestJsonName, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestJsonName::FIELD_NAME5_option,
                get_mut: self::super::TestJsonName::FIELD_NAME5_mut,
                set: self::super::TestJsonName::set_FIELD_NAME5,
                take: self::super::TestJsonName::take_FIELD_NAME5,
                clear: self::super::TestJsonName::clear_FIELD_NAME5,
            };
        pub(in super::super) static FIELD_NAME6_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestJsonName, i32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestJsonName::field_name6_option,
                get_mut: self::super::TestJsonName::field_name6_mut,
                set: self::super::TestJsonName::set_field_name6,
                take: self::super::TestJsonName::take_field_name6,
                clear: self::super::TestJsonName::clear_field_name6,
            };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestHugeFieldNumbers {
        optional_int32: ::std::option::Option<i32>,
        fixed_32: ::std::option::Option<i32>,
        repeated_int32: ::protrust::collections::RepeatedField<i32>,
        packed_int32: ::protrust::collections::RepeatedField<i32>,
        optional_enum: ::std::option::Option<::protrust::EnumValue<self::ForeignEnum>>,
        optional_string: ::std::option::Option<::std::string::String>,
        optional_bytes: ::std::option::Option<::std::vec::Vec<u8>>,
        optional_message: ::std::option::Option<::std::boxed::Box<self::ForeignMessage>>,
        optionalgroup:
            ::std::option::Option<::std::boxed::Box<self::test_huge_field_numbers::OptionalGroup>>,
        string_string_map:
            ::protrust::collections::MapField<::std::string::String, ::std::string::String>,
        oneof_field: self::test_huge_field_numbers::OneofField,
        unknown_fields: ::protrust::UnknownFieldSet,
        extensions: ::protrust::ExtensionSet<Self>,
    }
    impl ::protrust::CodedMessage for self::TestHugeFieldNumbers {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    4294960000 | 4294960002 => self.set_optional_int32(input.read_int32()?),
                    4294960008 | 4294960010 => self.set_fixed_32(input.read_int32()?),
                    4294960016 | 4294960018 => self
                        .repeated_int32
                        .add_entries(input, &self::test_huge_field_numbers::REPEATED_INT32_CODEC)?,
                    4294960026 => self
                        .packed_int32
                        .add_entries(input, &self::test_huge_field_numbers::PACKED_INT32_CODEC)?,
                    4294960032 | 4294960034 => self.set_optional_enum(input.read_enum_value()?),
                    4294960042 => self.set_optional_string(input.read_string()?),
                    4294960050 => self.set_optional_bytes(input.read_bytes()?),
                    4294960058 => input.read_message(self.optional_message_mut())?,
                    4294960067 => input.read_group(self.optionalgroup_mut())?,
                    4294960082 => self.string_string_map.add_entries(
                        input,
                        &self::test_huge_field_numbers::STRING_STRING_MAP_CODEC,
                    )?,
                    4294960088 | 4294960090 => self.set_oneof_uint32(input.read_uint32()?),
                    4294960098 => input.read_message(self.oneof_test_all_types_mut())?,
                    4294960106 => self.set_oneof_string(input.read_string()?),
                    4294960114 => self.set_oneof_bytes(input.read_bytes()?),
                    _ => {
                        if !self.extensions.merge_from(input)? {
                            self.unknown_fields.merge_from(tag, input)?
                        }
                    }
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(optional_int32) = self.optional_int32_option() {
                size += 5;
                size += ::protrust::io::sizes::int32(*optional_int32);
            }
            if let ::std::option::Option::Some(fixed_32) = self.fixed_32_option() {
                size += 5;
                size += ::protrust::io::sizes::int32(*fixed_32);
            }
            size += self
                .repeated_int32()
                .calculate_size(&self::test_huge_field_numbers::REPEATED_INT32_CODEC);
            size += self
                .packed_int32()
                .calculate_size(&self::test_huge_field_numbers::PACKED_INT32_CODEC);
            if let ::std::option::Option::Some(optional_enum) = self.optional_enum_option() {
                size += 5;
                size += ::protrust::io::sizes::enum_value(*optional_enum);
            }
            if let ::std::option::Option::Some(optional_string) = self.optional_string_option() {
                size += 5;
                size += ::protrust::io::sizes::string(optional_string);
            }
            if let ::std::option::Option::Some(optional_bytes) = self.optional_bytes_option() {
                size += 5;
                size += ::protrust::io::sizes::bytes(optional_bytes);
            }
            if let ::std::option::Option::Some(optional_message) = self.optional_message() {
                size += 5;
                size += ::protrust::io::sizes::message(optional_message);
            }
            if let ::std::option::Option::Some(optionalgroup) = self.optionalgroup() {
                size += 5;
                size += ::protrust::io::sizes::group(optionalgroup);
                size += 5;
            }
            size += self
                .string_string_map()
                .calculate_size(&self::test_huge_field_numbers::STRING_STRING_MAP_CODEC);
            if let ::std::option::Option::Some(oneof_uint32) = self.oneof_uint32() {
                size += 5;
                size += ::protrust::io::sizes::uint32(*oneof_uint32);
            }
            if let ::std::option::Option::Some(oneof_test_all_types) = self.oneof_test_all_types() {
                size += 5;
                size += ::protrust::io::sizes::message(oneof_test_all_types);
            }
            if let ::std::option::Option::Some(oneof_string) = self.oneof_string() {
                size += 5;
                size += ::protrust::io::sizes::string(oneof_string);
            }
            if let ::std::option::Option::Some(oneof_bytes) = self.oneof_bytes() {
                size += 5;
                size += ::protrust::io::sizes::bytes(oneof_bytes);
            }
            size += self.extensions.calculate_size();
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(optional_int32) = self.optional_int32_option() {
                output.write_raw_tag_bytes(&[128, 199, 255, 255, 15])?;
                output.write_int32(*optional_int32)?;
            }
            if let ::std::option::Option::Some(fixed_32) = self.fixed_32_option() {
                output.write_raw_tag_bytes(&[136, 199, 255, 255, 15])?;
                output.write_int32(*fixed_32)?;
            }
            self.repeated_int32()
                .write_to(output, &self::test_huge_field_numbers::REPEATED_INT32_CODEC)?;
            self.packed_int32()
                .write_to(output, &self::test_huge_field_numbers::PACKED_INT32_CODEC)?;
            if let ::std::option::Option::Some(optional_enum) = self.optional_enum_option() {
                output.write_raw_tag_bytes(&[160, 199, 255, 255, 15])?;
                output.write_enum_value(*optional_enum)?;
            }
            if let ::std::option::Option::Some(optional_string) = self.optional_string_option() {
                output.write_raw_tag_bytes(&[170, 199, 255, 255, 15])?;
                output.write_string(optional_string)?;
            }
            if let ::std::option::Option::Some(optional_bytes) = self.optional_bytes_option() {
                output.write_raw_tag_bytes(&[178, 199, 255, 255, 15])?;
                output.write_bytes(optional_bytes)?;
            }
            if let ::std::option::Option::Some(optional_message) = self.optional_message() {
                output.write_raw_tag_bytes(&[186, 199, 255, 255, 15])?;
                output.write_message(optional_message)?;
            }
            if let ::std::option::Option::Some(optionalgroup) = self.optionalgroup() {
                output.write_raw_tag_bytes(&[195, 199, 255, 255, 15])?;
                output.write_group(optionalgroup)?;
                output.write_raw_tag_bytes(&[196, 199, 255, 255, 15])?;
            }
            self.string_string_map().write_to(
                output,
                &self::test_huge_field_numbers::STRING_STRING_MAP_CODEC,
            )?;
            if let ::std::option::Option::Some(oneof_uint32) = self.oneof_uint32() {
                output.write_raw_tag_bytes(&[216, 199, 255, 255, 15])?;
                output.write_uint32(*oneof_uint32)?;
            }
            if let ::std::option::Option::Some(oneof_test_all_types) = self.oneof_test_all_types() {
                output.write_raw_tag_bytes(&[226, 199, 255, 255, 15])?;
                output.write_message(oneof_test_all_types)?;
            }
            if let ::std::option::Option::Some(oneof_string) = self.oneof_string() {
                output.write_raw_tag_bytes(&[234, 199, 255, 255, 15])?;
                output.write_string(oneof_string)?;
            }
            if let ::std::option::Option::Some(oneof_bytes) = self.oneof_bytes() {
                output.write_raw_tag_bytes(&[242, 199, 255, 255, 15])?;
                output.write_bytes(oneof_bytes)?;
            }
            self.extensions.write_to(output)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(optional_message) = self.optional_message() {
                if !::protrust::CodedMessage::is_initialized(optional_message) {
                    return false;
                }
            }
            if let ::std::option::Option::Some(optionalgroup) = self.optionalgroup() {
                if !::protrust::CodedMessage::is_initialized(optionalgroup) {
                    return false;
                }
            }
            if let ::std::option::Option::Some(oneof_test_all_types) = self.oneof_test_all_types() {
                if !::protrust::CodedMessage::is_initialized(oneof_test_all_types) {
                    return false;
                }
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestHugeFieldNumbers {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(optional_int32) = other.optional_int32_option() {
                self.set_optional_int32(*optional_int32);
            }
            if let ::std::option::Option::Some(fixed_32) = other.fixed_32_option() {
                self.set_fixed_32(*fixed_32);
            }
            self.repeated_int32.merge(&other.repeated_int32);
            self.packed_int32.merge(&other.packed_int32);
            if let ::std::option::Option::Some(optional_enum) = other.optional_enum_option() {
                self.set_optional_enum(*optional_enum);
            }
            if let ::std::option::Option::Some(optional_string) = other.optional_string_option() {
                self.set_optional_string(::std::clone::Clone::clone(optional_string));
            }
            if let ::std::option::Option::Some(optional_bytes) = other.optional_bytes_option() {
                self.set_optional_bytes(::std::clone::Clone::clone(optional_bytes));
            }
            if let ::std::option::Option::Some(optional_message) = &other.optional_message() {
                ::protrust::LiteMessage::merge(self.optional_message_mut(), optional_message);
            }
            if let ::std::option::Option::Some(optionalgroup) = &other.optionalgroup() {
                ::protrust::LiteMessage::merge(self.optionalgroup_mut(), optionalgroup);
            }
            self.string_string_map.merge(&other.string_string_map);
            if let ::std::option::Option::Some(oneof_uint32) = other.oneof_uint32() {
                self.set_oneof_uint32(*oneof_uint32);
            }
            if let ::std::option::Option::Some(oneof_test_all_types) = &other.oneof_test_all_types()
            {
                ::protrust::LiteMessage::merge(
                    self.oneof_test_all_types_mut(),
                    oneof_test_all_types,
                );
            }
            if let ::std::option::Option::Some(oneof_string) = other.oneof_string() {
                self.set_oneof_string(::std::clone::Clone::clone(oneof_string));
            }
            if let ::std::option::Option::Some(oneof_bytes) = other.oneof_bytes() {
                self.set_oneof_bytes(::std::clone::Clone::clone(oneof_bytes));
            }
            self.extensions.merge(&other.extensions);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::ExtendableMessage for self::TestHugeFieldNumbers {
        fn registry(&self) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> {
            self.extensions.registry()
        }
        fn replace_registry(
            &mut self,
            extensions: ::std::option::Option<&'static ::protrust::ExtensionRegistry>,
        ) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> {
            self.extensions.replace_registry(extensions)
        }
        fn has_extension<T: ::protrust::ExtensionIdentifier>(&self, extension: &'static T) -> bool {
            self.extensions.has_extension(extension)
        }
        fn has_extension_unchecked<T: ::protrust::ExtensionIdentifier>(
            &self,
            extension: &'static T,
        ) -> bool {
            self.extensions.has_extension_unchecked(extension)
        }
        fn get_value<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> Option<&V> {
            self.extensions.get_value(extension)
        }
        fn get_value_or_default<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync
                + ::std::ops::Deref<Target = L>,
            D: ::std::marker::Sync + ::std::ops::Deref<Target = L>,
            L,
        >(
            &self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> Option<&L> {
            self.extensions.get_value_or_default(extension)
        }
        fn get_repeated_value<
            V: ::std::cmp::PartialEq
                + ::std::clone::Clone
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &self,
            extension: &'static ::protrust::RepeatedExtension<Self, V>,
        ) -> Option<&::protrust::collections::RepeatedField<V>> {
            self.extensions.get_repeated_value(extension)
        }
        fn field<
            V: ::std::default::Default
                + ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> ::std::option::Option<::protrust::ExtensionField<Self, V, D>> {
            self.extensions.field(extension)
        }
        fn repeated_field<
            V: ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static ::protrust::RepeatedExtension<Self, V>,
        ) -> ::std::option::Option<::protrust::RepeatedExtensionField<Self, V>> {
            self.extensions.repeated_field(extension)
        }
    }
    impl ::protrust::Message for self::TestHugeFieldNumbers {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[62]
        }
    }
    impl self::TestHugeFieldNumbers {
        pub const OPTIONAL_INT32_FIELD_NUMBER: i32 = 536870000;
        pub const OPTIONAL_INT32_DEFAULT_VALUE: i32 = 0;
        pub fn optional_int32(&self) -> i32 {
            self.optional_int32
                .unwrap_or(Self::OPTIONAL_INT32_DEFAULT_VALUE)
        }
        pub fn optional_int32_option(&self) -> ::std::option::Option<&i32> {
            self.optional_int32.as_ref()
        }
        pub fn optional_int32_mut(&mut self) -> &mut i32 {
            self.optional_int32
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_int32(&self) -> bool {
            self.optional_int32.is_some()
        }
        pub fn set_optional_int32(&mut self, value: i32) {
            self.optional_int32 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_int32(&mut self) -> ::std::option::Option<i32> {
            self.optional_int32.take()
        }
        pub fn clear_optional_int32(&mut self) {
            self.optional_int32 = ::std::option::Option::None;
        }
        pub const FIXED_32_FIELD_NUMBER: i32 = 536870001;
        pub const FIXED_32_DEFAULT_VALUE: i32 = 0;
        pub fn fixed_32(&self) -> i32 {
            self.fixed_32.unwrap_or(Self::FIXED_32_DEFAULT_VALUE)
        }
        pub fn fixed_32_option(&self) -> ::std::option::Option<&i32> {
            self.fixed_32.as_ref()
        }
        pub fn fixed_32_mut(&mut self) -> &mut i32 {
            self.fixed_32
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_fixed_32(&self) -> bool {
            self.fixed_32.is_some()
        }
        pub fn set_fixed_32(&mut self, value: i32) {
            self.fixed_32 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_fixed_32(&mut self) -> ::std::option::Option<i32> {
            self.fixed_32.take()
        }
        pub fn clear_fixed_32(&mut self) {
            self.fixed_32 = ::std::option::Option::None;
        }
        pub const REPEATED_INT32_FIELD_NUMBER: i32 = 536870002;
        pub fn repeated_int32(&self) -> &::protrust::collections::RepeatedField<i32> {
            &self.repeated_int32
        }
        pub fn repeated_int32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
            &mut self.repeated_int32
        }
        pub const PACKED_INT32_FIELD_NUMBER: i32 = 536870003;
        pub fn packed_int32(&self) -> &::protrust::collections::RepeatedField<i32> {
            &self.packed_int32
        }
        pub fn packed_int32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
            &mut self.packed_int32
        }
        pub const OPTIONAL_ENUM_FIELD_NUMBER: i32 = 536870004;
        pub const OPTIONAL_ENUM_DEFAULT_VALUE: ::protrust::EnumValue<self::ForeignEnum> =
            ::protrust::EnumValue::Undefined(0);
        pub fn optional_enum(&self) -> ::protrust::EnumValue<self::ForeignEnum> {
            self.optional_enum
                .unwrap_or(Self::OPTIONAL_ENUM_DEFAULT_VALUE)
        }
        pub fn optional_enum_option(
            &self,
        ) -> ::std::option::Option<&::protrust::EnumValue<self::ForeignEnum>> {
            self.optional_enum.as_ref()
        }
        pub fn optional_enum_mut(&mut self) -> &mut ::protrust::EnumValue<self::ForeignEnum> {
            self.optional_enum
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_enum(&self) -> bool {
            self.optional_enum.is_some()
        }
        pub fn set_optional_enum(&mut self, value: ::protrust::EnumValue<self::ForeignEnum>) {
            self.optional_enum = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_enum(
            &mut self,
        ) -> ::std::option::Option<::protrust::EnumValue<self::ForeignEnum>> {
            self.optional_enum.take()
        }
        pub fn clear_optional_enum(&mut self) {
            self.optional_enum = ::std::option::Option::None;
        }
        pub const OPTIONAL_STRING_FIELD_NUMBER: i32 = 536870005;
        pub const OPTIONAL_STRING_DEFAULT_VALUE: &'static str = "";
        pub fn optional_string(&self) -> &str {
            self.optional_string
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::OPTIONAL_STRING_DEFAULT_VALUE)
        }
        pub fn optional_string_option(&self) -> ::std::option::Option<&::std::string::String> {
            self.optional_string.as_ref()
        }
        pub fn optional_string_mut(&mut self) -> &mut ::std::string::String {
            self.optional_string
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_string(&self) -> bool {
            self.optional_string.is_some()
        }
        pub fn set_optional_string(&mut self, value: ::std::string::String) {
            self.optional_string = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_string(&mut self) -> ::std::option::Option<::std::string::String> {
            self.optional_string.take()
        }
        pub fn clear_optional_string(&mut self) {
            self.optional_string = ::std::option::Option::None;
        }
        pub const OPTIONAL_BYTES_FIELD_NUMBER: i32 = 536870006;
        pub const OPTIONAL_BYTES_DEFAULT_VALUE: &'static [u8] = &[];
        pub fn optional_bytes(&self) -> &[u8] {
            self.optional_bytes
                .as_ref()
                .map(|v| &**v)
                .unwrap_or(Self::OPTIONAL_BYTES_DEFAULT_VALUE)
        }
        pub fn optional_bytes_option(&self) -> ::std::option::Option<&::std::vec::Vec<u8>> {
            self.optional_bytes.as_ref()
        }
        pub fn optional_bytes_mut(&mut self) -> &mut ::std::vec::Vec<u8> {
            self.optional_bytes
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_bytes(&self) -> bool {
            self.optional_bytes.is_some()
        }
        pub fn set_optional_bytes(&mut self, value: ::std::vec::Vec<u8>) {
            self.optional_bytes = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_bytes(&mut self) -> ::std::option::Option<::std::vec::Vec<u8>> {
            self.optional_bytes.take()
        }
        pub fn clear_optional_bytes(&mut self) {
            self.optional_bytes = ::std::option::Option::None;
        }
        pub const OPTIONAL_MESSAGE_FIELD_NUMBER: i32 = 536870007;
        pub fn optional_message(&self) -> ::std::option::Option<&self::ForeignMessage> {
            self.optional_message.as_ref().map(|v| &**v)
        }
        pub fn optional_message_mut(&mut self) -> &mut self::ForeignMessage {
            self.optional_message
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_message(&self) -> bool {
            self.optional_message.is_some()
        }
        pub fn set_optional_message(&mut self, value: self::ForeignMessage) {
            self.optional_message = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_message(&mut self) -> ::std::option::Option<self::ForeignMessage> {
            self.optional_message.take().map(|v| *v)
        }
        pub fn clear_optional_message(&mut self) {
            self.optional_message = ::std::option::Option::None;
        }
        pub const OPTIONALGROUP_FIELD_NUMBER: i32 = 536870008;
        pub fn optionalgroup(
            &self,
        ) -> ::std::option::Option<&self::test_huge_field_numbers::OptionalGroup> {
            self.optionalgroup.as_ref().map(|v| &**v)
        }
        pub fn optionalgroup_mut(&mut self) -> &mut self::test_huge_field_numbers::OptionalGroup {
            self.optionalgroup
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optionalgroup(&self) -> bool {
            self.optionalgroup.is_some()
        }
        pub fn set_optionalgroup(&mut self, value: self::test_huge_field_numbers::OptionalGroup) {
            self.optionalgroup = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optionalgroup(
            &mut self,
        ) -> ::std::option::Option<self::test_huge_field_numbers::OptionalGroup> {
            self.optionalgroup.take().map(|v| *v)
        }
        pub fn clear_optionalgroup(&mut self) {
            self.optionalgroup = ::std::option::Option::None;
        }
        pub const STRING_STRING_MAP_FIELD_NUMBER: i32 = 536870010;
        pub fn string_string_map(
            &self,
        ) -> &::protrust::collections::MapField<::std::string::String, ::std::string::String>
        {
            &self.string_string_map
        }
        pub fn string_string_map_mut(
            &mut self,
        ) -> &mut ::protrust::collections::MapField<::std::string::String, ::std::string::String>
        {
            &mut self.string_string_map
        }
        pub const ONEOF_UINT32_FIELD_NUMBER: i32 = 536870011;
        pub const ONEOF_UINT32_DEFAULT_VALUE: u32 = 0;
        pub fn oneof_uint32(&self) -> ::std::option::Option<&u32> {
            match &self.oneof_field {
                self::test_huge_field_numbers::OneofField::OneofUint32(oneof_field) => {
                    ::std::option::Option::Some(oneof_field)
                }
                _ => ::std::option::Option::None,
            }
        }
        pub fn oneof_uint32_mut(&mut self) -> &mut u32 {
            match self.oneof_field {
                self::test_huge_field_numbers::OneofField::OneofUint32(_) => (),
                _ => {
                    self.oneof_field = self::test_huge_field_numbers::OneofField::OneofUint32(
                        ::std::default::Default::default(),
                    )
                }
            }
            match self.oneof_field {
                self::test_huge_field_numbers::OneofField::OneofUint32(ref mut oneof_field) => {
                    oneof_field
                }
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_oneof_uint32(&self) -> bool {
            match self.oneof_field {
                self::test_huge_field_numbers::OneofField::OneofUint32(_) => true,
                _ => false,
            }
        }
        pub fn set_oneof_uint32(&mut self, value: u32) {
            self.oneof_field = self::test_huge_field_numbers::OneofField::OneofUint32(
                ::std::convert::From::from(value),
            )
        }
        pub fn take_oneof_uint32(&mut self) -> ::std::option::Option<u32> {
            let oneof_field = ::std::mem::replace(
                &mut self.oneof_field,
                self::test_huge_field_numbers::OneofField::None,
            );
            match oneof_field {
                self::test_huge_field_numbers::OneofField::OneofUint32(oneof_field) => {
                    ::std::option::Option::Some(oneof_field)
                }
                mut oneof_field => {
                    ::std::mem::swap(&mut self.oneof_field, &mut oneof_field);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_oneof_uint32(&mut self) {
            let oneof_field = ::std::mem::replace(
                &mut self.oneof_field,
                self::test_huge_field_numbers::OneofField::None,
            );
            match oneof_field {
                self::test_huge_field_numbers::OneofField::OneofUint32(_) => {}
                mut oneof_field => ::std::mem::swap(&mut self.oneof_field, &mut oneof_field),
            }
        }
        pub const ONEOF_TEST_ALL_TYPES_FIELD_NUMBER: i32 = 536870012;
        pub fn oneof_test_all_types(&self) -> ::std::option::Option<&self::TestAllTypes> {
            match &self.oneof_field {
                self::test_huge_field_numbers::OneofField::OneofTestAllTypes(oneof_field) => {
                    ::std::option::Option::Some(&**oneof_field)
                }
                _ => ::std::option::Option::None,
            }
        }
        pub fn oneof_test_all_types_mut(&mut self) -> &mut self::TestAllTypes {
            match self.oneof_field {
                self::test_huge_field_numbers::OneofField::OneofTestAllTypes(_) => (),
                _ => {
                    self.oneof_field = self::test_huge_field_numbers::OneofField::OneofTestAllTypes(
                        ::std::default::Default::default(),
                    )
                }
            }
            match self.oneof_field {
                self::test_huge_field_numbers::OneofField::OneofTestAllTypes(
                    ref mut oneof_field,
                ) => &mut **oneof_field,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_oneof_test_all_types(&self) -> bool {
            match self.oneof_field {
                self::test_huge_field_numbers::OneofField::OneofTestAllTypes(_) => true,
                _ => false,
            }
        }
        pub fn set_oneof_test_all_types(&mut self, value: self::TestAllTypes) {
            self.oneof_field = self::test_huge_field_numbers::OneofField::OneofTestAllTypes(
                ::std::convert::From::from(value),
            )
        }
        pub fn take_oneof_test_all_types(&mut self) -> ::std::option::Option<self::TestAllTypes> {
            let oneof_field = ::std::mem::replace(
                &mut self.oneof_field,
                self::test_huge_field_numbers::OneofField::None,
            );
            match oneof_field {
                self::test_huge_field_numbers::OneofField::OneofTestAllTypes(oneof_field) => {
                    ::std::option::Option::Some(*oneof_field)
                }
                mut oneof_field => {
                    ::std::mem::swap(&mut self.oneof_field, &mut oneof_field);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_oneof_test_all_types(&mut self) {
            let oneof_field = ::std::mem::replace(
                &mut self.oneof_field,
                self::test_huge_field_numbers::OneofField::None,
            );
            match oneof_field {
                self::test_huge_field_numbers::OneofField::OneofTestAllTypes(_) => {}
                mut oneof_field => ::std::mem::swap(&mut self.oneof_field, &mut oneof_field),
            }
        }
        pub const ONEOF_STRING_FIELD_NUMBER: i32 = 536870013;
        pub const ONEOF_STRING_DEFAULT_VALUE: &'static str = "";
        pub fn oneof_string(&self) -> ::std::option::Option<&::std::string::String> {
            match &self.oneof_field {
                self::test_huge_field_numbers::OneofField::OneofString(oneof_field) => {
                    ::std::option::Option::Some(oneof_field)
                }
                _ => ::std::option::Option::None,
            }
        }
        pub fn oneof_string_mut(&mut self) -> &mut ::std::string::String {
            match self.oneof_field {
                self::test_huge_field_numbers::OneofField::OneofString(_) => (),
                _ => {
                    self.oneof_field = self::test_huge_field_numbers::OneofField::OneofString(
                        ::std::default::Default::default(),
                    )
                }
            }
            match self.oneof_field {
                self::test_huge_field_numbers::OneofField::OneofString(ref mut oneof_field) => {
                    oneof_field
                }
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_oneof_string(&self) -> bool {
            match self.oneof_field {
                self::test_huge_field_numbers::OneofField::OneofString(_) => true,
                _ => false,
            }
        }
        pub fn set_oneof_string(&mut self, value: ::std::string::String) {
            self.oneof_field = self::test_huge_field_numbers::OneofField::OneofString(
                ::std::convert::From::from(value),
            )
        }
        pub fn take_oneof_string(&mut self) -> ::std::option::Option<::std::string::String> {
            let oneof_field = ::std::mem::replace(
                &mut self.oneof_field,
                self::test_huge_field_numbers::OneofField::None,
            );
            match oneof_field {
                self::test_huge_field_numbers::OneofField::OneofString(oneof_field) => {
                    ::std::option::Option::Some(oneof_field)
                }
                mut oneof_field => {
                    ::std::mem::swap(&mut self.oneof_field, &mut oneof_field);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_oneof_string(&mut self) {
            let oneof_field = ::std::mem::replace(
                &mut self.oneof_field,
                self::test_huge_field_numbers::OneofField::None,
            );
            match oneof_field {
                self::test_huge_field_numbers::OneofField::OneofString(_) => {}
                mut oneof_field => ::std::mem::swap(&mut self.oneof_field, &mut oneof_field),
            }
        }
        pub const ONEOF_BYTES_FIELD_NUMBER: i32 = 536870014;
        pub const ONEOF_BYTES_DEFAULT_VALUE: &'static [u8] = &[];
        pub fn oneof_bytes(&self) -> ::std::option::Option<&::std::vec::Vec<u8>> {
            match &self.oneof_field {
                self::test_huge_field_numbers::OneofField::OneofBytes(oneof_field) => {
                    ::std::option::Option::Some(oneof_field)
                }
                _ => ::std::option::Option::None,
            }
        }
        pub fn oneof_bytes_mut(&mut self) -> &mut ::std::vec::Vec<u8> {
            match self.oneof_field {
                self::test_huge_field_numbers::OneofField::OneofBytes(_) => (),
                _ => {
                    self.oneof_field = self::test_huge_field_numbers::OneofField::OneofBytes(
                        ::std::default::Default::default(),
                    )
                }
            }
            match self.oneof_field {
                self::test_huge_field_numbers::OneofField::OneofBytes(ref mut oneof_field) => {
                    oneof_field
                }
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_oneof_bytes(&self) -> bool {
            match self.oneof_field {
                self::test_huge_field_numbers::OneofField::OneofBytes(_) => true,
                _ => false,
            }
        }
        pub fn set_oneof_bytes(&mut self, value: ::std::vec::Vec<u8>) {
            self.oneof_field = self::test_huge_field_numbers::OneofField::OneofBytes(
                ::std::convert::From::from(value),
            )
        }
        pub fn take_oneof_bytes(&mut self) -> ::std::option::Option<::std::vec::Vec<u8>> {
            let oneof_field = ::std::mem::replace(
                &mut self.oneof_field,
                self::test_huge_field_numbers::OneofField::None,
            );
            match oneof_field {
                self::test_huge_field_numbers::OneofField::OneofBytes(oneof_field) => {
                    ::std::option::Option::Some(oneof_field)
                }
                mut oneof_field => {
                    ::std::mem::swap(&mut self.oneof_field, &mut oneof_field);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_oneof_bytes(&mut self) {
            let oneof_field = ::std::mem::replace(
                &mut self.oneof_field,
                self::test_huge_field_numbers::OneofField::None,
            );
            match oneof_field {
                self::test_huge_field_numbers::OneofField::OneofBytes(_) => {}
                mut oneof_field => ::std::mem::swap(&mut self.oneof_field, &mut oneof_field),
            }
        }
        pub fn oneof_field(&self) -> &self::test_huge_field_numbers::OneofField {
            &self.oneof_field
        }
        pub fn oneof_field_mut(&mut self) -> &mut self::test_huge_field_numbers::OneofField {
            &mut self.oneof_field
        }
    }
    pub mod test_huge_field_numbers {
        #[derive(Clone, Debug, PartialEq)]
        pub enum OneofField {
            None,
            OneofUint32(u32),
            OneofTestAllTypes(::std::boxed::Box<self::super::TestAllTypes>),
            OneofString(::std::string::String),
            OneofBytes(::std::vec::Vec<u8>),
        }
        impl ::std::default::Default for self::OneofField {
            fn default() -> Self {
                self::OneofField::None
            }
        }
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct OptionalGroup {
            group_a: ::std::option::Option<i32>,
            unknown_fields: ::protrust::UnknownFieldSet,
        }
        impl ::protrust::CodedMessage for self::OptionalGroup {
            fn merge_from(
                &mut self,
                input: &mut ::protrust::io::CodedInput,
            ) -> ::protrust::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        4294960072 | 4294960074 => self.set_group_a(input.read_int32()?),
                        4294960068 => break,
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> i32 {
                let mut size = 0i32;
                if let ::std::option::Option::Some(group_a) = self.group_a_option() {
                    size += 5;
                    size += ::protrust::io::sizes::int32(*group_a);
                }
                size += self.unknown_fields.calculate_size();
                size
            }
            fn write_to(
                &self,
                output: &mut ::protrust::io::CodedOutput,
            ) -> ::protrust::io::OutputResult {
                if let ::std::option::Option::Some(group_a) = self.group_a_option() {
                    output.write_raw_tag_bytes(&[200, 199, 255, 255, 15])?;
                    output.write_int32(*group_a)?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                true
            }
        }
        impl ::protrust::LiteMessage for self::OptionalGroup {
            fn merge(&mut self, other: &Self) {
                if let ::std::option::Option::Some(group_a) = other.group_a_option() {
                    self.set_group_a(*group_a);
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl ::protrust::Message for self::OptionalGroup {
            fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
                &<self::super::TestHugeFieldNumbers as ::protrust::Message>::descriptor().messages()
                    [0]
            }
        }
        impl self::OptionalGroup {
            pub const GROUP_A_FIELD_NUMBER: i32 = 536870009;
            pub const GROUP_A_DEFAULT_VALUE: i32 = 0;
            pub fn group_a(&self) -> i32 {
                self.group_a.unwrap_or(Self::GROUP_A_DEFAULT_VALUE)
            }
            pub fn group_a_option(&self) -> ::std::option::Option<&i32> {
                self.group_a.as_ref()
            }
            pub fn group_a_mut(&mut self) -> &mut i32 {
                self.group_a
                    .get_or_insert_with(::std::default::Default::default)
            }
            pub fn has_group_a(&self) -> bool {
                self.group_a.is_some()
            }
            pub fn set_group_a(&mut self, value: i32) {
                self.group_a = ::std::option::Option::Some(::std::convert::From::from(value))
            }
            pub fn take_group_a(&mut self) -> ::std::option::Option<i32> {
                self.group_a.take()
            }
            pub fn clear_group_a(&mut self) {
                self.group_a = ::std::option::Option::None;
            }
        }
        pub(in super::super::super) mod optional_group {
            pub(in super::super::super) static GROUP_A_REFLECTOR:
                ::protrust::reflect::access::VerboseFieldAccessor<self::super::OptionalGroup, i32> =
                ::protrust::reflect::access::VerboseFieldAccessor {
                    get_option: self::super::OptionalGroup::group_a_option,
                    get_mut: self::super::OptionalGroup::group_a_mut,
                    set: self::super::OptionalGroup::set_group_a,
                    take: self::super::OptionalGroup::take_group_a,
                    clear: self::super::OptionalGroup::clear_group_a,
                };
        }
        pub(super) static REPEATED_INT32_CODEC: ::protrust::Codec<i32> =
            ::protrust::Codec::int32(4294960016);
        pub(super) static PACKED_INT32_CODEC: ::protrust::Codec<i32> =
            ::protrust::Codec::int32(4294960026);
        pub(super) static STRING_STRING_MAP_CODEC: ::protrust::collections::MapCodec<
            ::std::string::String,
            ::std::string::String,
        > = ::protrust::collections::MapCodec::new(
            ::protrust::Codec::string(10),
            ::protrust::Codec::string(18),
            4294960082,
        );
        pub(in super::super) static OPTIONAL_INT32_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestHugeFieldNumbers,
                i32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestHugeFieldNumbers::optional_int32_option,
            get_mut: self::super::TestHugeFieldNumbers::optional_int32_mut,
            set: self::super::TestHugeFieldNumbers::set_optional_int32,
            take: self::super::TestHugeFieldNumbers::take_optional_int32,
            clear: self::super::TestHugeFieldNumbers::clear_optional_int32,
        };
        pub(in super::super) static FIXED_32_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestHugeFieldNumbers,
                i32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestHugeFieldNumbers::fixed_32_option,
            get_mut: self::super::TestHugeFieldNumbers::fixed_32_mut,
            set: self::super::TestHugeFieldNumbers::set_fixed_32,
            take: self::super::TestHugeFieldNumbers::take_fixed_32,
            clear: self::super::TestHugeFieldNumbers::clear_fixed_32,
        };
        pub(in super::super) static REPEATED_INT32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestHugeFieldNumbers,
                ::protrust::collections::RepeatedField<i32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestHugeFieldNumbers::repeated_int32,
            get_mut: self::super::TestHugeFieldNumbers::repeated_int32_mut,
        };
        pub(in super::super) static PACKED_INT32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestHugeFieldNumbers,
                ::protrust::collections::RepeatedField<i32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestHugeFieldNumbers::packed_int32,
            get_mut: self::super::TestHugeFieldNumbers::packed_int32_mut,
        };
        pub(in super::super) static OPTIONAL_ENUM_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestHugeFieldNumbers,
                ::protrust::EnumValue<self::super::ForeignEnum>,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestHugeFieldNumbers::optional_enum_option,
            get_mut: self::super::TestHugeFieldNumbers::optional_enum_mut,
            set: self::super::TestHugeFieldNumbers::set_optional_enum,
            take: self::super::TestHugeFieldNumbers::take_optional_enum,
            clear: self::super::TestHugeFieldNumbers::clear_optional_enum,
        };
        pub(in super::super) static OPTIONAL_STRING_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestHugeFieldNumbers,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestHugeFieldNumbers::optional_string_option,
            get_mut: self::super::TestHugeFieldNumbers::optional_string_mut,
            set: self::super::TestHugeFieldNumbers::set_optional_string,
            take: self::super::TestHugeFieldNumbers::take_optional_string,
            clear: self::super::TestHugeFieldNumbers::clear_optional_string,
        };
        pub(in super::super) static OPTIONAL_BYTES_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestHugeFieldNumbers,
                ::std::vec::Vec<u8>,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestHugeFieldNumbers::optional_bytes_option,
            get_mut: self::super::TestHugeFieldNumbers::optional_bytes_mut,
            set: self::super::TestHugeFieldNumbers::set_optional_bytes,
            take: self::super::TestHugeFieldNumbers::take_optional_bytes,
            clear: self::super::TestHugeFieldNumbers::clear_optional_bytes,
        };
        pub(in super::super) static OPTIONAL_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestHugeFieldNumbers,
                self::super::ForeignMessage,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestHugeFieldNumbers::optional_message,
            get_mut: self::super::TestHugeFieldNumbers::optional_message_mut,
            set: self::super::TestHugeFieldNumbers::set_optional_message,
            take: self::super::TestHugeFieldNumbers::take_optional_message,
            clear: self::super::TestHugeFieldNumbers::clear_optional_message,
        };
        pub(in super::super) static OPTIONALGROUP_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestHugeFieldNumbers,
                self::OptionalGroup,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestHugeFieldNumbers::optionalgroup,
            get_mut: self::super::TestHugeFieldNumbers::optionalgroup_mut,
            set: self::super::TestHugeFieldNumbers::set_optionalgroup,
            take: self::super::TestHugeFieldNumbers::take_optionalgroup,
            clear: self::super::TestHugeFieldNumbers::clear_optionalgroup,
        };
        pub(in super::super) static STRING_STRING_MAP_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestHugeFieldNumbers,
                ::protrust::collections::MapField<::std::string::String, ::std::string::String>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestHugeFieldNumbers::string_string_map,
            get_mut: self::super::TestHugeFieldNumbers::string_string_map_mut,
        };
        pub(in super::super) static ONEOF_UINT32_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestHugeFieldNumbers,
                u32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestHugeFieldNumbers::oneof_uint32,
            get_mut: self::super::TestHugeFieldNumbers::oneof_uint32_mut,
            set: self::super::TestHugeFieldNumbers::set_oneof_uint32,
            take: self::super::TestHugeFieldNumbers::take_oneof_uint32,
            clear: self::super::TestHugeFieldNumbers::clear_oneof_uint32,
        };
        pub(in super::super) static ONEOF_TEST_ALL_TYPES_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestHugeFieldNumbers,
                self::super::TestAllTypes,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestHugeFieldNumbers::oneof_test_all_types,
            get_mut: self::super::TestHugeFieldNumbers::oneof_test_all_types_mut,
            set: self::super::TestHugeFieldNumbers::set_oneof_test_all_types,
            take: self::super::TestHugeFieldNumbers::take_oneof_test_all_types,
            clear: self::super::TestHugeFieldNumbers::clear_oneof_test_all_types,
        };
        pub(in super::super) static ONEOF_STRING_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestHugeFieldNumbers,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestHugeFieldNumbers::oneof_string,
            get_mut: self::super::TestHugeFieldNumbers::oneof_string_mut,
            set: self::super::TestHugeFieldNumbers::set_oneof_string,
            take: self::super::TestHugeFieldNumbers::take_oneof_string,
            clear: self::super::TestHugeFieldNumbers::clear_oneof_string,
        };
        pub(in super::super) static ONEOF_BYTES_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestHugeFieldNumbers,
                ::std::vec::Vec<u8>,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestHugeFieldNumbers::oneof_bytes,
            get_mut: self::super::TestHugeFieldNumbers::oneof_bytes_mut,
            set: self::super::TestHugeFieldNumbers::set_oneof_bytes,
            take: self::super::TestHugeFieldNumbers::take_oneof_bytes,
            clear: self::super::TestHugeFieldNumbers::clear_oneof_bytes,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestExtensionInsideTable {
        field1: ::std::option::Option<i32>,
        field2: ::std::option::Option<i32>,
        field3: ::std::option::Option<i32>,
        field4: ::std::option::Option<i32>,
        field6: ::std::option::Option<i32>,
        field7: ::std::option::Option<i32>,
        field8: ::std::option::Option<i32>,
        field9: ::std::option::Option<i32>,
        field10: ::std::option::Option<i32>,
        unknown_fields: ::protrust::UnknownFieldSet,
        extensions: ::protrust::ExtensionSet<Self>,
    }
    impl ::protrust::CodedMessage for self::TestExtensionInsideTable {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.set_field1(input.read_int32()?),
                    16 | 18 => self.set_field2(input.read_int32()?),
                    24 | 26 => self.set_field3(input.read_int32()?),
                    32 | 34 => self.set_field4(input.read_int32()?),
                    48 | 50 => self.set_field6(input.read_int32()?),
                    56 | 58 => self.set_field7(input.read_int32()?),
                    64 | 66 => self.set_field8(input.read_int32()?),
                    72 | 74 => self.set_field9(input.read_int32()?),
                    80 | 82 => self.set_field10(input.read_int32()?),
                    _ => {
                        if !self.extensions.merge_from(input)? {
                            self.unknown_fields.merge_from(tag, input)?
                        }
                    }
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(field1) = self.field1_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*field1);
            }
            if let ::std::option::Option::Some(field2) = self.field2_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*field2);
            }
            if let ::std::option::Option::Some(field3) = self.field3_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*field3);
            }
            if let ::std::option::Option::Some(field4) = self.field4_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*field4);
            }
            if let ::std::option::Option::Some(field6) = self.field6_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*field6);
            }
            if let ::std::option::Option::Some(field7) = self.field7_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*field7);
            }
            if let ::std::option::Option::Some(field8) = self.field8_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*field8);
            }
            if let ::std::option::Option::Some(field9) = self.field9_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*field9);
            }
            if let ::std::option::Option::Some(field10) = self.field10_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*field10);
            }
            size += self.extensions.calculate_size();
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(field1) = self.field1_option() {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(*field1)?;
            }
            if let ::std::option::Option::Some(field2) = self.field2_option() {
                output.write_raw_tag_bytes(&[16])?;
                output.write_int32(*field2)?;
            }
            if let ::std::option::Option::Some(field3) = self.field3_option() {
                output.write_raw_tag_bytes(&[24])?;
                output.write_int32(*field3)?;
            }
            if let ::std::option::Option::Some(field4) = self.field4_option() {
                output.write_raw_tag_bytes(&[32])?;
                output.write_int32(*field4)?;
            }
            if let ::std::option::Option::Some(field6) = self.field6_option() {
                output.write_raw_tag_bytes(&[48])?;
                output.write_int32(*field6)?;
            }
            if let ::std::option::Option::Some(field7) = self.field7_option() {
                output.write_raw_tag_bytes(&[56])?;
                output.write_int32(*field7)?;
            }
            if let ::std::option::Option::Some(field8) = self.field8_option() {
                output.write_raw_tag_bytes(&[64])?;
                output.write_int32(*field8)?;
            }
            if let ::std::option::Option::Some(field9) = self.field9_option() {
                output.write_raw_tag_bytes(&[72])?;
                output.write_int32(*field9)?;
            }
            if let ::std::option::Option::Some(field10) = self.field10_option() {
                output.write_raw_tag_bytes(&[80])?;
                output.write_int32(*field10)?;
            }
            self.extensions.write_to(output)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestExtensionInsideTable {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(field1) = other.field1_option() {
                self.set_field1(*field1);
            }
            if let ::std::option::Option::Some(field2) = other.field2_option() {
                self.set_field2(*field2);
            }
            if let ::std::option::Option::Some(field3) = other.field3_option() {
                self.set_field3(*field3);
            }
            if let ::std::option::Option::Some(field4) = other.field4_option() {
                self.set_field4(*field4);
            }
            if let ::std::option::Option::Some(field6) = other.field6_option() {
                self.set_field6(*field6);
            }
            if let ::std::option::Option::Some(field7) = other.field7_option() {
                self.set_field7(*field7);
            }
            if let ::std::option::Option::Some(field8) = other.field8_option() {
                self.set_field8(*field8);
            }
            if let ::std::option::Option::Some(field9) = other.field9_option() {
                self.set_field9(*field9);
            }
            if let ::std::option::Option::Some(field10) = other.field10_option() {
                self.set_field10(*field10);
            }
            self.extensions.merge(&other.extensions);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::ExtendableMessage for self::TestExtensionInsideTable {
        fn registry(&self) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> {
            self.extensions.registry()
        }
        fn replace_registry(
            &mut self,
            extensions: ::std::option::Option<&'static ::protrust::ExtensionRegistry>,
        ) -> ::std::option::Option<&'static ::protrust::ExtensionRegistry> {
            self.extensions.replace_registry(extensions)
        }
        fn has_extension<T: ::protrust::ExtensionIdentifier>(&self, extension: &'static T) -> bool {
            self.extensions.has_extension(extension)
        }
        fn has_extension_unchecked<T: ::protrust::ExtensionIdentifier>(
            &self,
            extension: &'static T,
        ) -> bool {
            self.extensions.has_extension_unchecked(extension)
        }
        fn get_value<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> Option<&V> {
            self.extensions.get_value(extension)
        }
        fn get_value_or_default<
            V: ::std::clone::Clone
                + std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync
                + ::std::ops::Deref<Target = L>,
            D: ::std::marker::Sync + ::std::ops::Deref<Target = L>,
            L,
        >(
            &self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> Option<&L> {
            self.extensions.get_value_or_default(extension)
        }
        fn get_repeated_value<
            V: ::std::cmp::PartialEq
                + ::std::clone::Clone
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &self,
            extension: &'static ::protrust::RepeatedExtension<Self, V>,
        ) -> Option<&::protrust::collections::RepeatedField<V>> {
            self.extensions.get_repeated_value(extension)
        }
        fn field<
            V: ::std::default::Default
                + ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
            D: ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static ::protrust::Extension<Self, V, D>,
        ) -> ::std::option::Option<::protrust::ExtensionField<Self, V, D>> {
            self.extensions.field(extension)
        }
        fn repeated_field<
            V: ::std::clone::Clone
                + ::std::cmp::PartialEq
                + ::std::fmt::Debug
                + ::std::marker::Send
                + ::std::marker::Sync,
        >(
            &mut self,
            extension: &'static ::protrust::RepeatedExtension<Self, V>,
        ) -> ::std::option::Option<::protrust::RepeatedExtensionField<Self, V>> {
            self.extensions.repeated_field(extension)
        }
    }
    impl ::protrust::Message for self::TestExtensionInsideTable {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[63]
        }
    }
    impl self::TestExtensionInsideTable {
        pub const FIELD1_FIELD_NUMBER: i32 = 1;
        pub const FIELD1_DEFAULT_VALUE: i32 = 0;
        pub fn field1(&self) -> i32 {
            self.field1.unwrap_or(Self::FIELD1_DEFAULT_VALUE)
        }
        pub fn field1_option(&self) -> ::std::option::Option<&i32> {
            self.field1.as_ref()
        }
        pub fn field1_mut(&mut self) -> &mut i32 {
            self.field1
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_field1(&self) -> bool {
            self.field1.is_some()
        }
        pub fn set_field1(&mut self, value: i32) {
            self.field1 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_field1(&mut self) -> ::std::option::Option<i32> {
            self.field1.take()
        }
        pub fn clear_field1(&mut self) {
            self.field1 = ::std::option::Option::None;
        }
        pub const FIELD2_FIELD_NUMBER: i32 = 2;
        pub const FIELD2_DEFAULT_VALUE: i32 = 0;
        pub fn field2(&self) -> i32 {
            self.field2.unwrap_or(Self::FIELD2_DEFAULT_VALUE)
        }
        pub fn field2_option(&self) -> ::std::option::Option<&i32> {
            self.field2.as_ref()
        }
        pub fn field2_mut(&mut self) -> &mut i32 {
            self.field2
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_field2(&self) -> bool {
            self.field2.is_some()
        }
        pub fn set_field2(&mut self, value: i32) {
            self.field2 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_field2(&mut self) -> ::std::option::Option<i32> {
            self.field2.take()
        }
        pub fn clear_field2(&mut self) {
            self.field2 = ::std::option::Option::None;
        }
        pub const FIELD3_FIELD_NUMBER: i32 = 3;
        pub const FIELD3_DEFAULT_VALUE: i32 = 0;
        pub fn field3(&self) -> i32 {
            self.field3.unwrap_or(Self::FIELD3_DEFAULT_VALUE)
        }
        pub fn field3_option(&self) -> ::std::option::Option<&i32> {
            self.field3.as_ref()
        }
        pub fn field3_mut(&mut self) -> &mut i32 {
            self.field3
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_field3(&self) -> bool {
            self.field3.is_some()
        }
        pub fn set_field3(&mut self, value: i32) {
            self.field3 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_field3(&mut self) -> ::std::option::Option<i32> {
            self.field3.take()
        }
        pub fn clear_field3(&mut self) {
            self.field3 = ::std::option::Option::None;
        }
        pub const FIELD4_FIELD_NUMBER: i32 = 4;
        pub const FIELD4_DEFAULT_VALUE: i32 = 0;
        pub fn field4(&self) -> i32 {
            self.field4.unwrap_or(Self::FIELD4_DEFAULT_VALUE)
        }
        pub fn field4_option(&self) -> ::std::option::Option<&i32> {
            self.field4.as_ref()
        }
        pub fn field4_mut(&mut self) -> &mut i32 {
            self.field4
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_field4(&self) -> bool {
            self.field4.is_some()
        }
        pub fn set_field4(&mut self, value: i32) {
            self.field4 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_field4(&mut self) -> ::std::option::Option<i32> {
            self.field4.take()
        }
        pub fn clear_field4(&mut self) {
            self.field4 = ::std::option::Option::None;
        }
        pub const FIELD6_FIELD_NUMBER: i32 = 6;
        pub const FIELD6_DEFAULT_VALUE: i32 = 0;
        pub fn field6(&self) -> i32 {
            self.field6.unwrap_or(Self::FIELD6_DEFAULT_VALUE)
        }
        pub fn field6_option(&self) -> ::std::option::Option<&i32> {
            self.field6.as_ref()
        }
        pub fn field6_mut(&mut self) -> &mut i32 {
            self.field6
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_field6(&self) -> bool {
            self.field6.is_some()
        }
        pub fn set_field6(&mut self, value: i32) {
            self.field6 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_field6(&mut self) -> ::std::option::Option<i32> {
            self.field6.take()
        }
        pub fn clear_field6(&mut self) {
            self.field6 = ::std::option::Option::None;
        }
        pub const FIELD7_FIELD_NUMBER: i32 = 7;
        pub const FIELD7_DEFAULT_VALUE: i32 = 0;
        pub fn field7(&self) -> i32 {
            self.field7.unwrap_or(Self::FIELD7_DEFAULT_VALUE)
        }
        pub fn field7_option(&self) -> ::std::option::Option<&i32> {
            self.field7.as_ref()
        }
        pub fn field7_mut(&mut self) -> &mut i32 {
            self.field7
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_field7(&self) -> bool {
            self.field7.is_some()
        }
        pub fn set_field7(&mut self, value: i32) {
            self.field7 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_field7(&mut self) -> ::std::option::Option<i32> {
            self.field7.take()
        }
        pub fn clear_field7(&mut self) {
            self.field7 = ::std::option::Option::None;
        }
        pub const FIELD8_FIELD_NUMBER: i32 = 8;
        pub const FIELD8_DEFAULT_VALUE: i32 = 0;
        pub fn field8(&self) -> i32 {
            self.field8.unwrap_or(Self::FIELD8_DEFAULT_VALUE)
        }
        pub fn field8_option(&self) -> ::std::option::Option<&i32> {
            self.field8.as_ref()
        }
        pub fn field8_mut(&mut self) -> &mut i32 {
            self.field8
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_field8(&self) -> bool {
            self.field8.is_some()
        }
        pub fn set_field8(&mut self, value: i32) {
            self.field8 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_field8(&mut self) -> ::std::option::Option<i32> {
            self.field8.take()
        }
        pub fn clear_field8(&mut self) {
            self.field8 = ::std::option::Option::None;
        }
        pub const FIELD9_FIELD_NUMBER: i32 = 9;
        pub const FIELD9_DEFAULT_VALUE: i32 = 0;
        pub fn field9(&self) -> i32 {
            self.field9.unwrap_or(Self::FIELD9_DEFAULT_VALUE)
        }
        pub fn field9_option(&self) -> ::std::option::Option<&i32> {
            self.field9.as_ref()
        }
        pub fn field9_mut(&mut self) -> &mut i32 {
            self.field9
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_field9(&self) -> bool {
            self.field9.is_some()
        }
        pub fn set_field9(&mut self, value: i32) {
            self.field9 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_field9(&mut self) -> ::std::option::Option<i32> {
            self.field9.take()
        }
        pub fn clear_field9(&mut self) {
            self.field9 = ::std::option::Option::None;
        }
        pub const FIELD10_FIELD_NUMBER: i32 = 10;
        pub const FIELD10_DEFAULT_VALUE: i32 = 0;
        pub fn field10(&self) -> i32 {
            self.field10.unwrap_or(Self::FIELD10_DEFAULT_VALUE)
        }
        pub fn field10_option(&self) -> ::std::option::Option<&i32> {
            self.field10.as_ref()
        }
        pub fn field10_mut(&mut self) -> &mut i32 {
            self.field10
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_field10(&self) -> bool {
            self.field10.is_some()
        }
        pub fn set_field10(&mut self, value: i32) {
            self.field10 = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_field10(&mut self) -> ::std::option::Option<i32> {
            self.field10.take()
        }
        pub fn clear_field10(&mut self) {
            self.field10 = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod test_extension_inside_table {
        pub(in super::super) static FIELD1_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtensionInsideTable,
                i32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtensionInsideTable::field1_option,
            get_mut: self::super::TestExtensionInsideTable::field1_mut,
            set: self::super::TestExtensionInsideTable::set_field1,
            take: self::super::TestExtensionInsideTable::take_field1,
            clear: self::super::TestExtensionInsideTable::clear_field1,
        };
        pub(in super::super) static FIELD2_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtensionInsideTable,
                i32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtensionInsideTable::field2_option,
            get_mut: self::super::TestExtensionInsideTable::field2_mut,
            set: self::super::TestExtensionInsideTable::set_field2,
            take: self::super::TestExtensionInsideTable::take_field2,
            clear: self::super::TestExtensionInsideTable::clear_field2,
        };
        pub(in super::super) static FIELD3_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtensionInsideTable,
                i32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtensionInsideTable::field3_option,
            get_mut: self::super::TestExtensionInsideTable::field3_mut,
            set: self::super::TestExtensionInsideTable::set_field3,
            take: self::super::TestExtensionInsideTable::take_field3,
            clear: self::super::TestExtensionInsideTable::clear_field3,
        };
        pub(in super::super) static FIELD4_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtensionInsideTable,
                i32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtensionInsideTable::field4_option,
            get_mut: self::super::TestExtensionInsideTable::field4_mut,
            set: self::super::TestExtensionInsideTable::set_field4,
            take: self::super::TestExtensionInsideTable::take_field4,
            clear: self::super::TestExtensionInsideTable::clear_field4,
        };
        pub(in super::super) static FIELD6_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtensionInsideTable,
                i32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtensionInsideTable::field6_option,
            get_mut: self::super::TestExtensionInsideTable::field6_mut,
            set: self::super::TestExtensionInsideTable::set_field6,
            take: self::super::TestExtensionInsideTable::take_field6,
            clear: self::super::TestExtensionInsideTable::clear_field6,
        };
        pub(in super::super) static FIELD7_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtensionInsideTable,
                i32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtensionInsideTable::field7_option,
            get_mut: self::super::TestExtensionInsideTable::field7_mut,
            set: self::super::TestExtensionInsideTable::set_field7,
            take: self::super::TestExtensionInsideTable::take_field7,
            clear: self::super::TestExtensionInsideTable::clear_field7,
        };
        pub(in super::super) static FIELD8_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtensionInsideTable,
                i32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtensionInsideTable::field8_option,
            get_mut: self::super::TestExtensionInsideTable::field8_mut,
            set: self::super::TestExtensionInsideTable::set_field8,
            take: self::super::TestExtensionInsideTable::take_field8,
            clear: self::super::TestExtensionInsideTable::clear_field8,
        };
        pub(in super::super) static FIELD9_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtensionInsideTable,
                i32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtensionInsideTable::field9_option,
            get_mut: self::super::TestExtensionInsideTable::field9_mut,
            set: self::super::TestExtensionInsideTable::set_field9,
            take: self::super::TestExtensionInsideTable::take_field9,
            clear: self::super::TestExtensionInsideTable::clear_field9,
        };
        pub(in super::super) static FIELD10_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestExtensionInsideTable,
                i32,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestExtensionInsideTable::field10_option,
            get_mut: self::super::TestExtensionInsideTable::field10_mut,
            set: self::super::TestExtensionInsideTable::set_field10,
            take: self::super::TestExtensionInsideTable::take_field10,
            clear: self::super::TestExtensionInsideTable::clear_field10,
        };
    }
    #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
    pub enum ForeignEnum {
        ForeignFoo,
        ForeignBar,
        ForeignBaz,
    }
    impl ::protrust::Enum for self::ForeignEnum {
        fn descriptor() -> &'static ::protrust::reflect::EnumDescriptor<'static> {
            &self::file().enums()[0]
        }
    }
    impl ::std::convert::TryFrom<i32> for self::ForeignEnum {
        type Error = ::protrust::VariantUndefinedError;
        fn try_from(value: i32) -> ::std::result::Result<Self, ::protrust::VariantUndefinedError> {
            #[allow(unreachable_patterns)]
            match value {
                4 => ::std::result::Result::Ok(self::ForeignEnum::ForeignFoo),
                5 => ::std::result::Result::Ok(self::ForeignEnum::ForeignBar),
                6 => ::std::result::Result::Ok(self::ForeignEnum::ForeignBaz),
                _ => ::std::result::Result::Err(::protrust::VariantUndefinedError),
            }
        }
    }
    impl ::std::convert::From<self::ForeignEnum> for i32 {
        fn from(value: self::ForeignEnum) -> i32 {
            match value {
                self::ForeignEnum::ForeignFoo => 4,
                self::ForeignEnum::ForeignBar => 5,
                self::ForeignEnum::ForeignBaz => 6,
            }
        }
    }
    #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
    pub enum TestEnumWithDupValue {
        Foo1,
        Bar1,
        Baz,
        Foo2,
        Bar2,
    }
    impl ::protrust::Enum for self::TestEnumWithDupValue {
        fn descriptor() -> &'static ::protrust::reflect::EnumDescriptor<'static> {
            &self::file().enums()[1]
        }
    }
    impl ::std::convert::TryFrom<i32> for self::TestEnumWithDupValue {
        type Error = ::protrust::VariantUndefinedError;
        fn try_from(value: i32) -> ::std::result::Result<Self, ::protrust::VariantUndefinedError> {
            #[allow(unreachable_patterns)]
            match value {
                1 => ::std::result::Result::Ok(self::TestEnumWithDupValue::Foo1),
                2 => ::std::result::Result::Ok(self::TestEnumWithDupValue::Bar1),
                3 => ::std::result::Result::Ok(self::TestEnumWithDupValue::Baz),
                1 => ::std::result::Result::Ok(self::TestEnumWithDupValue::Foo2),
                2 => ::std::result::Result::Ok(self::TestEnumWithDupValue::Bar2),
                _ => ::std::result::Result::Err(::protrust::VariantUndefinedError),
            }
        }
    }
    impl ::std::convert::From<self::TestEnumWithDupValue> for i32 {
        fn from(value: self::TestEnumWithDupValue) -> i32 {
            match value {
                self::TestEnumWithDupValue::Foo1 => 1,
                self::TestEnumWithDupValue::Bar1 => 2,
                self::TestEnumWithDupValue::Baz => 3,
                self::TestEnumWithDupValue::Foo2 => 1,
                self::TestEnumWithDupValue::Bar2 => 2,
            }
        }
    }
    #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
    pub enum TestSparseEnum {
        SparseA,
        SparseB,
        SparseC,
        SparseD,
        SparseE,
        SparseF,
        SparseG,
    }
    impl ::protrust::Enum for self::TestSparseEnum {
        fn descriptor() -> &'static ::protrust::reflect::EnumDescriptor<'static> {
            &self::file().enums()[2]
        }
    }
    impl ::std::convert::TryFrom<i32> for self::TestSparseEnum {
        type Error = ::protrust::VariantUndefinedError;
        fn try_from(value: i32) -> ::std::result::Result<Self, ::protrust::VariantUndefinedError> {
            #[allow(unreachable_patterns)]
            match value {
                123 => ::std::result::Result::Ok(self::TestSparseEnum::SparseA),
                62374 => ::std::result::Result::Ok(self::TestSparseEnum::SparseB),
                12589234 => ::std::result::Result::Ok(self::TestSparseEnum::SparseC),
                -15 => ::std::result::Result::Ok(self::TestSparseEnum::SparseD),
                -53452 => ::std::result::Result::Ok(self::TestSparseEnum::SparseE),
                0 => ::std::result::Result::Ok(self::TestSparseEnum::SparseF),
                2 => ::std::result::Result::Ok(self::TestSparseEnum::SparseG),
                _ => ::std::result::Result::Err(::protrust::VariantUndefinedError),
            }
        }
    }
    impl ::std::convert::From<self::TestSparseEnum> for i32 {
        fn from(value: self::TestSparseEnum) -> i32 {
            match value {
                self::TestSparseEnum::SparseA => 123,
                self::TestSparseEnum::SparseB => 62374,
                self::TestSparseEnum::SparseC => 12589234,
                self::TestSparseEnum::SparseD => -15,
                self::TestSparseEnum::SparseE => -53452,
                self::TestSparseEnum::SparseF => 0,
                self::TestSparseEnum::SparseG => 2,
            }
        }
    }
}
static UNITTEST_PROTO3_PROTO_BINARY: &'static [u8] = &[
    10, 21, 117, 110, 105, 116, 116, 101, 115, 116, 95, 112, 114, 111, 116, 111, 51, 46, 112, 114,
    111, 116, 111, 18, 15, 112, 114, 111, 116, 111, 51, 95, 117, 110, 105, 116, 116, 101, 115, 116,
    26, 21, 117, 110, 105, 116, 116, 101, 115, 116, 95, 105, 109, 112, 111, 114, 116, 46, 112, 114,
    111, 116, 111, 34, 171, 24, 10, 12, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115,
    18, 37, 10, 14, 111, 112, 116, 105, 111, 110, 97, 108, 95, 105, 110, 116, 51, 50, 24, 1, 32, 1,
    40, 5, 82, 13, 111, 112, 116, 105, 111, 110, 97, 108, 73, 110, 116, 51, 50, 18, 37, 10, 14,
    111, 112, 116, 105, 111, 110, 97, 108, 95, 105, 110, 116, 54, 52, 24, 2, 32, 1, 40, 3, 82, 13,
    111, 112, 116, 105, 111, 110, 97, 108, 73, 110, 116, 54, 52, 18, 39, 10, 15, 111, 112, 116,
    105, 111, 110, 97, 108, 95, 117, 105, 110, 116, 51, 50, 24, 3, 32, 1, 40, 13, 82, 14, 111, 112,
    116, 105, 111, 110, 97, 108, 85, 105, 110, 116, 51, 50, 18, 39, 10, 15, 111, 112, 116, 105,
    111, 110, 97, 108, 95, 117, 105, 110, 116, 54, 52, 24, 4, 32, 1, 40, 4, 82, 14, 111, 112, 116,
    105, 111, 110, 97, 108, 85, 105, 110, 116, 54, 52, 18, 39, 10, 15, 111, 112, 116, 105, 111,
    110, 97, 108, 95, 115, 105, 110, 116, 51, 50, 24, 5, 32, 1, 40, 17, 82, 14, 111, 112, 116, 105,
    111, 110, 97, 108, 83, 105, 110, 116, 51, 50, 18, 39, 10, 15, 111, 112, 116, 105, 111, 110, 97,
    108, 95, 115, 105, 110, 116, 54, 52, 24, 6, 32, 1, 40, 18, 82, 14, 111, 112, 116, 105, 111,
    110, 97, 108, 83, 105, 110, 116, 54, 52, 18, 41, 10, 16, 111, 112, 116, 105, 111, 110, 97, 108,
    95, 102, 105, 120, 101, 100, 51, 50, 24, 7, 32, 1, 40, 7, 82, 15, 111, 112, 116, 105, 111, 110,
    97, 108, 70, 105, 120, 101, 100, 51, 50, 18, 41, 10, 16, 111, 112, 116, 105, 111, 110, 97, 108,
    95, 102, 105, 120, 101, 100, 54, 52, 24, 8, 32, 1, 40, 6, 82, 15, 111, 112, 116, 105, 111, 110,
    97, 108, 70, 105, 120, 101, 100, 54, 52, 18, 43, 10, 17, 111, 112, 116, 105, 111, 110, 97, 108,
    95, 115, 102, 105, 120, 101, 100, 51, 50, 24, 9, 32, 1, 40, 15, 82, 16, 111, 112, 116, 105,
    111, 110, 97, 108, 83, 102, 105, 120, 101, 100, 51, 50, 18, 43, 10, 17, 111, 112, 116, 105,
    111, 110, 97, 108, 95, 115, 102, 105, 120, 101, 100, 54, 52, 24, 10, 32, 1, 40, 16, 82, 16,
    111, 112, 116, 105, 111, 110, 97, 108, 83, 102, 105, 120, 101, 100, 54, 52, 18, 37, 10, 14,
    111, 112, 116, 105, 111, 110, 97, 108, 95, 102, 108, 111, 97, 116, 24, 11, 32, 1, 40, 2, 82,
    13, 111, 112, 116, 105, 111, 110, 97, 108, 70, 108, 111, 97, 116, 18, 39, 10, 15, 111, 112,
    116, 105, 111, 110, 97, 108, 95, 100, 111, 117, 98, 108, 101, 24, 12, 32, 1, 40, 1, 82, 14,
    111, 112, 116, 105, 111, 110, 97, 108, 68, 111, 117, 98, 108, 101, 18, 35, 10, 13, 111, 112,
    116, 105, 111, 110, 97, 108, 95, 98, 111, 111, 108, 24, 13, 32, 1, 40, 8, 82, 12, 111, 112,
    116, 105, 111, 110, 97, 108, 66, 111, 111, 108, 18, 39, 10, 15, 111, 112, 116, 105, 111, 110,
    97, 108, 95, 115, 116, 114, 105, 110, 103, 24, 14, 32, 1, 40, 9, 82, 14, 111, 112, 116, 105,
    111, 110, 97, 108, 83, 116, 114, 105, 110, 103, 18, 37, 10, 14, 111, 112, 116, 105, 111, 110,
    97, 108, 95, 98, 121, 116, 101, 115, 24, 15, 32, 1, 40, 12, 82, 13, 111, 112, 116, 105, 111,
    110, 97, 108, 66, 121, 116, 101, 115, 18, 99, 10, 23, 111, 112, 116, 105, 111, 110, 97, 108,
    95, 110, 101, 115, 116, 101, 100, 95, 109, 101, 115, 115, 97, 103, 101, 24, 18, 32, 1, 40, 11,
    50, 43, 46, 112, 114, 111, 116, 111, 51, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84,
    101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 46, 78, 101, 115, 116, 101, 100, 77, 101,
    115, 115, 97, 103, 101, 82, 21, 111, 112, 116, 105, 111, 110, 97, 108, 78, 101, 115, 116, 101,
    100, 77, 101, 115, 115, 97, 103, 101, 18, 89, 10, 24, 111, 112, 116, 105, 111, 110, 97, 108,
    95, 102, 111, 114, 101, 105, 103, 110, 95, 109, 101, 115, 115, 97, 103, 101, 24, 19, 32, 1, 40,
    11, 50, 31, 46, 112, 114, 111, 116, 111, 51, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46,
    70, 111, 114, 101, 105, 103, 110, 77, 101, 115, 115, 97, 103, 101, 82, 22, 111, 112, 116, 105,
    111, 110, 97, 108, 70, 111, 114, 101, 105, 103, 110, 77, 101, 115, 115, 97, 103, 101, 18, 95,
    10, 23, 111, 112, 116, 105, 111, 110, 97, 108, 95, 105, 109, 112, 111, 114, 116, 95, 109, 101,
    115, 115, 97, 103, 101, 24, 20, 32, 1, 40, 11, 50, 39, 46, 112, 114, 111, 116, 111, 98, 117,
    102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 95, 105, 109, 112, 111, 114, 116, 46, 73, 109,
    112, 111, 114, 116, 77, 101, 115, 115, 97, 103, 101, 82, 21, 111, 112, 116, 105, 111, 110, 97,
    108, 73, 109, 112, 111, 114, 116, 77, 101, 115, 115, 97, 103, 101, 18, 90, 10, 20, 111, 112,
    116, 105, 111, 110, 97, 108, 95, 110, 101, 115, 116, 101, 100, 95, 101, 110, 117, 109, 24, 21,
    32, 1, 40, 14, 50, 40, 46, 112, 114, 111, 116, 111, 51, 95, 117, 110, 105, 116, 116, 101, 115,
    116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 46, 78, 101, 115, 116, 101,
    100, 69, 110, 117, 109, 82, 18, 111, 112, 116, 105, 111, 110, 97, 108, 78, 101, 115, 116, 101,
    100, 69, 110, 117, 109, 18, 80, 10, 21, 111, 112, 116, 105, 111, 110, 97, 108, 95, 102, 111,
    114, 101, 105, 103, 110, 95, 101, 110, 117, 109, 24, 22, 32, 1, 40, 14, 50, 28, 46, 112, 114,
    111, 116, 111, 51, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 70, 111, 114, 101, 105, 103,
    110, 69, 110, 117, 109, 82, 19, 111, 112, 116, 105, 111, 110, 97, 108, 70, 111, 114, 101, 105,
    103, 110, 69, 110, 117, 109, 18, 54, 10, 21, 111, 112, 116, 105, 111, 110, 97, 108, 95, 115,
    116, 114, 105, 110, 103, 95, 112, 105, 101, 99, 101, 24, 24, 32, 1, 40, 9, 82, 19, 111, 112,
    116, 105, 111, 110, 97, 108, 83, 116, 114, 105, 110, 103, 80, 105, 101, 99, 101, 66, 2, 8, 2,
    18, 39, 10, 13, 111, 112, 116, 105, 111, 110, 97, 108, 95, 99, 111, 114, 100, 24, 25, 32, 1,
    40, 9, 82, 12, 111, 112, 116, 105, 111, 110, 97, 108, 67, 111, 114, 100, 66, 2, 8, 1, 18, 114,
    10, 30, 111, 112, 116, 105, 111, 110, 97, 108, 95, 112, 117, 98, 108, 105, 99, 95, 105, 109,
    112, 111, 114, 116, 95, 109, 101, 115, 115, 97, 103, 101, 24, 26, 32, 1, 40, 11, 50, 45, 46,
    112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 95, 105,
    109, 112, 111, 114, 116, 46, 80, 117, 98, 108, 105, 99, 73, 109, 112, 111, 114, 116, 77, 101,
    115, 115, 97, 103, 101, 82, 27, 111, 112, 116, 105, 111, 110, 97, 108, 80, 117, 98, 108, 105,
    99, 73, 109, 112, 111, 114, 116, 77, 101, 115, 115, 97, 103, 101, 18, 99, 10, 21, 111, 112,
    116, 105, 111, 110, 97, 108, 95, 108, 97, 122, 121, 95, 109, 101, 115, 115, 97, 103, 101, 24,
    27, 32, 1, 40, 11, 50, 43, 46, 112, 114, 111, 116, 111, 51, 95, 117, 110, 105, 116, 116, 101,
    115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 46, 78, 101, 115, 116,
    101, 100, 77, 101, 115, 115, 97, 103, 101, 82, 19, 111, 112, 116, 105, 111, 110, 97, 108, 76,
    97, 122, 121, 77, 101, 115, 115, 97, 103, 101, 66, 2, 40, 1, 18, 108, 10, 28, 111, 112, 116,
    105, 111, 110, 97, 108, 95, 108, 97, 122, 121, 95, 105, 109, 112, 111, 114, 116, 95, 109, 101,
    115, 115, 97, 103, 101, 24, 115, 32, 1, 40, 11, 50, 39, 46, 112, 114, 111, 116, 111, 98, 117,
    102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 95, 105, 109, 112, 111, 114, 116, 46, 73, 109,
    112, 111, 114, 116, 77, 101, 115, 115, 97, 103, 101, 82, 25, 111, 112, 116, 105, 111, 110, 97,
    108, 76, 97, 122, 121, 73, 109, 112, 111, 114, 116, 77, 101, 115, 115, 97, 103, 101, 66, 2, 40,
    1, 18, 37, 10, 14, 114, 101, 112, 101, 97, 116, 101, 100, 95, 105, 110, 116, 51, 50, 24, 31,
    32, 3, 40, 5, 82, 13, 114, 101, 112, 101, 97, 116, 101, 100, 73, 110, 116, 51, 50, 18, 37, 10,
    14, 114, 101, 112, 101, 97, 116, 101, 100, 95, 105, 110, 116, 54, 52, 24, 32, 32, 3, 40, 3, 82,
    13, 114, 101, 112, 101, 97, 116, 101, 100, 73, 110, 116, 54, 52, 18, 39, 10, 15, 114, 101, 112,
    101, 97, 116, 101, 100, 95, 117, 105, 110, 116, 51, 50, 24, 33, 32, 3, 40, 13, 82, 14, 114,
    101, 112, 101, 97, 116, 101, 100, 85, 105, 110, 116, 51, 50, 18, 39, 10, 15, 114, 101, 112,
    101, 97, 116, 101, 100, 95, 117, 105, 110, 116, 54, 52, 24, 34, 32, 3, 40, 4, 82, 14, 114, 101,
    112, 101, 97, 116, 101, 100, 85, 105, 110, 116, 54, 52, 18, 39, 10, 15, 114, 101, 112, 101, 97,
    116, 101, 100, 95, 115, 105, 110, 116, 51, 50, 24, 35, 32, 3, 40, 17, 82, 14, 114, 101, 112,
    101, 97, 116, 101, 100, 83, 105, 110, 116, 51, 50, 18, 39, 10, 15, 114, 101, 112, 101, 97, 116,
    101, 100, 95, 115, 105, 110, 116, 54, 52, 24, 36, 32, 3, 40, 18, 82, 14, 114, 101, 112, 101,
    97, 116, 101, 100, 83, 105, 110, 116, 54, 52, 18, 41, 10, 16, 114, 101, 112, 101, 97, 116, 101,
    100, 95, 102, 105, 120, 101, 100, 51, 50, 24, 37, 32, 3, 40, 7, 82, 15, 114, 101, 112, 101, 97,
    116, 101, 100, 70, 105, 120, 101, 100, 51, 50, 18, 41, 10, 16, 114, 101, 112, 101, 97, 116,
    101, 100, 95, 102, 105, 120, 101, 100, 54, 52, 24, 38, 32, 3, 40, 6, 82, 15, 114, 101, 112,
    101, 97, 116, 101, 100, 70, 105, 120, 101, 100, 54, 52, 18, 43, 10, 17, 114, 101, 112, 101, 97,
    116, 101, 100, 95, 115, 102, 105, 120, 101, 100, 51, 50, 24, 39, 32, 3, 40, 15, 82, 16, 114,
    101, 112, 101, 97, 116, 101, 100, 83, 102, 105, 120, 101, 100, 51, 50, 18, 43, 10, 17, 114,
    101, 112, 101, 97, 116, 101, 100, 95, 115, 102, 105, 120, 101, 100, 54, 52, 24, 40, 32, 3, 40,
    16, 82, 16, 114, 101, 112, 101, 97, 116, 101, 100, 83, 102, 105, 120, 101, 100, 54, 52, 18, 37,
    10, 14, 114, 101, 112, 101, 97, 116, 101, 100, 95, 102, 108, 111, 97, 116, 24, 41, 32, 3, 40,
    2, 82, 13, 114, 101, 112, 101, 97, 116, 101, 100, 70, 108, 111, 97, 116, 18, 39, 10, 15, 114,
    101, 112, 101, 97, 116, 101, 100, 95, 100, 111, 117, 98, 108, 101, 24, 42, 32, 3, 40, 1, 82,
    14, 114, 101, 112, 101, 97, 116, 101, 100, 68, 111, 117, 98, 108, 101, 18, 35, 10, 13, 114,
    101, 112, 101, 97, 116, 101, 100, 95, 98, 111, 111, 108, 24, 43, 32, 3, 40, 8, 82, 12, 114,
    101, 112, 101, 97, 116, 101, 100, 66, 111, 111, 108, 18, 39, 10, 15, 114, 101, 112, 101, 97,
    116, 101, 100, 95, 115, 116, 114, 105, 110, 103, 24, 44, 32, 3, 40, 9, 82, 14, 114, 101, 112,
    101, 97, 116, 101, 100, 83, 116, 114, 105, 110, 103, 18, 37, 10, 14, 114, 101, 112, 101, 97,
    116, 101, 100, 95, 98, 121, 116, 101, 115, 24, 45, 32, 3, 40, 12, 82, 13, 114, 101, 112, 101,
    97, 116, 101, 100, 66, 121, 116, 101, 115, 18, 99, 10, 23, 114, 101, 112, 101, 97, 116, 101,
    100, 95, 110, 101, 115, 116, 101, 100, 95, 109, 101, 115, 115, 97, 103, 101, 24, 48, 32, 3, 40,
    11, 50, 43, 46, 112, 114, 111, 116, 111, 51, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46,
    84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 46, 78, 101, 115, 116, 101, 100, 77,
    101, 115, 115, 97, 103, 101, 82, 21, 114, 101, 112, 101, 97, 116, 101, 100, 78, 101, 115, 116,
    101, 100, 77, 101, 115, 115, 97, 103, 101, 18, 89, 10, 24, 114, 101, 112, 101, 97, 116, 101,
    100, 95, 102, 111, 114, 101, 105, 103, 110, 95, 109, 101, 115, 115, 97, 103, 101, 24, 49, 32,
    3, 40, 11, 50, 31, 46, 112, 114, 111, 116, 111, 51, 95, 117, 110, 105, 116, 116, 101, 115, 116,
    46, 70, 111, 114, 101, 105, 103, 110, 77, 101, 115, 115, 97, 103, 101, 82, 22, 114, 101, 112,
    101, 97, 116, 101, 100, 70, 111, 114, 101, 105, 103, 110, 77, 101, 115, 115, 97, 103, 101, 18,
    95, 10, 23, 114, 101, 112, 101, 97, 116, 101, 100, 95, 105, 109, 112, 111, 114, 116, 95, 109,
    101, 115, 115, 97, 103, 101, 24, 50, 32, 3, 40, 11, 50, 39, 46, 112, 114, 111, 116, 111, 98,
    117, 102, 95, 117, 110, 105, 116, 116, 101, 115, 116, 95, 105, 109, 112, 111, 114, 116, 46, 73,
    109, 112, 111, 114, 116, 77, 101, 115, 115, 97, 103, 101, 82, 21, 114, 101, 112, 101, 97, 116,
    101, 100, 73, 109, 112, 111, 114, 116, 77, 101, 115, 115, 97, 103, 101, 18, 90, 10, 20, 114,
    101, 112, 101, 97, 116, 101, 100, 95, 110, 101, 115, 116, 101, 100, 95, 101, 110, 117, 109, 24,
    51, 32, 3, 40, 14, 50, 40, 46, 112, 114, 111, 116, 111, 51, 95, 117, 110, 105, 116, 116, 101,
    115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 46, 78, 101, 115, 116,
    101, 100, 69, 110, 117, 109, 82, 18, 114, 101, 112, 101, 97, 116, 101, 100, 78, 101, 115, 116,
    101, 100, 69, 110, 117, 109, 18, 80, 10, 21, 114, 101, 112, 101, 97, 116, 101, 100, 95, 102,
    111, 114, 101, 105, 103, 110, 95, 101, 110, 117, 109, 24, 52, 32, 3, 40, 14, 50, 28, 46, 112,
    114, 111, 116, 111, 51, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 70, 111, 114, 101, 105,
    103, 110, 69, 110, 117, 109, 82, 19, 114, 101, 112, 101, 97, 116, 101, 100, 70, 111, 114, 101,
    105, 103, 110, 69, 110, 117, 109, 18, 54, 10, 21, 114, 101, 112, 101, 97, 116, 101, 100, 95,
    115, 116, 114, 105, 110, 103, 95, 112, 105, 101, 99, 101, 24, 54, 32, 3, 40, 9, 82, 19, 114,
    101, 112, 101, 97, 116, 101, 100, 83, 116, 114, 105, 110, 103, 80, 105, 101, 99, 101, 66, 2, 8,
    2, 18, 39, 10, 13, 114, 101, 112, 101, 97, 116, 101, 100, 95, 99, 111, 114, 100, 24, 55, 32, 3,
    40, 9, 82, 12, 114, 101, 112, 101, 97, 116, 101, 100, 67, 111, 114, 100, 66, 2, 8, 1, 18, 99,
    10, 21, 114, 101, 112, 101, 97, 116, 101, 100, 95, 108, 97, 122, 121, 95, 109, 101, 115, 115,
    97, 103, 101, 24, 57, 32, 3, 40, 11, 50, 43, 46, 112, 114, 111, 116, 111, 51, 95, 117, 110,
    105, 116, 116, 101, 115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 46,
    78, 101, 115, 116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 82, 19, 114, 101, 112, 101, 97,
    116, 101, 100, 76, 97, 122, 121, 77, 101, 115, 115, 97, 103, 101, 66, 2, 40, 1, 18, 35, 10, 12,
    111, 110, 101, 111, 102, 95, 117, 105, 110, 116, 51, 50, 24, 111, 32, 1, 40, 13, 72, 0, 82, 11,
    111, 110, 101, 111, 102, 85, 105, 110, 116, 51, 50, 18, 95, 10, 20, 111, 110, 101, 111, 102,
    95, 110, 101, 115, 116, 101, 100, 95, 109, 101, 115, 115, 97, 103, 101, 24, 112, 32, 1, 40, 11,
    50, 43, 46, 112, 114, 111, 116, 111, 51, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84,
    101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 46, 78, 101, 115, 116, 101, 100, 77, 101,
    115, 115, 97, 103, 101, 72, 0, 82, 18, 111, 110, 101, 111, 102, 78, 101, 115, 116, 101, 100,
    77, 101, 115, 115, 97, 103, 101, 18, 35, 10, 12, 111, 110, 101, 111, 102, 95, 115, 116, 114,
    105, 110, 103, 24, 113, 32, 1, 40, 9, 72, 0, 82, 11, 111, 110, 101, 111, 102, 83, 116, 114,
    105, 110, 103, 18, 33, 10, 11, 111, 110, 101, 111, 102, 95, 98, 121, 116, 101, 115, 24, 114,
    32, 1, 40, 12, 72, 0, 82, 10, 111, 110, 101, 111, 102, 66, 121, 116, 101, 115, 26, 31, 10, 13,
    78, 101, 115, 116, 101, 100, 77, 101, 115, 115, 97, 103, 101, 18, 14, 10, 2, 98, 98, 24, 1, 32,
    1, 40, 5, 82, 2, 98, 98, 34, 67, 10, 10, 78, 101, 115, 116, 101, 100, 69, 110, 117, 109, 18, 8,
    10, 4, 90, 69, 82, 79, 16, 0, 18, 7, 10, 3, 70, 79, 79, 16, 1, 18, 7, 10, 3, 66, 65, 82, 16, 2,
    18, 7, 10, 3, 66, 65, 90, 16, 3, 18, 16, 10, 3, 78, 69, 71, 16, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 1, 66, 13, 10, 11, 111, 110, 101, 111, 102, 95, 102, 105, 101, 108, 100, 34,
    235, 4, 10, 15, 84, 101, 115, 116, 80, 97, 99, 107, 101, 100, 84, 121, 112, 101, 115, 18, 37,
    10, 12, 112, 97, 99, 107, 101, 100, 95, 105, 110, 116, 51, 50, 24, 90, 32, 3, 40, 5, 82, 11,
    112, 97, 99, 107, 101, 100, 73, 110, 116, 51, 50, 66, 2, 16, 1, 18, 37, 10, 12, 112, 97, 99,
    107, 101, 100, 95, 105, 110, 116, 54, 52, 24, 91, 32, 3, 40, 3, 82, 11, 112, 97, 99, 107, 101,
    100, 73, 110, 116, 54, 52, 66, 2, 16, 1, 18, 39, 10, 13, 112, 97, 99, 107, 101, 100, 95, 117,
    105, 110, 116, 51, 50, 24, 92, 32, 3, 40, 13, 82, 12, 112, 97, 99, 107, 101, 100, 85, 105, 110,
    116, 51, 50, 66, 2, 16, 1, 18, 39, 10, 13, 112, 97, 99, 107, 101, 100, 95, 117, 105, 110, 116,
    54, 52, 24, 93, 32, 3, 40, 4, 82, 12, 112, 97, 99, 107, 101, 100, 85, 105, 110, 116, 54, 52,
    66, 2, 16, 1, 18, 39, 10, 13, 112, 97, 99, 107, 101, 100, 95, 115, 105, 110, 116, 51, 50, 24,
    94, 32, 3, 40, 17, 82, 12, 112, 97, 99, 107, 101, 100, 83, 105, 110, 116, 51, 50, 66, 2, 16, 1,
    18, 39, 10, 13, 112, 97, 99, 107, 101, 100, 95, 115, 105, 110, 116, 54, 52, 24, 95, 32, 3, 40,
    18, 82, 12, 112, 97, 99, 107, 101, 100, 83, 105, 110, 116, 54, 52, 66, 2, 16, 1, 18, 41, 10,
    14, 112, 97, 99, 107, 101, 100, 95, 102, 105, 120, 101, 100, 51, 50, 24, 96, 32, 3, 40, 7, 82,
    13, 112, 97, 99, 107, 101, 100, 70, 105, 120, 101, 100, 51, 50, 66, 2, 16, 1, 18, 41, 10, 14,
    112, 97, 99, 107, 101, 100, 95, 102, 105, 120, 101, 100, 54, 52, 24, 97, 32, 3, 40, 6, 82, 13,
    112, 97, 99, 107, 101, 100, 70, 105, 120, 101, 100, 54, 52, 66, 2, 16, 1, 18, 43, 10, 15, 112,
    97, 99, 107, 101, 100, 95, 115, 102, 105, 120, 101, 100, 51, 50, 24, 98, 32, 3, 40, 15, 82, 14,
    112, 97, 99, 107, 101, 100, 83, 102, 105, 120, 101, 100, 51, 50, 66, 2, 16, 1, 18, 43, 10, 15,
    112, 97, 99, 107, 101, 100, 95, 115, 102, 105, 120, 101, 100, 54, 52, 24, 99, 32, 3, 40, 16,
    82, 14, 112, 97, 99, 107, 101, 100, 83, 102, 105, 120, 101, 100, 54, 52, 66, 2, 16, 1, 18, 37,
    10, 12, 112, 97, 99, 107, 101, 100, 95, 102, 108, 111, 97, 116, 24, 100, 32, 3, 40, 2, 82, 11,
    112, 97, 99, 107, 101, 100, 70, 108, 111, 97, 116, 66, 2, 16, 1, 18, 39, 10, 13, 112, 97, 99,
    107, 101, 100, 95, 100, 111, 117, 98, 108, 101, 24, 101, 32, 3, 40, 1, 82, 12, 112, 97, 99,
    107, 101, 100, 68, 111, 117, 98, 108, 101, 66, 2, 16, 1, 18, 35, 10, 11, 112, 97, 99, 107, 101,
    100, 95, 98, 111, 111, 108, 24, 102, 32, 3, 40, 8, 82, 10, 112, 97, 99, 107, 101, 100, 66, 111,
    111, 108, 66, 2, 16, 1, 18, 65, 10, 11, 112, 97, 99, 107, 101, 100, 95, 101, 110, 117, 109, 24,
    103, 32, 3, 40, 14, 50, 28, 46, 112, 114, 111, 116, 111, 51, 95, 117, 110, 105, 116, 116, 101,
    115, 116, 46, 70, 111, 114, 101, 105, 103, 110, 69, 110, 117, 109, 82, 10, 112, 97, 99, 107,
    101, 100, 69, 110, 117, 109, 66, 2, 16, 1, 34, 190, 5, 10, 17, 84, 101, 115, 116, 85, 110, 112,
    97, 99, 107, 101, 100, 84, 121, 112, 101, 115, 18, 41, 10, 14, 114, 101, 112, 101, 97, 116,
    101, 100, 95, 105, 110, 116, 51, 50, 24, 1, 32, 3, 40, 5, 82, 13, 114, 101, 112, 101, 97, 116,
    101, 100, 73, 110, 116, 51, 50, 66, 2, 16, 0, 18, 41, 10, 14, 114, 101, 112, 101, 97, 116, 101,
    100, 95, 105, 110, 116, 54, 52, 24, 2, 32, 3, 40, 3, 82, 13, 114, 101, 112, 101, 97, 116, 101,
    100, 73, 110, 116, 54, 52, 66, 2, 16, 0, 18, 43, 10, 15, 114, 101, 112, 101, 97, 116, 101, 100,
    95, 117, 105, 110, 116, 51, 50, 24, 3, 32, 3, 40, 13, 82, 14, 114, 101, 112, 101, 97, 116, 101,
    100, 85, 105, 110, 116, 51, 50, 66, 2, 16, 0, 18, 43, 10, 15, 114, 101, 112, 101, 97, 116, 101,
    100, 95, 117, 105, 110, 116, 54, 52, 24, 4, 32, 3, 40, 4, 82, 14, 114, 101, 112, 101, 97, 116,
    101, 100, 85, 105, 110, 116, 54, 52, 66, 2, 16, 0, 18, 43, 10, 15, 114, 101, 112, 101, 97, 116,
    101, 100, 95, 115, 105, 110, 116, 51, 50, 24, 5, 32, 3, 40, 17, 82, 14, 114, 101, 112, 101, 97,
    116, 101, 100, 83, 105, 110, 116, 51, 50, 66, 2, 16, 0, 18, 43, 10, 15, 114, 101, 112, 101, 97,
    116, 101, 100, 95, 115, 105, 110, 116, 54, 52, 24, 6, 32, 3, 40, 18, 82, 14, 114, 101, 112,
    101, 97, 116, 101, 100, 83, 105, 110, 116, 54, 52, 66, 2, 16, 0, 18, 45, 10, 16, 114, 101, 112,
    101, 97, 116, 101, 100, 95, 102, 105, 120, 101, 100, 51, 50, 24, 7, 32, 3, 40, 7, 82, 15, 114,
    101, 112, 101, 97, 116, 101, 100, 70, 105, 120, 101, 100, 51, 50, 66, 2, 16, 0, 18, 45, 10, 16,
    114, 101, 112, 101, 97, 116, 101, 100, 95, 102, 105, 120, 101, 100, 54, 52, 24, 8, 32, 3, 40,
    6, 82, 15, 114, 101, 112, 101, 97, 116, 101, 100, 70, 105, 120, 101, 100, 54, 52, 66, 2, 16, 0,
    18, 47, 10, 17, 114, 101, 112, 101, 97, 116, 101, 100, 95, 115, 102, 105, 120, 101, 100, 51,
    50, 24, 9, 32, 3, 40, 15, 82, 16, 114, 101, 112, 101, 97, 116, 101, 100, 83, 102, 105, 120,
    101, 100, 51, 50, 66, 2, 16, 0, 18, 47, 10, 17, 114, 101, 112, 101, 97, 116, 101, 100, 95, 115,
    102, 105, 120, 101, 100, 54, 52, 24, 10, 32, 3, 40, 16, 82, 16, 114, 101, 112, 101, 97, 116,
    101, 100, 83, 102, 105, 120, 101, 100, 54, 52, 66, 2, 16, 0, 18, 41, 10, 14, 114, 101, 112,
    101, 97, 116, 101, 100, 95, 102, 108, 111, 97, 116, 24, 11, 32, 3, 40, 2, 82, 13, 114, 101,
    112, 101, 97, 116, 101, 100, 70, 108, 111, 97, 116, 66, 2, 16, 0, 18, 43, 10, 15, 114, 101,
    112, 101, 97, 116, 101, 100, 95, 100, 111, 117, 98, 108, 101, 24, 12, 32, 3, 40, 1, 82, 14,
    114, 101, 112, 101, 97, 116, 101, 100, 68, 111, 117, 98, 108, 101, 66, 2, 16, 0, 18, 39, 10,
    13, 114, 101, 112, 101, 97, 116, 101, 100, 95, 98, 111, 111, 108, 24, 13, 32, 3, 40, 8, 82, 12,
    114, 101, 112, 101, 97, 116, 101, 100, 66, 111, 111, 108, 66, 2, 16, 0, 18, 94, 10, 20, 114,
    101, 112, 101, 97, 116, 101, 100, 95, 110, 101, 115, 116, 101, 100, 95, 101, 110, 117, 109, 24,
    14, 32, 3, 40, 14, 50, 40, 46, 112, 114, 111, 116, 111, 51, 95, 117, 110, 105, 116, 116, 101,
    115, 116, 46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 46, 78, 101, 115, 116,
    101, 100, 69, 110, 117, 109, 82, 18, 114, 101, 112, 101, 97, 116, 101, 100, 78, 101, 115, 116,
    101, 100, 69, 110, 117, 109, 66, 2, 16, 0, 34, 136, 1, 10, 18, 78, 101, 115, 116, 101, 100, 84,
    101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 18, 57, 10, 5, 99, 104, 105, 108, 100, 24,
    1, 32, 1, 40, 11, 50, 35, 46, 112, 114, 111, 116, 111, 51, 95, 117, 110, 105, 116, 116, 101,
    115, 116, 46, 78, 101, 115, 116, 101, 100, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101,
    115, 82, 5, 99, 104, 105, 108, 100, 18, 55, 10, 7, 112, 97, 121, 108, 111, 97, 100, 24, 2, 32,
    1, 40, 11, 50, 29, 46, 112, 114, 111, 116, 111, 51, 95, 117, 110, 105, 116, 116, 101, 115, 116,
    46, 84, 101, 115, 116, 65, 108, 108, 84, 121, 112, 101, 115, 82, 7, 112, 97, 121, 108, 111, 97,
    100, 34, 30, 10, 14, 70, 111, 114, 101, 105, 103, 110, 77, 101, 115, 115, 97, 103, 101, 18, 12,
    10, 1, 99, 24, 1, 32, 1, 40, 5, 82, 1, 99, 34, 18, 10, 16, 84, 101, 115, 116, 69, 109, 112,
    116, 121, 77, 101, 115, 115, 97, 103, 101, 34, 142, 1, 10, 10, 84, 101, 115, 116, 79, 110, 101,
    111, 102, 50, 18, 67, 10, 8, 102, 111, 111, 95, 101, 110, 117, 109, 24, 6, 32, 1, 40, 14, 50,
    38, 46, 112, 114, 111, 116, 111, 51, 95, 117, 110, 105, 116, 116, 101, 115, 116, 46, 84, 101,
    115, 116, 79, 110, 101, 111, 102, 50, 46, 78, 101, 115, 116, 101, 100, 69, 110, 117, 109, 72,
    0, 82, 7, 102, 111, 111, 69, 110, 117, 109, 34, 52, 10, 10, 78, 101, 115, 116, 101, 100, 69,
    110, 117, 109, 18, 11, 10, 7, 85, 78, 75, 78, 79, 87, 78, 16, 0, 18, 7, 10, 3, 70, 79, 79, 16,
    1, 18, 7, 10, 3, 66, 65, 82, 16, 2, 18, 7, 10, 3, 66, 65, 90, 16, 3, 66, 5, 10, 3, 102, 111,
    111, 42, 82, 10, 11, 70, 111, 114, 101, 105, 103, 110, 69, 110, 117, 109, 18, 16, 10, 12, 70,
    79, 82, 69, 73, 71, 78, 95, 90, 69, 82, 79, 16, 0, 18, 15, 10, 11, 70, 79, 82, 69, 73, 71, 78,
    95, 70, 79, 79, 16, 4, 18, 15, 10, 11, 70, 79, 82, 69, 73, 71, 78, 95, 66, 65, 82, 16, 5, 18,
    15, 10, 11, 70, 79, 82, 69, 73, 71, 78, 95, 66, 65, 90, 16, 6, 66, 2, 72, 1, 98, 6, 112, 114,
    111, 116, 111, 51,
];
pub mod unittest_proto3_proto {
    pub fn file() -> &'static ::protrust::reflect::FileDescriptor<'static> {
        super::pool()
            .find_file_by_name("unittest_proto3.proto")
            .unwrap()
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestAllTypes {
        optional_int32: i32,
        optional_int64: i64,
        optional_uint32: u32,
        optional_uint64: u64,
        optional_sint32: i32,
        optional_sint64: i64,
        optional_fixed32: u32,
        optional_fixed64: u64,
        optional_sfixed32: i32,
        optional_sfixed64: i64,
        optional_float: f32,
        optional_double: f64,
        optional_bool: bool,
        optional_string: ::std::string::String,
        optional_bytes: ::std::vec::Vec<u8>,
        optional_nested_message:
            ::std::option::Option<::std::boxed::Box<self::test_all_types::NestedMessage>>,
        optional_foreign_message: ::std::option::Option<::std::boxed::Box<self::ForeignMessage>>,
        optional_import_message: ::std::option::Option<
            ::std::boxed::Box<self::super::unittest_import_proto::ImportMessage>,
        >,
        optional_nested_enum: ::protrust::EnumValue<self::test_all_types::NestedEnum>,
        optional_foreign_enum: ::protrust::EnumValue<self::ForeignEnum>,
        optional_string_piece: ::std::string::String,
        optional_cord: ::std::string::String,
        optional_public_import_message: ::std::option::Option<
            ::std::boxed::Box<self::super::unittest_import_public_proto::PublicImportMessage>,
        >,
        optional_lazy_message:
            ::std::option::Option<::std::boxed::Box<self::test_all_types::NestedMessage>>,
        optional_lazy_import_message: ::std::option::Option<
            ::std::boxed::Box<self::super::unittest_import_proto::ImportMessage>,
        >,
        repeated_int32: ::protrust::collections::RepeatedField<i32>,
        repeated_int64: ::protrust::collections::RepeatedField<i64>,
        repeated_uint32: ::protrust::collections::RepeatedField<u32>,
        repeated_uint64: ::protrust::collections::RepeatedField<u64>,
        repeated_sint32: ::protrust::collections::RepeatedField<i32>,
        repeated_sint64: ::protrust::collections::RepeatedField<i64>,
        repeated_fixed32: ::protrust::collections::RepeatedField<u32>,
        repeated_fixed64: ::protrust::collections::RepeatedField<u64>,
        repeated_sfixed32: ::protrust::collections::RepeatedField<i32>,
        repeated_sfixed64: ::protrust::collections::RepeatedField<i64>,
        repeated_float: ::protrust::collections::RepeatedField<f32>,
        repeated_double: ::protrust::collections::RepeatedField<f64>,
        repeated_bool: ::protrust::collections::RepeatedField<bool>,
        repeated_string: ::protrust::collections::RepeatedField<::std::string::String>,
        repeated_bytes: ::protrust::collections::RepeatedField<::std::vec::Vec<u8>>,
        repeated_nested_message:
            ::protrust::collections::RepeatedField<self::test_all_types::NestedMessage>,
        repeated_foreign_message: ::protrust::collections::RepeatedField<self::ForeignMessage>,
        repeated_import_message: ::protrust::collections::RepeatedField<
            self::super::unittest_import_proto::ImportMessage,
        >,
        repeated_nested_enum: ::protrust::collections::RepeatedField<
            ::protrust::EnumValue<self::test_all_types::NestedEnum>,
        >,
        repeated_foreign_enum:
            ::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>>,
        repeated_string_piece: ::protrust::collections::RepeatedField<::std::string::String>,
        repeated_cord: ::protrust::collections::RepeatedField<::std::string::String>,
        repeated_lazy_message:
            ::protrust::collections::RepeatedField<self::test_all_types::NestedMessage>,
        oneof_field: self::test_all_types::OneofField,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestAllTypes {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => *self.optional_int32_mut() = input.read_int32()?,
                    16 | 18 => *self.optional_int64_mut() = input.read_int64()?,
                    24 | 26 => *self.optional_uint32_mut() = input.read_uint32()?,
                    32 | 34 => *self.optional_uint64_mut() = input.read_uint64()?,
                    40 | 42 => *self.optional_sint32_mut() = input.read_sint32()?,
                    48 | 50 => *self.optional_sint64_mut() = input.read_sint64()?,
                    61 | 58 => *self.optional_fixed32_mut() = input.read_fixed32()?,
                    65 | 66 => *self.optional_fixed64_mut() = input.read_fixed64()?,
                    77 | 74 => *self.optional_sfixed32_mut() = input.read_sfixed32()?,
                    81 | 82 => *self.optional_sfixed64_mut() = input.read_sfixed64()?,
                    93 | 90 => *self.optional_float_mut() = input.read_float()?,
                    97 | 98 => *self.optional_double_mut() = input.read_double()?,
                    104 | 106 => *self.optional_bool_mut() = input.read_bool()?,
                    114 => *self.optional_string_mut() = input.read_string()?,
                    122 => *self.optional_bytes_mut() = input.read_bytes()?,
                    146 => input.read_message(self.optional_nested_message_mut())?,
                    154 => input.read_message(self.optional_foreign_message_mut())?,
                    162 => input.read_message(self.optional_import_message_mut())?,
                    168 | 170 => *self.optional_nested_enum_mut() = input.read_enum_value()?,
                    176 | 178 => *self.optional_foreign_enum_mut() = input.read_enum_value()?,
                    194 => *self.optional_string_piece_mut() = input.read_string()?,
                    202 => *self.optional_cord_mut() = input.read_string()?,
                    210 => input.read_message(self.optional_public_import_message_mut())?,
                    218 => input.read_message(self.optional_lazy_message_mut())?,
                    922 => input.read_message(self.optional_lazy_import_message_mut())?,
                    250 => self
                        .repeated_int32
                        .add_entries(input, &self::test_all_types::REPEATED_INT32_CODEC)?,
                    258 => self
                        .repeated_int64
                        .add_entries(input, &self::test_all_types::REPEATED_INT64_CODEC)?,
                    266 => self
                        .repeated_uint32
                        .add_entries(input, &self::test_all_types::REPEATED_UINT32_CODEC)?,
                    274 => self
                        .repeated_uint64
                        .add_entries(input, &self::test_all_types::REPEATED_UINT64_CODEC)?,
                    282 => self
                        .repeated_sint32
                        .add_entries(input, &self::test_all_types::REPEATED_SINT32_CODEC)?,
                    290 => self
                        .repeated_sint64
                        .add_entries(input, &self::test_all_types::REPEATED_SINT64_CODEC)?,
                    298 => self
                        .repeated_fixed32
                        .add_entries(input, &self::test_all_types::REPEATED_FIXED32_CODEC)?,
                    306 => self
                        .repeated_fixed64
                        .add_entries(input, &self::test_all_types::REPEATED_FIXED64_CODEC)?,
                    314 => self
                        .repeated_sfixed32
                        .add_entries(input, &self::test_all_types::REPEATED_SFIXED32_CODEC)?,
                    322 => self
                        .repeated_sfixed64
                        .add_entries(input, &self::test_all_types::REPEATED_SFIXED64_CODEC)?,
                    330 => self
                        .repeated_float
                        .add_entries(input, &self::test_all_types::REPEATED_FLOAT_CODEC)?,
                    338 => self
                        .repeated_double
                        .add_entries(input, &self::test_all_types::REPEATED_DOUBLE_CODEC)?,
                    346 => self
                        .repeated_bool
                        .add_entries(input, &self::test_all_types::REPEATED_BOOL_CODEC)?,
                    354 => self
                        .repeated_string
                        .add_entries(input, &self::test_all_types::REPEATED_STRING_CODEC)?,
                    362 => self
                        .repeated_bytes
                        .add_entries(input, &self::test_all_types::REPEATED_BYTES_CODEC)?,
                    386 => self
                        .repeated_nested_message
                        .add_entries(input, &self::test_all_types::REPEATED_NESTED_MESSAGE_CODEC)?,
                    394 => self.repeated_foreign_message.add_entries(
                        input,
                        &self::test_all_types::REPEATED_FOREIGN_MESSAGE_CODEC,
                    )?,
                    402 => self
                        .repeated_import_message
                        .add_entries(input, &self::test_all_types::REPEATED_IMPORT_MESSAGE_CODEC)?,
                    410 => self
                        .repeated_nested_enum
                        .add_entries(input, &self::test_all_types::REPEATED_NESTED_ENUM_CODEC)?,
                    418 => self
                        .repeated_foreign_enum
                        .add_entries(input, &self::test_all_types::REPEATED_FOREIGN_ENUM_CODEC)?,
                    434 => self
                        .repeated_string_piece
                        .add_entries(input, &self::test_all_types::REPEATED_STRING_PIECE_CODEC)?,
                    442 => self
                        .repeated_cord
                        .add_entries(input, &self::test_all_types::REPEATED_CORD_CODEC)?,
                    458 => self
                        .repeated_lazy_message
                        .add_entries(input, &self::test_all_types::REPEATED_LAZY_MESSAGE_CODEC)?,
                    888 | 890 => *self.oneof_uint32_mut() = input.read_uint32()?,
                    898 => input.read_message(self.oneof_nested_message_mut())?,
                    906 => *self.oneof_string_mut() = input.read_string()?,
                    914 => *self.oneof_bytes_mut() = input.read_bytes()?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if *self.optional_int32() != Self::OPTIONAL_INT32_DEFAULT_VALUE {
                size += 1;
                size += ::protrust::io::sizes::int32(*self.optional_int32());
            }
            if *self.optional_int64() != Self::OPTIONAL_INT64_DEFAULT_VALUE {
                size += 1;
                size += ::protrust::io::sizes::int64(*self.optional_int64());
            }
            if *self.optional_uint32() != Self::OPTIONAL_UINT32_DEFAULT_VALUE {
                size += 1;
                size += ::protrust::io::sizes::uint32(*self.optional_uint32());
            }
            if *self.optional_uint64() != Self::OPTIONAL_UINT64_DEFAULT_VALUE {
                size += 1;
                size += ::protrust::io::sizes::uint64(*self.optional_uint64());
            }
            if *self.optional_sint32() != Self::OPTIONAL_SINT32_DEFAULT_VALUE {
                size += 1;
                size += ::protrust::io::sizes::sint32(*self.optional_sint32());
            }
            if *self.optional_sint64() != Self::OPTIONAL_SINT64_DEFAULT_VALUE {
                size += 1;
                size += ::protrust::io::sizes::sint64(*self.optional_sint64());
            }
            if *self.optional_fixed32() != Self::OPTIONAL_FIXED32_DEFAULT_VALUE {
                size += 1;
                size += ::protrust::io::sizes::fixed32(*self.optional_fixed32());
            }
            if *self.optional_fixed64() != Self::OPTIONAL_FIXED64_DEFAULT_VALUE {
                size += 1;
                size += ::protrust::io::sizes::fixed64(*self.optional_fixed64());
            }
            if *self.optional_sfixed32() != Self::OPTIONAL_SFIXED32_DEFAULT_VALUE {
                size += 1;
                size += ::protrust::io::sizes::sfixed32(*self.optional_sfixed32());
            }
            if *self.optional_sfixed64() != Self::OPTIONAL_SFIXED64_DEFAULT_VALUE {
                size += 1;
                size += ::protrust::io::sizes::sfixed64(*self.optional_sfixed64());
            }
            if *self.optional_float() != Self::OPTIONAL_FLOAT_DEFAULT_VALUE {
                size += 1;
                size += ::protrust::io::sizes::float(*self.optional_float());
            }
            if *self.optional_double() != Self::OPTIONAL_DOUBLE_DEFAULT_VALUE {
                size += 1;
                size += ::protrust::io::sizes::double(*self.optional_double());
            }
            if *self.optional_bool() != Self::OPTIONAL_BOOL_DEFAULT_VALUE {
                size += 1;
                size += ::protrust::io::sizes::bool(*self.optional_bool());
            }
            if **self.optional_string() != *Self::OPTIONAL_STRING_DEFAULT_VALUE {
                size += 1;
                size += ::protrust::io::sizes::string(self.optional_string());
            }
            if **self.optional_bytes() != *Self::OPTIONAL_BYTES_DEFAULT_VALUE {
                size += 1;
                size += ::protrust::io::sizes::bytes(self.optional_bytes());
            }
            if let ::std::option::Option::Some(optional_nested_message) =
                self.optional_nested_message()
            {
                size += 2;
                size += ::protrust::io::sizes::message(optional_nested_message);
            }
            if let ::std::option::Option::Some(optional_foreign_message) =
                self.optional_foreign_message()
            {
                size += 2;
                size += ::protrust::io::sizes::message(optional_foreign_message);
            }
            if let ::std::option::Option::Some(optional_import_message) =
                self.optional_import_message()
            {
                size += 2;
                size += ::protrust::io::sizes::message(optional_import_message);
            }
            if *self.optional_nested_enum() != Self::OPTIONAL_NESTED_ENUM_DEFAULT_VALUE {
                size += 2;
                size += ::protrust::io::sizes::enum_value(*self.optional_nested_enum());
            }
            if *self.optional_foreign_enum() != Self::OPTIONAL_FOREIGN_ENUM_DEFAULT_VALUE {
                size += 2;
                size += ::protrust::io::sizes::enum_value(*self.optional_foreign_enum());
            }
            if **self.optional_string_piece() != *Self::OPTIONAL_STRING_PIECE_DEFAULT_VALUE {
                size += 2;
                size += ::protrust::io::sizes::string(self.optional_string_piece());
            }
            if **self.optional_cord() != *Self::OPTIONAL_CORD_DEFAULT_VALUE {
                size += 2;
                size += ::protrust::io::sizes::string(self.optional_cord());
            }
            if let ::std::option::Option::Some(optional_public_import_message) =
                self.optional_public_import_message()
            {
                size += 2;
                size += ::protrust::io::sizes::message(optional_public_import_message);
            }
            if let ::std::option::Option::Some(optional_lazy_message) = self.optional_lazy_message()
            {
                size += 2;
                size += ::protrust::io::sizes::message(optional_lazy_message);
            }
            if let ::std::option::Option::Some(optional_lazy_import_message) =
                self.optional_lazy_import_message()
            {
                size += 2;
                size += ::protrust::io::sizes::message(optional_lazy_import_message);
            }
            size += self
                .repeated_int32()
                .calculate_size(&self::test_all_types::REPEATED_INT32_CODEC);
            size += self
                .repeated_int64()
                .calculate_size(&self::test_all_types::REPEATED_INT64_CODEC);
            size += self
                .repeated_uint32()
                .calculate_size(&self::test_all_types::REPEATED_UINT32_CODEC);
            size += self
                .repeated_uint64()
                .calculate_size(&self::test_all_types::REPEATED_UINT64_CODEC);
            size += self
                .repeated_sint32()
                .calculate_size(&self::test_all_types::REPEATED_SINT32_CODEC);
            size += self
                .repeated_sint64()
                .calculate_size(&self::test_all_types::REPEATED_SINT64_CODEC);
            size += self
                .repeated_fixed32()
                .calculate_size(&self::test_all_types::REPEATED_FIXED32_CODEC);
            size += self
                .repeated_fixed64()
                .calculate_size(&self::test_all_types::REPEATED_FIXED64_CODEC);
            size += self
                .repeated_sfixed32()
                .calculate_size(&self::test_all_types::REPEATED_SFIXED32_CODEC);
            size += self
                .repeated_sfixed64()
                .calculate_size(&self::test_all_types::REPEATED_SFIXED64_CODEC);
            size += self
                .repeated_float()
                .calculate_size(&self::test_all_types::REPEATED_FLOAT_CODEC);
            size += self
                .repeated_double()
                .calculate_size(&self::test_all_types::REPEATED_DOUBLE_CODEC);
            size += self
                .repeated_bool()
                .calculate_size(&self::test_all_types::REPEATED_BOOL_CODEC);
            size += self
                .repeated_string()
                .calculate_size(&self::test_all_types::REPEATED_STRING_CODEC);
            size += self
                .repeated_bytes()
                .calculate_size(&self::test_all_types::REPEATED_BYTES_CODEC);
            size += self
                .repeated_nested_message()
                .calculate_size(&self::test_all_types::REPEATED_NESTED_MESSAGE_CODEC);
            size += self
                .repeated_foreign_message()
                .calculate_size(&self::test_all_types::REPEATED_FOREIGN_MESSAGE_CODEC);
            size += self
                .repeated_import_message()
                .calculate_size(&self::test_all_types::REPEATED_IMPORT_MESSAGE_CODEC);
            size += self
                .repeated_nested_enum()
                .calculate_size(&self::test_all_types::REPEATED_NESTED_ENUM_CODEC);
            size += self
                .repeated_foreign_enum()
                .calculate_size(&self::test_all_types::REPEATED_FOREIGN_ENUM_CODEC);
            size += self
                .repeated_string_piece()
                .calculate_size(&self::test_all_types::REPEATED_STRING_PIECE_CODEC);
            size += self
                .repeated_cord()
                .calculate_size(&self::test_all_types::REPEATED_CORD_CODEC);
            size += self
                .repeated_lazy_message()
                .calculate_size(&self::test_all_types::REPEATED_LAZY_MESSAGE_CODEC);
            if let ::std::option::Option::Some(oneof_uint32) = self.oneof_uint32() {
                size += 2;
                size += ::protrust::io::sizes::uint32(*oneof_uint32);
            }
            if let ::std::option::Option::Some(oneof_nested_message) = self.oneof_nested_message() {
                size += 2;
                size += ::protrust::io::sizes::message(oneof_nested_message);
            }
            if let ::std::option::Option::Some(oneof_string) = self.oneof_string() {
                size += 2;
                size += ::protrust::io::sizes::string(oneof_string);
            }
            if let ::std::option::Option::Some(oneof_bytes) = self.oneof_bytes() {
                size += 2;
                size += ::protrust::io::sizes::bytes(oneof_bytes);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if *self.optional_int32() != Self::OPTIONAL_INT32_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(*self.optional_int32())?;
            }
            if *self.optional_int64() != Self::OPTIONAL_INT64_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[16])?;
                output.write_int64(*self.optional_int64())?;
            }
            if *self.optional_uint32() != Self::OPTIONAL_UINT32_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[24])?;
                output.write_uint32(*self.optional_uint32())?;
            }
            if *self.optional_uint64() != Self::OPTIONAL_UINT64_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[32])?;
                output.write_uint64(*self.optional_uint64())?;
            }
            if *self.optional_sint32() != Self::OPTIONAL_SINT32_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[40])?;
                output.write_sint32(*self.optional_sint32())?;
            }
            if *self.optional_sint64() != Self::OPTIONAL_SINT64_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[48])?;
                output.write_sint64(*self.optional_sint64())?;
            }
            if *self.optional_fixed32() != Self::OPTIONAL_FIXED32_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[61])?;
                output.write_fixed32(*self.optional_fixed32())?;
            }
            if *self.optional_fixed64() != Self::OPTIONAL_FIXED64_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[65])?;
                output.write_fixed64(*self.optional_fixed64())?;
            }
            if *self.optional_sfixed32() != Self::OPTIONAL_SFIXED32_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[77])?;
                output.write_sfixed32(*self.optional_sfixed32())?;
            }
            if *self.optional_sfixed64() != Self::OPTIONAL_SFIXED64_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[81])?;
                output.write_sfixed64(*self.optional_sfixed64())?;
            }
            if *self.optional_float() != Self::OPTIONAL_FLOAT_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[93])?;
                output.write_float(*self.optional_float())?;
            }
            if *self.optional_double() != Self::OPTIONAL_DOUBLE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[97])?;
                output.write_double(*self.optional_double())?;
            }
            if *self.optional_bool() != Self::OPTIONAL_BOOL_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[104])?;
                output.write_bool(*self.optional_bool())?;
            }
            if **self.optional_string() != *Self::OPTIONAL_STRING_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[114])?;
                output.write_string(self.optional_string())?;
            }
            if **self.optional_bytes() != *Self::OPTIONAL_BYTES_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[122])?;
                output.write_bytes(self.optional_bytes())?;
            }
            if let ::std::option::Option::Some(optional_nested_message) =
                self.optional_nested_message()
            {
                output.write_raw_tag_bytes(&[146, 1])?;
                output.write_message(optional_nested_message)?;
            }
            if let ::std::option::Option::Some(optional_foreign_message) =
                self.optional_foreign_message()
            {
                output.write_raw_tag_bytes(&[154, 1])?;
                output.write_message(optional_foreign_message)?;
            }
            if let ::std::option::Option::Some(optional_import_message) =
                self.optional_import_message()
            {
                output.write_raw_tag_bytes(&[162, 1])?;
                output.write_message(optional_import_message)?;
            }
            if *self.optional_nested_enum() != Self::OPTIONAL_NESTED_ENUM_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[168, 1])?;
                output.write_enum_value(*self.optional_nested_enum())?;
            }
            if *self.optional_foreign_enum() != Self::OPTIONAL_FOREIGN_ENUM_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[176, 1])?;
                output.write_enum_value(*self.optional_foreign_enum())?;
            }
            if **self.optional_string_piece() != *Self::OPTIONAL_STRING_PIECE_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[194, 1])?;
                output.write_string(self.optional_string_piece())?;
            }
            if **self.optional_cord() != *Self::OPTIONAL_CORD_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[202, 1])?;
                output.write_string(self.optional_cord())?;
            }
            if let ::std::option::Option::Some(optional_public_import_message) =
                self.optional_public_import_message()
            {
                output.write_raw_tag_bytes(&[210, 1])?;
                output.write_message(optional_public_import_message)?;
            }
            if let ::std::option::Option::Some(optional_lazy_message) = self.optional_lazy_message()
            {
                output.write_raw_tag_bytes(&[218, 1])?;
                output.write_message(optional_lazy_message)?;
            }
            if let ::std::option::Option::Some(optional_lazy_import_message) =
                self.optional_lazy_import_message()
            {
                output.write_raw_tag_bytes(&[154, 7])?;
                output.write_message(optional_lazy_import_message)?;
            }
            self.repeated_int32()
                .write_to(output, &self::test_all_types::REPEATED_INT32_CODEC)?;
            self.repeated_int64()
                .write_to(output, &self::test_all_types::REPEATED_INT64_CODEC)?;
            self.repeated_uint32()
                .write_to(output, &self::test_all_types::REPEATED_UINT32_CODEC)?;
            self.repeated_uint64()
                .write_to(output, &self::test_all_types::REPEATED_UINT64_CODEC)?;
            self.repeated_sint32()
                .write_to(output, &self::test_all_types::REPEATED_SINT32_CODEC)?;
            self.repeated_sint64()
                .write_to(output, &self::test_all_types::REPEATED_SINT64_CODEC)?;
            self.repeated_fixed32()
                .write_to(output, &self::test_all_types::REPEATED_FIXED32_CODEC)?;
            self.repeated_fixed64()
                .write_to(output, &self::test_all_types::REPEATED_FIXED64_CODEC)?;
            self.repeated_sfixed32()
                .write_to(output, &self::test_all_types::REPEATED_SFIXED32_CODEC)?;
            self.repeated_sfixed64()
                .write_to(output, &self::test_all_types::REPEATED_SFIXED64_CODEC)?;
            self.repeated_float()
                .write_to(output, &self::test_all_types::REPEATED_FLOAT_CODEC)?;
            self.repeated_double()
                .write_to(output, &self::test_all_types::REPEATED_DOUBLE_CODEC)?;
            self.repeated_bool()
                .write_to(output, &self::test_all_types::REPEATED_BOOL_CODEC)?;
            self.repeated_string()
                .write_to(output, &self::test_all_types::REPEATED_STRING_CODEC)?;
            self.repeated_bytes()
                .write_to(output, &self::test_all_types::REPEATED_BYTES_CODEC)?;
            self.repeated_nested_message()
                .write_to(output, &self::test_all_types::REPEATED_NESTED_MESSAGE_CODEC)?;
            self.repeated_foreign_message().write_to(
                output,
                &self::test_all_types::REPEATED_FOREIGN_MESSAGE_CODEC,
            )?;
            self.repeated_import_message()
                .write_to(output, &self::test_all_types::REPEATED_IMPORT_MESSAGE_CODEC)?;
            self.repeated_nested_enum()
                .write_to(output, &self::test_all_types::REPEATED_NESTED_ENUM_CODEC)?;
            self.repeated_foreign_enum()
                .write_to(output, &self::test_all_types::REPEATED_FOREIGN_ENUM_CODEC)?;
            self.repeated_string_piece()
                .write_to(output, &self::test_all_types::REPEATED_STRING_PIECE_CODEC)?;
            self.repeated_cord()
                .write_to(output, &self::test_all_types::REPEATED_CORD_CODEC)?;
            self.repeated_lazy_message()
                .write_to(output, &self::test_all_types::REPEATED_LAZY_MESSAGE_CODEC)?;
            if let ::std::option::Option::Some(oneof_uint32) = self.oneof_uint32() {
                output.write_raw_tag_bytes(&[248, 6])?;
                output.write_uint32(*oneof_uint32)?;
            }
            if let ::std::option::Option::Some(oneof_nested_message) = self.oneof_nested_message() {
                output.write_raw_tag_bytes(&[130, 7])?;
                output.write_message(oneof_nested_message)?;
            }
            if let ::std::option::Option::Some(oneof_string) = self.oneof_string() {
                output.write_raw_tag_bytes(&[138, 7])?;
                output.write_string(oneof_string)?;
            }
            if let ::std::option::Option::Some(oneof_bytes) = self.oneof_bytes() {
                output.write_raw_tag_bytes(&[146, 7])?;
                output.write_bytes(oneof_bytes)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(optional_nested_message) =
                self.optional_nested_message()
            {
                if !::protrust::CodedMessage::is_initialized(optional_nested_message) {
                    return false;
                }
            }
            if let ::std::option::Option::Some(optional_foreign_message) =
                self.optional_foreign_message()
            {
                if !::protrust::CodedMessage::is_initialized(optional_foreign_message) {
                    return false;
                }
            }
            if let ::std::option::Option::Some(optional_import_message) =
                self.optional_import_message()
            {
                if !::protrust::CodedMessage::is_initialized(optional_import_message) {
                    return false;
                }
            }
            if let ::std::option::Option::Some(optional_public_import_message) =
                self.optional_public_import_message()
            {
                if !::protrust::CodedMessage::is_initialized(optional_public_import_message) {
                    return false;
                }
            }
            if let ::std::option::Option::Some(optional_lazy_message) = self.optional_lazy_message()
            {
                if !::protrust::CodedMessage::is_initialized(optional_lazy_message) {
                    return false;
                }
            }
            if let ::std::option::Option::Some(optional_lazy_import_message) =
                self.optional_lazy_import_message()
            {
                if !::protrust::CodedMessage::is_initialized(optional_lazy_import_message) {
                    return false;
                }
            }
            if !self.repeated_nested_message.is_initialized() {
                return false;
            }
            if !self.repeated_foreign_message.is_initialized() {
                return false;
            }
            if !self.repeated_import_message.is_initialized() {
                return false;
            }
            if !self.repeated_lazy_message.is_initialized() {
                return false;
            }
            if let ::std::option::Option::Some(oneof_nested_message) = self.oneof_nested_message() {
                if !::protrust::CodedMessage::is_initialized(oneof_nested_message) {
                    return false;
                }
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestAllTypes {
        fn merge(&mut self, other: &Self) {
            if *other.optional_int32() != Self::OPTIONAL_INT32_DEFAULT_VALUE {
                *self.optional_int32_mut() = *other.optional_int32();
            }
            if *other.optional_int64() != Self::OPTIONAL_INT64_DEFAULT_VALUE {
                *self.optional_int64_mut() = *other.optional_int64();
            }
            if *other.optional_uint32() != Self::OPTIONAL_UINT32_DEFAULT_VALUE {
                *self.optional_uint32_mut() = *other.optional_uint32();
            }
            if *other.optional_uint64() != Self::OPTIONAL_UINT64_DEFAULT_VALUE {
                *self.optional_uint64_mut() = *other.optional_uint64();
            }
            if *other.optional_sint32() != Self::OPTIONAL_SINT32_DEFAULT_VALUE {
                *self.optional_sint32_mut() = *other.optional_sint32();
            }
            if *other.optional_sint64() != Self::OPTIONAL_SINT64_DEFAULT_VALUE {
                *self.optional_sint64_mut() = *other.optional_sint64();
            }
            if *other.optional_fixed32() != Self::OPTIONAL_FIXED32_DEFAULT_VALUE {
                *self.optional_fixed32_mut() = *other.optional_fixed32();
            }
            if *other.optional_fixed64() != Self::OPTIONAL_FIXED64_DEFAULT_VALUE {
                *self.optional_fixed64_mut() = *other.optional_fixed64();
            }
            if *other.optional_sfixed32() != Self::OPTIONAL_SFIXED32_DEFAULT_VALUE {
                *self.optional_sfixed32_mut() = *other.optional_sfixed32();
            }
            if *other.optional_sfixed64() != Self::OPTIONAL_SFIXED64_DEFAULT_VALUE {
                *self.optional_sfixed64_mut() = *other.optional_sfixed64();
            }
            if *other.optional_float() != Self::OPTIONAL_FLOAT_DEFAULT_VALUE {
                *self.optional_float_mut() = *other.optional_float();
            }
            if *other.optional_double() != Self::OPTIONAL_DOUBLE_DEFAULT_VALUE {
                *self.optional_double_mut() = *other.optional_double();
            }
            if *other.optional_bool() != Self::OPTIONAL_BOOL_DEFAULT_VALUE {
                *self.optional_bool_mut() = *other.optional_bool();
            }
            if other.optional_string.len() != 0 {
                *self.optional_string_mut() = ::std::clone::Clone::clone(other.optional_string());
            }
            if other.optional_bytes.len() != 0 {
                *self.optional_bytes_mut() = ::std::clone::Clone::clone(other.optional_bytes());
            }
            if let ::std::option::Option::Some(optional_nested_message) =
                &other.optional_nested_message()
            {
                ::protrust::LiteMessage::merge(
                    self.optional_nested_message_mut(),
                    optional_nested_message,
                );
            }
            if let ::std::option::Option::Some(optional_foreign_message) =
                &other.optional_foreign_message()
            {
                ::protrust::LiteMessage::merge(
                    self.optional_foreign_message_mut(),
                    optional_foreign_message,
                );
            }
            if let ::std::option::Option::Some(optional_import_message) =
                &other.optional_import_message()
            {
                ::protrust::LiteMessage::merge(
                    self.optional_import_message_mut(),
                    optional_import_message,
                );
            }
            if *other.optional_nested_enum() != Self::OPTIONAL_NESTED_ENUM_DEFAULT_VALUE {
                *self.optional_nested_enum_mut() = *other.optional_nested_enum();
            }
            if *other.optional_foreign_enum() != Self::OPTIONAL_FOREIGN_ENUM_DEFAULT_VALUE {
                *self.optional_foreign_enum_mut() = *other.optional_foreign_enum();
            }
            if other.optional_string_piece.len() != 0 {
                *self.optional_string_piece_mut() =
                    ::std::clone::Clone::clone(other.optional_string_piece());
            }
            if other.optional_cord.len() != 0 {
                *self.optional_cord_mut() = ::std::clone::Clone::clone(other.optional_cord());
            }
            if let ::std::option::Option::Some(optional_public_import_message) =
                &other.optional_public_import_message()
            {
                ::protrust::LiteMessage::merge(
                    self.optional_public_import_message_mut(),
                    optional_public_import_message,
                );
            }
            if let ::std::option::Option::Some(optional_lazy_message) =
                &other.optional_lazy_message()
            {
                ::protrust::LiteMessage::merge(
                    self.optional_lazy_message_mut(),
                    optional_lazy_message,
                );
            }
            if let ::std::option::Option::Some(optional_lazy_import_message) =
                &other.optional_lazy_import_message()
            {
                ::protrust::LiteMessage::merge(
                    self.optional_lazy_import_message_mut(),
                    optional_lazy_import_message,
                );
            }
            self.repeated_int32.merge(&other.repeated_int32);
            self.repeated_int64.merge(&other.repeated_int64);
            self.repeated_uint32.merge(&other.repeated_uint32);
            self.repeated_uint64.merge(&other.repeated_uint64);
            self.repeated_sint32.merge(&other.repeated_sint32);
            self.repeated_sint64.merge(&other.repeated_sint64);
            self.repeated_fixed32.merge(&other.repeated_fixed32);
            self.repeated_fixed64.merge(&other.repeated_fixed64);
            self.repeated_sfixed32.merge(&other.repeated_sfixed32);
            self.repeated_sfixed64.merge(&other.repeated_sfixed64);
            self.repeated_float.merge(&other.repeated_float);
            self.repeated_double.merge(&other.repeated_double);
            self.repeated_bool.merge(&other.repeated_bool);
            self.repeated_string.merge(&other.repeated_string);
            self.repeated_bytes.merge(&other.repeated_bytes);
            self.repeated_nested_message
                .merge(&other.repeated_nested_message);
            self.repeated_foreign_message
                .merge(&other.repeated_foreign_message);
            self.repeated_import_message
                .merge(&other.repeated_import_message);
            self.repeated_nested_enum.merge(&other.repeated_nested_enum);
            self.repeated_foreign_enum
                .merge(&other.repeated_foreign_enum);
            self.repeated_string_piece
                .merge(&other.repeated_string_piece);
            self.repeated_cord.merge(&other.repeated_cord);
            self.repeated_lazy_message
                .merge(&other.repeated_lazy_message);
            if let ::std::option::Option::Some(oneof_uint32) = other.oneof_uint32() {
                self.set_oneof_uint32(*oneof_uint32);
            }
            if let ::std::option::Option::Some(oneof_nested_message) = &other.oneof_nested_message()
            {
                ::protrust::LiteMessage::merge(
                    self.oneof_nested_message_mut(),
                    oneof_nested_message,
                );
            }
            if let ::std::option::Option::Some(oneof_string) = other.oneof_string() {
                self.set_oneof_string(::std::clone::Clone::clone(oneof_string));
            }
            if let ::std::option::Option::Some(oneof_bytes) = other.oneof_bytes() {
                self.set_oneof_bytes(::std::clone::Clone::clone(oneof_bytes));
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestAllTypes {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[0]
        }
    }
    impl self::TestAllTypes {
        pub const OPTIONAL_INT32_FIELD_NUMBER: i32 = 1;
        pub const OPTIONAL_INT32_DEFAULT_VALUE: i32 = 0;
        pub fn optional_int32(&self) -> &i32 {
            &self.optional_int32
        }
        pub fn optional_int32_mut(&mut self) -> &mut i32 {
            &mut self.optional_int32
        }
        pub const OPTIONAL_INT64_FIELD_NUMBER: i32 = 2;
        pub const OPTIONAL_INT64_DEFAULT_VALUE: i64 = 0;
        pub fn optional_int64(&self) -> &i64 {
            &self.optional_int64
        }
        pub fn optional_int64_mut(&mut self) -> &mut i64 {
            &mut self.optional_int64
        }
        pub const OPTIONAL_UINT32_FIELD_NUMBER: i32 = 3;
        pub const OPTIONAL_UINT32_DEFAULT_VALUE: u32 = 0;
        pub fn optional_uint32(&self) -> &u32 {
            &self.optional_uint32
        }
        pub fn optional_uint32_mut(&mut self) -> &mut u32 {
            &mut self.optional_uint32
        }
        pub const OPTIONAL_UINT64_FIELD_NUMBER: i32 = 4;
        pub const OPTIONAL_UINT64_DEFAULT_VALUE: u64 = 0;
        pub fn optional_uint64(&self) -> &u64 {
            &self.optional_uint64
        }
        pub fn optional_uint64_mut(&mut self) -> &mut u64 {
            &mut self.optional_uint64
        }
        pub const OPTIONAL_SINT32_FIELD_NUMBER: i32 = 5;
        pub const OPTIONAL_SINT32_DEFAULT_VALUE: i32 = 0;
        pub fn optional_sint32(&self) -> &i32 {
            &self.optional_sint32
        }
        pub fn optional_sint32_mut(&mut self) -> &mut i32 {
            &mut self.optional_sint32
        }
        pub const OPTIONAL_SINT64_FIELD_NUMBER: i32 = 6;
        pub const OPTIONAL_SINT64_DEFAULT_VALUE: i64 = 0;
        pub fn optional_sint64(&self) -> &i64 {
            &self.optional_sint64
        }
        pub fn optional_sint64_mut(&mut self) -> &mut i64 {
            &mut self.optional_sint64
        }
        pub const OPTIONAL_FIXED32_FIELD_NUMBER: i32 = 7;
        pub const OPTIONAL_FIXED32_DEFAULT_VALUE: u32 = 0;
        pub fn optional_fixed32(&self) -> &u32 {
            &self.optional_fixed32
        }
        pub fn optional_fixed32_mut(&mut self) -> &mut u32 {
            &mut self.optional_fixed32
        }
        pub const OPTIONAL_FIXED64_FIELD_NUMBER: i32 = 8;
        pub const OPTIONAL_FIXED64_DEFAULT_VALUE: u64 = 0;
        pub fn optional_fixed64(&self) -> &u64 {
            &self.optional_fixed64
        }
        pub fn optional_fixed64_mut(&mut self) -> &mut u64 {
            &mut self.optional_fixed64
        }
        pub const OPTIONAL_SFIXED32_FIELD_NUMBER: i32 = 9;
        pub const OPTIONAL_SFIXED32_DEFAULT_VALUE: i32 = 0;
        pub fn optional_sfixed32(&self) -> &i32 {
            &self.optional_sfixed32
        }
        pub fn optional_sfixed32_mut(&mut self) -> &mut i32 {
            &mut self.optional_sfixed32
        }
        pub const OPTIONAL_SFIXED64_FIELD_NUMBER: i32 = 10;
        pub const OPTIONAL_SFIXED64_DEFAULT_VALUE: i64 = 0;
        pub fn optional_sfixed64(&self) -> &i64 {
            &self.optional_sfixed64
        }
        pub fn optional_sfixed64_mut(&mut self) -> &mut i64 {
            &mut self.optional_sfixed64
        }
        pub const OPTIONAL_FLOAT_FIELD_NUMBER: i32 = 11;
        pub const OPTIONAL_FLOAT_DEFAULT_VALUE: f32 = 0.0;
        pub fn optional_float(&self) -> &f32 {
            &self.optional_float
        }
        pub fn optional_float_mut(&mut self) -> &mut f32 {
            &mut self.optional_float
        }
        pub const OPTIONAL_DOUBLE_FIELD_NUMBER: i32 = 12;
        pub const OPTIONAL_DOUBLE_DEFAULT_VALUE: f64 = 0.0;
        pub fn optional_double(&self) -> &f64 {
            &self.optional_double
        }
        pub fn optional_double_mut(&mut self) -> &mut f64 {
            &mut self.optional_double
        }
        pub const OPTIONAL_BOOL_FIELD_NUMBER: i32 = 13;
        pub const OPTIONAL_BOOL_DEFAULT_VALUE: bool = false;
        pub fn optional_bool(&self) -> &bool {
            &self.optional_bool
        }
        pub fn optional_bool_mut(&mut self) -> &mut bool {
            &mut self.optional_bool
        }
        pub const OPTIONAL_STRING_FIELD_NUMBER: i32 = 14;
        pub const OPTIONAL_STRING_DEFAULT_VALUE: &'static str = "";
        pub fn optional_string(&self) -> &::std::string::String {
            &self.optional_string
        }
        pub fn optional_string_mut(&mut self) -> &mut ::std::string::String {
            &mut self.optional_string
        }
        pub const OPTIONAL_BYTES_FIELD_NUMBER: i32 = 15;
        pub const OPTIONAL_BYTES_DEFAULT_VALUE: &'static [u8] = &[];
        pub fn optional_bytes(&self) -> &::std::vec::Vec<u8> {
            &self.optional_bytes
        }
        pub fn optional_bytes_mut(&mut self) -> &mut ::std::vec::Vec<u8> {
            &mut self.optional_bytes
        }
        pub const OPTIONAL_NESTED_MESSAGE_FIELD_NUMBER: i32 = 18;
        pub fn optional_nested_message(
            &self,
        ) -> ::std::option::Option<&self::test_all_types::NestedMessage> {
            self.optional_nested_message.as_ref().map(|v| &**v)
        }
        pub fn optional_nested_message_mut(&mut self) -> &mut self::test_all_types::NestedMessage {
            self.optional_nested_message
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_nested_message(&self) -> bool {
            self.optional_nested_message.is_some()
        }
        pub fn set_optional_nested_message(&mut self, value: self::test_all_types::NestedMessage) {
            self.optional_nested_message =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_nested_message(
            &mut self,
        ) -> ::std::option::Option<self::test_all_types::NestedMessage> {
            self.optional_nested_message.take().map(|v| *v)
        }
        pub fn clear_optional_nested_message(&mut self) {
            self.optional_nested_message = ::std::option::Option::None;
        }
        pub const OPTIONAL_FOREIGN_MESSAGE_FIELD_NUMBER: i32 = 19;
        pub fn optional_foreign_message(&self) -> ::std::option::Option<&self::ForeignMessage> {
            self.optional_foreign_message.as_ref().map(|v| &**v)
        }
        pub fn optional_foreign_message_mut(&mut self) -> &mut self::ForeignMessage {
            self.optional_foreign_message
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_foreign_message(&self) -> bool {
            self.optional_foreign_message.is_some()
        }
        pub fn set_optional_foreign_message(&mut self, value: self::ForeignMessage) {
            self.optional_foreign_message =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_foreign_message(
            &mut self,
        ) -> ::std::option::Option<self::ForeignMessage> {
            self.optional_foreign_message.take().map(|v| *v)
        }
        pub fn clear_optional_foreign_message(&mut self) {
            self.optional_foreign_message = ::std::option::Option::None;
        }
        pub const OPTIONAL_IMPORT_MESSAGE_FIELD_NUMBER: i32 = 20;
        pub fn optional_import_message(
            &self,
        ) -> ::std::option::Option<&self::super::unittest_import_proto::ImportMessage> {
            self.optional_import_message.as_ref().map(|v| &**v)
        }
        pub fn optional_import_message_mut(
            &mut self,
        ) -> &mut self::super::unittest_import_proto::ImportMessage {
            self.optional_import_message
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_import_message(&self) -> bool {
            self.optional_import_message.is_some()
        }
        pub fn set_optional_import_message(
            &mut self,
            value: self::super::unittest_import_proto::ImportMessage,
        ) {
            self.optional_import_message =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_import_message(
            &mut self,
        ) -> ::std::option::Option<self::super::unittest_import_proto::ImportMessage> {
            self.optional_import_message.take().map(|v| *v)
        }
        pub fn clear_optional_import_message(&mut self) {
            self.optional_import_message = ::std::option::Option::None;
        }
        pub const OPTIONAL_NESTED_ENUM_FIELD_NUMBER: i32 = 21;
        pub const OPTIONAL_NESTED_ENUM_DEFAULT_VALUE: ::protrust::EnumValue<
            self::test_all_types::NestedEnum,
        > = ::protrust::EnumValue::Defined(self::test_all_types::NestedEnum::Zero);
        pub fn optional_nested_enum(
            &self,
        ) -> &::protrust::EnumValue<self::test_all_types::NestedEnum> {
            &self.optional_nested_enum
        }
        pub fn optional_nested_enum_mut(
            &mut self,
        ) -> &mut ::protrust::EnumValue<self::test_all_types::NestedEnum> {
            &mut self.optional_nested_enum
        }
        pub const OPTIONAL_FOREIGN_ENUM_FIELD_NUMBER: i32 = 22;
        pub const OPTIONAL_FOREIGN_ENUM_DEFAULT_VALUE: ::protrust::EnumValue<self::ForeignEnum> =
            ::protrust::EnumValue::Defined(self::ForeignEnum::ForeignZero);
        pub fn optional_foreign_enum(&self) -> &::protrust::EnumValue<self::ForeignEnum> {
            &self.optional_foreign_enum
        }
        pub fn optional_foreign_enum_mut(
            &mut self,
        ) -> &mut ::protrust::EnumValue<self::ForeignEnum> {
            &mut self.optional_foreign_enum
        }
        pub const OPTIONAL_STRING_PIECE_FIELD_NUMBER: i32 = 24;
        pub const OPTIONAL_STRING_PIECE_DEFAULT_VALUE: &'static str = "";
        pub fn optional_string_piece(&self) -> &::std::string::String {
            &self.optional_string_piece
        }
        pub fn optional_string_piece_mut(&mut self) -> &mut ::std::string::String {
            &mut self.optional_string_piece
        }
        pub const OPTIONAL_CORD_FIELD_NUMBER: i32 = 25;
        pub const OPTIONAL_CORD_DEFAULT_VALUE: &'static str = "";
        pub fn optional_cord(&self) -> &::std::string::String {
            &self.optional_cord
        }
        pub fn optional_cord_mut(&mut self) -> &mut ::std::string::String {
            &mut self.optional_cord
        }
        pub const OPTIONAL_PUBLIC_IMPORT_MESSAGE_FIELD_NUMBER: i32 = 26;
        pub fn optional_public_import_message(
            &self,
        ) -> ::std::option::Option<&self::super::unittest_import_public_proto::PublicImportMessage>
        {
            self.optional_public_import_message.as_ref().map(|v| &**v)
        }
        pub fn optional_public_import_message_mut(
            &mut self,
        ) -> &mut self::super::unittest_import_public_proto::PublicImportMessage {
            self.optional_public_import_message
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_public_import_message(&self) -> bool {
            self.optional_public_import_message.is_some()
        }
        pub fn set_optional_public_import_message(
            &mut self,
            value: self::super::unittest_import_public_proto::PublicImportMessage,
        ) {
            self.optional_public_import_message =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_public_import_message(
            &mut self,
        ) -> ::std::option::Option<self::super::unittest_import_public_proto::PublicImportMessage>
        {
            self.optional_public_import_message.take().map(|v| *v)
        }
        pub fn clear_optional_public_import_message(&mut self) {
            self.optional_public_import_message = ::std::option::Option::None;
        }
        pub const OPTIONAL_LAZY_MESSAGE_FIELD_NUMBER: i32 = 27;
        pub fn optional_lazy_message(
            &self,
        ) -> ::std::option::Option<&self::test_all_types::NestedMessage> {
            self.optional_lazy_message.as_ref().map(|v| &**v)
        }
        pub fn optional_lazy_message_mut(&mut self) -> &mut self::test_all_types::NestedMessage {
            self.optional_lazy_message
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_lazy_message(&self) -> bool {
            self.optional_lazy_message.is_some()
        }
        pub fn set_optional_lazy_message(&mut self, value: self::test_all_types::NestedMessage) {
            self.optional_lazy_message =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_lazy_message(
            &mut self,
        ) -> ::std::option::Option<self::test_all_types::NestedMessage> {
            self.optional_lazy_message.take().map(|v| *v)
        }
        pub fn clear_optional_lazy_message(&mut self) {
            self.optional_lazy_message = ::std::option::Option::None;
        }
        pub const OPTIONAL_LAZY_IMPORT_MESSAGE_FIELD_NUMBER: i32 = 115;
        pub fn optional_lazy_import_message(
            &self,
        ) -> ::std::option::Option<&self::super::unittest_import_proto::ImportMessage> {
            self.optional_lazy_import_message.as_ref().map(|v| &**v)
        }
        pub fn optional_lazy_import_message_mut(
            &mut self,
        ) -> &mut self::super::unittest_import_proto::ImportMessage {
            self.optional_lazy_import_message
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_optional_lazy_import_message(&self) -> bool {
            self.optional_lazy_import_message.is_some()
        }
        pub fn set_optional_lazy_import_message(
            &mut self,
            value: self::super::unittest_import_proto::ImportMessage,
        ) {
            self.optional_lazy_import_message =
                ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_optional_lazy_import_message(
            &mut self,
        ) -> ::std::option::Option<self::super::unittest_import_proto::ImportMessage> {
            self.optional_lazy_import_message.take().map(|v| *v)
        }
        pub fn clear_optional_lazy_import_message(&mut self) {
            self.optional_lazy_import_message = ::std::option::Option::None;
        }
        pub const REPEATED_INT32_FIELD_NUMBER: i32 = 31;
        pub fn repeated_int32(&self) -> &::protrust::collections::RepeatedField<i32> {
            &self.repeated_int32
        }
        pub fn repeated_int32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
            &mut self.repeated_int32
        }
        pub const REPEATED_INT64_FIELD_NUMBER: i32 = 32;
        pub fn repeated_int64(&self) -> &::protrust::collections::RepeatedField<i64> {
            &self.repeated_int64
        }
        pub fn repeated_int64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
            &mut self.repeated_int64
        }
        pub const REPEATED_UINT32_FIELD_NUMBER: i32 = 33;
        pub fn repeated_uint32(&self) -> &::protrust::collections::RepeatedField<u32> {
            &self.repeated_uint32
        }
        pub fn repeated_uint32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u32> {
            &mut self.repeated_uint32
        }
        pub const REPEATED_UINT64_FIELD_NUMBER: i32 = 34;
        pub fn repeated_uint64(&self) -> &::protrust::collections::RepeatedField<u64> {
            &self.repeated_uint64
        }
        pub fn repeated_uint64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u64> {
            &mut self.repeated_uint64
        }
        pub const REPEATED_SINT32_FIELD_NUMBER: i32 = 35;
        pub fn repeated_sint32(&self) -> &::protrust::collections::RepeatedField<i32> {
            &self.repeated_sint32
        }
        pub fn repeated_sint32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
            &mut self.repeated_sint32
        }
        pub const REPEATED_SINT64_FIELD_NUMBER: i32 = 36;
        pub fn repeated_sint64(&self) -> &::protrust::collections::RepeatedField<i64> {
            &self.repeated_sint64
        }
        pub fn repeated_sint64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
            &mut self.repeated_sint64
        }
        pub const REPEATED_FIXED32_FIELD_NUMBER: i32 = 37;
        pub fn repeated_fixed32(&self) -> &::protrust::collections::RepeatedField<u32> {
            &self.repeated_fixed32
        }
        pub fn repeated_fixed32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u32> {
            &mut self.repeated_fixed32
        }
        pub const REPEATED_FIXED64_FIELD_NUMBER: i32 = 38;
        pub fn repeated_fixed64(&self) -> &::protrust::collections::RepeatedField<u64> {
            &self.repeated_fixed64
        }
        pub fn repeated_fixed64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u64> {
            &mut self.repeated_fixed64
        }
        pub const REPEATED_SFIXED32_FIELD_NUMBER: i32 = 39;
        pub fn repeated_sfixed32(&self) -> &::protrust::collections::RepeatedField<i32> {
            &self.repeated_sfixed32
        }
        pub fn repeated_sfixed32_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<i32> {
            &mut self.repeated_sfixed32
        }
        pub const REPEATED_SFIXED64_FIELD_NUMBER: i32 = 40;
        pub fn repeated_sfixed64(&self) -> &::protrust::collections::RepeatedField<i64> {
            &self.repeated_sfixed64
        }
        pub fn repeated_sfixed64_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<i64> {
            &mut self.repeated_sfixed64
        }
        pub const REPEATED_FLOAT_FIELD_NUMBER: i32 = 41;
        pub fn repeated_float(&self) -> &::protrust::collections::RepeatedField<f32> {
            &self.repeated_float
        }
        pub fn repeated_float_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<f32> {
            &mut self.repeated_float
        }
        pub const REPEATED_DOUBLE_FIELD_NUMBER: i32 = 42;
        pub fn repeated_double(&self) -> &::protrust::collections::RepeatedField<f64> {
            &self.repeated_double
        }
        pub fn repeated_double_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<f64> {
            &mut self.repeated_double
        }
        pub const REPEATED_BOOL_FIELD_NUMBER: i32 = 43;
        pub fn repeated_bool(&self) -> &::protrust::collections::RepeatedField<bool> {
            &self.repeated_bool
        }
        pub fn repeated_bool_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<bool> {
            &mut self.repeated_bool
        }
        pub const REPEATED_STRING_FIELD_NUMBER: i32 = 44;
        pub fn repeated_string(
            &self,
        ) -> &::protrust::collections::RepeatedField<::std::string::String> {
            &self.repeated_string
        }
        pub fn repeated_string_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<::std::string::String> {
            &mut self.repeated_string
        }
        pub const REPEATED_BYTES_FIELD_NUMBER: i32 = 45;
        pub fn repeated_bytes(
            &self,
        ) -> &::protrust::collections::RepeatedField<::std::vec::Vec<u8>> {
            &self.repeated_bytes
        }
        pub fn repeated_bytes_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<::std::vec::Vec<u8>> {
            &mut self.repeated_bytes
        }
        pub const REPEATED_NESTED_MESSAGE_FIELD_NUMBER: i32 = 48;
        pub fn repeated_nested_message(
            &self,
        ) -> &::protrust::collections::RepeatedField<self::test_all_types::NestedMessage> {
            &self.repeated_nested_message
        }
        pub fn repeated_nested_message_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<self::test_all_types::NestedMessage>
        {
            &mut self.repeated_nested_message
        }
        pub const REPEATED_FOREIGN_MESSAGE_FIELD_NUMBER: i32 = 49;
        pub fn repeated_foreign_message(
            &self,
        ) -> &::protrust::collections::RepeatedField<self::ForeignMessage> {
            &self.repeated_foreign_message
        }
        pub fn repeated_foreign_message_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<self::ForeignMessage> {
            &mut self.repeated_foreign_message
        }
        pub const REPEATED_IMPORT_MESSAGE_FIELD_NUMBER: i32 = 50;
        pub fn repeated_import_message(
            &self,
        ) -> &::protrust::collections::RepeatedField<
            self::super::unittest_import_proto::ImportMessage,
        > {
            &self.repeated_import_message
        }
        pub fn repeated_import_message_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<
            self::super::unittest_import_proto::ImportMessage,
        > {
            &mut self.repeated_import_message
        }
        pub const REPEATED_NESTED_ENUM_FIELD_NUMBER: i32 = 51;
        pub fn repeated_nested_enum(
            &self,
        ) -> &::protrust::collections::RepeatedField<
            ::protrust::EnumValue<self::test_all_types::NestedEnum>,
        > {
            &self.repeated_nested_enum
        }
        pub fn repeated_nested_enum_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<
            ::protrust::EnumValue<self::test_all_types::NestedEnum>,
        > {
            &mut self.repeated_nested_enum
        }
        pub const REPEATED_FOREIGN_ENUM_FIELD_NUMBER: i32 = 52;
        pub fn repeated_foreign_enum(
            &self,
        ) -> &::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>>
        {
            &self.repeated_foreign_enum
        }
        pub fn repeated_foreign_enum_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>>
        {
            &mut self.repeated_foreign_enum
        }
        pub const REPEATED_STRING_PIECE_FIELD_NUMBER: i32 = 54;
        pub fn repeated_string_piece(
            &self,
        ) -> &::protrust::collections::RepeatedField<::std::string::String> {
            &self.repeated_string_piece
        }
        pub fn repeated_string_piece_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<::std::string::String> {
            &mut self.repeated_string_piece
        }
        pub const REPEATED_CORD_FIELD_NUMBER: i32 = 55;
        pub fn repeated_cord(
            &self,
        ) -> &::protrust::collections::RepeatedField<::std::string::String> {
            &self.repeated_cord
        }
        pub fn repeated_cord_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<::std::string::String> {
            &mut self.repeated_cord
        }
        pub const REPEATED_LAZY_MESSAGE_FIELD_NUMBER: i32 = 57;
        pub fn repeated_lazy_message(
            &self,
        ) -> &::protrust::collections::RepeatedField<self::test_all_types::NestedMessage> {
            &self.repeated_lazy_message
        }
        pub fn repeated_lazy_message_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<self::test_all_types::NestedMessage>
        {
            &mut self.repeated_lazy_message
        }
        pub const ONEOF_UINT32_FIELD_NUMBER: i32 = 111;
        pub const ONEOF_UINT32_DEFAULT_VALUE: u32 = 0;
        pub fn oneof_uint32(&self) -> ::std::option::Option<&u32> {
            match &self.oneof_field {
                self::test_all_types::OneofField::OneofUint32(oneof_field) => {
                    ::std::option::Option::Some(oneof_field)
                }
                _ => ::std::option::Option::None,
            }
        }
        pub fn oneof_uint32_mut(&mut self) -> &mut u32 {
            match self.oneof_field {
                self::test_all_types::OneofField::OneofUint32(_) => (),
                _ => {
                    self.oneof_field = self::test_all_types::OneofField::OneofUint32(
                        ::std::default::Default::default(),
                    )
                }
            }
            match self.oneof_field {
                self::test_all_types::OneofField::OneofUint32(ref mut oneof_field) => oneof_field,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_oneof_uint32(&self) -> bool {
            match self.oneof_field {
                self::test_all_types::OneofField::OneofUint32(_) => true,
                _ => false,
            }
        }
        pub fn set_oneof_uint32(&mut self, value: u32) {
            self.oneof_field =
                self::test_all_types::OneofField::OneofUint32(::std::convert::From::from(value))
        }
        pub fn take_oneof_uint32(&mut self) -> ::std::option::Option<u32> {
            let oneof_field = ::std::mem::replace(
                &mut self.oneof_field,
                self::test_all_types::OneofField::None,
            );
            match oneof_field {
                self::test_all_types::OneofField::OneofUint32(oneof_field) => {
                    ::std::option::Option::Some(oneof_field)
                }
                mut oneof_field => {
                    ::std::mem::swap(&mut self.oneof_field, &mut oneof_field);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_oneof_uint32(&mut self) {
            let oneof_field = ::std::mem::replace(
                &mut self.oneof_field,
                self::test_all_types::OneofField::None,
            );
            match oneof_field {
                self::test_all_types::OneofField::OneofUint32(_) => {}
                mut oneof_field => ::std::mem::swap(&mut self.oneof_field, &mut oneof_field),
            }
        }
        pub const ONEOF_NESTED_MESSAGE_FIELD_NUMBER: i32 = 112;
        pub fn oneof_nested_message(
            &self,
        ) -> ::std::option::Option<&self::test_all_types::NestedMessage> {
            match &self.oneof_field {
                self::test_all_types::OneofField::OneofNestedMessage(oneof_field) => {
                    ::std::option::Option::Some(&**oneof_field)
                }
                _ => ::std::option::Option::None,
            }
        }
        pub fn oneof_nested_message_mut(&mut self) -> &mut self::test_all_types::NestedMessage {
            match self.oneof_field {
                self::test_all_types::OneofField::OneofNestedMessage(_) => (),
                _ => {
                    self.oneof_field = self::test_all_types::OneofField::OneofNestedMessage(
                        ::std::default::Default::default(),
                    )
                }
            }
            match self.oneof_field {
                self::test_all_types::OneofField::OneofNestedMessage(ref mut oneof_field) => {
                    &mut **oneof_field
                }
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_oneof_nested_message(&self) -> bool {
            match self.oneof_field {
                self::test_all_types::OneofField::OneofNestedMessage(_) => true,
                _ => false,
            }
        }
        pub fn set_oneof_nested_message(&mut self, value: self::test_all_types::NestedMessage) {
            self.oneof_field = self::test_all_types::OneofField::OneofNestedMessage(
                ::std::convert::From::from(value),
            )
        }
        pub fn take_oneof_nested_message(
            &mut self,
        ) -> ::std::option::Option<self::test_all_types::NestedMessage> {
            let oneof_field = ::std::mem::replace(
                &mut self.oneof_field,
                self::test_all_types::OneofField::None,
            );
            match oneof_field {
                self::test_all_types::OneofField::OneofNestedMessage(oneof_field) => {
                    ::std::option::Option::Some(*oneof_field)
                }
                mut oneof_field => {
                    ::std::mem::swap(&mut self.oneof_field, &mut oneof_field);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_oneof_nested_message(&mut self) {
            let oneof_field = ::std::mem::replace(
                &mut self.oneof_field,
                self::test_all_types::OneofField::None,
            );
            match oneof_field {
                self::test_all_types::OneofField::OneofNestedMessage(_) => {}
                mut oneof_field => ::std::mem::swap(&mut self.oneof_field, &mut oneof_field),
            }
        }
        pub const ONEOF_STRING_FIELD_NUMBER: i32 = 113;
        pub const ONEOF_STRING_DEFAULT_VALUE: &'static str = "";
        pub fn oneof_string(&self) -> ::std::option::Option<&::std::string::String> {
            match &self.oneof_field {
                self::test_all_types::OneofField::OneofString(oneof_field) => {
                    ::std::option::Option::Some(oneof_field)
                }
                _ => ::std::option::Option::None,
            }
        }
        pub fn oneof_string_mut(&mut self) -> &mut ::std::string::String {
            match self.oneof_field {
                self::test_all_types::OneofField::OneofString(_) => (),
                _ => {
                    self.oneof_field = self::test_all_types::OneofField::OneofString(
                        ::std::default::Default::default(),
                    )
                }
            }
            match self.oneof_field {
                self::test_all_types::OneofField::OneofString(ref mut oneof_field) => oneof_field,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_oneof_string(&self) -> bool {
            match self.oneof_field {
                self::test_all_types::OneofField::OneofString(_) => true,
                _ => false,
            }
        }
        pub fn set_oneof_string(&mut self, value: ::std::string::String) {
            self.oneof_field =
                self::test_all_types::OneofField::OneofString(::std::convert::From::from(value))
        }
        pub fn take_oneof_string(&mut self) -> ::std::option::Option<::std::string::String> {
            let oneof_field = ::std::mem::replace(
                &mut self.oneof_field,
                self::test_all_types::OneofField::None,
            );
            match oneof_field {
                self::test_all_types::OneofField::OneofString(oneof_field) => {
                    ::std::option::Option::Some(oneof_field)
                }
                mut oneof_field => {
                    ::std::mem::swap(&mut self.oneof_field, &mut oneof_field);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_oneof_string(&mut self) {
            let oneof_field = ::std::mem::replace(
                &mut self.oneof_field,
                self::test_all_types::OneofField::None,
            );
            match oneof_field {
                self::test_all_types::OneofField::OneofString(_) => {}
                mut oneof_field => ::std::mem::swap(&mut self.oneof_field, &mut oneof_field),
            }
        }
        pub const ONEOF_BYTES_FIELD_NUMBER: i32 = 114;
        pub const ONEOF_BYTES_DEFAULT_VALUE: &'static [u8] = &[];
        pub fn oneof_bytes(&self) -> ::std::option::Option<&::std::vec::Vec<u8>> {
            match &self.oneof_field {
                self::test_all_types::OneofField::OneofBytes(oneof_field) => {
                    ::std::option::Option::Some(oneof_field)
                }
                _ => ::std::option::Option::None,
            }
        }
        pub fn oneof_bytes_mut(&mut self) -> &mut ::std::vec::Vec<u8> {
            match self.oneof_field {
                self::test_all_types::OneofField::OneofBytes(_) => (),
                _ => {
                    self.oneof_field = self::test_all_types::OneofField::OneofBytes(
                        ::std::default::Default::default(),
                    )
                }
            }
            match self.oneof_field {
                self::test_all_types::OneofField::OneofBytes(ref mut oneof_field) => oneof_field,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_oneof_bytes(&self) -> bool {
            match self.oneof_field {
                self::test_all_types::OneofField::OneofBytes(_) => true,
                _ => false,
            }
        }
        pub fn set_oneof_bytes(&mut self, value: ::std::vec::Vec<u8>) {
            self.oneof_field =
                self::test_all_types::OneofField::OneofBytes(::std::convert::From::from(value))
        }
        pub fn take_oneof_bytes(&mut self) -> ::std::option::Option<::std::vec::Vec<u8>> {
            let oneof_field = ::std::mem::replace(
                &mut self.oneof_field,
                self::test_all_types::OneofField::None,
            );
            match oneof_field {
                self::test_all_types::OneofField::OneofBytes(oneof_field) => {
                    ::std::option::Option::Some(oneof_field)
                }
                mut oneof_field => {
                    ::std::mem::swap(&mut self.oneof_field, &mut oneof_field);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_oneof_bytes(&mut self) {
            let oneof_field = ::std::mem::replace(
                &mut self.oneof_field,
                self::test_all_types::OneofField::None,
            );
            match oneof_field {
                self::test_all_types::OneofField::OneofBytes(_) => {}
                mut oneof_field => ::std::mem::swap(&mut self.oneof_field, &mut oneof_field),
            }
        }
        pub fn oneof_field(&self) -> &self::test_all_types::OneofField {
            &self.oneof_field
        }
        pub fn oneof_field_mut(&mut self) -> &mut self::test_all_types::OneofField {
            &mut self.oneof_field
        }
    }
    pub mod test_all_types {
        #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
        pub enum NestedEnum {
            Zero,
            Foo,
            Bar,
            Baz,
            Neg,
        }
        impl ::protrust::Enum for self::NestedEnum {
            fn descriptor() -> &'static ::protrust::reflect::EnumDescriptor<'static> {
                &<self::super::TestAllTypes as ::protrust::Message>::descriptor().enums()[0]
            }
        }
        impl ::std::convert::TryFrom<i32> for self::NestedEnum {
            type Error = ::protrust::VariantUndefinedError;
            fn try_from(
                value: i32,
            ) -> ::std::result::Result<Self, ::protrust::VariantUndefinedError> {
                #[allow(unreachable_patterns)]
                match value {
                    0 => ::std::result::Result::Ok(self::NestedEnum::Zero),
                    1 => ::std::result::Result::Ok(self::NestedEnum::Foo),
                    2 => ::std::result::Result::Ok(self::NestedEnum::Bar),
                    3 => ::std::result::Result::Ok(self::NestedEnum::Baz),
                    -1 => ::std::result::Result::Ok(self::NestedEnum::Neg),
                    _ => ::std::result::Result::Err(::protrust::VariantUndefinedError),
                }
            }
        }
        impl ::std::convert::From<self::NestedEnum> for i32 {
            fn from(value: self::NestedEnum) -> i32 {
                match value {
                    self::NestedEnum::Zero => 0,
                    self::NestedEnum::Foo => 1,
                    self::NestedEnum::Bar => 2,
                    self::NestedEnum::Baz => 3,
                    self::NestedEnum::Neg => -1,
                }
            }
        }
        #[derive(Clone, Debug, PartialEq)]
        pub enum OneofField {
            None,
            OneofUint32(u32),
            OneofNestedMessage(::std::boxed::Box<self::NestedMessage>),
            OneofString(::std::string::String),
            OneofBytes(::std::vec::Vec<u8>),
        }
        impl ::std::default::Default for self::OneofField {
            fn default() -> Self {
                self::OneofField::None
            }
        }
        #[derive(Clone, Debug, PartialEq, Default)]
        pub struct NestedMessage {
            bb: i32,
            unknown_fields: ::protrust::UnknownFieldSet,
        }
        impl ::protrust::CodedMessage for self::NestedMessage {
            fn merge_from(
                &mut self,
                input: &mut ::protrust::io::CodedInput,
            ) -> ::protrust::io::InputResult<()> {
                while let ::std::option::Option::Some(tag) = input.read_tag()? {
                    match tag.get() {
                        8 | 10 => *self.bb_mut() = input.read_int32()?,
                        _ => self.unknown_fields.merge_from(tag, input)?,
                    }
                }
                ::std::result::Result::Ok(())
            }
            fn calculate_size(&self) -> i32 {
                let mut size = 0i32;
                if *self.bb() != Self::BB_DEFAULT_VALUE {
                    size += 1;
                    size += ::protrust::io::sizes::int32(*self.bb());
                }
                size += self.unknown_fields.calculate_size();
                size
            }
            fn write_to(
                &self,
                output: &mut ::protrust::io::CodedOutput,
            ) -> ::protrust::io::OutputResult {
                if *self.bb() != Self::BB_DEFAULT_VALUE {
                    output.write_raw_tag_bytes(&[8])?;
                    output.write_int32(*self.bb())?;
                }
                self.unknown_fields.write_to(output)?;
                ::std::result::Result::Ok(())
            }
            fn is_initialized(&self) -> bool {
                true
            }
        }
        impl ::protrust::LiteMessage for self::NestedMessage {
            fn merge(&mut self, other: &Self) {
                if *other.bb() != Self::BB_DEFAULT_VALUE {
                    *self.bb_mut() = *other.bb();
                }
                self.unknown_fields.merge(&other.unknown_fields);
            }
        }
        impl ::protrust::Message for self::NestedMessage {
            fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
                &<self::super::TestAllTypes as ::protrust::Message>::descriptor().messages()[0]
            }
        }
        impl self::NestedMessage {
            pub const BB_FIELD_NUMBER: i32 = 1;
            pub const BB_DEFAULT_VALUE: i32 = 0;
            pub fn bb(&self) -> &i32 {
                &self.bb
            }
            pub fn bb_mut(&mut self) -> &mut i32 {
                &mut self.bb
            }
        }
        pub(in super::super::super) mod nested_message {
            pub(in super::super::super) static BB_REFLECTOR:
                ::protrust::reflect::access::SimpleFieldAccessor<self::super::NestedMessage, i32> =
                ::protrust::reflect::access::SimpleFieldAccessor {
                    get: self::super::NestedMessage::bb,
                    get_mut: self::super::NestedMessage::bb_mut,
                };
        }
        pub(super) static REPEATED_INT32_CODEC: ::protrust::Codec<i32> =
            ::protrust::Codec::int32(250);
        pub(super) static REPEATED_INT64_CODEC: ::protrust::Codec<i64> =
            ::protrust::Codec::int64(258);
        pub(super) static REPEATED_UINT32_CODEC: ::protrust::Codec<u32> =
            ::protrust::Codec::uint32(266);
        pub(super) static REPEATED_UINT64_CODEC: ::protrust::Codec<u64> =
            ::protrust::Codec::uint64(274);
        pub(super) static REPEATED_SINT32_CODEC: ::protrust::Codec<i32> =
            ::protrust::Codec::sint32(282);
        pub(super) static REPEATED_SINT64_CODEC: ::protrust::Codec<i64> =
            ::protrust::Codec::sint64(290);
        pub(super) static REPEATED_FIXED32_CODEC: ::protrust::Codec<u32> =
            ::protrust::Codec::fixed32(298);
        pub(super) static REPEATED_FIXED64_CODEC: ::protrust::Codec<u64> =
            ::protrust::Codec::fixed64(306);
        pub(super) static REPEATED_SFIXED32_CODEC: ::protrust::Codec<i32> =
            ::protrust::Codec::sfixed32(314);
        pub(super) static REPEATED_SFIXED64_CODEC: ::protrust::Codec<i64> =
            ::protrust::Codec::sfixed64(322);
        pub(super) static REPEATED_FLOAT_CODEC: ::protrust::Codec<f32> =
            ::protrust::Codec::float(330);
        pub(super) static REPEATED_DOUBLE_CODEC: ::protrust::Codec<f64> =
            ::protrust::Codec::double(338);
        pub(super) static REPEATED_BOOL_CODEC: ::protrust::Codec<bool> =
            ::protrust::Codec::bool(346);
        pub(super) static REPEATED_STRING_CODEC: ::protrust::Codec<::std::string::String> =
            ::protrust::Codec::string(354);
        pub(super) static REPEATED_BYTES_CODEC: ::protrust::Codec<::std::vec::Vec<u8>> =
            ::protrust::Codec::bytes(362);
        pub(super) static REPEATED_NESTED_MESSAGE_CODEC: ::protrust::Codec<self::NestedMessage> =
            ::protrust::Codec::message(386);
        pub(super) static REPEATED_FOREIGN_MESSAGE_CODEC: ::protrust::Codec<
            self::super::ForeignMessage,
        > = ::protrust::Codec::message(394);
        pub(super) static REPEATED_IMPORT_MESSAGE_CODEC: ::protrust::Codec<
            self::super::super::unittest_import_proto::ImportMessage,
        > = ::protrust::Codec::message(402);
        pub(super) static REPEATED_NESTED_ENUM_CODEC: ::protrust::Codec<
            ::protrust::EnumValue<self::NestedEnum>,
        > = ::protrust::Codec::enum_value(410);
        pub(super) static REPEATED_FOREIGN_ENUM_CODEC: ::protrust::Codec<
            ::protrust::EnumValue<self::super::ForeignEnum>,
        > = ::protrust::Codec::enum_value(418);
        pub(super) static REPEATED_STRING_PIECE_CODEC: ::protrust::Codec<::std::string::String> =
            ::protrust::Codec::string(434);
        pub(super) static REPEATED_CORD_CODEC: ::protrust::Codec<::std::string::String> =
            ::protrust::Codec::string(442);
        pub(super) static REPEATED_LAZY_MESSAGE_CODEC: ::protrust::Codec<self::NestedMessage> =
            ::protrust::Codec::message(458);
        pub(in super::super) static OPTIONAL_INT32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<self::super::TestAllTypes, i32> =
            ::protrust::reflect::access::SimpleFieldAccessor {
                get: self::super::TestAllTypes::optional_int32,
                get_mut: self::super::TestAllTypes::optional_int32_mut,
            };
        pub(in super::super) static OPTIONAL_INT64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<self::super::TestAllTypes, i64> =
            ::protrust::reflect::access::SimpleFieldAccessor {
                get: self::super::TestAllTypes::optional_int64,
                get_mut: self::super::TestAllTypes::optional_int64_mut,
            };
        pub(in super::super) static OPTIONAL_UINT32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<self::super::TestAllTypes, u32> =
            ::protrust::reflect::access::SimpleFieldAccessor {
                get: self::super::TestAllTypes::optional_uint32,
                get_mut: self::super::TestAllTypes::optional_uint32_mut,
            };
        pub(in super::super) static OPTIONAL_UINT64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<self::super::TestAllTypes, u64> =
            ::protrust::reflect::access::SimpleFieldAccessor {
                get: self::super::TestAllTypes::optional_uint64,
                get_mut: self::super::TestAllTypes::optional_uint64_mut,
            };
        pub(in super::super) static OPTIONAL_SINT32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<self::super::TestAllTypes, i32> =
            ::protrust::reflect::access::SimpleFieldAccessor {
                get: self::super::TestAllTypes::optional_sint32,
                get_mut: self::super::TestAllTypes::optional_sint32_mut,
            };
        pub(in super::super) static OPTIONAL_SINT64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<self::super::TestAllTypes, i64> =
            ::protrust::reflect::access::SimpleFieldAccessor {
                get: self::super::TestAllTypes::optional_sint64,
                get_mut: self::super::TestAllTypes::optional_sint64_mut,
            };
        pub(in super::super) static OPTIONAL_FIXED32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<self::super::TestAllTypes, u32> =
            ::protrust::reflect::access::SimpleFieldAccessor {
                get: self::super::TestAllTypes::optional_fixed32,
                get_mut: self::super::TestAllTypes::optional_fixed32_mut,
            };
        pub(in super::super) static OPTIONAL_FIXED64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<self::super::TestAllTypes, u64> =
            ::protrust::reflect::access::SimpleFieldAccessor {
                get: self::super::TestAllTypes::optional_fixed64,
                get_mut: self::super::TestAllTypes::optional_fixed64_mut,
            };
        pub(in super::super) static OPTIONAL_SFIXED32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<self::super::TestAllTypes, i32> =
            ::protrust::reflect::access::SimpleFieldAccessor {
                get: self::super::TestAllTypes::optional_sfixed32,
                get_mut: self::super::TestAllTypes::optional_sfixed32_mut,
            };
        pub(in super::super) static OPTIONAL_SFIXED64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<self::super::TestAllTypes, i64> =
            ::protrust::reflect::access::SimpleFieldAccessor {
                get: self::super::TestAllTypes::optional_sfixed64,
                get_mut: self::super::TestAllTypes::optional_sfixed64_mut,
            };
        pub(in super::super) static OPTIONAL_FLOAT_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<self::super::TestAllTypes, f32> =
            ::protrust::reflect::access::SimpleFieldAccessor {
                get: self::super::TestAllTypes::optional_float,
                get_mut: self::super::TestAllTypes::optional_float_mut,
            };
        pub(in super::super) static OPTIONAL_DOUBLE_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<self::super::TestAllTypes, f64> =
            ::protrust::reflect::access::SimpleFieldAccessor {
                get: self::super::TestAllTypes::optional_double,
                get_mut: self::super::TestAllTypes::optional_double_mut,
            };
        pub(in super::super) static OPTIONAL_BOOL_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<self::super::TestAllTypes, bool> =
            ::protrust::reflect::access::SimpleFieldAccessor {
                get: self::super::TestAllTypes::optional_bool,
                get_mut: self::super::TestAllTypes::optional_bool_mut,
            };
        pub(in super::super) static OPTIONAL_STRING_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::std::string::String,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::optional_string,
            get_mut: self::super::TestAllTypes::optional_string_mut,
        };
        pub(in super::super) static OPTIONAL_BYTES_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::std::vec::Vec<u8>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::optional_bytes,
            get_mut: self::super::TestAllTypes::optional_bytes_mut,
        };
        pub(in super::super) static OPTIONAL_NESTED_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                self::NestedMessage,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::optional_nested_message,
            get_mut: self::super::TestAllTypes::optional_nested_message_mut,
            set: self::super::TestAllTypes::set_optional_nested_message,
            take: self::super::TestAllTypes::take_optional_nested_message,
            clear: self::super::TestAllTypes::clear_optional_nested_message,
        };
        pub(in super::super) static OPTIONAL_FOREIGN_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                self::super::ForeignMessage,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::optional_foreign_message,
            get_mut: self::super::TestAllTypes::optional_foreign_message_mut,
            set: self::super::TestAllTypes::set_optional_foreign_message,
            take: self::super::TestAllTypes::take_optional_foreign_message,
            clear: self::super::TestAllTypes::clear_optional_foreign_message,
        };
        pub(in super::super) static OPTIONAL_IMPORT_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                self::super::super::unittest_import_proto::ImportMessage,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::optional_import_message,
            get_mut: self::super::TestAllTypes::optional_import_message_mut,
            set: self::super::TestAllTypes::set_optional_import_message,
            take: self::super::TestAllTypes::take_optional_import_message,
            clear: self::super::TestAllTypes::clear_optional_import_message,
        };
        pub(in super::super) static OPTIONAL_NESTED_ENUM_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::EnumValue<self::NestedEnum>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::optional_nested_enum,
            get_mut: self::super::TestAllTypes::optional_nested_enum_mut,
        };
        pub(in super::super) static OPTIONAL_FOREIGN_ENUM_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::EnumValue<self::super::ForeignEnum>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::optional_foreign_enum,
            get_mut: self::super::TestAllTypes::optional_foreign_enum_mut,
        };
        pub(in super::super) static OPTIONAL_STRING_PIECE_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::std::string::String,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::optional_string_piece,
            get_mut: self::super::TestAllTypes::optional_string_piece_mut,
        };
        pub(in super::super) static OPTIONAL_CORD_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::std::string::String,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::optional_cord,
            get_mut: self::super::TestAllTypes::optional_cord_mut,
        };
        pub(in super::super) static OPTIONAL_PUBLIC_IMPORT_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                self::super::super::unittest_import_public_proto::PublicImportMessage,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::optional_public_import_message,
            get_mut: self::super::TestAllTypes::optional_public_import_message_mut,
            set: self::super::TestAllTypes::set_optional_public_import_message,
            take: self::super::TestAllTypes::take_optional_public_import_message,
            clear: self::super::TestAllTypes::clear_optional_public_import_message,
        };
        pub(in super::super) static OPTIONAL_LAZY_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                self::NestedMessage,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::optional_lazy_message,
            get_mut: self::super::TestAllTypes::optional_lazy_message_mut,
            set: self::super::TestAllTypes::set_optional_lazy_message,
            take: self::super::TestAllTypes::take_optional_lazy_message,
            clear: self::super::TestAllTypes::clear_optional_lazy_message,
        };
        pub(in super::super) static OPTIONAL_LAZY_IMPORT_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                self::super::super::unittest_import_proto::ImportMessage,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::optional_lazy_import_message,
            get_mut: self::super::TestAllTypes::optional_lazy_import_message_mut,
            set: self::super::TestAllTypes::set_optional_lazy_import_message,
            take: self::super::TestAllTypes::take_optional_lazy_import_message,
            clear: self::super::TestAllTypes::clear_optional_lazy_import_message,
        };
        pub(in super::super) static REPEATED_INT32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<i32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_int32,
            get_mut: self::super::TestAllTypes::repeated_int32_mut,
        };
        pub(in super::super) static REPEATED_INT64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<i64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_int64,
            get_mut: self::super::TestAllTypes::repeated_int64_mut,
        };
        pub(in super::super) static REPEATED_UINT32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<u32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_uint32,
            get_mut: self::super::TestAllTypes::repeated_uint32_mut,
        };
        pub(in super::super) static REPEATED_UINT64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<u64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_uint64,
            get_mut: self::super::TestAllTypes::repeated_uint64_mut,
        };
        pub(in super::super) static REPEATED_SINT32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<i32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_sint32,
            get_mut: self::super::TestAllTypes::repeated_sint32_mut,
        };
        pub(in super::super) static REPEATED_SINT64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<i64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_sint64,
            get_mut: self::super::TestAllTypes::repeated_sint64_mut,
        };
        pub(in super::super) static REPEATED_FIXED32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<u32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_fixed32,
            get_mut: self::super::TestAllTypes::repeated_fixed32_mut,
        };
        pub(in super::super) static REPEATED_FIXED64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<u64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_fixed64,
            get_mut: self::super::TestAllTypes::repeated_fixed64_mut,
        };
        pub(in super::super) static REPEATED_SFIXED32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<i32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_sfixed32,
            get_mut: self::super::TestAllTypes::repeated_sfixed32_mut,
        };
        pub(in super::super) static REPEATED_SFIXED64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<i64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_sfixed64,
            get_mut: self::super::TestAllTypes::repeated_sfixed64_mut,
        };
        pub(in super::super) static REPEATED_FLOAT_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<f32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_float,
            get_mut: self::super::TestAllTypes::repeated_float_mut,
        };
        pub(in super::super) static REPEATED_DOUBLE_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<f64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_double,
            get_mut: self::super::TestAllTypes::repeated_double_mut,
        };
        pub(in super::super) static REPEATED_BOOL_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<bool>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_bool,
            get_mut: self::super::TestAllTypes::repeated_bool_mut,
        };
        pub(in super::super) static REPEATED_STRING_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<::std::string::String>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_string,
            get_mut: self::super::TestAllTypes::repeated_string_mut,
        };
        pub(in super::super) static REPEATED_BYTES_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<::std::vec::Vec<u8>>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_bytes,
            get_mut: self::super::TestAllTypes::repeated_bytes_mut,
        };
        pub(in super::super) static REPEATED_NESTED_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<self::NestedMessage>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_nested_message,
            get_mut: self::super::TestAllTypes::repeated_nested_message_mut,
        };
        pub(in super::super) static REPEATED_FOREIGN_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<self::super::ForeignMessage>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_foreign_message,
            get_mut: self::super::TestAllTypes::repeated_foreign_message_mut,
        };
        pub(in super::super) static REPEATED_IMPORT_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<
                    self::super::super::unittest_import_proto::ImportMessage,
                >,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_import_message,
            get_mut: self::super::TestAllTypes::repeated_import_message_mut,
        };
        pub(in super::super) static REPEATED_NESTED_ENUM_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<::protrust::EnumValue<self::NestedEnum>>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_nested_enum,
            get_mut: self::super::TestAllTypes::repeated_nested_enum_mut,
        };
        pub(in super::super) static REPEATED_FOREIGN_ENUM_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<
                    ::protrust::EnumValue<self::super::ForeignEnum>,
                >,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_foreign_enum,
            get_mut: self::super::TestAllTypes::repeated_foreign_enum_mut,
        };
        pub(in super::super) static REPEATED_STRING_PIECE_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<::std::string::String>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_string_piece,
            get_mut: self::super::TestAllTypes::repeated_string_piece_mut,
        };
        pub(in super::super) static REPEATED_CORD_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<::std::string::String>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_cord,
            get_mut: self::super::TestAllTypes::repeated_cord_mut,
        };
        pub(in super::super) static REPEATED_LAZY_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestAllTypes,
                ::protrust::collections::RepeatedField<self::NestedMessage>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestAllTypes::repeated_lazy_message,
            get_mut: self::super::TestAllTypes::repeated_lazy_message_mut,
        };
        pub(in super::super) static ONEOF_UINT32_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<self::super::TestAllTypes, u32> =
            ::protrust::reflect::access::VerboseFieldAccessor {
                get_option: self::super::TestAllTypes::oneof_uint32,
                get_mut: self::super::TestAllTypes::oneof_uint32_mut,
                set: self::super::TestAllTypes::set_oneof_uint32,
                take: self::super::TestAllTypes::take_oneof_uint32,
                clear: self::super::TestAllTypes::clear_oneof_uint32,
            };
        pub(in super::super) static ONEOF_NESTED_MESSAGE_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                self::NestedMessage,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::oneof_nested_message,
            get_mut: self::super::TestAllTypes::oneof_nested_message_mut,
            set: self::super::TestAllTypes::set_oneof_nested_message,
            take: self::super::TestAllTypes::take_oneof_nested_message,
            clear: self::super::TestAllTypes::clear_oneof_nested_message,
        };
        pub(in super::super) static ONEOF_STRING_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                ::std::string::String,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::oneof_string,
            get_mut: self::super::TestAllTypes::oneof_string_mut,
            set: self::super::TestAllTypes::set_oneof_string,
            take: self::super::TestAllTypes::take_oneof_string,
            clear: self::super::TestAllTypes::clear_oneof_string,
        };
        pub(in super::super) static ONEOF_BYTES_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestAllTypes,
                ::std::vec::Vec<u8>,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestAllTypes::oneof_bytes,
            get_mut: self::super::TestAllTypes::oneof_bytes_mut,
            set: self::super::TestAllTypes::set_oneof_bytes,
            take: self::super::TestAllTypes::take_oneof_bytes,
            clear: self::super::TestAllTypes::clear_oneof_bytes,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestPackedTypes {
        packed_int32: ::protrust::collections::RepeatedField<i32>,
        packed_int64: ::protrust::collections::RepeatedField<i64>,
        packed_uint32: ::protrust::collections::RepeatedField<u32>,
        packed_uint64: ::protrust::collections::RepeatedField<u64>,
        packed_sint32: ::protrust::collections::RepeatedField<i32>,
        packed_sint64: ::protrust::collections::RepeatedField<i64>,
        packed_fixed32: ::protrust::collections::RepeatedField<u32>,
        packed_fixed64: ::protrust::collections::RepeatedField<u64>,
        packed_sfixed32: ::protrust::collections::RepeatedField<i32>,
        packed_sfixed64: ::protrust::collections::RepeatedField<i64>,
        packed_float: ::protrust::collections::RepeatedField<f32>,
        packed_double: ::protrust::collections::RepeatedField<f64>,
        packed_bool: ::protrust::collections::RepeatedField<bool>,
        packed_enum:
            ::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestPackedTypes {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    722 => self
                        .packed_int32
                        .add_entries(input, &self::test_packed_types::PACKED_INT32_CODEC)?,
                    730 => self
                        .packed_int64
                        .add_entries(input, &self::test_packed_types::PACKED_INT64_CODEC)?,
                    738 => self
                        .packed_uint32
                        .add_entries(input, &self::test_packed_types::PACKED_UINT32_CODEC)?,
                    746 => self
                        .packed_uint64
                        .add_entries(input, &self::test_packed_types::PACKED_UINT64_CODEC)?,
                    754 => self
                        .packed_sint32
                        .add_entries(input, &self::test_packed_types::PACKED_SINT32_CODEC)?,
                    762 => self
                        .packed_sint64
                        .add_entries(input, &self::test_packed_types::PACKED_SINT64_CODEC)?,
                    770 => self
                        .packed_fixed32
                        .add_entries(input, &self::test_packed_types::PACKED_FIXED32_CODEC)?,
                    778 => self
                        .packed_fixed64
                        .add_entries(input, &self::test_packed_types::PACKED_FIXED64_CODEC)?,
                    786 => self
                        .packed_sfixed32
                        .add_entries(input, &self::test_packed_types::PACKED_SFIXED32_CODEC)?,
                    794 => self
                        .packed_sfixed64
                        .add_entries(input, &self::test_packed_types::PACKED_SFIXED64_CODEC)?,
                    802 => self
                        .packed_float
                        .add_entries(input, &self::test_packed_types::PACKED_FLOAT_CODEC)?,
                    810 => self
                        .packed_double
                        .add_entries(input, &self::test_packed_types::PACKED_DOUBLE_CODEC)?,
                    818 => self
                        .packed_bool
                        .add_entries(input, &self::test_packed_types::PACKED_BOOL_CODEC)?,
                    826 => self
                        .packed_enum
                        .add_entries(input, &self::test_packed_types::PACKED_ENUM_CODEC)?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            size += self
                .packed_int32()
                .calculate_size(&self::test_packed_types::PACKED_INT32_CODEC);
            size += self
                .packed_int64()
                .calculate_size(&self::test_packed_types::PACKED_INT64_CODEC);
            size += self
                .packed_uint32()
                .calculate_size(&self::test_packed_types::PACKED_UINT32_CODEC);
            size += self
                .packed_uint64()
                .calculate_size(&self::test_packed_types::PACKED_UINT64_CODEC);
            size += self
                .packed_sint32()
                .calculate_size(&self::test_packed_types::PACKED_SINT32_CODEC);
            size += self
                .packed_sint64()
                .calculate_size(&self::test_packed_types::PACKED_SINT64_CODEC);
            size += self
                .packed_fixed32()
                .calculate_size(&self::test_packed_types::PACKED_FIXED32_CODEC);
            size += self
                .packed_fixed64()
                .calculate_size(&self::test_packed_types::PACKED_FIXED64_CODEC);
            size += self
                .packed_sfixed32()
                .calculate_size(&self::test_packed_types::PACKED_SFIXED32_CODEC);
            size += self
                .packed_sfixed64()
                .calculate_size(&self::test_packed_types::PACKED_SFIXED64_CODEC);
            size += self
                .packed_float()
                .calculate_size(&self::test_packed_types::PACKED_FLOAT_CODEC);
            size += self
                .packed_double()
                .calculate_size(&self::test_packed_types::PACKED_DOUBLE_CODEC);
            size += self
                .packed_bool()
                .calculate_size(&self::test_packed_types::PACKED_BOOL_CODEC);
            size += self
                .packed_enum()
                .calculate_size(&self::test_packed_types::PACKED_ENUM_CODEC);
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            self.packed_int32()
                .write_to(output, &self::test_packed_types::PACKED_INT32_CODEC)?;
            self.packed_int64()
                .write_to(output, &self::test_packed_types::PACKED_INT64_CODEC)?;
            self.packed_uint32()
                .write_to(output, &self::test_packed_types::PACKED_UINT32_CODEC)?;
            self.packed_uint64()
                .write_to(output, &self::test_packed_types::PACKED_UINT64_CODEC)?;
            self.packed_sint32()
                .write_to(output, &self::test_packed_types::PACKED_SINT32_CODEC)?;
            self.packed_sint64()
                .write_to(output, &self::test_packed_types::PACKED_SINT64_CODEC)?;
            self.packed_fixed32()
                .write_to(output, &self::test_packed_types::PACKED_FIXED32_CODEC)?;
            self.packed_fixed64()
                .write_to(output, &self::test_packed_types::PACKED_FIXED64_CODEC)?;
            self.packed_sfixed32()
                .write_to(output, &self::test_packed_types::PACKED_SFIXED32_CODEC)?;
            self.packed_sfixed64()
                .write_to(output, &self::test_packed_types::PACKED_SFIXED64_CODEC)?;
            self.packed_float()
                .write_to(output, &self::test_packed_types::PACKED_FLOAT_CODEC)?;
            self.packed_double()
                .write_to(output, &self::test_packed_types::PACKED_DOUBLE_CODEC)?;
            self.packed_bool()
                .write_to(output, &self::test_packed_types::PACKED_BOOL_CODEC)?;
            self.packed_enum()
                .write_to(output, &self::test_packed_types::PACKED_ENUM_CODEC)?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestPackedTypes {
        fn merge(&mut self, other: &Self) {
            self.packed_int32.merge(&other.packed_int32);
            self.packed_int64.merge(&other.packed_int64);
            self.packed_uint32.merge(&other.packed_uint32);
            self.packed_uint64.merge(&other.packed_uint64);
            self.packed_sint32.merge(&other.packed_sint32);
            self.packed_sint64.merge(&other.packed_sint64);
            self.packed_fixed32.merge(&other.packed_fixed32);
            self.packed_fixed64.merge(&other.packed_fixed64);
            self.packed_sfixed32.merge(&other.packed_sfixed32);
            self.packed_sfixed64.merge(&other.packed_sfixed64);
            self.packed_float.merge(&other.packed_float);
            self.packed_double.merge(&other.packed_double);
            self.packed_bool.merge(&other.packed_bool);
            self.packed_enum.merge(&other.packed_enum);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestPackedTypes {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[1]
        }
    }
    impl self::TestPackedTypes {
        pub const PACKED_INT32_FIELD_NUMBER: i32 = 90;
        pub fn packed_int32(&self) -> &::protrust::collections::RepeatedField<i32> {
            &self.packed_int32
        }
        pub fn packed_int32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
            &mut self.packed_int32
        }
        pub const PACKED_INT64_FIELD_NUMBER: i32 = 91;
        pub fn packed_int64(&self) -> &::protrust::collections::RepeatedField<i64> {
            &self.packed_int64
        }
        pub fn packed_int64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
            &mut self.packed_int64
        }
        pub const PACKED_UINT32_FIELD_NUMBER: i32 = 92;
        pub fn packed_uint32(&self) -> &::protrust::collections::RepeatedField<u32> {
            &self.packed_uint32
        }
        pub fn packed_uint32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u32> {
            &mut self.packed_uint32
        }
        pub const PACKED_UINT64_FIELD_NUMBER: i32 = 93;
        pub fn packed_uint64(&self) -> &::protrust::collections::RepeatedField<u64> {
            &self.packed_uint64
        }
        pub fn packed_uint64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u64> {
            &mut self.packed_uint64
        }
        pub const PACKED_SINT32_FIELD_NUMBER: i32 = 94;
        pub fn packed_sint32(&self) -> &::protrust::collections::RepeatedField<i32> {
            &self.packed_sint32
        }
        pub fn packed_sint32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
            &mut self.packed_sint32
        }
        pub const PACKED_SINT64_FIELD_NUMBER: i32 = 95;
        pub fn packed_sint64(&self) -> &::protrust::collections::RepeatedField<i64> {
            &self.packed_sint64
        }
        pub fn packed_sint64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
            &mut self.packed_sint64
        }
        pub const PACKED_FIXED32_FIELD_NUMBER: i32 = 96;
        pub fn packed_fixed32(&self) -> &::protrust::collections::RepeatedField<u32> {
            &self.packed_fixed32
        }
        pub fn packed_fixed32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u32> {
            &mut self.packed_fixed32
        }
        pub const PACKED_FIXED64_FIELD_NUMBER: i32 = 97;
        pub fn packed_fixed64(&self) -> &::protrust::collections::RepeatedField<u64> {
            &self.packed_fixed64
        }
        pub fn packed_fixed64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u64> {
            &mut self.packed_fixed64
        }
        pub const PACKED_SFIXED32_FIELD_NUMBER: i32 = 98;
        pub fn packed_sfixed32(&self) -> &::protrust::collections::RepeatedField<i32> {
            &self.packed_sfixed32
        }
        pub fn packed_sfixed32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
            &mut self.packed_sfixed32
        }
        pub const PACKED_SFIXED64_FIELD_NUMBER: i32 = 99;
        pub fn packed_sfixed64(&self) -> &::protrust::collections::RepeatedField<i64> {
            &self.packed_sfixed64
        }
        pub fn packed_sfixed64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
            &mut self.packed_sfixed64
        }
        pub const PACKED_FLOAT_FIELD_NUMBER: i32 = 100;
        pub fn packed_float(&self) -> &::protrust::collections::RepeatedField<f32> {
            &self.packed_float
        }
        pub fn packed_float_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<f32> {
            &mut self.packed_float
        }
        pub const PACKED_DOUBLE_FIELD_NUMBER: i32 = 101;
        pub fn packed_double(&self) -> &::protrust::collections::RepeatedField<f64> {
            &self.packed_double
        }
        pub fn packed_double_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<f64> {
            &mut self.packed_double
        }
        pub const PACKED_BOOL_FIELD_NUMBER: i32 = 102;
        pub fn packed_bool(&self) -> &::protrust::collections::RepeatedField<bool> {
            &self.packed_bool
        }
        pub fn packed_bool_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<bool> {
            &mut self.packed_bool
        }
        pub const PACKED_ENUM_FIELD_NUMBER: i32 = 103;
        pub fn packed_enum(
            &self,
        ) -> &::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>>
        {
            &self.packed_enum
        }
        pub fn packed_enum_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<::protrust::EnumValue<self::ForeignEnum>>
        {
            &mut self.packed_enum
        }
    }
    pub(in super::super) mod test_packed_types {
        pub(super) static PACKED_INT32_CODEC: ::protrust::Codec<i32> =
            ::protrust::Codec::int32(722);
        pub(super) static PACKED_INT64_CODEC: ::protrust::Codec<i64> =
            ::protrust::Codec::int64(730);
        pub(super) static PACKED_UINT32_CODEC: ::protrust::Codec<u32> =
            ::protrust::Codec::uint32(738);
        pub(super) static PACKED_UINT64_CODEC: ::protrust::Codec<u64> =
            ::protrust::Codec::uint64(746);
        pub(super) static PACKED_SINT32_CODEC: ::protrust::Codec<i32> =
            ::protrust::Codec::sint32(754);
        pub(super) static PACKED_SINT64_CODEC: ::protrust::Codec<i64> =
            ::protrust::Codec::sint64(762);
        pub(super) static PACKED_FIXED32_CODEC: ::protrust::Codec<u32> =
            ::protrust::Codec::fixed32(770);
        pub(super) static PACKED_FIXED64_CODEC: ::protrust::Codec<u64> =
            ::protrust::Codec::fixed64(778);
        pub(super) static PACKED_SFIXED32_CODEC: ::protrust::Codec<i32> =
            ::protrust::Codec::sfixed32(786);
        pub(super) static PACKED_SFIXED64_CODEC: ::protrust::Codec<i64> =
            ::protrust::Codec::sfixed64(794);
        pub(super) static PACKED_FLOAT_CODEC: ::protrust::Codec<f32> =
            ::protrust::Codec::float(802);
        pub(super) static PACKED_DOUBLE_CODEC: ::protrust::Codec<f64> =
            ::protrust::Codec::double(810);
        pub(super) static PACKED_BOOL_CODEC: ::protrust::Codec<bool> = ::protrust::Codec::bool(818);
        pub(super) static PACKED_ENUM_CODEC: ::protrust::Codec<
            ::protrust::EnumValue<self::super::ForeignEnum>,
        > = ::protrust::Codec::enum_value(826);
        pub(in super::super) static PACKED_INT32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestPackedTypes,
                ::protrust::collections::RepeatedField<i32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestPackedTypes::packed_int32,
            get_mut: self::super::TestPackedTypes::packed_int32_mut,
        };
        pub(in super::super) static PACKED_INT64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestPackedTypes,
                ::protrust::collections::RepeatedField<i64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestPackedTypes::packed_int64,
            get_mut: self::super::TestPackedTypes::packed_int64_mut,
        };
        pub(in super::super) static PACKED_UINT32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestPackedTypes,
                ::protrust::collections::RepeatedField<u32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestPackedTypes::packed_uint32,
            get_mut: self::super::TestPackedTypes::packed_uint32_mut,
        };
        pub(in super::super) static PACKED_UINT64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestPackedTypes,
                ::protrust::collections::RepeatedField<u64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestPackedTypes::packed_uint64,
            get_mut: self::super::TestPackedTypes::packed_uint64_mut,
        };
        pub(in super::super) static PACKED_SINT32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestPackedTypes,
                ::protrust::collections::RepeatedField<i32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestPackedTypes::packed_sint32,
            get_mut: self::super::TestPackedTypes::packed_sint32_mut,
        };
        pub(in super::super) static PACKED_SINT64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestPackedTypes,
                ::protrust::collections::RepeatedField<i64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestPackedTypes::packed_sint64,
            get_mut: self::super::TestPackedTypes::packed_sint64_mut,
        };
        pub(in super::super) static PACKED_FIXED32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestPackedTypes,
                ::protrust::collections::RepeatedField<u32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestPackedTypes::packed_fixed32,
            get_mut: self::super::TestPackedTypes::packed_fixed32_mut,
        };
        pub(in super::super) static PACKED_FIXED64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestPackedTypes,
                ::protrust::collections::RepeatedField<u64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestPackedTypes::packed_fixed64,
            get_mut: self::super::TestPackedTypes::packed_fixed64_mut,
        };
        pub(in super::super) static PACKED_SFIXED32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestPackedTypes,
                ::protrust::collections::RepeatedField<i32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestPackedTypes::packed_sfixed32,
            get_mut: self::super::TestPackedTypes::packed_sfixed32_mut,
        };
        pub(in super::super) static PACKED_SFIXED64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestPackedTypes,
                ::protrust::collections::RepeatedField<i64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestPackedTypes::packed_sfixed64,
            get_mut: self::super::TestPackedTypes::packed_sfixed64_mut,
        };
        pub(in super::super) static PACKED_FLOAT_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestPackedTypes,
                ::protrust::collections::RepeatedField<f32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestPackedTypes::packed_float,
            get_mut: self::super::TestPackedTypes::packed_float_mut,
        };
        pub(in super::super) static PACKED_DOUBLE_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestPackedTypes,
                ::protrust::collections::RepeatedField<f64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestPackedTypes::packed_double,
            get_mut: self::super::TestPackedTypes::packed_double_mut,
        };
        pub(in super::super) static PACKED_BOOL_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestPackedTypes,
                ::protrust::collections::RepeatedField<bool>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestPackedTypes::packed_bool,
            get_mut: self::super::TestPackedTypes::packed_bool_mut,
        };
        pub(in super::super) static PACKED_ENUM_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestPackedTypes,
                ::protrust::collections::RepeatedField<
                    ::protrust::EnumValue<self::super::ForeignEnum>,
                >,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestPackedTypes::packed_enum,
            get_mut: self::super::TestPackedTypes::packed_enum_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestUnpackedTypes {
        repeated_int32: ::protrust::collections::RepeatedField<i32>,
        repeated_int64: ::protrust::collections::RepeatedField<i64>,
        repeated_uint32: ::protrust::collections::RepeatedField<u32>,
        repeated_uint64: ::protrust::collections::RepeatedField<u64>,
        repeated_sint32: ::protrust::collections::RepeatedField<i32>,
        repeated_sint64: ::protrust::collections::RepeatedField<i64>,
        repeated_fixed32: ::protrust::collections::RepeatedField<u32>,
        repeated_fixed64: ::protrust::collections::RepeatedField<u64>,
        repeated_sfixed32: ::protrust::collections::RepeatedField<i32>,
        repeated_sfixed64: ::protrust::collections::RepeatedField<i64>,
        repeated_float: ::protrust::collections::RepeatedField<f32>,
        repeated_double: ::protrust::collections::RepeatedField<f64>,
        repeated_bool: ::protrust::collections::RepeatedField<bool>,
        repeated_nested_enum: ::protrust::collections::RepeatedField<
            ::protrust::EnumValue<self::test_all_types::NestedEnum>,
        >,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestUnpackedTypes {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self
                        .repeated_int32
                        .add_entries(input, &self::test_unpacked_types::REPEATED_INT32_CODEC)?,
                    16 | 18 => self
                        .repeated_int64
                        .add_entries(input, &self::test_unpacked_types::REPEATED_INT64_CODEC)?,
                    24 | 26 => self
                        .repeated_uint32
                        .add_entries(input, &self::test_unpacked_types::REPEATED_UINT32_CODEC)?,
                    32 | 34 => self
                        .repeated_uint64
                        .add_entries(input, &self::test_unpacked_types::REPEATED_UINT64_CODEC)?,
                    40 | 42 => self
                        .repeated_sint32
                        .add_entries(input, &self::test_unpacked_types::REPEATED_SINT32_CODEC)?,
                    48 | 50 => self
                        .repeated_sint64
                        .add_entries(input, &self::test_unpacked_types::REPEATED_SINT64_CODEC)?,
                    61 | 58 => self
                        .repeated_fixed32
                        .add_entries(input, &self::test_unpacked_types::REPEATED_FIXED32_CODEC)?,
                    65 | 66 => self
                        .repeated_fixed64
                        .add_entries(input, &self::test_unpacked_types::REPEATED_FIXED64_CODEC)?,
                    77 | 74 => self
                        .repeated_sfixed32
                        .add_entries(input, &self::test_unpacked_types::REPEATED_SFIXED32_CODEC)?,
                    81 | 82 => self
                        .repeated_sfixed64
                        .add_entries(input, &self::test_unpacked_types::REPEATED_SFIXED64_CODEC)?,
                    93 | 90 => self
                        .repeated_float
                        .add_entries(input, &self::test_unpacked_types::REPEATED_FLOAT_CODEC)?,
                    97 | 98 => self
                        .repeated_double
                        .add_entries(input, &self::test_unpacked_types::REPEATED_DOUBLE_CODEC)?,
                    104 | 106 => self
                        .repeated_bool
                        .add_entries(input, &self::test_unpacked_types::REPEATED_BOOL_CODEC)?,
                    112 | 114 => self.repeated_nested_enum.add_entries(
                        input,
                        &self::test_unpacked_types::REPEATED_NESTED_ENUM_CODEC,
                    )?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            size += self
                .repeated_int32()
                .calculate_size(&self::test_unpacked_types::REPEATED_INT32_CODEC);
            size += self
                .repeated_int64()
                .calculate_size(&self::test_unpacked_types::REPEATED_INT64_CODEC);
            size += self
                .repeated_uint32()
                .calculate_size(&self::test_unpacked_types::REPEATED_UINT32_CODEC);
            size += self
                .repeated_uint64()
                .calculate_size(&self::test_unpacked_types::REPEATED_UINT64_CODEC);
            size += self
                .repeated_sint32()
                .calculate_size(&self::test_unpacked_types::REPEATED_SINT32_CODEC);
            size += self
                .repeated_sint64()
                .calculate_size(&self::test_unpacked_types::REPEATED_SINT64_CODEC);
            size += self
                .repeated_fixed32()
                .calculate_size(&self::test_unpacked_types::REPEATED_FIXED32_CODEC);
            size += self
                .repeated_fixed64()
                .calculate_size(&self::test_unpacked_types::REPEATED_FIXED64_CODEC);
            size += self
                .repeated_sfixed32()
                .calculate_size(&self::test_unpacked_types::REPEATED_SFIXED32_CODEC);
            size += self
                .repeated_sfixed64()
                .calculate_size(&self::test_unpacked_types::REPEATED_SFIXED64_CODEC);
            size += self
                .repeated_float()
                .calculate_size(&self::test_unpacked_types::REPEATED_FLOAT_CODEC);
            size += self
                .repeated_double()
                .calculate_size(&self::test_unpacked_types::REPEATED_DOUBLE_CODEC);
            size += self
                .repeated_bool()
                .calculate_size(&self::test_unpacked_types::REPEATED_BOOL_CODEC);
            size += self
                .repeated_nested_enum()
                .calculate_size(&self::test_unpacked_types::REPEATED_NESTED_ENUM_CODEC);
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            self.repeated_int32()
                .write_to(output, &self::test_unpacked_types::REPEATED_INT32_CODEC)?;
            self.repeated_int64()
                .write_to(output, &self::test_unpacked_types::REPEATED_INT64_CODEC)?;
            self.repeated_uint32()
                .write_to(output, &self::test_unpacked_types::REPEATED_UINT32_CODEC)?;
            self.repeated_uint64()
                .write_to(output, &self::test_unpacked_types::REPEATED_UINT64_CODEC)?;
            self.repeated_sint32()
                .write_to(output, &self::test_unpacked_types::REPEATED_SINT32_CODEC)?;
            self.repeated_sint64()
                .write_to(output, &self::test_unpacked_types::REPEATED_SINT64_CODEC)?;
            self.repeated_fixed32()
                .write_to(output, &self::test_unpacked_types::REPEATED_FIXED32_CODEC)?;
            self.repeated_fixed64()
                .write_to(output, &self::test_unpacked_types::REPEATED_FIXED64_CODEC)?;
            self.repeated_sfixed32()
                .write_to(output, &self::test_unpacked_types::REPEATED_SFIXED32_CODEC)?;
            self.repeated_sfixed64()
                .write_to(output, &self::test_unpacked_types::REPEATED_SFIXED64_CODEC)?;
            self.repeated_float()
                .write_to(output, &self::test_unpacked_types::REPEATED_FLOAT_CODEC)?;
            self.repeated_double()
                .write_to(output, &self::test_unpacked_types::REPEATED_DOUBLE_CODEC)?;
            self.repeated_bool()
                .write_to(output, &self::test_unpacked_types::REPEATED_BOOL_CODEC)?;
            self.repeated_nested_enum().write_to(
                output,
                &self::test_unpacked_types::REPEATED_NESTED_ENUM_CODEC,
            )?;
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestUnpackedTypes {
        fn merge(&mut self, other: &Self) {
            self.repeated_int32.merge(&other.repeated_int32);
            self.repeated_int64.merge(&other.repeated_int64);
            self.repeated_uint32.merge(&other.repeated_uint32);
            self.repeated_uint64.merge(&other.repeated_uint64);
            self.repeated_sint32.merge(&other.repeated_sint32);
            self.repeated_sint64.merge(&other.repeated_sint64);
            self.repeated_fixed32.merge(&other.repeated_fixed32);
            self.repeated_fixed64.merge(&other.repeated_fixed64);
            self.repeated_sfixed32.merge(&other.repeated_sfixed32);
            self.repeated_sfixed64.merge(&other.repeated_sfixed64);
            self.repeated_float.merge(&other.repeated_float);
            self.repeated_double.merge(&other.repeated_double);
            self.repeated_bool.merge(&other.repeated_bool);
            self.repeated_nested_enum.merge(&other.repeated_nested_enum);
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestUnpackedTypes {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[2]
        }
    }
    impl self::TestUnpackedTypes {
        pub const REPEATED_INT32_FIELD_NUMBER: i32 = 1;
        pub fn repeated_int32(&self) -> &::protrust::collections::RepeatedField<i32> {
            &self.repeated_int32
        }
        pub fn repeated_int32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
            &mut self.repeated_int32
        }
        pub const REPEATED_INT64_FIELD_NUMBER: i32 = 2;
        pub fn repeated_int64(&self) -> &::protrust::collections::RepeatedField<i64> {
            &self.repeated_int64
        }
        pub fn repeated_int64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
            &mut self.repeated_int64
        }
        pub const REPEATED_UINT32_FIELD_NUMBER: i32 = 3;
        pub fn repeated_uint32(&self) -> &::protrust::collections::RepeatedField<u32> {
            &self.repeated_uint32
        }
        pub fn repeated_uint32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u32> {
            &mut self.repeated_uint32
        }
        pub const REPEATED_UINT64_FIELD_NUMBER: i32 = 4;
        pub fn repeated_uint64(&self) -> &::protrust::collections::RepeatedField<u64> {
            &self.repeated_uint64
        }
        pub fn repeated_uint64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u64> {
            &mut self.repeated_uint64
        }
        pub const REPEATED_SINT32_FIELD_NUMBER: i32 = 5;
        pub fn repeated_sint32(&self) -> &::protrust::collections::RepeatedField<i32> {
            &self.repeated_sint32
        }
        pub fn repeated_sint32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i32> {
            &mut self.repeated_sint32
        }
        pub const REPEATED_SINT64_FIELD_NUMBER: i32 = 6;
        pub fn repeated_sint64(&self) -> &::protrust::collections::RepeatedField<i64> {
            &self.repeated_sint64
        }
        pub fn repeated_sint64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<i64> {
            &mut self.repeated_sint64
        }
        pub const REPEATED_FIXED32_FIELD_NUMBER: i32 = 7;
        pub fn repeated_fixed32(&self) -> &::protrust::collections::RepeatedField<u32> {
            &self.repeated_fixed32
        }
        pub fn repeated_fixed32_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u32> {
            &mut self.repeated_fixed32
        }
        pub const REPEATED_FIXED64_FIELD_NUMBER: i32 = 8;
        pub fn repeated_fixed64(&self) -> &::protrust::collections::RepeatedField<u64> {
            &self.repeated_fixed64
        }
        pub fn repeated_fixed64_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<u64> {
            &mut self.repeated_fixed64
        }
        pub const REPEATED_SFIXED32_FIELD_NUMBER: i32 = 9;
        pub fn repeated_sfixed32(&self) -> &::protrust::collections::RepeatedField<i32> {
            &self.repeated_sfixed32
        }
        pub fn repeated_sfixed32_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<i32> {
            &mut self.repeated_sfixed32
        }
        pub const REPEATED_SFIXED64_FIELD_NUMBER: i32 = 10;
        pub fn repeated_sfixed64(&self) -> &::protrust::collections::RepeatedField<i64> {
            &self.repeated_sfixed64
        }
        pub fn repeated_sfixed64_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<i64> {
            &mut self.repeated_sfixed64
        }
        pub const REPEATED_FLOAT_FIELD_NUMBER: i32 = 11;
        pub fn repeated_float(&self) -> &::protrust::collections::RepeatedField<f32> {
            &self.repeated_float
        }
        pub fn repeated_float_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<f32> {
            &mut self.repeated_float
        }
        pub const REPEATED_DOUBLE_FIELD_NUMBER: i32 = 12;
        pub fn repeated_double(&self) -> &::protrust::collections::RepeatedField<f64> {
            &self.repeated_double
        }
        pub fn repeated_double_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<f64> {
            &mut self.repeated_double
        }
        pub const REPEATED_BOOL_FIELD_NUMBER: i32 = 13;
        pub fn repeated_bool(&self) -> &::protrust::collections::RepeatedField<bool> {
            &self.repeated_bool
        }
        pub fn repeated_bool_mut(&mut self) -> &mut ::protrust::collections::RepeatedField<bool> {
            &mut self.repeated_bool
        }
        pub const REPEATED_NESTED_ENUM_FIELD_NUMBER: i32 = 14;
        pub fn repeated_nested_enum(
            &self,
        ) -> &::protrust::collections::RepeatedField<
            ::protrust::EnumValue<self::test_all_types::NestedEnum>,
        > {
            &self.repeated_nested_enum
        }
        pub fn repeated_nested_enum_mut(
            &mut self,
        ) -> &mut ::protrust::collections::RepeatedField<
            ::protrust::EnumValue<self::test_all_types::NestedEnum>,
        > {
            &mut self.repeated_nested_enum
        }
    }
    pub(in super::super) mod test_unpacked_types {
        pub(super) static REPEATED_INT32_CODEC: ::protrust::Codec<i32> =
            ::protrust::Codec::int32(8);
        pub(super) static REPEATED_INT64_CODEC: ::protrust::Codec<i64> =
            ::protrust::Codec::int64(16);
        pub(super) static REPEATED_UINT32_CODEC: ::protrust::Codec<u32> =
            ::protrust::Codec::uint32(24);
        pub(super) static REPEATED_UINT64_CODEC: ::protrust::Codec<u64> =
            ::protrust::Codec::uint64(32);
        pub(super) static REPEATED_SINT32_CODEC: ::protrust::Codec<i32> =
            ::protrust::Codec::sint32(40);
        pub(super) static REPEATED_SINT64_CODEC: ::protrust::Codec<i64> =
            ::protrust::Codec::sint64(48);
        pub(super) static REPEATED_FIXED32_CODEC: ::protrust::Codec<u32> =
            ::protrust::Codec::fixed32(61);
        pub(super) static REPEATED_FIXED64_CODEC: ::protrust::Codec<u64> =
            ::protrust::Codec::fixed64(65);
        pub(super) static REPEATED_SFIXED32_CODEC: ::protrust::Codec<i32> =
            ::protrust::Codec::sfixed32(77);
        pub(super) static REPEATED_SFIXED64_CODEC: ::protrust::Codec<i64> =
            ::protrust::Codec::sfixed64(81);
        pub(super) static REPEATED_FLOAT_CODEC: ::protrust::Codec<f32> =
            ::protrust::Codec::float(93);
        pub(super) static REPEATED_DOUBLE_CODEC: ::protrust::Codec<f64> =
            ::protrust::Codec::double(97);
        pub(super) static REPEATED_BOOL_CODEC: ::protrust::Codec<bool> =
            ::protrust::Codec::bool(104);
        pub(super) static REPEATED_NESTED_ENUM_CODEC: ::protrust::Codec<
            ::protrust::EnumValue<self::super::test_all_types::NestedEnum>,
        > = ::protrust::Codec::enum_value(112);
        pub(in super::super) static REPEATED_INT32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestUnpackedTypes,
                ::protrust::collections::RepeatedField<i32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestUnpackedTypes::repeated_int32,
            get_mut: self::super::TestUnpackedTypes::repeated_int32_mut,
        };
        pub(in super::super) static REPEATED_INT64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestUnpackedTypes,
                ::protrust::collections::RepeatedField<i64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestUnpackedTypes::repeated_int64,
            get_mut: self::super::TestUnpackedTypes::repeated_int64_mut,
        };
        pub(in super::super) static REPEATED_UINT32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestUnpackedTypes,
                ::protrust::collections::RepeatedField<u32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestUnpackedTypes::repeated_uint32,
            get_mut: self::super::TestUnpackedTypes::repeated_uint32_mut,
        };
        pub(in super::super) static REPEATED_UINT64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestUnpackedTypes,
                ::protrust::collections::RepeatedField<u64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestUnpackedTypes::repeated_uint64,
            get_mut: self::super::TestUnpackedTypes::repeated_uint64_mut,
        };
        pub(in super::super) static REPEATED_SINT32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestUnpackedTypes,
                ::protrust::collections::RepeatedField<i32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestUnpackedTypes::repeated_sint32,
            get_mut: self::super::TestUnpackedTypes::repeated_sint32_mut,
        };
        pub(in super::super) static REPEATED_SINT64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestUnpackedTypes,
                ::protrust::collections::RepeatedField<i64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestUnpackedTypes::repeated_sint64,
            get_mut: self::super::TestUnpackedTypes::repeated_sint64_mut,
        };
        pub(in super::super) static REPEATED_FIXED32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestUnpackedTypes,
                ::protrust::collections::RepeatedField<u32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestUnpackedTypes::repeated_fixed32,
            get_mut: self::super::TestUnpackedTypes::repeated_fixed32_mut,
        };
        pub(in super::super) static REPEATED_FIXED64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestUnpackedTypes,
                ::protrust::collections::RepeatedField<u64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestUnpackedTypes::repeated_fixed64,
            get_mut: self::super::TestUnpackedTypes::repeated_fixed64_mut,
        };
        pub(in super::super) static REPEATED_SFIXED32_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestUnpackedTypes,
                ::protrust::collections::RepeatedField<i32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestUnpackedTypes::repeated_sfixed32,
            get_mut: self::super::TestUnpackedTypes::repeated_sfixed32_mut,
        };
        pub(in super::super) static REPEATED_SFIXED64_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestUnpackedTypes,
                ::protrust::collections::RepeatedField<i64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestUnpackedTypes::repeated_sfixed64,
            get_mut: self::super::TestUnpackedTypes::repeated_sfixed64_mut,
        };
        pub(in super::super) static REPEATED_FLOAT_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestUnpackedTypes,
                ::protrust::collections::RepeatedField<f32>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestUnpackedTypes::repeated_float,
            get_mut: self::super::TestUnpackedTypes::repeated_float_mut,
        };
        pub(in super::super) static REPEATED_DOUBLE_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestUnpackedTypes,
                ::protrust::collections::RepeatedField<f64>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestUnpackedTypes::repeated_double,
            get_mut: self::super::TestUnpackedTypes::repeated_double_mut,
        };
        pub(in super::super) static REPEATED_BOOL_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestUnpackedTypes,
                ::protrust::collections::RepeatedField<bool>,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestUnpackedTypes::repeated_bool,
            get_mut: self::super::TestUnpackedTypes::repeated_bool_mut,
        };
        pub(in super::super) static REPEATED_NESTED_ENUM_REFLECTOR:
            ::protrust::reflect::access::SimpleFieldAccessor<
                self::super::TestUnpackedTypes,
                ::protrust::collections::RepeatedField<
                    ::protrust::EnumValue<self::super::test_all_types::NestedEnum>,
                >,
            > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::TestUnpackedTypes::repeated_nested_enum,
            get_mut: self::super::TestUnpackedTypes::repeated_nested_enum_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct NestedTestAllTypes {
        child: ::std::option::Option<::std::boxed::Box<self::NestedTestAllTypes>>,
        payload: ::std::option::Option<::std::boxed::Box<self::TestAllTypes>>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::NestedTestAllTypes {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    10 => input.read_message(self.child_mut())?,
                    18 => input.read_message(self.payload_mut())?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(child) = self.child() {
                size += 1;
                size += ::protrust::io::sizes::message(child);
            }
            if let ::std::option::Option::Some(payload) = self.payload() {
                size += 1;
                size += ::protrust::io::sizes::message(payload);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(child) = self.child() {
                output.write_raw_tag_bytes(&[10])?;
                output.write_message(child)?;
            }
            if let ::std::option::Option::Some(payload) = self.payload() {
                output.write_raw_tag_bytes(&[18])?;
                output.write_message(payload)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            if let ::std::option::Option::Some(child) = self.child() {
                if !::protrust::CodedMessage::is_initialized(child) {
                    return false;
                }
            }
            if let ::std::option::Option::Some(payload) = self.payload() {
                if !::protrust::CodedMessage::is_initialized(payload) {
                    return false;
                }
            }
            true
        }
    }
    impl ::protrust::LiteMessage for self::NestedTestAllTypes {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(child) = &other.child() {
                ::protrust::LiteMessage::merge(self.child_mut(), child);
            }
            if let ::std::option::Option::Some(payload) = &other.payload() {
                ::protrust::LiteMessage::merge(self.payload_mut(), payload);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::NestedTestAllTypes {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[3]
        }
    }
    impl self::NestedTestAllTypes {
        pub const CHILD_FIELD_NUMBER: i32 = 1;
        pub fn child(&self) -> ::std::option::Option<&self::NestedTestAllTypes> {
            self.child.as_ref().map(|v| &**v)
        }
        pub fn child_mut(&mut self) -> &mut self::NestedTestAllTypes {
            self.child
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_child(&self) -> bool {
            self.child.is_some()
        }
        pub fn set_child(&mut self, value: self::NestedTestAllTypes) {
            self.child = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_child(&mut self) -> ::std::option::Option<self::NestedTestAllTypes> {
            self.child.take().map(|v| *v)
        }
        pub fn clear_child(&mut self) {
            self.child = ::std::option::Option::None;
        }
        pub const PAYLOAD_FIELD_NUMBER: i32 = 2;
        pub fn payload(&self) -> ::std::option::Option<&self::TestAllTypes> {
            self.payload.as_ref().map(|v| &**v)
        }
        pub fn payload_mut(&mut self) -> &mut self::TestAllTypes {
            self.payload
                .get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_payload(&self) -> bool {
            self.payload.is_some()
        }
        pub fn set_payload(&mut self, value: self::TestAllTypes) {
            self.payload = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_payload(&mut self) -> ::std::option::Option<self::TestAllTypes> {
            self.payload.take().map(|v| *v)
        }
        pub fn clear_payload(&mut self) {
            self.payload = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod nested_test_all_types {
        pub(in super::super) static CHILD_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::NestedTestAllTypes,
                self::super::NestedTestAllTypes,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::NestedTestAllTypes::child,
            get_mut: self::super::NestedTestAllTypes::child_mut,
            set: self::super::NestedTestAllTypes::set_child,
            take: self::super::NestedTestAllTypes::take_child,
            clear: self::super::NestedTestAllTypes::clear_child,
        };
        pub(in super::super) static PAYLOAD_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::NestedTestAllTypes,
                self::super::TestAllTypes,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::NestedTestAllTypes::payload,
            get_mut: self::super::NestedTestAllTypes::payload_mut,
            set: self::super::NestedTestAllTypes::set_payload,
            take: self::super::NestedTestAllTypes::take_payload,
            clear: self::super::NestedTestAllTypes::clear_payload,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct ForeignMessage {
        c: i32,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::ForeignMessage {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => *self.c_mut() = input.read_int32()?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if *self.c() != Self::C_DEFAULT_VALUE {
                size += 1;
                size += ::protrust::io::sizes::int32(*self.c());
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if *self.c() != Self::C_DEFAULT_VALUE {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(*self.c())?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::ForeignMessage {
        fn merge(&mut self, other: &Self) {
            if *other.c() != Self::C_DEFAULT_VALUE {
                *self.c_mut() = *other.c();
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::ForeignMessage {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[4]
        }
    }
    impl self::ForeignMessage {
        pub const C_FIELD_NUMBER: i32 = 1;
        pub const C_DEFAULT_VALUE: i32 = 0;
        pub fn c(&self) -> &i32 {
            &self.c
        }
        pub fn c_mut(&mut self) -> &mut i32 {
            &mut self.c
        }
    }
    pub(in super::super) mod foreign_message {
        pub(in super::super) static C_REFLECTOR: ::protrust::reflect::access::SimpleFieldAccessor<
            self::super::ForeignMessage,
            i32,
        > = ::protrust::reflect::access::SimpleFieldAccessor {
            get: self::super::ForeignMessage::c,
            get_mut: self::super::ForeignMessage::c_mut,
        };
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestEmptyMessage {
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestEmptyMessage {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestEmptyMessage {
        fn merge(&mut self, other: &Self) {
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestEmptyMessage {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[5]
        }
    }
    impl self::TestEmptyMessage {}
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct TestOneof2 {
        foo: self::test_oneof2::Foo,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::TestOneof2 {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    48 | 50 => *self.foo_enum_mut() = input.read_enum_value()?,
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(foo_enum) = self.foo_enum() {
                size += 1;
                size += ::protrust::io::sizes::enum_value(*foo_enum);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(foo_enum) = self.foo_enum() {
                output.write_raw_tag_bytes(&[48])?;
                output.write_enum_value(*foo_enum)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::TestOneof2 {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(foo_enum) = other.foo_enum() {
                self.set_foo_enum(*foo_enum);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::TestOneof2 {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[6]
        }
    }
    impl self::TestOneof2 {
        pub const FOO_ENUM_FIELD_NUMBER: i32 = 6;
        pub const FOO_ENUM_DEFAULT_VALUE: ::protrust::EnumValue<self::test_oneof2::NestedEnum> =
            ::protrust::EnumValue::Defined(self::test_oneof2::NestedEnum::Unknown);
        pub fn foo_enum(
            &self,
        ) -> ::std::option::Option<&::protrust::EnumValue<self::test_oneof2::NestedEnum>> {
            match &self.foo {
                self::test_oneof2::Foo::FooEnum(foo) => ::std::option::Option::Some(foo),
                _ => ::std::option::Option::None,
            }
        }
        pub fn foo_enum_mut(
            &mut self,
        ) -> &mut ::protrust::EnumValue<self::test_oneof2::NestedEnum> {
            match self.foo {
                self::test_oneof2::Foo::FooEnum(_) => (),
                _ => self.foo = self::test_oneof2::Foo::FooEnum(::std::default::Default::default()),
            }
            match self.foo {
                self::test_oneof2::Foo::FooEnum(ref mut foo) => foo,
                _ => unsafe { std::hint::unreachable_unchecked() },
            }
        }
        pub fn has_foo_enum(&self) -> bool {
            match self.foo {
                self::test_oneof2::Foo::FooEnum(_) => true,
                _ => false,
            }
        }
        pub fn set_foo_enum(
            &mut self,
            value: ::protrust::EnumValue<self::test_oneof2::NestedEnum>,
        ) {
            self.foo = self::test_oneof2::Foo::FooEnum(::std::convert::From::from(value))
        }
        pub fn take_foo_enum(
            &mut self,
        ) -> ::std::option::Option<::protrust::EnumValue<self::test_oneof2::NestedEnum>> {
            let foo = ::std::mem::replace(&mut self.foo, self::test_oneof2::Foo::None);
            match foo {
                self::test_oneof2::Foo::FooEnum(foo) => ::std::option::Option::Some(foo),
                mut foo => {
                    ::std::mem::swap(&mut self.foo, &mut foo);
                    ::std::option::Option::None
                }
            }
        }
        pub fn clear_foo_enum(&mut self) {
            let foo = ::std::mem::replace(&mut self.foo, self::test_oneof2::Foo::None);
            match foo {
                self::test_oneof2::Foo::FooEnum(_) => {}
                mut foo => ::std::mem::swap(&mut self.foo, &mut foo),
            }
        }
        pub fn foo(&self) -> &self::test_oneof2::Foo {
            &self.foo
        }
        pub fn foo_mut(&mut self) -> &mut self::test_oneof2::Foo {
            &mut self.foo
        }
    }
    pub mod test_oneof2 {
        #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
        pub enum NestedEnum {
            Unknown,
            Foo,
            Bar,
            Baz,
        }
        impl ::protrust::Enum for self::NestedEnum {
            fn descriptor() -> &'static ::protrust::reflect::EnumDescriptor<'static> {
                &<self::super::TestOneof2 as ::protrust::Message>::descriptor().enums()[0]
            }
        }
        impl ::std::convert::TryFrom<i32> for self::NestedEnum {
            type Error = ::protrust::VariantUndefinedError;
            fn try_from(
                value: i32,
            ) -> ::std::result::Result<Self, ::protrust::VariantUndefinedError> {
                #[allow(unreachable_patterns)]
                match value {
                    0 => ::std::result::Result::Ok(self::NestedEnum::Unknown),
                    1 => ::std::result::Result::Ok(self::NestedEnum::Foo),
                    2 => ::std::result::Result::Ok(self::NestedEnum::Bar),
                    3 => ::std::result::Result::Ok(self::NestedEnum::Baz),
                    _ => ::std::result::Result::Err(::protrust::VariantUndefinedError),
                }
            }
        }
        impl ::std::convert::From<self::NestedEnum> for i32 {
            fn from(value: self::NestedEnum) -> i32 {
                match value {
                    self::NestedEnum::Unknown => 0,
                    self::NestedEnum::Foo => 1,
                    self::NestedEnum::Bar => 2,
                    self::NestedEnum::Baz => 3,
                }
            }
        }
        #[derive(Clone, Debug, PartialEq)]
        pub enum Foo {
            None,
            FooEnum(::protrust::EnumValue<self::NestedEnum>),
        }
        impl ::std::default::Default for self::Foo {
            fn default() -> Self {
                self::Foo::None
            }
        }
        pub(in super::super) static FOO_ENUM_REFLECTOR:
            ::protrust::reflect::access::VerboseFieldAccessor<
                self::super::TestOneof2,
                ::protrust::EnumValue<self::NestedEnum>,
            > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::TestOneof2::foo_enum,
            get_mut: self::super::TestOneof2::foo_enum_mut,
            set: self::super::TestOneof2::set_foo_enum,
            take: self::super::TestOneof2::take_foo_enum,
            clear: self::super::TestOneof2::clear_foo_enum,
        };
    }
    #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
    pub enum ForeignEnum {
        ForeignZero,
        ForeignFoo,
        ForeignBar,
        ForeignBaz,
    }
    impl ::protrust::Enum for self::ForeignEnum {
        fn descriptor() -> &'static ::protrust::reflect::EnumDescriptor<'static> {
            &self::file().enums()[0]
        }
    }
    impl ::std::convert::TryFrom<i32> for self::ForeignEnum {
        type Error = ::protrust::VariantUndefinedError;
        fn try_from(value: i32) -> ::std::result::Result<Self, ::protrust::VariantUndefinedError> {
            #[allow(unreachable_patterns)]
            match value {
                0 => ::std::result::Result::Ok(self::ForeignEnum::ForeignZero),
                4 => ::std::result::Result::Ok(self::ForeignEnum::ForeignFoo),
                5 => ::std::result::Result::Ok(self::ForeignEnum::ForeignBar),
                6 => ::std::result::Result::Ok(self::ForeignEnum::ForeignBaz),
                _ => ::std::result::Result::Err(::protrust::VariantUndefinedError),
            }
        }
    }
    impl ::std::convert::From<self::ForeignEnum> for i32 {
        fn from(value: self::ForeignEnum) -> i32 {
            match value {
                self::ForeignEnum::ForeignZero => 0,
                self::ForeignEnum::ForeignFoo => 4,
                self::ForeignEnum::ForeignBar => 5,
                self::ForeignEnum::ForeignBaz => 6,
            }
        }
    }
}
static UNITTEST_IMPORT_PROTO_BINARY: &'static [u8] = &[
    10, 21, 117, 110, 105, 116, 116, 101, 115, 116, 95, 105, 109, 112, 111, 114, 116, 46, 112, 114,
    111, 116, 111, 18, 24, 112, 114, 111, 116, 111, 98, 117, 102, 95, 117, 110, 105, 116, 116, 101,
    115, 116, 95, 105, 109, 112, 111, 114, 116, 26, 28, 117, 110, 105, 116, 116, 101, 115, 116, 95,
    105, 109, 112, 111, 114, 116, 95, 112, 117, 98, 108, 105, 99, 46, 112, 114, 111, 116, 111, 80,
    0, 34, 29, 10, 13, 73, 109, 112, 111, 114, 116, 77, 101, 115, 115, 97, 103, 101, 18, 12, 10, 1,
    100, 24, 1, 32, 1, 40, 5, 82, 1, 100, 42, 60, 10, 10, 73, 109, 112, 111, 114, 116, 69, 110,
    117, 109, 18, 14, 10, 10, 73, 77, 80, 79, 82, 84, 95, 70, 79, 79, 16, 7, 18, 14, 10, 10, 73,
    77, 80, 79, 82, 84, 95, 66, 65, 82, 16, 8, 18, 14, 10, 10, 73, 77, 80, 79, 82, 84, 95, 66, 65,
    90, 16, 9, 42, 49, 10, 16, 73, 109, 112, 111, 114, 116, 69, 110, 117, 109, 70, 111, 114, 77,
    97, 112, 18, 11, 10, 7, 85, 78, 75, 78, 79, 87, 78, 16, 0, 18, 7, 10, 3, 70, 79, 79, 16, 1, 18,
    7, 10, 3, 66, 65, 82, 16, 2, 66, 31, 10, 24, 99, 111, 109, 46, 103, 111, 111, 103, 108, 101,
    46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 116, 101, 115, 116, 72, 1, 248, 1, 1,
];
pub mod unittest_import_proto {
    pub fn file() -> &'static ::protrust::reflect::FileDescriptor<'static> {
        super::pool()
            .find_file_by_name("unittest_import.proto")
            .unwrap()
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct ImportMessage {
        d: ::std::option::Option<i32>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::ImportMessage {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.set_d(input.read_int32()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(d) = self.d_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*d);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(d) = self.d_option() {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(*d)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::ImportMessage {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(d) = other.d_option() {
                self.set_d(*d);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::ImportMessage {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[0]
        }
    }
    impl self::ImportMessage {
        pub const D_FIELD_NUMBER: i32 = 1;
        pub const D_DEFAULT_VALUE: i32 = 0;
        pub fn d(&self) -> i32 {
            self.d.unwrap_or(Self::D_DEFAULT_VALUE)
        }
        pub fn d_option(&self) -> ::std::option::Option<&i32> {
            self.d.as_ref()
        }
        pub fn d_mut(&mut self) -> &mut i32 {
            self.d.get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_d(&self) -> bool {
            self.d.is_some()
        }
        pub fn set_d(&mut self, value: i32) {
            self.d = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_d(&mut self) -> ::std::option::Option<i32> {
            self.d.take()
        }
        pub fn clear_d(&mut self) {
            self.d = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod import_message {
        pub(in super::super) static D_REFLECTOR: ::protrust::reflect::access::VerboseFieldAccessor<
            self::super::ImportMessage,
            i32,
        > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::ImportMessage::d_option,
            get_mut: self::super::ImportMessage::d_mut,
            set: self::super::ImportMessage::set_d,
            take: self::super::ImportMessage::take_d,
            clear: self::super::ImportMessage::clear_d,
        };
    }
    #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
    pub enum ImportEnum {
        ImportFoo,
        ImportBar,
        ImportBaz,
    }
    impl ::protrust::Enum for self::ImportEnum {
        fn descriptor() -> &'static ::protrust::reflect::EnumDescriptor<'static> {
            &self::file().enums()[0]
        }
    }
    impl ::std::convert::TryFrom<i32> for self::ImportEnum {
        type Error = ::protrust::VariantUndefinedError;
        fn try_from(value: i32) -> ::std::result::Result<Self, ::protrust::VariantUndefinedError> {
            #[allow(unreachable_patterns)]
            match value {
                7 => ::std::result::Result::Ok(self::ImportEnum::ImportFoo),
                8 => ::std::result::Result::Ok(self::ImportEnum::ImportBar),
                9 => ::std::result::Result::Ok(self::ImportEnum::ImportBaz),
                _ => ::std::result::Result::Err(::protrust::VariantUndefinedError),
            }
        }
    }
    impl ::std::convert::From<self::ImportEnum> for i32 {
        fn from(value: self::ImportEnum) -> i32 {
            match value {
                self::ImportEnum::ImportFoo => 7,
                self::ImportEnum::ImportBar => 8,
                self::ImportEnum::ImportBaz => 9,
            }
        }
    }
    #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
    pub enum ImportEnumForMap {
        Unknown,
        Foo,
        Bar,
    }
    impl ::protrust::Enum for self::ImportEnumForMap {
        fn descriptor() -> &'static ::protrust::reflect::EnumDescriptor<'static> {
            &self::file().enums()[1]
        }
    }
    impl ::std::convert::TryFrom<i32> for self::ImportEnumForMap {
        type Error = ::protrust::VariantUndefinedError;
        fn try_from(value: i32) -> ::std::result::Result<Self, ::protrust::VariantUndefinedError> {
            #[allow(unreachable_patterns)]
            match value {
                0 => ::std::result::Result::Ok(self::ImportEnumForMap::Unknown),
                1 => ::std::result::Result::Ok(self::ImportEnumForMap::Foo),
                2 => ::std::result::Result::Ok(self::ImportEnumForMap::Bar),
                _ => ::std::result::Result::Err(::protrust::VariantUndefinedError),
            }
        }
    }
    impl ::std::convert::From<self::ImportEnumForMap> for i32 {
        fn from(value: self::ImportEnumForMap) -> i32 {
            match value {
                self::ImportEnumForMap::Unknown => 0,
                self::ImportEnumForMap::Foo => 1,
                self::ImportEnumForMap::Bar => 2,
            }
        }
    }
}
static UNITTEST_IMPORT_PUBLIC_PROTO_BINARY: &'static [u8] = &[
    10, 28, 117, 110, 105, 116, 116, 101, 115, 116, 95, 105, 109, 112, 111, 114, 116, 95, 112, 117,
    98, 108, 105, 99, 46, 112, 114, 111, 116, 111, 18, 24, 112, 114, 111, 116, 111, 98, 117, 102,
    95, 117, 110, 105, 116, 116, 101, 115, 116, 95, 105, 109, 112, 111, 114, 116, 34, 35, 10, 19,
    80, 117, 98, 108, 105, 99, 73, 109, 112, 111, 114, 116, 77, 101, 115, 115, 97, 103, 101, 18,
    12, 10, 1, 101, 24, 1, 32, 1, 40, 5, 82, 1, 101, 66, 26, 10, 24, 99, 111, 109, 46, 103, 111,
    111, 103, 108, 101, 46, 112, 114, 111, 116, 111, 98, 117, 102, 46, 116, 101, 115, 116,
];
pub mod unittest_import_public_proto {
    pub fn file() -> &'static ::protrust::reflect::FileDescriptor<'static> {
        super::pool()
            .find_file_by_name("unittest_import_public.proto")
            .unwrap()
    }
    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct PublicImportMessage {
        e: ::std::option::Option<i32>,
        unknown_fields: ::protrust::UnknownFieldSet,
    }
    impl ::protrust::CodedMessage for self::PublicImportMessage {
        fn merge_from(
            &mut self,
            input: &mut ::protrust::io::CodedInput,
        ) -> ::protrust::io::InputResult<()> {
            while let ::std::option::Option::Some(tag) = input.read_tag()? {
                match tag.get() {
                    8 | 10 => self.set_e(input.read_int32()?),
                    _ => self.unknown_fields.merge_from(tag, input)?,
                }
            }
            ::std::result::Result::Ok(())
        }
        fn calculate_size(&self) -> i32 {
            let mut size = 0i32;
            if let ::std::option::Option::Some(e) = self.e_option() {
                size += 1;
                size += ::protrust::io::sizes::int32(*e);
            }
            size += self.unknown_fields.calculate_size();
            size
        }
        fn write_to(
            &self,
            output: &mut ::protrust::io::CodedOutput,
        ) -> ::protrust::io::OutputResult {
            if let ::std::option::Option::Some(e) = self.e_option() {
                output.write_raw_tag_bytes(&[8])?;
                output.write_int32(*e)?;
            }
            self.unknown_fields.write_to(output)?;
            ::std::result::Result::Ok(())
        }
        fn is_initialized(&self) -> bool {
            true
        }
    }
    impl ::protrust::LiteMessage for self::PublicImportMessage {
        fn merge(&mut self, other: &Self) {
            if let ::std::option::Option::Some(e) = other.e_option() {
                self.set_e(*e);
            }
            self.unknown_fields.merge(&other.unknown_fields);
        }
    }
    impl ::protrust::Message for self::PublicImportMessage {
        fn descriptor() -> &'static ::protrust::reflect::MessageDescriptor<'static> {
            &self::file().messages()[0]
        }
    }
    impl self::PublicImportMessage {
        pub const E_FIELD_NUMBER: i32 = 1;
        pub const E_DEFAULT_VALUE: i32 = 0;
        pub fn e(&self) -> i32 {
            self.e.unwrap_or(Self::E_DEFAULT_VALUE)
        }
        pub fn e_option(&self) -> ::std::option::Option<&i32> {
            self.e.as_ref()
        }
        pub fn e_mut(&mut self) -> &mut i32 {
            self.e.get_or_insert_with(::std::default::Default::default)
        }
        pub fn has_e(&self) -> bool {
            self.e.is_some()
        }
        pub fn set_e(&mut self, value: i32) {
            self.e = ::std::option::Option::Some(::std::convert::From::from(value))
        }
        pub fn take_e(&mut self) -> ::std::option::Option<i32> {
            self.e.take()
        }
        pub fn clear_e(&mut self) {
            self.e = ::std::option::Option::None;
        }
    }
    pub(in super::super) mod public_import_message {
        pub(in super::super) static E_REFLECTOR: ::protrust::reflect::access::VerboseFieldAccessor<
            self::super::PublicImportMessage,
            i32,
        > = ::protrust::reflect::access::VerboseFieldAccessor {
            get_option: self::super::PublicImportMessage::e_option,
            get_mut: self::super::PublicImportMessage::e_mut,
            set: self::super::PublicImportMessage::set_e,
            take: self::super::PublicImportMessage::take_e,
            clear: self::super::PublicImportMessage::clear_e,
        };
    }
}
